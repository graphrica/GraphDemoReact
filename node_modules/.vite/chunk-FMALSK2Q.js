import {
  init_os,
  os_exports,
  require_url
} from "./chunk-SSQCKGNF.js";
import {
  require_dist
} from "./chunk-GY2U6V7C.js";
import {
  require_src2 as require_src
} from "./chunk-HRG2DHFT.js";
import {
  require_browser
} from "./chunk-6XVHBKXF.js";
import {
  require_util
} from "./chunk-BTG65MVN.js";
import {
  require_buffer
} from "./chunk-557FO4FU.js";
import {
  init_lib2 as init_lib10,
  lib_exports
} from "./chunk-VFG3R5NB.js";
import {
  BigNumber,
  Description,
  Logger,
  MaxUint256,
  NegativeOne,
  One,
  Zero,
  arrayify,
  concat,
  defineReadOnly,
  getAddress,
  getStatic,
  hexConcat,
  hexDataSlice,
  hexZeroPad,
  hexlify,
  id,
  init_lib,
  init_lib10 as init_lib9,
  init_lib2,
  init_lib3,
  init_lib4,
  init_lib5,
  init_lib7 as init_lib6,
  init_lib8 as init_lib7,
  init_lib9 as init_lib8,
  isHexString,
  keccak256,
  toUtf8Bytes,
  toUtf8String
} from "./chunk-QLJNFGTT.js";
import {
  require_sha3
} from "./chunk-HEQAI6WE.js";
import {
  require_bn
} from "./chunk-VIQ6GMKA.js";
import {
  __commonJS,
  __esm,
  __export,
  __spreadProps,
  __spreadValues,
  __toCommonJS,
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// node_modules/ethjs-unit/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/ethjs-unit/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_define_process_env();
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/number-to-bn/node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/number-to-bn/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_define_process_env();
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/number-to-bn/src/index.js
var require_src2 = __commonJS({
  "node_modules/number-to-bn/src/index.js"(exports, module) {
    init_define_process_env();
    var BN = require_bn3();
    var stripHexPrefix = require_src();
    module.exports = function numberToBN(arg) {
      if (typeof arg === "string" || typeof arg === "number") {
        var multiplier = new BN(1);
        var formattedString = String(arg).toLowerCase().trim();
        var isHexPrefixed = formattedString.substr(0, 2) === "0x" || formattedString.substr(0, 3) === "-0x";
        var stringArg = stripHexPrefix(formattedString);
        if (stringArg.substr(0, 1) === "-") {
          stringArg = stripHexPrefix(stringArg.slice(1));
          multiplier = new BN(-1, 10);
        }
        stringArg = stringArg === "" ? "0" : stringArg;
        if (!stringArg.match(/^-?[0-9]+$/) && stringArg.match(/^[0-9A-Fa-f]+$/) || stringArg.match(/^[a-fA-F]+$/) || isHexPrefixed === true && stringArg.match(/^[0-9A-Fa-f]+$/)) {
          return new BN(stringArg, 16).mul(multiplier);
        }
        if ((stringArg.match(/^-?[0-9]+$/) || stringArg === "") && isHexPrefixed === false) {
          return new BN(stringArg, 10).mul(multiplier);
        }
      } else if (typeof arg === "object" && arg.toString && (!arg.pop && !arg.push)) {
        if (arg.toString(10).match(/^-?[0-9]+$/) && (arg.mul || arg.dividedToIntegerBy)) {
          return new BN(arg.toString(10), 10);
        }
      }
      throw new Error("[number-to-bn] while converting number " + JSON.stringify(arg) + " to BN.js instance, error: invalid number value. Value must be an integer, hex string, BN or BigNumber instance. Note, decimals are not supported.");
    };
  }
});

// node_modules/ethjs-unit/lib/index.js
var require_lib = __commonJS({
  "node_modules/ethjs-unit/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var BN = require_bn2();
    var numberToBN = require_src2();
    var zero = new BN(0);
    var negative1 = new BN(-1);
    var unitMap = {
      "noether": "0",
      "wei": "1",
      "kwei": "1000",
      "Kwei": "1000",
      "babbage": "1000",
      "femtoether": "1000",
      "mwei": "1000000",
      "Mwei": "1000000",
      "lovelace": "1000000",
      "picoether": "1000000",
      "gwei": "1000000000",
      "Gwei": "1000000000",
      "shannon": "1000000000",
      "nanoether": "1000000000",
      "nano": "1000000000",
      "szabo": "1000000000000",
      "microether": "1000000000000",
      "micro": "1000000000000",
      "finney": "1000000000000000",
      "milliether": "1000000000000000",
      "milli": "1000000000000000",
      "ether": "1000000000000000000",
      "kether": "1000000000000000000000",
      "grand": "1000000000000000000000",
      "mether": "1000000000000000000000000",
      "gether": "1000000000000000000000000000",
      "tether": "1000000000000000000000000000000"
    };
    function getValueOfUnit(unitInput) {
      var unit = unitInput ? unitInput.toLowerCase() : "ether";
      var unitValue = unitMap[unit];
      if (typeof unitValue !== "string") {
        throw new Error("[ethjs-unit] the unit provided " + unitInput + " doesn't exists, please use the one of the following units " + JSON.stringify(unitMap, null, 2));
      }
      return new BN(unitValue, 10);
    }
    function numberToString(arg) {
      if (typeof arg === "string") {
        if (!arg.match(/^-?[0-9.]+$/)) {
          throw new Error("while converting number to string, invalid number value '" + arg + "', should be a number matching (^-?[0-9.]+).");
        }
        return arg;
      } else if (typeof arg === "number") {
        return String(arg);
      } else if (typeof arg === "object" && arg.toString && (arg.toTwos || arg.dividedToIntegerBy)) {
        if (arg.toPrecision) {
          return String(arg.toPrecision());
        } else {
          return arg.toString(10);
        }
      }
      throw new Error("while converting number to string, invalid number value '" + arg + "' type " + typeof arg + ".");
    }
    function fromWei(weiInput, unit, optionsInput) {
      var wei = numberToBN(weiInput);
      var negative = wei.lt(zero);
      var base = getValueOfUnit(unit);
      var baseLength = unitMap[unit].length - 1 || 1;
      var options = optionsInput || {};
      if (negative) {
        wei = wei.mul(negative1);
      }
      var fraction = wei.mod(base).toString(10);
      while (fraction.length < baseLength) {
        fraction = "0" + fraction;
      }
      if (!options.pad) {
        fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      }
      var whole = wei.div(base).toString(10);
      if (options.commify) {
        whole = whole.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      }
      var value = "" + whole + (fraction == "0" ? "" : "." + fraction);
      if (negative) {
        value = "-" + value;
      }
      return value;
    }
    function toWei(etherInput, unit) {
      var ether = numberToString(etherInput);
      var base = getValueOfUnit(unit);
      var baseLength = unitMap[unit].length - 1 || 1;
      var negative = ether.substring(0, 1) === "-";
      if (negative) {
        ether = ether.substring(1);
      }
      if (ether === ".") {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, invalid value");
      }
      var comps = ether.split(".");
      if (comps.length > 2) {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei,  too many decimal points");
      }
      var whole = comps[0], fraction = comps[1];
      if (!whole) {
        whole = "0";
      }
      if (!fraction) {
        fraction = "0";
      }
      if (fraction.length > baseLength) {
        throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, too many decimal places");
      }
      while (fraction.length < baseLength) {
        fraction += "0";
      }
      whole = new BN(whole);
      fraction = new BN(fraction);
      var wei = whole.mul(base).add(fraction);
      if (negative) {
        wei = wei.mul(negative1);
      }
      return new BN(wei.toString(10), 10);
    }
    module.exports = {
      unitMap,
      numberToString,
      getValueOfUnit,
      fromWei,
      toWei
    };
  }
});

// node_modules/utf8/utf8.js
var require_utf8 = __commonJS({
  "node_modules/utf8/utf8.js"(exports) {
    init_define_process_env();
    (function(root) {
      var stringFromCharCode = String.fromCharCode;
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        var value;
        var extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        var length = array.length;
        var index = -1;
        var value;
        var output = "";
        while (++index < length) {
          value = array[index];
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
        }
        return output;
      }
      function checkScalarValue(codePoint) {
        if (codePoint >= 55296 && codePoint <= 57343) {
          throw Error("Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value");
        }
      }
      function createByte(codePoint, shift) {
        return stringFromCharCode(codePoint >> shift & 63 | 128);
      }
      function encodeCodePoint(codePoint) {
        if ((codePoint & 4294967168) == 0) {
          return stringFromCharCode(codePoint);
        }
        var symbol = "";
        if ((codePoint & 4294965248) == 0) {
          symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
        } else if ((codePoint & 4294901760) == 0) {
          checkScalarValue(codePoint);
          symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
          symbol += createByte(codePoint, 6);
        } else if ((codePoint & 4292870144) == 0) {
          symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
          symbol += createByte(codePoint, 12);
          symbol += createByte(codePoint, 6);
        }
        symbol += stringFromCharCode(codePoint & 63 | 128);
        return symbol;
      }
      function utf8encode(string) {
        var codePoints = ucs2decode(string);
        var length = codePoints.length;
        var index = -1;
        var codePoint;
        var byteString = "";
        while (++index < length) {
          codePoint = codePoints[index];
          byteString += encodeCodePoint(codePoint);
        }
        return byteString;
      }
      function readContinuationByte() {
        if (byteIndex >= byteCount) {
          throw Error("Invalid byte index");
        }
        var continuationByte = byteArray[byteIndex] & 255;
        byteIndex++;
        if ((continuationByte & 192) == 128) {
          return continuationByte & 63;
        }
        throw Error("Invalid continuation byte");
      }
      function decodeSymbol() {
        var byte1;
        var byte2;
        var byte3;
        var byte4;
        var codePoint;
        if (byteIndex > byteCount) {
          throw Error("Invalid byte index");
        }
        if (byteIndex == byteCount) {
          return false;
        }
        byte1 = byteArray[byteIndex] & 255;
        byteIndex++;
        if ((byte1 & 128) == 0) {
          return byte1;
        }
        if ((byte1 & 224) == 192) {
          byte2 = readContinuationByte();
          codePoint = (byte1 & 31) << 6 | byte2;
          if (codePoint >= 128) {
            return codePoint;
          } else {
            throw Error("Invalid continuation byte");
          }
        }
        if ((byte1 & 240) == 224) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
          if (codePoint >= 2048) {
            checkScalarValue(codePoint);
            return codePoint;
          } else {
            throw Error("Invalid continuation byte");
          }
        }
        if ((byte1 & 248) == 240) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          byte4 = readContinuationByte();
          codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (codePoint >= 65536 && codePoint <= 1114111) {
            return codePoint;
          }
        }
        throw Error("Invalid UTF-8 detected");
      }
      var byteArray;
      var byteCount;
      var byteIndex;
      function utf8decode(byteString) {
        byteArray = ucs2decode(byteString);
        byteCount = byteArray.length;
        byteIndex = 0;
        var codePoints = [];
        var tmp;
        while ((tmp = decodeSymbol()) !== false) {
          codePoints.push(tmp);
        }
        return ucs2encode(codePoints);
      }
      root.version = "3.0.0";
      root.encode = utf8encode;
      root.decode = utf8decode;
    })(typeof exports === "undefined" ? exports.utf8 = {} : exports);
  }
});

// node_modules/ethereum-bloom-filters/dist/utils.js
var require_utils = __commonJS({
  "node_modules/ethereum-bloom-filters/dist/utils.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    var sha3 = require_sha3();
    function keccak2562(data) {
      return "0x" + sha3.keccak_256(toByteArray(data));
    }
    exports.keccak256 = keccak2562;
    exports.padLeft = (value, chars) => {
      const hasPrefix = /^0x/i.test(value) || typeof value === "number";
      value = value.toString().replace(/^0x/i, "");
      const padding = chars - value.length + 1 >= 0 ? chars - value.length + 1 : 0;
      return (hasPrefix ? "0x" : "") + new Array(padding).join("0") + value;
    };
    function bytesToHex(bytes) {
      const hex = [];
      for (let i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 15).toString(16));
      }
      return `0x${hex.join("").replace(/^0+/, "")}`;
    }
    exports.bytesToHex = bytesToHex;
    function toByteArray(value) {
      if (value == null) {
        throw new Error("cannot convert null value to array");
      }
      if (typeof value === "string") {
        const match = value.match(/^(0x)?[0-9a-fA-F]*$/);
        if (!match) {
          throw new Error("invalid hexidecimal string");
        }
        if (match[1] !== "0x") {
          throw new Error("hex string must have 0x prefix");
        }
        value = value.substring(2);
        if (value.length % 2) {
          value = "0" + value;
        }
        const result = [];
        for (let i = 0; i < value.length; i += 2) {
          result.push(parseInt(value.substr(i, 2), 16));
        }
        return addSlice(new Uint8Array(result));
      }
      if (isByteArray(value)) {
        return addSlice(new Uint8Array(value));
      }
      throw new Error("invalid arrayify value");
    }
    exports.toByteArray = toByteArray;
    function isByteArray(value) {
      if (!value || parseInt(String(value.length)) != value.length || typeof value === "string") {
        return false;
      }
      for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (v < 0 || v >= 256 || parseInt(String(v)) != v) {
          return false;
        }
      }
      return true;
    }
    function addSlice(array) {
      if (array.slice !== void 0) {
        return array;
      }
      array.slice = () => {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
      };
      return array;
    }
  }
});

// node_modules/ethereum-bloom-filters/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/ethereum-bloom-filters/dist/index.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    function isBloom(bloom) {
      if (typeof bloom !== "string") {
        return false;
      }
      if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
        return false;
      }
      if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
        return true;
      }
      return false;
    }
    exports.isBloom = isBloom;
    function isInBloom(bloom, value) {
      if (typeof value === "object" && value.constructor === Uint8Array) {
        value = utils_1.bytesToHex(value);
      }
      const hash = utils_1.keccak256(value).replace("0x", "");
      for (let i = 0; i < 12; i += 4) {
        const bitpos = (parseInt(hash.substr(i, 2), 16) << 8) + parseInt(hash.substr(i + 2, 2), 16) & 2047;
        const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));
        const offset = 1 << bitpos % 4;
        if ((code & offset) !== offset) {
          return false;
        }
      }
      return true;
    }
    exports.isInBloom = isInBloom;
    function codePointToInt(codePoint) {
      if (codePoint >= 48 && codePoint <= 57) {
        return codePoint - 48;
      }
      if (codePoint >= 65 && codePoint <= 70) {
        return codePoint - 55;
      }
      if (codePoint >= 97 && codePoint <= 102) {
        return codePoint - 87;
      }
      throw new Error("invalid bloom");
    }
    function isUserEthereumAddressInBloom(bloom, ethereumAddress) {
      if (!isBloom(bloom)) {
        throw new Error("Invalid bloom given");
      }
      if (!isAddress(ethereumAddress)) {
        throw new Error(`Invalid ethereum address given: "${ethereumAddress}"`);
      }
      const address = utils_1.padLeft(ethereumAddress, 64);
      return isInBloom(bloom, address);
    }
    exports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;
    function isContractAddressInBloom(bloom, contractAddress) {
      if (!isBloom(bloom)) {
        throw new Error("Invalid bloom given");
      }
      if (!isAddress(contractAddress)) {
        throw new Error(`Invalid contract address given: "${contractAddress}"`);
      }
      return isInBloom(bloom, contractAddress);
    }
    exports.isContractAddressInBloom = isContractAddressInBloom;
    function isTopicInBloom(bloom, topic) {
      if (!isBloom(bloom)) {
        throw new Error("Invalid bloom given");
      }
      if (!isTopic(topic)) {
        throw new Error("Invalid topic");
      }
      return isInBloom(bloom, topic);
    }
    exports.isTopicInBloom = isTopicInBloom;
    function isTopic(topic) {
      if (typeof topic !== "string") {
        return false;
      }
      if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
        return false;
      } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
        return true;
      }
      return false;
    }
    exports.isTopic = isTopic;
    function isAddress(address) {
      if (typeof address !== "string") {
        return false;
      }
      if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        return true;
      }
      if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        return true;
      }
      return false;
    }
    exports.isAddress = isAddress;
  }
});

// node_modules/web3-utils/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/web3-utils/lib/utils.js"(exports, module) {
    init_define_process_env();
    var BN = require_bn();
    var numberToBN = require_src2();
    var utf8 = require_utf8();
    var ethereumjsUtil = require_dist();
    var ethereumBloomFilters = require_dist2();
    var isBN = function(object) {
      return BN.isBN(object);
    };
    var isBigNumber = function(object) {
      return object && object.constructor && object.constructor.name === "BigNumber";
    };
    var toBN = function(number) {
      try {
        return numberToBN.apply(null, arguments);
      } catch (e) {
        throw new Error(e + ' Given value: "' + number + '"');
      }
    };
    var toTwosComplement = function(number) {
      return "0x" + toBN(number).toTwos(256).toString(16, 64);
    };
    var isAddress = function(address) {
      if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        return false;
      } else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {
        return true;
      } else {
        return checkAddressChecksum(address);
      }
    };
    var checkAddressChecksum = function(address) {
      address = address.replace(/^0x/i, "");
      var addressHash = sha3(address.toLowerCase()).replace(/^0x/i, "");
      for (var i = 0; i < 40; i++) {
        if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {
          return false;
        }
      }
      return true;
    };
    var leftPad = function(string, chars, sign) {
      var hasPrefix = /^0x/i.test(string) || typeof string === "number";
      string = string.toString(16).replace(/^0x/i, "");
      var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;
      return (hasPrefix ? "0x" : "") + new Array(padding).join(sign ? sign : "0") + string;
    };
    var rightPad = function(string, chars, sign) {
      var hasPrefix = /^0x/i.test(string) || typeof string === "number";
      string = string.toString(16).replace(/^0x/i, "");
      var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;
      return (hasPrefix ? "0x" : "") + string + new Array(padding).join(sign ? sign : "0");
    };
    var utf8ToHex = function(str) {
      str = utf8.encode(str);
      var hex = "";
      str = str.replace(/^(?:\u0000)*/, "");
      str = str.split("").reverse().join("");
      str = str.replace(/^(?:\u0000)*/, "");
      str = str.split("").reverse().join("");
      for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0" + n : n;
      }
      return "0x" + hex;
    };
    var hexToUtf8 = function(hex) {
      if (!isHexStrict(hex))
        throw new Error('The parameter "' + hex + '" must be a valid HEX string.');
      var str = "";
      var code = 0;
      hex = hex.replace(/^0x/i, "");
      hex = hex.replace(/^(?:00)*/, "");
      hex = hex.split("").reverse().join("");
      hex = hex.replace(/^(?:00)*/, "");
      hex = hex.split("").reverse().join("");
      var l = hex.length;
      for (var i = 0; i < l; i += 2) {
        code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return utf8.decode(str);
    };
    var hexToNumber = function(value) {
      if (!value) {
        return value;
      }
      if (typeof value === "string" && !isHexStrict(value)) {
        throw new Error('Given value "' + value + '" is not a valid hex string.');
      }
      return toBN(value).toNumber();
    };
    var hexToNumberString = function(value) {
      if (!value)
        return value;
      if (typeof value === "string" && !isHexStrict(value)) {
        throw new Error('Given value "' + value + '" is not a valid hex string.');
      }
      return toBN(value).toString(10);
    };
    var numberToHex = function(value) {
      if (value === null || value === void 0) {
        return value;
      }
      if (!isFinite(value) && !isHexStrict(value)) {
        throw new Error('Given input "' + value + '" is not a number.');
      }
      var number = toBN(value);
      var result = number.toString(16);
      return number.lt(new BN(0)) ? "-0x" + result.substr(1) : "0x" + result;
    };
    var bytesToHex = function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 15).toString(16));
      }
      return "0x" + hex.join("");
    };
    var hexToBytes = function(hex) {
      hex = hex.toString(16);
      if (!isHexStrict(hex)) {
        throw new Error('Given value "' + hex + '" is not a valid hex string.');
      }
      hex = hex.replace(/^0x/i, "");
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    };
    var toHex = function(value, returnType) {
      if (isAddress(value)) {
        return returnType ? "address" : "0x" + value.toLowerCase().replace(/^0x/i, "");
      }
      if (typeof value === "boolean") {
        return returnType ? "bool" : value ? "0x01" : "0x00";
      }
      if (Buffer.isBuffer(value)) {
        return "0x" + value.toString("hex");
      }
      if (typeof value === "object" && !!value && !isBigNumber(value) && !isBN(value)) {
        return returnType ? "string" : utf8ToHex(JSON.stringify(value));
      }
      if (typeof value === "string") {
        if (value.indexOf("-0x") === 0 || value.indexOf("-0X") === 0) {
          return returnType ? "int256" : numberToHex(value);
        } else if (value.indexOf("0x") === 0 || value.indexOf("0X") === 0) {
          return returnType ? "bytes" : value;
        } else if (!isFinite(value)) {
          return returnType ? "string" : utf8ToHex(value);
        }
      }
      return returnType ? value < 0 ? "int256" : "uint256" : numberToHex(value);
    };
    var isHexStrict = function(hex) {
      return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex);
    };
    var isHex = function(hex) {
      return (typeof hex === "string" || typeof hex === "number") && /^(-0x|0x)?[0-9a-f]*$/i.test(hex);
    };
    var stripHexPrefix = function(str) {
      if (str !== 0 && isHex(str))
        return str.replace(/^(-)?0x/i, "$1");
      return str;
    };
    var isBloom = function(bloom) {
      return ethereumBloomFilters.isBloom(bloom);
    };
    var isUserEthereumAddressInBloom = function(bloom, ethereumAddress) {
      return ethereumBloomFilters.isUserEthereumAddressInBloom(bloom, ethereumAddress);
    };
    var isContractAddressInBloom = function(bloom, contractAddress) {
      return ethereumBloomFilters.isContractAddressInBloom(bloom, contractAddress);
    };
    var isTopic = function(topic) {
      return ethereumBloomFilters.isTopic(topic);
    };
    var isTopicInBloom = function(bloom, topic) {
      return ethereumBloomFilters.isTopicInBloom(bloom, topic);
    };
    var isInBloom = function(bloom, topic) {
      return ethereumBloomFilters.isInBloom(bloom, topic);
    };
    var SHA3_NULL_S = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    var sha3 = function(value) {
      if (isBN(value)) {
        value = value.toString();
      }
      if (isHexStrict(value) && /^0x/i.test(value.toString())) {
        value = ethereumjsUtil.toBuffer(value);
      } else if (typeof value === "string") {
        value = Buffer.from(value, "utf-8");
      }
      var returnValue = ethereumjsUtil.bufferToHex(ethereumjsUtil.keccak256(value));
      if (returnValue === SHA3_NULL_S) {
        return null;
      } else {
        return returnValue;
      }
    };
    sha3._Hash = ethereumjsUtil.keccak256;
    var sha3Raw = function(value) {
      value = sha3(value);
      if (value === null) {
        return SHA3_NULL_S;
      }
      return value;
    };
    var toNumber = function(value) {
      return typeof value === "number" ? value : hexToNumber(toHex(value));
    };
    module.exports = {
      BN,
      isBN,
      isBigNumber,
      toBN,
      isAddress,
      isBloom,
      isUserEthereumAddressInBloom,
      isContractAddressInBloom,
      isTopic,
      isTopicInBloom,
      isInBloom,
      checkAddressChecksum,
      utf8ToHex,
      hexToUtf8,
      hexToNumber,
      hexToNumberString,
      numberToHex,
      toHex,
      hexToBytes,
      bytesToHex,
      isHex,
      isHexStrict,
      stripHexPrefix,
      leftPad,
      rightPad,
      toTwosComplement,
      sha3,
      sha3Raw,
      toNumber
    };
  }
});

// node_modules/web3-utils/lib/soliditySha3.js
var require_soliditySha3 = __commonJS({
  "node_modules/web3-utils/lib/soliditySha3.js"(exports, module) {
    init_define_process_env();
    var BN = require_bn();
    var utils = require_utils2();
    var _elementaryName = function(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    };
    var _parseTypeN = function(type) {
      var typesize = /^\D+(\d+).*$/.exec(type);
      return typesize ? parseInt(typesize[1], 10) : null;
    };
    var _parseTypeNArray = function(type) {
      var arraySize = /^\D+\d*\[(\d+)\]$/.exec(type);
      return arraySize ? parseInt(arraySize[1], 10) : null;
    };
    var _parseNumber = function(arg) {
      var type = typeof arg;
      if (type === "string") {
        if (utils.isHexStrict(arg)) {
          return new BN(arg.replace(/0x/i, ""), 16);
        } else {
          return new BN(arg, 10);
        }
      } else if (type === "number") {
        return new BN(arg);
      } else if (utils.isBigNumber(arg)) {
        return new BN(arg.toString(10));
      } else if (utils.isBN(arg)) {
        return arg;
      } else {
        throw new Error(arg + " is not a number");
      }
    };
    var _solidityPack = function(type, value, arraySize) {
      var size, num;
      type = _elementaryName(type);
      if (type === "bytes") {
        if (value.replace(/^0x/i, "").length % 2 !== 0) {
          throw new Error("Invalid bytes characters " + value.length);
        }
        return value;
      } else if (type === "string") {
        return utils.utf8ToHex(value);
      } else if (type === "bool") {
        return value ? "01" : "00";
      } else if (type.startsWith("address")) {
        if (arraySize) {
          size = 64;
        } else {
          size = 40;
        }
        if (!utils.isAddress(value)) {
          throw new Error(value + " is not a valid address, or the checksum is invalid.");
        }
        return utils.leftPad(value.toLowerCase(), size);
      }
      size = _parseTypeN(type);
      if (type.startsWith("bytes")) {
        if (!size) {
          throw new Error("bytes[] not yet supported in solidity");
        }
        if (arraySize) {
          size = 32;
        }
        if (size < 1 || size > 32 || size < value.replace(/^0x/i, "").length / 2) {
          throw new Error("Invalid bytes" + size + " for " + value);
        }
        return utils.rightPad(value, size * 2);
      } else if (type.startsWith("uint")) {
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint" + size + " size");
        }
        num = _parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num.lt(new BN(0))) {
          throw new Error("Supplied uint " + num.toString() + " is negative");
        }
        return size ? utils.leftPad(num.toString("hex"), size / 8 * 2) : num;
      } else if (type.startsWith("int")) {
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int" + size + " size");
        }
        num = _parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num.lt(new BN(0))) {
          return num.toTwos(size).toString("hex");
        } else {
          return size ? utils.leftPad(num.toString("hex"), size / 8 * 2) : num;
        }
      } else {
        throw new Error("Unsupported or invalid type: " + type);
      }
    };
    var _processSolidityEncodePackedArgs = function(arg) {
      if (Array.isArray(arg)) {
        throw new Error("Autodetection of array types is not supported.");
      }
      var type, value = "";
      var hexArg, arraySize;
      if (!!arg && typeof arg === "object" && (arg.hasOwnProperty("v") || arg.hasOwnProperty("t") || arg.hasOwnProperty("value") || arg.hasOwnProperty("type"))) {
        type = arg.hasOwnProperty("t") ? arg.t : arg.type;
        value = arg.hasOwnProperty("v") ? arg.v : arg.value;
      } else {
        type = utils.toHex(arg, true);
        value = utils.toHex(arg);
        if (!type.startsWith("int") && !type.startsWith("uint")) {
          type = "bytes";
        }
      }
      if ((type.startsWith("int") || type.startsWith("uint")) && typeof value === "string" && !/^(-)?0x/i.test(value)) {
        value = new BN(value);
      }
      if (Array.isArray(value)) {
        arraySize = _parseTypeNArray(type);
        if (arraySize && value.length !== arraySize) {
          throw new Error(type + " is not matching the given array " + JSON.stringify(value));
        } else {
          arraySize = value.length;
        }
      }
      if (Array.isArray(value)) {
        hexArg = value.map(function(val) {
          return _solidityPack(type, val, arraySize).toString("hex").replace("0x", "");
        });
        return hexArg.join("");
      } else {
        hexArg = _solidityPack(type, value, arraySize);
        return hexArg.toString("hex").replace("0x", "");
      }
    };
    var soliditySha3 = function() {
      var args = Array.prototype.slice.call(arguments);
      var hexArgs = args.map(_processSolidityEncodePackedArgs);
      return utils.sha3("0x" + hexArgs.join(""));
    };
    var soliditySha3Raw = function() {
      return utils.sha3Raw("0x" + Array.prototype.slice.call(arguments).map(_processSolidityEncodePackedArgs).join(""));
    };
    var encodePacked = function() {
      var args = Array.prototype.slice.call(arguments);
      var hexArgs = args.map(_processSolidityEncodePackedArgs);
      return "0x" + hexArgs.join("").toLowerCase();
    };
    module.exports = {
      soliditySha3,
      soliditySha3Raw,
      encodePacked
    };
  }
});

// node_modules/web3-utils/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/web3-utils/lib/index.js"(exports, module) {
    init_define_process_env();
    var ethjsUnit = require_lib();
    var utils = require_utils2();
    var soliditySha3 = require_soliditySha3();
    var randombytes = require_browser();
    var BN = require_bn();
    var _fireError = function(error, emitter, reject, callback, optionalData) {
      if (!!error && typeof error === "object" && !(error instanceof Error) && error.data) {
        if (!!error.data && typeof error.data === "object" || Array.isArray(error.data)) {
          error.data = JSON.stringify(error.data, null, 2);
        }
        error = error.message + "\n" + error.data;
      }
      if (typeof error === "string") {
        error = new Error(error);
      }
      if (typeof callback === "function") {
        callback(error, optionalData);
      }
      if (typeof reject === "function") {
        if (emitter && (typeof emitter.listeners === "function" && emitter.listeners("error").length) || typeof callback === "function") {
          emitter.catch(function() {
          });
        }
        setTimeout(function() {
          reject(error);
        }, 1);
      }
      if (emitter && typeof emitter.emit === "function") {
        setTimeout(function() {
          emitter.emit("error", error, optionalData);
          emitter.removeAllListeners();
        }, 1);
      }
      return emitter;
    };
    var _jsonInterfaceMethodToString = function(json) {
      if (!!json && typeof json === "object" && json.name && json.name.indexOf("(") !== -1) {
        return json.name;
      }
      return json.name + "(" + _flattenTypes(false, json.inputs).join(",") + ")";
    };
    var _flattenTypes = function(includeTuple, puts) {
      var types = [];
      puts.forEach(function(param) {
        if (typeof param.components === "object") {
          if (param.type.substring(0, 5) !== "tuple") {
            throw new Error("components found but type is not tuple; report on GitHub");
          }
          var suffix = "";
          var arrayBracket = param.type.indexOf("[");
          if (arrayBracket >= 0) {
            suffix = param.type.substring(arrayBracket);
          }
          var result = _flattenTypes(includeTuple, param.components);
          if (Array.isArray(result) && includeTuple) {
            types.push("tuple(" + result.join(",") + ")" + suffix);
          } else if (!includeTuple) {
            types.push("(" + result.join(",") + ")" + suffix);
          } else {
            types.push("(" + result + ")");
          }
        } else {
          types.push(param.type);
        }
      });
      return types;
    };
    var randomHex = function(size) {
      return "0x" + randombytes(size).toString("hex");
    };
    var hexToAscii = function(hex) {
      if (!utils.isHexStrict(hex))
        throw new Error("The parameter must be a valid HEX string.");
      var str = "";
      var i = 0, l = hex.length;
      if (hex.substring(0, 2) === "0x") {
        i = 2;
      }
      for (; i < l; i += 2) {
        var code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    };
    var asciiToHex = function(str) {
      if (!str)
        return "0x00";
      var hex = "";
      for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0" + n : n;
      }
      return "0x" + hex;
    };
    var getUnitValue = function(unit) {
      unit = unit ? unit.toLowerCase() : "ether";
      if (!ethjsUnit.unitMap[unit]) {
        throw new Error('This unit "' + unit + `" doesn't exist, please use the one of the following units` + JSON.stringify(ethjsUnit.unitMap, null, 2));
      }
      return unit;
    };
    var fromWei = function(number, unit) {
      unit = getUnitValue(unit);
      if (!utils.isBN(number) && !(typeof number === "string")) {
        throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
      }
      return utils.isBN(number) ? ethjsUnit.fromWei(number, unit) : ethjsUnit.fromWei(number, unit).toString(10);
    };
    var toWei = function(number, unit) {
      unit = getUnitValue(unit);
      if (!utils.isBN(number) && !(typeof number === "string")) {
        throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
      }
      return utils.isBN(number) ? ethjsUnit.toWei(number, unit) : ethjsUnit.toWei(number, unit).toString(10);
    };
    var toChecksumAddress = function(address) {
      if (typeof address === "undefined")
        return "";
      if (!/^(0x)?[0-9a-f]{40}$/i.test(address))
        throw new Error('Given address "' + address + '" is not a valid Ethereum address.');
      address = address.toLowerCase().replace(/^0x/i, "");
      var addressHash = utils.sha3(address).replace(/^0x/i, "");
      var checksumAddress = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(addressHash[i], 16) > 7) {
          checksumAddress += address[i].toUpperCase();
        } else {
          checksumAddress += address[i];
        }
      }
      return checksumAddress;
    };
    var compareBlockNumbers = function(a, b) {
      if (a == b) {
        return 0;
      } else if ((a == "genesis" || a == "earliest" || a == 0) && (b == "genesis" || b == "earliest" || b == 0)) {
        return 0;
      } else if (a == "genesis" || a == "earliest") {
        return -1;
      } else if (b == "genesis" || b == "earliest") {
        return 1;
      } else if (a == "latest") {
        if (b == "pending") {
          return -1;
        } else {
          return 1;
        }
      } else if (b === "latest") {
        if (a == "pending") {
          return 1;
        } else {
          return -1;
        }
      } else if (a == "pending") {
        return 1;
      } else if (b == "pending") {
        return -1;
      } else {
        let bnA = new BN(a);
        let bnB = new BN(b);
        if (bnA.lt(bnB)) {
          return -1;
        } else if (bnA.eq(bnB)) {
          return 0;
        } else {
          return 1;
        }
      }
    };
    module.exports = {
      _fireError,
      _jsonInterfaceMethodToString,
      _flattenTypes,
      randomHex,
      BN: utils.BN,
      isBN: utils.isBN,
      isBigNumber: utils.isBigNumber,
      isHex: utils.isHex,
      isHexStrict: utils.isHexStrict,
      sha3: utils.sha3,
      sha3Raw: utils.sha3Raw,
      keccak256: utils.sha3,
      soliditySha3: soliditySha3.soliditySha3,
      soliditySha3Raw: soliditySha3.soliditySha3Raw,
      encodePacked: soliditySha3.encodePacked,
      isAddress: utils.isAddress,
      checkAddressChecksum: utils.checkAddressChecksum,
      toChecksumAddress,
      toHex: utils.toHex,
      toBN: utils.toBN,
      bytesToHex: utils.bytesToHex,
      hexToBytes: utils.hexToBytes,
      hexToNumberString: utils.hexToNumberString,
      hexToNumber: utils.hexToNumber,
      toDecimal: utils.hexToNumber,
      numberToHex: utils.numberToHex,
      fromDecimal: utils.numberToHex,
      hexToUtf8: utils.hexToUtf8,
      hexToString: utils.hexToUtf8,
      toUtf8: utils.hexToUtf8,
      stripHexPrefix: utils.stripHexPrefix,
      utf8ToHex: utils.utf8ToHex,
      stringToHex: utils.utf8ToHex,
      fromUtf8: utils.utf8ToHex,
      hexToAscii,
      toAscii: hexToAscii,
      asciiToHex,
      fromAscii: asciiToHex,
      unitMap: ethjsUnit.unitMap,
      toWei,
      fromWei,
      padLeft: utils.leftPad,
      leftPad: utils.leftPad,
      padRight: utils.rightPad,
      rightPad: utils.rightPad,
      toTwosComplement: utils.toTwosComplement,
      isBloom: utils.isBloom,
      isUserEthereumAddressInBloom: utils.isUserEthereumAddressInBloom,
      isContractAddressInBloom: utils.isContractAddressInBloom,
      isTopic: utils.isTopic,
      isTopicInBloom: utils.isTopicInBloom,
      isInBloom: utils.isInBloom,
      compareBlockNumbers,
      toNumber: utils.toNumber
    };
  }
});

// node_modules/web3-core-helpers/lib/errors.js
var require_errors = __commonJS({
  "node_modules/web3-core-helpers/lib/errors.js"(exports, module) {
    "use strict";
    init_define_process_env();
    module.exports = {
      ErrorResponse: function(result) {
        var message = !!result && !!result.error && !!result.error.message ? result.error.message : JSON.stringify(result);
        var data = !!result.error && !!result.error.data ? result.error.data : null;
        var err = new Error("Returned error: " + message);
        err.data = data;
        return err;
      },
      InvalidNumberOfParams: function(got, expected, method) {
        return new Error('Invalid number of parameters for "' + method + '". Got ' + got + " expected " + expected + "!");
      },
      InvalidConnection: function(host, event) {
        return this.ConnectionError("CONNECTION ERROR: Couldn't connect to node " + host + ".", event);
      },
      InvalidProvider: function() {
        return new Error("Provider not set or invalid");
      },
      InvalidResponse: function(result) {
        var message = !!result && !!result.error && !!result.error.message ? result.error.message : "Invalid JSON RPC response: " + JSON.stringify(result);
        return new Error(message);
      },
      ConnectionTimeout: function(ms) {
        return new Error("CONNECTION TIMEOUT: timeout of " + ms + " ms achived");
      },
      ConnectionNotOpenError: function(event) {
        return this.ConnectionError("connection not open on send()", event);
      },
      ConnectionCloseError: function(event) {
        if (typeof event === "object" && event.code && event.reason) {
          return this.ConnectionError("CONNECTION ERROR: The connection got closed with the close code `" + event.code + "` and the following reason string `" + event.reason + "`", event);
        }
        return new Error("CONNECTION ERROR: The connection closed unexpectedly");
      },
      MaxAttemptsReachedOnReconnectingError: function() {
        return new Error("Maximum number of reconnect attempts reached!");
      },
      PendingRequestsOnReconnectingError: function() {
        return new Error("CONNECTION ERROR: Provider started to reconnect before the response got received!");
      },
      ConnectionError: function(msg, event) {
        const error = new Error(msg);
        if (event) {
          error.code = event.code;
          error.reason = event.reason;
        }
        return error;
      },
      RevertInstructionError: function(reason, signature) {
        var error = new Error("Your request got reverted with the following reason string: " + reason);
        error.reason = reason;
        error.signature = signature;
        return error;
      },
      TransactionRevertInstructionError: function(reason, signature, receipt) {
        var error = new Error("Transaction has been reverted by the EVM:\n" + JSON.stringify(receipt, null, 2));
        error.reason = reason;
        error.signature = signature;
        error.receipt = receipt;
        return error;
      },
      TransactionError: function(message, receipt) {
        var error = new Error(message);
        error.receipt = receipt;
        return error;
      },
      NoContractAddressFoundError: function(receipt) {
        return this.TransactionError("The transaction receipt didn't contain a contract address.", receipt);
      },
      ContractCodeNotStoredError: function(receipt) {
        return this.TransactionError("The contract code couldn't be stored, please check your gas limit.", receipt);
      },
      TransactionRevertedWithoutReasonError: function(receipt) {
        return this.TransactionError("Transaction has been reverted by the EVM:\n" + JSON.stringify(receipt, null, 2), receipt);
      },
      TransactionOutOfGasError: function(receipt) {
        return this.TransactionError("Transaction ran out of gas. Please provide more gas:\n" + JSON.stringify(receipt, null, 2), receipt);
      },
      ResolverMethodMissingError: function(address, name) {
        return new Error("The resolver at " + address + 'does not implement requested method: "' + name + '".');
      },
      ContractMissingABIError: function() {
        return new Error("You must provide the json interface of the contract when instantiating a contract object.");
      },
      ContractOnceRequiresCallbackError: function() {
        return new Error("Once requires a callback as the second parameter.");
      },
      ContractEventDoesNotExistError: function(eventName) {
        return new Error('Event "' + eventName + `" doesn't exist in this contract.`);
      },
      ContractReservedEventError: function(type) {
        return new Error('The event "' + type + `" is a reserved event name, you can't use it.`);
      },
      ContractMissingDeployDataError: function() {
        return new Error('No "data" specified in neither the given options, nor the default options.');
      },
      ContractNoAddressDefinedError: function() {
        return new Error("This contract object doesn't have address set yet, please set an address first.");
      },
      ContractNoFromAddressDefinedError: function() {
        return new Error('No "from" address specified in neither the given options, nor the default options.');
      }
    };
  }
});

// node_modules/web3-eth-iban/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/web3-eth-iban/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var utils = require_lib2();
    var BigNumber2 = require_bn();
    var leftPad = function(string, bytes) {
      let result = string;
      while (result.length < bytes * 2) {
        result = "0" + result;
      }
      return result;
    };
    var iso13616Prepare = function(iban) {
      const A = "A".charCodeAt(0);
      const Z = "Z".charCodeAt(0);
      iban = iban.toUpperCase();
      iban = iban.substr(4) + iban.substr(0, 4);
      return iban.split("").map(function(n) {
        const code = n.charCodeAt(0);
        if (code >= A && code <= Z) {
          return code - A + 10;
        } else {
          return n;
        }
      }).join("");
    };
    var mod9710 = function(iban) {
      let remainder = iban;
      let block;
      while (remainder.length > 2) {
        block = remainder.slice(0, 9);
        remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);
      }
      return parseInt(remainder, 10) % 97;
    };
    var Iban = class {
      constructor(iban) {
        this._iban = iban;
      }
      static toAddress(ib) {
        ib = new Iban(ib);
        if (!ib.isDirect()) {
          throw new Error("IBAN is indirect and can't be converted");
        }
        return ib.toAddress();
      }
      static toIban(address) {
        return Iban.fromAddress(address).toString();
      }
      static fromAddress(address) {
        if (!utils.isAddress(address)) {
          throw new Error("Provided address is not a valid address: " + address);
        }
        address = address.replace("0x", "").replace("0X", "");
        const asBn = new BigNumber2(address, 16);
        const base36 = asBn.toString(36);
        const padded = leftPad(base36, 15);
        return Iban.fromBban(padded.toUpperCase());
      }
      static fromBban(bban) {
        const countryCode = "XE";
        const remainder = mod9710(iso13616Prepare(countryCode + "00" + bban));
        const checkDigit = ("0" + (98 - remainder)).slice(-2);
        return new Iban(countryCode + checkDigit + bban);
      }
      static createIndirect(options) {
        return Iban.fromBban("ETH" + options.institution + options.identifier);
      }
      static isValid(iban) {
        const i = new Iban(iban);
        return i.isValid();
      }
      isValid() {
        return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(this._iban) && mod9710(iso13616Prepare(this._iban)) === 1;
      }
      isDirect() {
        return this._iban.length === 34 || this._iban.length === 35;
      }
      isIndirect() {
        return this._iban.length === 20;
      }
      checksum() {
        return this._iban.substr(2, 2);
      }
      institution() {
        return this.isIndirect() ? this._iban.substr(7, 4) : "";
      }
      client() {
        return this.isIndirect() ? this._iban.substr(11) : "";
      }
      toAddress() {
        if (this.isDirect()) {
          const base36 = this._iban.substr(4);
          const asBn = new BigNumber2(base36, 36);
          return utils.toChecksumAddress(asBn.toString(16, 20));
        }
        return "";
      }
      toString() {
        return this._iban;
      }
    };
    module.exports = Iban;
  }
});

// node_modules/web3-core-helpers/lib/formatters.js
var require_formatters = __commonJS({
  "node_modules/web3-core-helpers/lib/formatters.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var utils = require_lib2();
    var Iban = require_lib3();
    var inputStorageKeysFormatter = function(keys) {
      return keys.map(utils.numberToHex);
    };
    var outputProofFormatter = function(proof) {
      proof.address = utils.toChecksumAddress(proof.address);
      proof.nonce = utils.hexToNumberString(proof.nonce);
      proof.balance = utils.hexToNumberString(proof.balance);
      return proof;
    };
    var outputBigNumberFormatter = function(number) {
      return utils.toBN(number).toString(10);
    };
    var isPredefinedBlockNumber = function(blockNumber) {
      return blockNumber === "latest" || blockNumber === "pending" || blockNumber === "earliest";
    };
    var inputDefaultBlockNumberFormatter = function(blockNumber) {
      if (this && (blockNumber === void 0 || blockNumber === null)) {
        return inputBlockNumberFormatter(this.defaultBlock);
      }
      return inputBlockNumberFormatter(blockNumber);
    };
    var inputBlockNumberFormatter = function(blockNumber) {
      if (blockNumber === void 0) {
        return void 0;
      }
      if (isPredefinedBlockNumber(blockNumber)) {
        return blockNumber;
      }
      if (blockNumber === "genesis") {
        return "0x0";
      }
      return utils.isHexStrict(blockNumber) ? typeof blockNumber === "string" ? blockNumber.toLowerCase() : blockNumber : utils.numberToHex(blockNumber);
    };
    var _txInputFormatter = function(options) {
      if (options.to) {
        options.to = inputAddressFormatter(options.to);
      }
      if (options.data && options.input) {
        throw new Error(`You can't have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.`);
      }
      if (!options.data && options.input) {
        options.data = options.input;
        delete options.input;
      }
      if (options.data && !options.data.startsWith("0x")) {
        options.data = "0x" + options.data;
      }
      if (options.data && !utils.isHex(options.data)) {
        throw new Error("The data field must be HEX encoded data.");
      }
      if (options.gas || options.gasLimit) {
        options.gas = options.gas || options.gasLimit;
      }
      if (options.maxPriorityFeePerGas || options.maxFeePerGas) {
        delete options.gasPrice;
      }
      ["gasPrice", "gas", "value", "maxPriorityFeePerGas", "maxFeePerGas", "nonce"].filter(function(key) {
        return options[key] !== void 0;
      }).forEach(function(key) {
        options[key] = utils.numberToHex(options[key]);
      });
      return options;
    };
    var inputCallFormatter = function(options) {
      options = _txInputFormatter(options);
      var from = options.from || (this ? this.defaultAccount : null);
      if (from) {
        options.from = inputAddressFormatter(from);
      }
      return options;
    };
    var inputTransactionFormatter = function(options) {
      options = _txInputFormatter(options);
      if (!(typeof options.from === "number") && !(!!options.from && typeof options.from === "object")) {
        options.from = options.from || (this ? this.defaultAccount : null);
        if (!options.from && !(typeof options.from === "number")) {
          throw new Error('The send transactions "from" field must be defined!');
        }
        options.from = inputAddressFormatter(options.from);
      }
      return options;
    };
    var inputSignFormatter = function(data) {
      return utils.isHexStrict(data) ? data : utils.utf8ToHex(data);
    };
    var outputTransactionFormatter = function(tx) {
      if (tx.blockNumber !== null)
        tx.blockNumber = utils.hexToNumber(tx.blockNumber);
      if (tx.transactionIndex !== null)
        tx.transactionIndex = utils.hexToNumber(tx.transactionIndex);
      tx.nonce = utils.hexToNumber(tx.nonce);
      tx.gas = utils.hexToNumber(tx.gas);
      if (tx.gasPrice)
        tx.gasPrice = outputBigNumberFormatter(tx.gasPrice);
      if (tx.maxFeePerGas)
        tx.maxFeePerGas = outputBigNumberFormatter(tx.maxFeePerGas);
      if (tx.maxPriorityFeePerGas)
        tx.maxPriorityFeePerGas = outputBigNumberFormatter(tx.maxPriorityFeePerGas);
      if (tx.type)
        tx.type = utils.hexToNumber(tx.type);
      tx.value = outputBigNumberFormatter(tx.value);
      if (tx.to && utils.isAddress(tx.to)) {
        tx.to = utils.toChecksumAddress(tx.to);
      } else {
        tx.to = null;
      }
      if (tx.from) {
        tx.from = utils.toChecksumAddress(tx.from);
      }
      return tx;
    };
    var outputTransactionReceiptFormatter = function(receipt) {
      if (typeof receipt !== "object") {
        throw new Error("Received receipt is invalid: " + receipt);
      }
      if (receipt.blockNumber !== null)
        receipt.blockNumber = utils.hexToNumber(receipt.blockNumber);
      if (receipt.transactionIndex !== null)
        receipt.transactionIndex = utils.hexToNumber(receipt.transactionIndex);
      receipt.cumulativeGasUsed = utils.hexToNumber(receipt.cumulativeGasUsed);
      receipt.gasUsed = utils.hexToNumber(receipt.gasUsed);
      if (Array.isArray(receipt.logs)) {
        receipt.logs = receipt.logs.map(outputLogFormatter);
      }
      if (receipt.effectiveGasPrice) {
        receipt.effectiveGasPrice = utils.hexToNumber(receipt.effectiveGasPrice);
      }
      if (receipt.contractAddress) {
        receipt.contractAddress = utils.toChecksumAddress(receipt.contractAddress);
      }
      if (typeof receipt.status !== "undefined" && receipt.status !== null) {
        receipt.status = Boolean(parseInt(receipt.status));
      }
      return receipt;
    };
    var outputBlockFormatter = function(block) {
      block.gasLimit = utils.hexToNumber(block.gasLimit);
      block.gasUsed = utils.hexToNumber(block.gasUsed);
      block.size = utils.hexToNumber(block.size);
      block.timestamp = utils.hexToNumber(block.timestamp);
      if (block.number !== null)
        block.number = utils.hexToNumber(block.number);
      if (block.difficulty)
        block.difficulty = outputBigNumberFormatter(block.difficulty);
      if (block.totalDifficulty)
        block.totalDifficulty = outputBigNumberFormatter(block.totalDifficulty);
      if (Array.isArray(block.transactions)) {
        block.transactions.forEach(function(item) {
          if (!(typeof item === "string"))
            return outputTransactionFormatter(item);
        });
      }
      if (block.miner)
        block.miner = utils.toChecksumAddress(block.miner);
      if (block.baseFeePerGas)
        block.baseFeePerGas = utils.hexToNumber(block.baseFeePerGas);
      return block;
    };
    var inputLogFormatter = function(options) {
      var toTopic = function(value) {
        if (value === null || typeof value === "undefined")
          return null;
        value = String(value);
        if (value.indexOf("0x") === 0)
          return value;
        else
          return utils.fromUtf8(value);
      };
      if (options === void 0)
        options = {};
      if (options.fromBlock === void 0)
        options = __spreadProps(__spreadValues({}, options), { fromBlock: "latest" });
      if (options.fromBlock || options.fromBlock === 0)
        options.fromBlock = inputBlockNumberFormatter(options.fromBlock);
      if (options.toBlock || options.toBlock === 0)
        options.toBlock = inputBlockNumberFormatter(options.toBlock);
      options.topics = options.topics || [];
      options.topics = options.topics.map(function(topic) {
        return Array.isArray(topic) ? topic.map(toTopic) : toTopic(topic);
      });
      toTopic = null;
      if (options.address) {
        options.address = Array.isArray(options.address) ? options.address.map(function(addr) {
          return inputAddressFormatter(addr);
        }) : inputAddressFormatter(options.address);
      }
      return options;
    };
    var outputLogFormatter = function(log) {
      if (typeof log.blockHash === "string" && typeof log.transactionHash === "string" && typeof log.logIndex === "string") {
        var shaId = utils.sha3(log.blockHash.replace("0x", "") + log.transactionHash.replace("0x", "") + log.logIndex.replace("0x", ""));
        log.id = "log_" + shaId.replace("0x", "").substr(0, 8);
      } else if (!log.id) {
        log.id = null;
      }
      if (log.blockNumber !== null)
        log.blockNumber = utils.hexToNumber(log.blockNumber);
      if (log.transactionIndex !== null)
        log.transactionIndex = utils.hexToNumber(log.transactionIndex);
      if (log.logIndex !== null)
        log.logIndex = utils.hexToNumber(log.logIndex);
      if (log.address) {
        log.address = utils.toChecksumAddress(log.address);
      }
      return log;
    };
    var inputPostFormatter = function(post) {
      if (post.ttl)
        post.ttl = utils.numberToHex(post.ttl);
      if (post.workToProve)
        post.workToProve = utils.numberToHex(post.workToProve);
      if (post.priority)
        post.priority = utils.numberToHex(post.priority);
      if (!Array.isArray(post.topics)) {
        post.topics = post.topics ? [post.topics] : [];
      }
      post.topics = post.topics.map(function(topic) {
        return topic.indexOf("0x") === 0 ? topic : utils.fromUtf8(topic);
      });
      return post;
    };
    var outputPostFormatter = function(post) {
      post.expiry = utils.hexToNumber(post.expiry);
      post.sent = utils.hexToNumber(post.sent);
      post.ttl = utils.hexToNumber(post.ttl);
      post.workProved = utils.hexToNumber(post.workProved);
      if (!post.topics) {
        post.topics = [];
      }
      post.topics = post.topics.map(function(topic) {
        return utils.toUtf8(topic);
      });
      return post;
    };
    var inputAddressFormatter = function(address) {
      var iban = new Iban(address);
      if (iban.isValid() && iban.isDirect()) {
        return iban.toAddress().toLowerCase();
      } else if (utils.isAddress(address)) {
        return "0x" + address.toLowerCase().replace("0x", "");
      }
      throw new Error(`Provided address ${address} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`);
    };
    var outputSyncingFormatter = function(result) {
      result.startingBlock = utils.hexToNumber(result.startingBlock);
      result.currentBlock = utils.hexToNumber(result.currentBlock);
      result.highestBlock = utils.hexToNumber(result.highestBlock);
      if (result.knownStates) {
        result.knownStates = utils.hexToNumber(result.knownStates);
        result.pulledStates = utils.hexToNumber(result.pulledStates);
      }
      return result;
    };
    module.exports = {
      inputDefaultBlockNumberFormatter,
      inputBlockNumberFormatter,
      inputCallFormatter,
      inputTransactionFormatter,
      inputAddressFormatter,
      inputPostFormatter,
      inputLogFormatter,
      inputSignFormatter,
      inputStorageKeysFormatter,
      outputProofFormatter,
      outputBigNumberFormatter,
      outputTransactionFormatter,
      outputTransactionReceiptFormatter,
      outputBlockFormatter,
      outputLogFormatter,
      outputPostFormatter,
      outputSyncingFormatter
    };
  }
});

// node_modules/web3-core-helpers/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/web3-core-helpers/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var errors = require_errors();
    var formatters = require_formatters();
    module.exports = {
      errors,
      formatters
    };
  }
});

// node_modules/web3-eth-contract/node_modules/web3-core-requestmanager/lib/jsonrpc.js
var require_jsonrpc = __commonJS({
  "node_modules/web3-eth-contract/node_modules/web3-core-requestmanager/lib/jsonrpc.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = {
      messageId: 0
    };
    Jsonrpc.toPayload = function(method, params) {
      if (!method) {
        throw new Error('JSONRPC method should be specified for params: "' + JSON.stringify(params) + '"!');
      }
      Jsonrpc.messageId++;
      return {
        jsonrpc: "2.0",
        id: Jsonrpc.messageId,
        method,
        params: params || []
      };
    };
    Jsonrpc.isValidResponse = function(response) {
      return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);
      function validateSingleMessage(message) {
        return !!message && !message.error && message.jsonrpc === "2.0" && (typeof message.id === "number" || typeof message.id === "string") && message.result !== void 0;
      }
    };
    Jsonrpc.toBatchPayload = function(messages) {
      return messages.map(function(message) {
        return Jsonrpc.toPayload(message.method, message.params);
      });
    };
    module.exports = Jsonrpc;
  }
});

// node_modules/web3-eth-contract/node_modules/web3-core-requestmanager/lib/batch.js
var require_batch = __commonJS({
  "node_modules/web3-eth-contract/node_modules/web3-core-requestmanager/lib/batch.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = require_jsonrpc();
    var errors = require_lib4().errors;
    var Batch = function(requestManager) {
      this.requestManager = requestManager;
      this.requests = [];
    };
    Batch.prototype.add = function(request) {
      this.requests.push(request);
    };
    Batch.prototype.execute = function() {
      var requests = this.requests;
      var sortResponses = this._sortResponses.bind(this);
      this.requestManager.sendBatch(requests, function(err, results) {
        results = sortResponses(results);
        requests.map(function(request, index) {
          return results[index] || {};
        }).forEach(function(result, index) {
          if (requests[index].callback) {
            if (result && result.error) {
              return requests[index].callback(errors.ErrorResponse(result));
            }
            if (!Jsonrpc.isValidResponse(result)) {
              return requests[index].callback(errors.InvalidResponse(result));
            }
            try {
              requests[index].callback(null, requests[index].format ? requests[index].format(result.result) : result.result);
            } catch (err2) {
              requests[index].callback(err2);
            }
          }
        });
      });
    };
    Batch.prototype._sortResponses = function(responses) {
      return (responses || []).sort((a, b) => a.id - b.id);
    };
    module.exports = Batch;
  }
});

// node_modules/web3-eth-contract/node_modules/web3-core-requestmanager/lib/givenProvider.js
var require_givenProvider = __commonJS({
  "node_modules/web3-eth-contract/node_modules/web3-core-requestmanager/lib/givenProvider.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var givenProvider = null;
    var global = typeof globalThis === "object" ? globalThis : void 0;
    if (!global) {
      try {
        global = Function("return this")();
      } catch (e) {
        global = self;
      }
    }
    if (typeof global.ethereum !== "undefined") {
      givenProvider = global.ethereum;
    } else if (typeof global.web3 !== "undefined" && global.web3.currentProvider) {
      if (global.web3.currentProvider.sendAsync) {
        global.web3.currentProvider.send = global.web3.currentProvider.sendAsync;
        delete global.web3.currentProvider.sendAsync;
      }
      if (!global.web3.currentProvider.on && global.web3.currentProvider.connection && global.web3.currentProvider.connection.constructor.name === "ipcProviderWrapper") {
        global.web3.currentProvider.on = function(type, callback) {
          if (typeof callback !== "function")
            throw new Error("The second parameter callback must be a function.");
          switch (type) {
            case "data":
              this.connection.on("data", function(data) {
                var result = "";
                data = data.toString();
                try {
                  result = JSON.parse(data);
                } catch (e) {
                  return callback(new Error("Couldn't parse response data" + data));
                }
                if (!result.id && result.method.indexOf("_subscription") !== -1) {
                  callback(null, result);
                }
              });
              break;
            default:
              this.connection.on(type, callback);
              break;
          }
        };
      }
      givenProvider = global.web3.currentProvider;
    }
    module.exports = givenProvider;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if (typeof module !== "undefined") {
      module.exports = EventEmitter;
    }
  }
});

// node_modules/web3-eth-contract/node_modules/web3-providers-ws/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/web3-eth-contract/node_modules/web3-providers-ws/lib/helpers.js"(exports, module) {
    init_define_process_env();
    var isNode = Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
    var isRN = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var _btoa = null;
    var helpers = null;
    if (isNode || isRN) {
      _btoa = function(str) {
        return Buffer.from(str).toString("base64");
      };
      url = require_url();
      if (url.URL) {
        newURL = url.URL;
        helpers = function(url2) {
          return new newURL(url2);
        };
      } else {
        helpers = require_url().parse;
      }
    } else {
      _btoa = btoa.bind(typeof globalThis === "object" ? globalThis : self);
      helpers = function(url2) {
        return new URL(url2);
      };
    }
    var url;
    var newURL;
    module.exports = {
      parseURL: helpers,
      btoa: _btoa
    };
  }
});

// node_modules/es5-ext/global.js
var require_global = __commonJS({
  "node_modules/es5-ext/global.js"(exports, module) {
    init_define_process_env();
    var naiveFallback = function() {
      if (typeof self === "object" && self)
        return self;
      if (typeof window === "object" && window)
        return window;
      throw new Error("Unable to resolve global `this`");
    };
    module.exports = function() {
      if (this)
        return this;
      if (typeof globalThis === "object" && globalThis)
        return globalThis;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function() {
            return this;
          },
          configurable: true
        });
      } catch (error) {
        return naiveFallback();
      }
      try {
        if (!__global__)
          return naiveFallback();
        return __global__;
      } finally {
        delete Object.prototype.__global__;
      }
    }();
  }
});

// node_modules/websocket/package.json
var require_package = __commonJS({
  "node_modules/websocket/package.json"(exports, module) {
    module.exports = {
      name: "websocket",
      description: "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
      keywords: [
        "websocket",
        "websockets",
        "socket",
        "networking",
        "comet",
        "push",
        "RFC-6455",
        "realtime",
        "server",
        "client"
      ],
      author: "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
      contributors: [
        "I\xF1aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
      ],
      version: "1.0.34",
      repository: {
        type: "git",
        url: "https://github.com/theturtle32/WebSocket-Node.git"
      },
      homepage: "https://github.com/theturtle32/WebSocket-Node",
      engines: {
        node: ">=4.0.0"
      },
      dependencies: {
        bufferutil: "^4.0.1",
        debug: "^2.2.0",
        "es5-ext": "^0.10.50",
        "typedarray-to-buffer": "^3.1.5",
        "utf-8-validate": "^5.0.2",
        yaeti: "^0.0.6"
      },
      devDependencies: {
        "buffer-equal": "^1.0.0",
        gulp: "^4.0.2",
        "gulp-jshint": "^2.0.4",
        "jshint-stylish": "^2.2.1",
        jshint: "^2.0.0",
        tape: "^4.9.1"
      },
      config: {
        verbose: false
      },
      scripts: {
        test: "tape test/unit/*.js",
        gulp: "gulp"
      },
      main: "index",
      directories: {
        lib: "./lib"
      },
      browser: "lib/browser.js",
      license: "Apache-2.0"
    };
  }
});

// node_modules/websocket/lib/version.js
var require_version = __commonJS({
  "node_modules/websocket/lib/version.js"(exports, module) {
    init_define_process_env();
    module.exports = require_package().version;
  }
});

// node_modules/websocket/lib/browser.js
var require_browser2 = __commonJS({
  "node_modules/websocket/lib/browser.js"(exports, module) {
    init_define_process_env();
    var _globalThis;
    if (typeof globalThis === "object") {
      _globalThis = globalThis;
    } else {
      try {
        _globalThis = require_global();
      } catch (error) {
      } finally {
        if (!_globalThis && typeof window !== "undefined") {
          _globalThis = window;
        }
        if (!_globalThis) {
          throw new Error("Could not determine global this");
        }
      }
    }
    var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
    var websocket_version = require_version();
    function W3CWebSocket(uri, protocols) {
      var native_instance;
      if (protocols) {
        native_instance = new NativeWebSocket(uri, protocols);
      } else {
        native_instance = new NativeWebSocket(uri);
      }
      return native_instance;
    }
    if (NativeWebSocket) {
      ["CONNECTING", "OPEN", "CLOSING", "CLOSED"].forEach(function(prop) {
        Object.defineProperty(W3CWebSocket, prop, {
          get: function() {
            return NativeWebSocket[prop];
          }
        });
      });
    }
    module.exports = {
      "w3cwebsocket": NativeWebSocket ? W3CWebSocket : null,
      "version": websocket_version
    };
  }
});

// node_modules/web3-eth-contract/node_modules/web3-providers-ws/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/web3-eth-contract/node_modules/web3-providers-ws/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var EventEmitter = require_eventemitter3();
    var helpers = require_helpers();
    var errors = require_lib4().errors;
    var Ws = require_browser2().w3cwebsocket;
    var WebsocketProvider = function WebsocketProvider2(url, options) {
      EventEmitter.call(this);
      options = options || {};
      this.url = url;
      this._customTimeout = options.timeout || 1e3 * 15;
      this.headers = options.headers || {};
      this.protocol = options.protocol || void 0;
      this.reconnectOptions = Object.assign({
        auto: false,
        delay: 5e3,
        maxAttempts: false,
        onTimeout: false
      }, options.reconnect);
      this.clientConfig = options.clientConfig || void 0;
      this.requestOptions = options.requestOptions || void 0;
      this.DATA = "data";
      this.CLOSE = "close";
      this.ERROR = "error";
      this.CONNECT = "connect";
      this.RECONNECT = "reconnect";
      this.connection = null;
      this.requestQueue = /* @__PURE__ */ new Map();
      this.responseQueue = /* @__PURE__ */ new Map();
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      var parsedURL = helpers.parseURL(url);
      if (parsedURL.username && parsedURL.password) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.username + ":" + parsedURL.password);
      }
      if (parsedURL.auth) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.auth);
      }
      Object.defineProperty(this, "connected", {
        get: function() {
          return this.connection && this.connection.readyState === this.connection.OPEN;
        },
        enumerable: true
      });
      this.connect();
    };
    WebsocketProvider.prototype = Object.create(EventEmitter.prototype);
    WebsocketProvider.prototype.constructor = WebsocketProvider;
    WebsocketProvider.prototype.connect = function() {
      this.connection = new Ws(this.url, this.protocol, void 0, this.headers, this.requestOptions, this.clientConfig);
      this._addSocketListeners();
    };
    WebsocketProvider.prototype._onMessage = function(e) {
      var _this = this;
      this._parseResponse(typeof e.data === "string" ? e.data : "").forEach(function(result) {
        if (result.method && result.method.indexOf("_subscription") !== -1) {
          _this.emit(_this.DATA, result);
          return;
        }
        var id2 = result.id;
        if (Array.isArray(result)) {
          id2 = result[0].id;
        }
        if (_this.responseQueue.has(id2)) {
          if (_this.responseQueue.get(id2).callback !== void 0) {
            _this.responseQueue.get(id2).callback(false, result);
          }
          _this.responseQueue.delete(id2);
        }
      });
    };
    WebsocketProvider.prototype._onConnect = function() {
      this.emit(this.CONNECT);
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        var _this = this;
        this.requestQueue.forEach(function(request, key) {
          _this.send(request.payload, request.callback);
          _this.requestQueue.delete(key);
        });
      }
    };
    WebsocketProvider.prototype._onClose = function(event) {
      var _this = this;
      if (this.reconnectOptions.auto && (![1e3, 1001].includes(event.code) || event.wasClean === false)) {
        this.reconnect();
        return;
      }
      this.emit(this.CLOSE, event);
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors.ConnectionNotOpenError(event));
          _this.requestQueue.delete(key);
        });
      }
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors.InvalidConnection("on WS", event));
          _this.responseQueue.delete(key);
        });
      }
      this._removeSocketListeners();
      this.removeAllListeners();
    };
    WebsocketProvider.prototype._addSocketListeners = function() {
      this.connection.addEventListener("message", this._onMessage.bind(this));
      this.connection.addEventListener("open", this._onConnect.bind(this));
      this.connection.addEventListener("close", this._onClose.bind(this));
    };
    WebsocketProvider.prototype._removeSocketListeners = function() {
      this.connection.removeEventListener("message", this._onMessage);
      this.connection.removeEventListener("open", this._onConnect);
      this.connection.removeEventListener("close", this._onClose);
    };
    WebsocketProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {
              _this.reconnect();
              return;
            }
            _this.emit(_this.ERROR, errors.ConnectionTimeout(_this._customTimeout));
            if (_this.requestQueue.size > 0) {
              _this.requestQueue.forEach(function(request, key) {
                request.callback(errors.ConnectionTimeout(_this._customTimeout));
                _this.requestQueue.delete(key);
              });
            }
          }, _this._customTimeout);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    WebsocketProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var id2 = payload.id;
      var request = { payload, callback };
      if (Array.isArray(payload)) {
        id2 = payload[0].id;
      }
      if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {
        this.requestQueue.set(id2, request);
        return;
      }
      if (this.connection.readyState !== this.connection.OPEN) {
        this.requestQueue.delete(id2);
        this.emit(this.ERROR, errors.ConnectionNotOpenError());
        request.callback(errors.ConnectionNotOpenError());
        return;
      }
      this.responseQueue.set(id2, request);
      this.requestQueue.delete(id2);
      try {
        this.connection.send(JSON.stringify(request.payload));
      } catch (error) {
        request.callback(error);
        _this.responseQueue.delete(id2);
      }
    };
    WebsocketProvider.prototype.reset = function() {
      this.responseQueue.clear();
      this.requestQueue.clear();
      this.removeAllListeners();
      this._removeSocketListeners();
      this._addSocketListeners();
    };
    WebsocketProvider.prototype.disconnect = function(code, reason) {
      this._removeSocketListeners();
      this.connection.close(code || 1e3, reason);
    };
    WebsocketProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    WebsocketProvider.prototype.reconnect = function() {
      var _this = this;
      this.reconnecting = true;
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors.PendingRequestsOnReconnectingError());
          _this.responseQueue.delete(key);
        });
      }
      if (!this.reconnectOptions.maxAttempts || this.reconnectAttempts < this.reconnectOptions.maxAttempts) {
        setTimeout(function() {
          _this.reconnectAttempts++;
          _this._removeSocketListeners();
          _this.emit(_this.RECONNECT, _this.reconnectAttempts);
          _this.connect();
        }, this.reconnectOptions.delay);
        return;
      }
      this.emit(this.ERROR, errors.MaxAttemptsReachedOnReconnectingError());
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors.MaxAttemptsReachedOnReconnectingError());
          _this.requestQueue.delete(key);
        });
      }
    };
    module.exports = WebsocketProvider;
  }
});

// browser-external:http
var http_exports = {};
__export(http_exports, {
  default: () => http_default
});
var http_default;
var init_http = __esm({
  "browser-external:http"() {
    init_define_process_env();
    http_default = new Proxy({}, {
      get() {
        throw new Error('Module "http" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:https
var https_exports = {};
__export(https_exports, {
  default: () => https_default
});
var https_default;
var init_https = __esm({
  "browser-external:https"() {
    init_define_process_env();
    https_default = new Proxy({}, {
      get() {
        throw new Error('Module "https" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/xhr2-cookies/dist/progress-event.js
var require_progress_event = __commonJS({
  "node_modules/xhr2-cookies/dist/progress-event.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProgressEvent = function() {
      function ProgressEvent2(type) {
        this.type = type;
        this.bubbles = false;
        this.cancelable = false;
        this.loaded = 0;
        this.lengthComputable = false;
        this.total = 0;
      }
      return ProgressEvent2;
    }();
    exports.ProgressEvent = ProgressEvent;
  }
});

// node_modules/xhr2-cookies/dist/errors.js
var require_errors2 = __commonJS({
  "node_modules/xhr2-cookies/dist/errors.js"(exports) {
    "use strict";
    init_define_process_env();
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var SecurityError = function(_super) {
      __extends(SecurityError2, _super);
      function SecurityError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return SecurityError2;
    }(Error);
    exports.SecurityError = SecurityError;
    var InvalidStateError = function(_super) {
      __extends(InvalidStateError2, _super);
      function InvalidStateError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return InvalidStateError2;
    }(Error);
    exports.InvalidStateError = InvalidStateError;
    var NetworkError = function(_super) {
      __extends(NetworkError2, _super);
      function NetworkError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NetworkError2;
    }(Error);
    exports.NetworkError = NetworkError;
    var SyntaxError = function(_super) {
      __extends(SyntaxError2, _super);
      function SyntaxError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return SyntaxError2;
    }(Error);
    exports.SyntaxError = SyntaxError;
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request-event-target.js
var require_xml_http_request_event_target = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request-event-target.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    var XMLHttpRequestEventTarget = function() {
      function XMLHttpRequestEventTarget2() {
        this.listeners = {};
      }
      XMLHttpRequestEventTarget2.prototype.addEventListener = function(eventType, listener) {
        eventType = eventType.toLowerCase();
        this.listeners[eventType] = this.listeners[eventType] || [];
        this.listeners[eventType].push(listener.handleEvent || listener);
      };
      XMLHttpRequestEventTarget2.prototype.removeEventListener = function(eventType, listener) {
        eventType = eventType.toLowerCase();
        if (!this.listeners[eventType]) {
          return;
        }
        var index = this.listeners[eventType].indexOf(listener.handleEvent || listener);
        if (index < 0) {
          return;
        }
        this.listeners[eventType].splice(index, 1);
      };
      XMLHttpRequestEventTarget2.prototype.dispatchEvent = function(event) {
        var eventType = event.type.toLowerCase();
        event.target = this;
        if (this.listeners[eventType]) {
          for (var _i = 0, _a = this.listeners[eventType]; _i < _a.length; _i++) {
            var listener_1 = _a[_i];
            listener_1.call(this, event);
          }
        }
        var listener = this["on" + eventType];
        if (listener) {
          listener.call(this, event);
        }
        return true;
      };
      return XMLHttpRequestEventTarget2;
    }();
    exports.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget;
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request-upload.js
var require_xml_http_request_upload = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request-upload.js"(exports) {
    "use strict";
    init_define_process_env();
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    var XMLHttpRequestUpload = function(_super) {
      __extends(XMLHttpRequestUpload2, _super);
      function XMLHttpRequestUpload2() {
        var _this = _super.call(this) || this;
        _this._contentType = null;
        _this._body = null;
        _this._reset();
        return _this;
      }
      XMLHttpRequestUpload2.prototype._reset = function() {
        this._contentType = null;
        this._body = null;
      };
      XMLHttpRequestUpload2.prototype._setData = function(data) {
        if (data == null) {
          return;
        }
        if (typeof data === "string") {
          if (data.length !== 0) {
            this._contentType = "text/plain;charset=UTF-8";
          }
          this._body = new Buffer(data, "utf-8");
        } else if (Buffer.isBuffer(data)) {
          this._body = data;
        } else if (data instanceof ArrayBuffer) {
          var body = new Buffer(data.byteLength);
          var view = new Uint8Array(data);
          for (var i = 0; i < data.byteLength; i++) {
            body[i] = view[i];
          }
          this._body = body;
        } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
          var body = new Buffer(data.byteLength);
          var offset = data.byteOffset;
          var view = new Uint8Array(data.buffer);
          for (var i = 0; i < data.byteLength; i++) {
            body[i] = view[i + offset];
          }
          this._body = body;
        } else {
          throw new Error("Unsupported send() data " + data);
        }
      };
      XMLHttpRequestUpload2.prototype._finalizeHeaders = function(headers, loweredHeaders) {
        if (this._contentType && !loweredHeaders["content-type"]) {
          headers["Content-Type"] = this._contentType;
        }
        if (this._body) {
          headers["Content-Length"] = this._body.length.toString();
        }
      };
      XMLHttpRequestUpload2.prototype._startUpload = function(request) {
        if (this._body) {
          request.write(this._body);
        }
        request.end();
      };
      return XMLHttpRequestUpload2;
    }(xml_http_request_event_target_1.XMLHttpRequestEventTarget);
    exports.XMLHttpRequestUpload = XMLHttpRequestUpload;
  }
});

// node_modules/cookiejar/cookiejar.js
var require_cookiejar = __commonJS({
  "node_modules/cookiejar/cookiejar.js"(exports) {
    init_define_process_env();
    (function() {
      "use strict";
      function CookieAccessInfo(domain, path, secure, script) {
        if (this instanceof CookieAccessInfo) {
          this.domain = domain || void 0;
          this.path = path || "/";
          this.secure = !!secure;
          this.script = !!script;
          return this;
        }
        return new CookieAccessInfo(domain, path, secure, script);
      }
      CookieAccessInfo.All = Object.freeze(/* @__PURE__ */ Object.create(null));
      exports.CookieAccessInfo = CookieAccessInfo;
      function Cookie(cookiestr, request_domain, request_path) {
        if (cookiestr instanceof Cookie) {
          return cookiestr;
        }
        if (this instanceof Cookie) {
          this.name = null;
          this.value = null;
          this.expiration_date = Infinity;
          this.path = String(request_path || "/");
          this.explicit_path = false;
          this.domain = request_domain || null;
          this.explicit_domain = false;
          this.secure = false;
          this.noscript = false;
          if (cookiestr) {
            this.parse(cookiestr, request_domain, request_path);
          }
          return this;
        }
        return new Cookie(cookiestr, request_domain, request_path);
      }
      exports.Cookie = Cookie;
      Cookie.prototype.toString = function toString() {
        var str = [this.name + "=" + this.value];
        if (this.expiration_date !== Infinity) {
          str.push("expires=" + new Date(this.expiration_date).toGMTString());
        }
        if (this.domain) {
          str.push("domain=" + this.domain);
        }
        if (this.path) {
          str.push("path=" + this.path);
        }
        if (this.secure) {
          str.push("secure");
        }
        if (this.noscript) {
          str.push("httponly");
        }
        return str.join("; ");
      };
      Cookie.prototype.toValueString = function toValueString() {
        return this.name + "=" + this.value;
      };
      var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
      Cookie.prototype.parse = function parse(str, request_domain, request_path) {
        if (this instanceof Cookie) {
          var parts = str.split(";").filter(function(value2) {
            return !!value2;
          });
          var i;
          var pair = parts[0].match(/([^=]+)=([\s\S]*)/);
          if (!pair) {
            console.warn("Invalid cookie header encountered. Header: '" + str + "'");
            return;
          }
          var key = pair[1];
          var value = pair[2];
          if (typeof key !== "string" || key.length === 0 || typeof value !== "string") {
            console.warn("Unable to extract values from cookie header. Cookie: '" + str + "'");
            return;
          }
          this.name = key;
          this.value = value;
          for (i = 1; i < parts.length; i += 1) {
            pair = parts[i].match(/([^=]+)(?:=([\s\S]*))?/);
            key = pair[1].trim().toLowerCase();
            value = pair[2];
            switch (key) {
              case "httponly":
                this.noscript = true;
                break;
              case "expires":
                this.expiration_date = value ? Number(Date.parse(value)) : Infinity;
                break;
              case "path":
                this.path = value ? value.trim() : "";
                this.explicit_path = true;
                break;
              case "domain":
                this.domain = value ? value.trim() : "";
                this.explicit_domain = !!this.domain;
                break;
              case "secure":
                this.secure = true;
                break;
            }
          }
          if (!this.explicit_path) {
            this.path = request_path || "/";
          }
          if (!this.explicit_domain) {
            this.domain = request_domain;
          }
          return this;
        }
        return new Cookie().parse(str, request_domain, request_path);
      };
      Cookie.prototype.matches = function matches(access_info) {
        if (access_info === CookieAccessInfo.All) {
          return true;
        }
        if (this.noscript && access_info.script || this.secure && !access_info.secure || !this.collidesWith(access_info)) {
          return false;
        }
        return true;
      };
      Cookie.prototype.collidesWith = function collidesWith(access_info) {
        if (this.path && !access_info.path || this.domain && !access_info.domain) {
          return false;
        }
        if (this.path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        if (this.explicit_path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/, "");
        var cookie_domain = this.domain && this.domain.replace(/^[\.]/, "");
        if (cookie_domain === access_domain) {
          return true;
        }
        if (cookie_domain) {
          if (!this.explicit_domain) {
            return false;
          }
          var wildcard = access_domain.indexOf(cookie_domain);
          if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
            return false;
          }
          return true;
        }
        return true;
      };
      function CookieJar() {
        var cookies, cookies_list, collidable_cookie;
        if (this instanceof CookieJar) {
          cookies = /* @__PURE__ */ Object.create(null);
          this.setCookie = function setCookie(cookie, request_domain, request_path) {
            var remove, i;
            cookie = new Cookie(cookie, request_domain, request_path);
            remove = cookie.expiration_date <= Date.now();
            if (cookies[cookie.name] !== void 0) {
              cookies_list = cookies[cookie.name];
              for (i = 0; i < cookies_list.length; i += 1) {
                collidable_cookie = cookies_list[i];
                if (collidable_cookie.collidesWith(cookie)) {
                  if (remove) {
                    cookies_list.splice(i, 1);
                    if (cookies_list.length === 0) {
                      delete cookies[cookie.name];
                    }
                    return false;
                  }
                  cookies_list[i] = cookie;
                  return cookie;
                }
              }
              if (remove) {
                return false;
              }
              cookies_list.push(cookie);
              return cookie;
            }
            if (remove) {
              return false;
            }
            cookies[cookie.name] = [cookie];
            return cookies[cookie.name];
          };
          this.getCookie = function getCookie(cookie_name, access_info) {
            var cookie, i;
            cookies_list = cookies[cookie_name];
            if (!cookies_list) {
              return;
            }
            for (i = 0; i < cookies_list.length; i += 1) {
              cookie = cookies_list[i];
              if (cookie.expiration_date <= Date.now()) {
                if (cookies_list.length === 0) {
                  delete cookies[cookie.name];
                }
                continue;
              }
              if (cookie.matches(access_info)) {
                return cookie;
              }
            }
          };
          this.getCookies = function getCookies(access_info) {
            var matches = [], cookie_name, cookie;
            for (cookie_name in cookies) {
              cookie = this.getCookie(cookie_name, access_info);
              if (cookie) {
                matches.push(cookie);
              }
            }
            matches.toString = function toString() {
              return matches.join(":");
            };
            matches.toValueString = function toValueString() {
              return matches.map(function(c) {
                return c.toValueString();
              }).join("; ");
            };
            return matches;
          };
          return this;
        }
        return new CookieJar();
      }
      exports.CookieJar = CookieJar;
      CookieJar.prototype.setCookies = function setCookies(cookies, request_domain, request_path) {
        cookies = Array.isArray(cookies) ? cookies : cookies.split(cookie_str_splitter);
        var successful = [], i, cookie;
        cookies = cookies.map(function(item) {
          return new Cookie(item, request_domain, request_path);
        });
        for (i = 0; i < cookies.length; i += 1) {
          cookie = cookies[i];
          if (this.setCookie(cookie, request_domain, request_path)) {
            successful.push(cookie);
          }
        }
        return successful;
      };
    })();
  }
});

// node_modules/xhr2-cookies/dist/xml-http-request.js
var require_xml_http_request = __commonJS({
  "node_modules/xhr2-cookies/dist/xml-http-request.js"(exports) {
    "use strict";
    init_define_process_env();
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var http = (init_http(), __toCommonJS(http_exports));
    var https = (init_https(), __toCommonJS(https_exports));
    var os = (init_os(), __toCommonJS(os_exports));
    var url = require_url();
    var progress_event_1 = require_progress_event();
    var errors_1 = require_errors2();
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    var xml_http_request_upload_1 = require_xml_http_request_upload();
    var Cookie = require_cookiejar();
    var XMLHttpRequest2 = function(_super) {
      __extends(XMLHttpRequest3, _super);
      function XMLHttpRequest3(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = _super.call(this) || this;
        _this.UNSENT = XMLHttpRequest3.UNSENT;
        _this.OPENED = XMLHttpRequest3.OPENED;
        _this.HEADERS_RECEIVED = XMLHttpRequest3.HEADERS_RECEIVED;
        _this.LOADING = XMLHttpRequest3.LOADING;
        _this.DONE = XMLHttpRequest3.DONE;
        _this.onreadystatechange = null;
        _this.readyState = XMLHttpRequest3.UNSENT;
        _this.response = null;
        _this.responseText = "";
        _this.responseType = "";
        _this.status = 0;
        _this.statusText = "";
        _this.timeout = 0;
        _this.upload = new xml_http_request_upload_1.XMLHttpRequestUpload();
        _this.responseUrl = "";
        _this.withCredentials = false;
        _this._method = null;
        _this._url = null;
        _this._sync = false;
        _this._headers = {};
        _this._loweredHeaders = {};
        _this._mimeOverride = null;
        _this._request = null;
        _this._response = null;
        _this._responseParts = null;
        _this._responseHeaders = null;
        _this._aborting = null;
        _this._error = null;
        _this._loadedBytes = 0;
        _this._totalBytes = 0;
        _this._lengthComputable = false;
        _this._restrictedMethods = { CONNECT: true, TRACE: true, TRACK: true };
        _this._restrictedHeaders = {
          "accept-charset": true,
          "accept-encoding": true,
          "access-control-request-headers": true,
          "access-control-request-method": true,
          connection: true,
          "content-length": true,
          cookie: true,
          cookie2: true,
          date: true,
          dnt: true,
          expect: true,
          host: true,
          "keep-alive": true,
          origin: true,
          referer: true,
          te: true,
          trailer: true,
          "transfer-encoding": true,
          upgrade: true,
          "user-agent": true,
          via: true
        };
        _this._privateHeaders = { "set-cookie": true, "set-cookie2": true };
        _this._userAgent = "Mozilla/5.0 (" + os.type() + " " + os.arch() + ") node.js/" + process.versions.node + " v8/" + process.versions.v8;
        _this._anonymous = options.anon || false;
        return _this;
      }
      XMLHttpRequest3.prototype.open = function(method, url2, async, user, password) {
        if (async === void 0) {
          async = true;
        }
        method = method.toUpperCase();
        if (this._restrictedMethods[method]) {
          throw new XMLHttpRequest3.SecurityError("HTTP method " + method + " is not allowed in XHR");
        }
        ;
        var xhrUrl = this._parseUrl(url2, user, password);
        if (this.readyState === XMLHttpRequest3.HEADERS_RECEIVED || this.readyState === XMLHttpRequest3.LOADING) {
        }
        this._method = method;
        this._url = xhrUrl;
        this._sync = !async;
        this._headers = {};
        this._loweredHeaders = {};
        this._mimeOverride = null;
        this._setReadyState(XMLHttpRequest3.OPENED);
        this._request = null;
        this._response = null;
        this.status = 0;
        this.statusText = "";
        this._responseParts = [];
        this._responseHeaders = null;
        this._loadedBytes = 0;
        this._totalBytes = 0;
        this._lengthComputable = false;
      };
      XMLHttpRequest3.prototype.setRequestHeader = function(name, value) {
        if (this.readyState !== XMLHttpRequest3.OPENED) {
          throw new XMLHttpRequest3.InvalidStateError("XHR readyState must be OPENED");
        }
        var loweredName = name.toLowerCase();
        if (this._restrictedHeaders[loweredName] || /^sec-/.test(loweredName) || /^proxy-/.test(loweredName)) {
          console.warn('Refused to set unsafe header "' + name + '"');
          return;
        }
        value = value.toString();
        if (this._loweredHeaders[loweredName] != null) {
          name = this._loweredHeaders[loweredName];
          this._headers[name] = this._headers[name] + ", " + value;
        } else {
          this._loweredHeaders[loweredName] = name;
          this._headers[name] = value;
        }
      };
      XMLHttpRequest3.prototype.send = function(data) {
        if (this.readyState !== XMLHttpRequest3.OPENED) {
          throw new XMLHttpRequest3.InvalidStateError("XHR readyState must be OPENED");
        }
        if (this._request) {
          throw new XMLHttpRequest3.InvalidStateError("send() already called");
        }
        switch (this._url.protocol) {
          case "file:":
            return this._sendFile(data);
          case "http:":
          case "https:":
            return this._sendHttp(data);
          default:
            throw new XMLHttpRequest3.NetworkError("Unsupported protocol " + this._url.protocol);
        }
      };
      XMLHttpRequest3.prototype.abort = function() {
        if (this._request == null) {
          return;
        }
        this._request.abort();
        this._setError();
        this._dispatchProgress("abort");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype.getResponseHeader = function(name) {
        if (this._responseHeaders == null || name == null) {
          return null;
        }
        var loweredName = name.toLowerCase();
        return this._responseHeaders.hasOwnProperty(loweredName) ? this._responseHeaders[name.toLowerCase()] : null;
      };
      XMLHttpRequest3.prototype.getAllResponseHeaders = function() {
        var _this = this;
        if (this._responseHeaders == null) {
          return "";
        }
        return Object.keys(this._responseHeaders).map(function(key) {
          return key + ": " + _this._responseHeaders[key];
        }).join("\r\n");
      };
      XMLHttpRequest3.prototype.overrideMimeType = function(mimeType) {
        if (this.readyState === XMLHttpRequest3.LOADING || this.readyState === XMLHttpRequest3.DONE) {
          throw new XMLHttpRequest3.InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
        }
        this._mimeOverride = mimeType.toLowerCase();
      };
      XMLHttpRequest3.prototype.nodejsSet = function(options) {
        this.nodejsHttpAgent = options.httpAgent || this.nodejsHttpAgent;
        this.nodejsHttpsAgent = options.httpsAgent || this.nodejsHttpsAgent;
        if (options.hasOwnProperty("baseUrl")) {
          if (options.baseUrl != null) {
            var parsedUrl = url.parse(options.baseUrl, false, true);
            if (!parsedUrl.protocol) {
              throw new XMLHttpRequest3.SyntaxError("baseUrl must be an absolute URL");
            }
          }
          this.nodejsBaseUrl = options.baseUrl;
        }
      };
      XMLHttpRequest3.nodejsSet = function(options) {
        XMLHttpRequest3.prototype.nodejsSet(options);
      };
      XMLHttpRequest3.prototype._setReadyState = function(readyState) {
        this.readyState = readyState;
        this.dispatchEvent(new progress_event_1.ProgressEvent("readystatechange"));
      };
      XMLHttpRequest3.prototype._sendFile = function(data) {
        throw new Error("Protocol file: not implemented");
      };
      XMLHttpRequest3.prototype._sendHttp = function(data) {
        if (this._sync) {
          throw new Error("Synchronous XHR processing not implemented");
        }
        if (data && (this._method === "GET" || this._method === "HEAD")) {
          console.warn("Discarding entity body for " + this._method + " requests");
          data = null;
        } else {
          data = data || "";
        }
        this.upload._setData(data);
        this._finalizeHeaders();
        this._sendHxxpRequest();
      };
      XMLHttpRequest3.prototype._sendHxxpRequest = function() {
        var _this = this;
        if (this.withCredentials) {
          var cookie = XMLHttpRequest3.cookieJar.getCookies(Cookie.CookieAccessInfo(this._url.hostname, this._url.pathname, this._url.protocol === "https:")).toValueString();
          this._headers.cookie = this._headers.cookie2 = cookie;
        }
        var _a = this._url.protocol === "http:" ? [http, this.nodejsHttpAgent] : [https, this.nodejsHttpsAgent], hxxp = _a[0], agent = _a[1];
        var requestMethod = hxxp.request.bind(hxxp);
        var request = requestMethod({
          hostname: this._url.hostname,
          port: +this._url.port,
          path: this._url.path,
          auth: this._url.auth,
          method: this._method,
          headers: this._headers,
          agent
        });
        this._request = request;
        if (this.timeout) {
          request.setTimeout(this.timeout, function() {
            return _this._onHttpTimeout(request);
          });
        }
        request.on("response", function(response) {
          return _this._onHttpResponse(request, response);
        });
        request.on("error", function(error) {
          return _this._onHttpRequestError(request, error);
        });
        this.upload._startUpload(request);
        if (this._request === request) {
          this._dispatchProgress("loadstart");
        }
      };
      XMLHttpRequest3.prototype._finalizeHeaders = function() {
        this._headers = __assign({}, this._headers, { Connection: "keep-alive", Host: this._url.host, "User-Agent": this._userAgent }, this._anonymous ? { Referer: "about:blank" } : {});
        this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
      };
      XMLHttpRequest3.prototype._onHttpResponse = function(request, response) {
        var _this = this;
        if (this._request !== request) {
          return;
        }
        if (this.withCredentials && (response.headers["set-cookie"] || response.headers["set-cookie2"])) {
          XMLHttpRequest3.cookieJar.setCookies(response.headers["set-cookie"] || response.headers["set-cookie2"]);
        }
        if ([301, 302, 303, 307, 308].indexOf(response.statusCode) >= 0) {
          this._url = this._parseUrl(response.headers.location);
          this._method = "GET";
          if (this._loweredHeaders["content-type"]) {
            delete this._headers[this._loweredHeaders["content-type"]];
            delete this._loweredHeaders["content-type"];
          }
          if (this._headers["Content-Type"] != null) {
            delete this._headers["Content-Type"];
          }
          delete this._headers["Content-Length"];
          this.upload._reset();
          this._finalizeHeaders();
          this._sendHxxpRequest();
          return;
        }
        this._response = response;
        this._response.on("data", function(data) {
          return _this._onHttpResponseData(response, data);
        });
        this._response.on("end", function() {
          return _this._onHttpResponseEnd(response);
        });
        this._response.on("close", function() {
          return _this._onHttpResponseClose(response);
        });
        this.responseUrl = this._url.href.split("#")[0];
        this.status = response.statusCode;
        this.statusText = http.STATUS_CODES[this.status];
        this._parseResponseHeaders(response);
        var lengthString = this._responseHeaders["content-length"] || "";
        this._totalBytes = +lengthString;
        this._lengthComputable = !!lengthString;
        this._setReadyState(XMLHttpRequest3.HEADERS_RECEIVED);
      };
      XMLHttpRequest3.prototype._onHttpResponseData = function(response, data) {
        if (this._response !== response) {
          return;
        }
        this._responseParts.push(new Buffer(data));
        this._loadedBytes += data.length;
        if (this.readyState !== XMLHttpRequest3.LOADING) {
          this._setReadyState(XMLHttpRequest3.LOADING);
        }
        this._dispatchProgress("progress");
      };
      XMLHttpRequest3.prototype._onHttpResponseEnd = function(response) {
        if (this._response !== response) {
          return;
        }
        this._parseResponse();
        this._request = null;
        this._response = null;
        this._setReadyState(XMLHttpRequest3.DONE);
        this._dispatchProgress("load");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype._onHttpResponseClose = function(response) {
        if (this._response !== response) {
          return;
        }
        var request = this._request;
        this._setError();
        request.abort();
        this._setReadyState(XMLHttpRequest3.DONE);
        this._dispatchProgress("error");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype._onHttpTimeout = function(request) {
        if (this._request !== request) {
          return;
        }
        this._setError();
        request.abort();
        this._setReadyState(XMLHttpRequest3.DONE);
        this._dispatchProgress("timeout");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype._onHttpRequestError = function(request, error) {
        if (this._request !== request) {
          return;
        }
        this._setError();
        request.abort();
        this._setReadyState(XMLHttpRequest3.DONE);
        this._dispatchProgress("error");
        this._dispatchProgress("loadend");
      };
      XMLHttpRequest3.prototype._dispatchProgress = function(eventType) {
        var event = new XMLHttpRequest3.ProgressEvent(eventType);
        event.lengthComputable = this._lengthComputable;
        event.loaded = this._loadedBytes;
        event.total = this._totalBytes;
        this.dispatchEvent(event);
      };
      XMLHttpRequest3.prototype._setError = function() {
        this._request = null;
        this._response = null;
        this._responseHeaders = null;
        this._responseParts = null;
      };
      XMLHttpRequest3.prototype._parseUrl = function(urlString, user, password) {
        var absoluteUrl = this.nodejsBaseUrl == null ? urlString : url.resolve(this.nodejsBaseUrl, urlString);
        var xhrUrl = url.parse(absoluteUrl, false, true);
        xhrUrl.hash = null;
        var _a = (xhrUrl.auth || "").split(":"), xhrUser = _a[0], xhrPassword = _a[1];
        if (xhrUser || xhrPassword || user || password) {
          xhrUrl.auth = (user || xhrUser || "") + ":" + (password || xhrPassword || "");
        }
        return xhrUrl;
      };
      XMLHttpRequest3.prototype._parseResponseHeaders = function(response) {
        this._responseHeaders = {};
        for (var name_1 in response.headers) {
          var loweredName = name_1.toLowerCase();
          if (this._privateHeaders[loweredName]) {
            continue;
          }
          this._responseHeaders[loweredName] = response.headers[name_1];
        }
        if (this._mimeOverride != null) {
          this._responseHeaders["content-type"] = this._mimeOverride;
        }
      };
      XMLHttpRequest3.prototype._parseResponse = function() {
        var buffer = Buffer.concat(this._responseParts);
        this._responseParts = null;
        switch (this.responseType) {
          case "json":
            this.responseText = null;
            try {
              this.response = JSON.parse(buffer.toString("utf-8"));
            } catch (_a) {
              this.response = null;
            }
            return;
          case "buffer":
            this.responseText = null;
            this.response = buffer;
            return;
          case "arraybuffer":
            this.responseText = null;
            var arrayBuffer = new ArrayBuffer(buffer.length);
            var view = new Uint8Array(arrayBuffer);
            for (var i = 0; i < buffer.length; i++) {
              view[i] = buffer[i];
            }
            this.response = arrayBuffer;
            return;
          case "text":
          default:
            try {
              this.responseText = buffer.toString(this._parseResponseEncoding());
            } catch (_b) {
              this.responseText = buffer.toString("binary");
            }
            this.response = this.responseText;
        }
      };
      XMLHttpRequest3.prototype._parseResponseEncoding = function() {
        return /;\s*charset=(.*)$/.exec(this._responseHeaders["content-type"] || "")[1] || "utf-8";
      };
      XMLHttpRequest3.ProgressEvent = progress_event_1.ProgressEvent;
      XMLHttpRequest3.InvalidStateError = errors_1.InvalidStateError;
      XMLHttpRequest3.NetworkError = errors_1.NetworkError;
      XMLHttpRequest3.SecurityError = errors_1.SecurityError;
      XMLHttpRequest3.SyntaxError = errors_1.SyntaxError;
      XMLHttpRequest3.XMLHttpRequestUpload = xml_http_request_upload_1.XMLHttpRequestUpload;
      XMLHttpRequest3.UNSENT = 0;
      XMLHttpRequest3.OPENED = 1;
      XMLHttpRequest3.HEADERS_RECEIVED = 2;
      XMLHttpRequest3.LOADING = 3;
      XMLHttpRequest3.DONE = 4;
      XMLHttpRequest3.cookieJar = Cookie.CookieJar();
      return XMLHttpRequest3;
    }(xml_http_request_event_target_1.XMLHttpRequestEventTarget);
    exports.XMLHttpRequest = XMLHttpRequest2;
    XMLHttpRequest2.prototype.nodejsHttpAgent = http.globalAgent;
    XMLHttpRequest2.prototype.nodejsHttpsAgent = https.globalAgent;
    XMLHttpRequest2.prototype.nodejsBaseUrl = null;
  }
});

// node_modules/xhr2-cookies/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/xhr2-cookies/dist/index.js"(exports) {
    "use strict";
    init_define_process_env();
    function __export2(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2(require_xml_http_request());
    var xml_http_request_event_target_1 = require_xml_http_request_event_target();
    exports.XMLHttpRequestEventTarget = xml_http_request_event_target_1.XMLHttpRequestEventTarget;
  }
});

// node_modules/web3-eth-contract/node_modules/web3-providers-http/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/web3-eth-contract/node_modules/web3-providers-http/lib/index.js"(exports, module) {
    init_define_process_env();
    var errors = require_lib4().errors;
    var XHR2 = require_dist3().XMLHttpRequest;
    var http = (init_http(), __toCommonJS(http_exports));
    var https = (init_https(), __toCommonJS(https_exports));
    var HttpProvider = function HttpProvider2(host, options) {
      options = options || {};
      this.withCredentials = options.withCredentials || false;
      this.timeout = options.timeout || 0;
      this.headers = options.headers;
      this.agent = options.agent;
      this.connected = false;
      const keepAlive = options.keepAlive !== false;
      this.host = host || "http://localhost:8545";
      if (!this.agent) {
        if (this.host.substring(0, 5) === "https") {
          this.httpsAgent = new https.Agent({ keepAlive });
        } else {
          this.httpAgent = new http.Agent({ keepAlive });
        }
      }
    };
    HttpProvider.prototype._prepareRequest = function() {
      var request;
      if (typeof XMLHttpRequest !== "undefined") {
        request = new XMLHttpRequest();
      } else {
        request = new XHR2();
        var agents = { httpsAgent: this.httpsAgent, httpAgent: this.httpAgent, baseUrl: this.baseUrl };
        if (this.agent) {
          agents.httpsAgent = this.agent.https;
          agents.httpAgent = this.agent.http;
          agents.baseUrl = this.agent.baseUrl;
        }
        request.nodejsSet(agents);
      }
      request.open("POST", this.host, true);
      request.setRequestHeader("Content-Type", "application/json");
      request.timeout = this.timeout;
      request.withCredentials = this.withCredentials;
      if (this.headers) {
        this.headers.forEach(function(header) {
          request.setRequestHeader(header.name, header.value);
        });
      }
      return request;
    };
    HttpProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var request = this._prepareRequest();
      request.onreadystatechange = function() {
        if (request.readyState === 4 && request.timeout !== 1) {
          var result = request.responseText;
          var error = null;
          try {
            result = JSON.parse(result);
          } catch (e) {
            error = errors.InvalidResponse(request.responseText);
          }
          _this.connected = true;
          callback(error, result);
        }
      };
      request.ontimeout = function() {
        _this.connected = false;
        callback(errors.ConnectionTimeout(this.timeout));
      };
      try {
        request.send(JSON.stringify(payload));
      } catch (error) {
        this.connected = false;
        callback(errors.InvalidConnection(this.host));
      }
    };
    HttpProvider.prototype.disconnect = function() {
    };
    HttpProvider.prototype.supportsSubscriptions = function() {
      return false;
    };
    module.exports = HttpProvider;
  }
});

// node_modules/oboe/dist/oboe-browser.js
var require_oboe_browser = __commonJS({
  "node_modules/oboe/dist/oboe-browser.js"(exports, module) {
    init_define_process_env();
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("oboe", [], factory);
      else if (typeof exports === "object")
        exports["oboe"] = factory();
      else
        root["oboe"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, {
              configurable: false,
              enumerable: true,
              get: getter
            });
          }
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? function getDefault() {
            return module2["default"];
          } : function getModuleExports() {
            return module2;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 7);
      }([
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "j", function() {
            return partialComplete;
          });
          __webpack_require__.d(__webpack_exports__, "d", function() {
            return compose2;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return attr;
          });
          __webpack_require__.d(__webpack_exports__, "h", function() {
            return lazyUnion;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return apply;
          });
          __webpack_require__.d(__webpack_exports__, "k", function() {
            return varArgs;
          });
          __webpack_require__.d(__webpack_exports__, "e", function() {
            return flip;
          });
          __webpack_require__.d(__webpack_exports__, "g", function() {
            return lazyIntersection;
          });
          __webpack_require__.d(__webpack_exports__, "i", function() {
            return noop;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return always;
          });
          __webpack_require__.d(__webpack_exports__, "f", function() {
            return functor;
          });
          var __WEBPACK_IMPORTED_MODULE_0__lists__ = __webpack_require__(1);
          var partialComplete = varArgs(function(fn, args) {
            var numBoundArgs = args.length;
            return varArgs(function(callArgs) {
              for (var i = 0; i < callArgs.length; i++) {
                args[numBoundArgs + i] = callArgs[i];
              }
              args.length = numBoundArgs + callArgs.length;
              return fn.apply(this, args);
            });
          });
          var compose = varArgs(function(fns) {
            var fnsList = Object(__WEBPACK_IMPORTED_MODULE_0__lists__["c"])(fns);
            function next(params, curFn) {
              return [apply(params, curFn)];
            }
            return varArgs(function(startParams) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__lists__["f"])(next, startParams, fnsList)[0];
            });
          });
          function compose2(f1, f2) {
            return function() {
              return f1.call(this, f2.apply(this, arguments));
            };
          }
          function attr(key) {
            return function(o) {
              return o[key];
            };
          }
          var lazyUnion = varArgs(function(fns) {
            return varArgs(function(params) {
              var maybeValue;
              for (var i = 0; i < attr("length")(fns); i++) {
                maybeValue = apply(params, fns[i]);
                if (maybeValue) {
                  return maybeValue;
                }
              }
            });
          });
          function apply(args, fn) {
            return fn.apply(void 0, args);
          }
          function varArgs(fn) {
            var numberOfFixedArguments = fn.length - 1;
            var slice = Array.prototype.slice;
            if (numberOfFixedArguments === 0) {
              return function() {
                return fn.call(this, slice.call(arguments));
              };
            } else if (numberOfFixedArguments === 1) {
              return function() {
                return fn.call(this, arguments[0], slice.call(arguments, 1));
              };
            }
            var argsHolder = Array(fn.length);
            return function() {
              for (var i = 0; i < numberOfFixedArguments; i++) {
                argsHolder[i] = arguments[i];
              }
              argsHolder[numberOfFixedArguments] = slice.call(arguments, numberOfFixedArguments);
              return fn.apply(this, argsHolder);
            };
          }
          function flip(fn) {
            return function(a, b) {
              return fn(b, a);
            };
          }
          function lazyIntersection(fn1, fn2) {
            return function(param) {
              return fn1(param) && fn2(param);
            };
          }
          function noop() {
          }
          function always() {
            return true;
          }
          function functor(val) {
            return function() {
              return val;
            };
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "d", function() {
            return cons;
          });
          __webpack_require__.d(__webpack_exports__, "g", function() {
            return head;
          });
          __webpack_require__.d(__webpack_exports__, "l", function() {
            return tail;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return arrayAsList;
          });
          __webpack_require__.d(__webpack_exports__, "h", function() {
            return list;
          });
          __webpack_require__.d(__webpack_exports__, "i", function() {
            return listAsArray;
          });
          __webpack_require__.d(__webpack_exports__, "j", function() {
            return map;
          });
          __webpack_require__.d(__webpack_exports__, "f", function() {
            return foldR;
          });
          __webpack_require__.d(__webpack_exports__, "m", function() {
            return without;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return all;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return applyEach;
          });
          __webpack_require__.d(__webpack_exports__, "k", function() {
            return reverseList;
          });
          __webpack_require__.d(__webpack_exports__, "e", function() {
            return first;
          });
          var __WEBPACK_IMPORTED_MODULE_0__functional__ = __webpack_require__(0);
          function cons(x, xs) {
            return [x, xs];
          }
          var emptyList = null;
          var head = Object(__WEBPACK_IMPORTED_MODULE_0__functional__["c"])(0);
          var tail = Object(__WEBPACK_IMPORTED_MODULE_0__functional__["c"])(1);
          function arrayAsList(inputArray) {
            return reverseList(inputArray.reduce(Object(__WEBPACK_IMPORTED_MODULE_0__functional__["e"])(cons), emptyList));
          }
          var list = Object(__WEBPACK_IMPORTED_MODULE_0__functional__["k"])(arrayAsList);
          function listAsArray(list2) {
            return foldR(function(arraySoFar, listItem) {
              arraySoFar.unshift(listItem);
              return arraySoFar;
            }, [], list2);
          }
          function map(fn, list2) {
            return list2 ? cons(fn(head(list2)), map(fn, tail(list2))) : emptyList;
          }
          function foldR(fn, startValue, list2) {
            return list2 ? fn(foldR(fn, startValue, tail(list2)), head(list2)) : startValue;
          }
          function foldR1(fn, list2) {
            return tail(list2) ? fn(foldR1(fn, tail(list2)), head(list2)) : head(list2);
          }
          function without(list2, test, removedFn) {
            return withoutInner(list2, removedFn || __WEBPACK_IMPORTED_MODULE_0__functional__["i"]);
            function withoutInner(subList, removedFn2) {
              return subList ? test(head(subList)) ? (removedFn2(head(subList)), tail(subList)) : cons(head(subList), withoutInner(tail(subList), removedFn2)) : emptyList;
            }
          }
          function all(fn, list2) {
            return !list2 || fn(head(list2)) && all(fn, tail(list2));
          }
          function applyEach(fnList, args) {
            if (fnList) {
              head(fnList).apply(null, args);
              applyEach(tail(fnList), args);
            }
          }
          function reverseList(list2) {
            function reverseInner(list3, reversedAlready) {
              if (!list3) {
                return reversedAlready;
              }
              return reverseInner(tail(list3), cons(head(list3), reversedAlready));
            }
            return reverseInner(list2, emptyList);
          }
          function first(test, list2) {
            return list2 && (test(head(list2)) ? head(list2) : first(test, tail(list2)));
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return isOfType;
          });
          __webpack_require__.d(__webpack_exports__, "e", function() {
            return len;
          });
          __webpack_require__.d(__webpack_exports__, "d", function() {
            return isString;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return defined;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return hasAllProperties;
          });
          var __WEBPACK_IMPORTED_MODULE_0__lists__ = __webpack_require__(1);
          var __WEBPACK_IMPORTED_MODULE_1__functional__ = __webpack_require__(0);
          function isOfType(T, maybeSomething) {
            return maybeSomething && maybeSomething.constructor === T;
          }
          var len = Object(__WEBPACK_IMPORTED_MODULE_1__functional__["c"])("length");
          var isString = Object(__WEBPACK_IMPORTED_MODULE_1__functional__["j"])(isOfType, String);
          function defined(value) {
            return value !== void 0;
          }
          function hasAllProperties(fieldList, o) {
            return o instanceof Object && Object(__WEBPACK_IMPORTED_MODULE_0__lists__["a"])(function(field) {
              return field in o;
            }, fieldList);
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "f", function() {
            return NODE_OPENED;
          });
          __webpack_require__.d(__webpack_exports__, "d", function() {
            return NODE_CLOSED;
          });
          __webpack_require__.d(__webpack_exports__, "g", function() {
            return NODE_SWAP;
          });
          __webpack_require__.d(__webpack_exports__, "e", function() {
            return NODE_DROP;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return FAIL_EVENT;
          });
          __webpack_require__.d(__webpack_exports__, "h", function() {
            return ROOT_NODE_FOUND;
          });
          __webpack_require__.d(__webpack_exports__, "i", function() {
            return ROOT_PATH_FOUND;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return HTTP_START;
          });
          __webpack_require__.d(__webpack_exports__, "m", function() {
            return STREAM_DATA;
          });
          __webpack_require__.d(__webpack_exports__, "n", function() {
            return STREAM_END;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return ABORTING;
          });
          __webpack_require__.d(__webpack_exports__, "j", function() {
            return SAX_KEY;
          });
          __webpack_require__.d(__webpack_exports__, "l", function() {
            return SAX_VALUE_OPEN;
          });
          __webpack_require__.d(__webpack_exports__, "k", function() {
            return SAX_VALUE_CLOSE;
          });
          __webpack_require__.d(__webpack_exports__, "o", function() {
            return errorReport;
          });
          var _S = 1;
          var NODE_OPENED = _S++;
          var NODE_CLOSED = _S++;
          var NODE_SWAP = _S++;
          var NODE_DROP = _S++;
          var FAIL_EVENT = "fail";
          var ROOT_NODE_FOUND = _S++;
          var ROOT_PATH_FOUND = _S++;
          var HTTP_START = "start";
          var STREAM_DATA = "data";
          var STREAM_END = "end";
          var ABORTING = _S++;
          var SAX_KEY = _S++;
          var SAX_VALUE_OPEN = _S++;
          var SAX_VALUE_CLOSE = _S++;
          function errorReport(statusCode, body, error) {
            try {
              var jsonBody = JSON.parse(body);
            } catch (e) {
            }
            return {
              statusCode,
              body,
              jsonBody,
              thrown: error
            };
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return namedNode;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return keyOf;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return nodeOf;
          });
          var __WEBPACK_IMPORTED_MODULE_0__functional__ = __webpack_require__(0);
          function namedNode(key, node) {
            return { key, node };
          }
          var keyOf = Object(__WEBPACK_IMPORTED_MODULE_0__functional__["c"])("key");
          var nodeOf = Object(__WEBPACK_IMPORTED_MODULE_0__functional__["c"])("node");
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return oboe;
          });
          var __WEBPACK_IMPORTED_MODULE_0__lists__ = __webpack_require__(1);
          var __WEBPACK_IMPORTED_MODULE_1__functional__ = __webpack_require__(0);
          var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(2);
          var __WEBPACK_IMPORTED_MODULE_3__defaults__ = __webpack_require__(8);
          var __WEBPACK_IMPORTED_MODULE_4__wire__ = __webpack_require__(9);
          function oboe(arg1) {
            var nodeStreamMethodNames = Object(__WEBPACK_IMPORTED_MODULE_0__lists__["h"])("resume", "pause", "pipe");
            var isStream = Object(__WEBPACK_IMPORTED_MODULE_1__functional__["j"])(__WEBPACK_IMPORTED_MODULE_2__util__["b"], nodeStreamMethodNames);
            if (arg1) {
              if (isStream(arg1) || Object(__WEBPACK_IMPORTED_MODULE_2__util__["d"])(arg1)) {
                return Object(__WEBPACK_IMPORTED_MODULE_3__defaults__["a"])(__WEBPACK_IMPORTED_MODULE_4__wire__["a"], arg1);
              } else {
                return Object(__WEBPACK_IMPORTED_MODULE_3__defaults__["a"])(__WEBPACK_IMPORTED_MODULE_4__wire__["a"], arg1.url, arg1.method, arg1.body, arg1.headers, arg1.withCredentials, arg1.cached);
              }
            } else {
              return Object(__WEBPACK_IMPORTED_MODULE_4__wire__["a"])();
            }
          }
          oboe.drop = function() {
            return oboe.drop;
          };
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return incrementalContentBuilder;
          });
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return ROOT_PATH;
          });
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(3);
          var __WEBPACK_IMPORTED_MODULE_1__ascent__ = __webpack_require__(4);
          var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(2);
          var __WEBPACK_IMPORTED_MODULE_3__lists__ = __webpack_require__(1);
          var ROOT_PATH = {};
          function incrementalContentBuilder(oboeBus) {
            var emitNodeOpened = oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["f"]).emit;
            var emitNodeClosed = oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["d"]).emit;
            var emitRootOpened = oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["i"]).emit;
            var emitRootClosed = oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["h"]).emit;
            function arrayIndicesAreKeys(possiblyInconsistentAscent, newDeepestNode) {
              var parentNode = Object(__WEBPACK_IMPORTED_MODULE_1__ascent__["c"])(Object(__WEBPACK_IMPORTED_MODULE_3__lists__["g"])(possiblyInconsistentAscent));
              return Object(__WEBPACK_IMPORTED_MODULE_2__util__["c"])(Array, parentNode) ? keyFound(possiblyInconsistentAscent, Object(__WEBPACK_IMPORTED_MODULE_2__util__["e"])(parentNode), newDeepestNode) : possiblyInconsistentAscent;
            }
            function nodeOpened(ascent, newDeepestNode) {
              if (!ascent) {
                emitRootOpened(newDeepestNode);
                return keyFound(ascent, ROOT_PATH, newDeepestNode);
              }
              var arrayConsistentAscent = arrayIndicesAreKeys(ascent, newDeepestNode);
              var ancestorBranches = Object(__WEBPACK_IMPORTED_MODULE_3__lists__["l"])(arrayConsistentAscent);
              var previouslyUnmappedName = Object(__WEBPACK_IMPORTED_MODULE_1__ascent__["a"])(Object(__WEBPACK_IMPORTED_MODULE_3__lists__["g"])(arrayConsistentAscent));
              appendBuiltContent(ancestorBranches, previouslyUnmappedName, newDeepestNode);
              return Object(__WEBPACK_IMPORTED_MODULE_3__lists__["d"])(Object(__WEBPACK_IMPORTED_MODULE_1__ascent__["b"])(previouslyUnmappedName, newDeepestNode), ancestorBranches);
            }
            function appendBuiltContent(ancestorBranches, key, node) {
              Object(__WEBPACK_IMPORTED_MODULE_1__ascent__["c"])(Object(__WEBPACK_IMPORTED_MODULE_3__lists__["g"])(ancestorBranches))[key] = node;
            }
            function keyFound(ascent, newDeepestName, maybeNewDeepestNode) {
              if (ascent) {
                appendBuiltContent(ascent, newDeepestName, maybeNewDeepestNode);
              }
              var ascentWithNewPath = Object(__WEBPACK_IMPORTED_MODULE_3__lists__["d"])(Object(__WEBPACK_IMPORTED_MODULE_1__ascent__["b"])(newDeepestName, maybeNewDeepestNode), ascent);
              emitNodeOpened(ascentWithNewPath);
              return ascentWithNewPath;
            }
            function nodeClosed(ascent) {
              emitNodeClosed(ascent);
              return Object(__WEBPACK_IMPORTED_MODULE_3__lists__["l"])(ascent) || emitRootClosed(Object(__WEBPACK_IMPORTED_MODULE_1__ascent__["c"])(Object(__WEBPACK_IMPORTED_MODULE_3__lists__["g"])(ascent)));
            }
            var contentBuilderHandlers = {};
            contentBuilderHandlers[__WEBPACK_IMPORTED_MODULE_0__events__["l"]] = nodeOpened;
            contentBuilderHandlers[__WEBPACK_IMPORTED_MODULE_0__events__["k"]] = nodeClosed;
            contentBuilderHandlers[__WEBPACK_IMPORTED_MODULE_0__events__["j"]] = keyFound;
            return contentBuilderHandlers;
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
          var __WEBPACK_IMPORTED_MODULE_0__publicApi__ = __webpack_require__(5);
          __webpack_exports__["default"] = __WEBPACK_IMPORTED_MODULE_0__publicApi__["a"];
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return applyDefaults;
          });
          var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(2);
          function applyDefaults(passthrough, url, httpMethodName, body, headers, withCredentials, cached) {
            headers = headers ? JSON.parse(JSON.stringify(headers)) : {};
            if (body) {
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__util__["d"])(body)) {
                body = JSON.stringify(body);
                headers["Content-Type"] = headers["Content-Type"] || "application/json";
              }
              headers["Content-Length"] = headers["Content-Length"] || body.length;
            } else {
              body = null;
            }
            function modifiedUrl(baseUrl, cached2) {
              if (cached2 === false) {
                if (baseUrl.indexOf("?") === -1) {
                  baseUrl += "?";
                } else {
                  baseUrl += "&";
                }
                baseUrl += "_=" + new Date().getTime();
              }
              return baseUrl;
            }
            return passthrough(httpMethodName || "GET", modifiedUrl(url, cached), body, headers, withCredentials || false);
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return wire;
          });
          var __WEBPACK_IMPORTED_MODULE_0__pubSub__ = __webpack_require__(10);
          var __WEBPACK_IMPORTED_MODULE_1__ascentManager__ = __webpack_require__(12);
          var __WEBPACK_IMPORTED_MODULE_2__incrementalContentBuilder__ = __webpack_require__(6);
          var __WEBPACK_IMPORTED_MODULE_3__patternAdapter__ = __webpack_require__(13);
          var __WEBPACK_IMPORTED_MODULE_4__jsonPath__ = __webpack_require__(14);
          var __WEBPACK_IMPORTED_MODULE_5__instanceApi__ = __webpack_require__(16);
          var __WEBPACK_IMPORTED_MODULE_6__libs_clarinet__ = __webpack_require__(17);
          var __WEBPACK_IMPORTED_MODULE_7__streamingHttp_node__ = __webpack_require__(18);
          function wire(httpMethodName, contentSource, body, headers, withCredentials) {
            var oboeBus = Object(__WEBPACK_IMPORTED_MODULE_0__pubSub__["a"])();
            if (contentSource) {
              Object(__WEBPACK_IMPORTED_MODULE_7__streamingHttp_node__["b"])(oboeBus, Object(__WEBPACK_IMPORTED_MODULE_7__streamingHttp_node__["a"])(), httpMethodName, contentSource, body, headers, withCredentials);
            }
            Object(__WEBPACK_IMPORTED_MODULE_6__libs_clarinet__["a"])(oboeBus);
            Object(__WEBPACK_IMPORTED_MODULE_1__ascentManager__["a"])(oboeBus, Object(__WEBPACK_IMPORTED_MODULE_2__incrementalContentBuilder__["b"])(oboeBus));
            Object(__WEBPACK_IMPORTED_MODULE_3__patternAdapter__["a"])(oboeBus, __WEBPACK_IMPORTED_MODULE_4__jsonPath__["a"]);
            return Object(__WEBPACK_IMPORTED_MODULE_5__instanceApi__["a"])(oboeBus, contentSource);
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return pubSub;
          });
          var __WEBPACK_IMPORTED_MODULE_0__singleEventPubSub__ = __webpack_require__(11);
          var __WEBPACK_IMPORTED_MODULE_1__functional__ = __webpack_require__(0);
          function pubSub() {
            var singles = {};
            var newListener = newSingle("newListener");
            var removeListener = newSingle("removeListener");
            function newSingle(eventName) {
              singles[eventName] = Object(__WEBPACK_IMPORTED_MODULE_0__singleEventPubSub__["a"])(eventName, newListener, removeListener);
              return singles[eventName];
            }
            function pubSubInstance(eventName) {
              return singles[eventName] || newSingle(eventName);
            }
            ["emit", "on", "un"].forEach(function(methodName) {
              pubSubInstance[methodName] = Object(__WEBPACK_IMPORTED_MODULE_1__functional__["k"])(function(eventName, parameters) {
                Object(__WEBPACK_IMPORTED_MODULE_1__functional__["b"])(parameters, pubSubInstance(eventName)[methodName]);
              });
            });
            return pubSubInstance;
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return singleEventPubSub;
          });
          var __WEBPACK_IMPORTED_MODULE_0__lists__ = __webpack_require__(1);
          var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(2);
          var __WEBPACK_IMPORTED_MODULE_2__functional__ = __webpack_require__(0);
          function singleEventPubSub(eventType, newListener, removeListener) {
            var listenerTupleList, listenerList;
            function hasId(id2) {
              return function(tuple) {
                return tuple.id === id2;
              };
            }
            return {
              on: function(listener, listenerId) {
                var tuple = {
                  listener,
                  id: listenerId || listener
                };
                if (newListener) {
                  newListener.emit(eventType, listener, tuple.id);
                }
                listenerTupleList = Object(__WEBPACK_IMPORTED_MODULE_0__lists__["d"])(tuple, listenerTupleList);
                listenerList = Object(__WEBPACK_IMPORTED_MODULE_0__lists__["d"])(listener, listenerList);
                return this;
              },
              emit: function() {
                Object(__WEBPACK_IMPORTED_MODULE_0__lists__["b"])(listenerList, arguments);
              },
              un: function(listenerId) {
                var removed;
                listenerTupleList = Object(__WEBPACK_IMPORTED_MODULE_0__lists__["m"])(listenerTupleList, hasId(listenerId), function(tuple) {
                  removed = tuple;
                });
                if (removed) {
                  listenerList = Object(__WEBPACK_IMPORTED_MODULE_0__lists__["m"])(listenerList, function(listener) {
                    return listener === removed.listener;
                  });
                  if (removeListener) {
                    removeListener.emit(eventType, removed.listener, removed.id);
                  }
                }
              },
              listeners: function() {
                return listenerList;
              },
              hasListener: function(listenerId) {
                var test = listenerId ? hasId(listenerId) : __WEBPACK_IMPORTED_MODULE_2__functional__["a"];
                return Object(__WEBPACK_IMPORTED_MODULE_1__util__["a"])(Object(__WEBPACK_IMPORTED_MODULE_0__lists__["e"])(test, listenerTupleList));
              }
            };
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return ascentManager;
          });
          var __WEBPACK_IMPORTED_MODULE_0__ascent__ = __webpack_require__(4);
          var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(3);
          var __WEBPACK_IMPORTED_MODULE_2__lists__ = __webpack_require__(1);
          function ascentManager(oboeBus, handlers) {
            "use strict";
            var listenerId = {};
            var ascent;
            function stateAfter(handler) {
              return function(param) {
                ascent = handler(ascent, param);
              };
            }
            for (var eventName in handlers) {
              oboeBus(eventName).on(stateAfter(handlers[eventName]), listenerId);
            }
            oboeBus(__WEBPACK_IMPORTED_MODULE_1__events__["g"]).on(function(newNode) {
              var oldHead = Object(__WEBPACK_IMPORTED_MODULE_2__lists__["g"])(ascent);
              var key = Object(__WEBPACK_IMPORTED_MODULE_0__ascent__["a"])(oldHead);
              var ancestors = Object(__WEBPACK_IMPORTED_MODULE_2__lists__["l"])(ascent);
              var parentNode;
              if (ancestors) {
                parentNode = Object(__WEBPACK_IMPORTED_MODULE_0__ascent__["c"])(Object(__WEBPACK_IMPORTED_MODULE_2__lists__["g"])(ancestors));
                parentNode[key] = newNode;
              }
            });
            oboeBus(__WEBPACK_IMPORTED_MODULE_1__events__["e"]).on(function() {
              var oldHead = Object(__WEBPACK_IMPORTED_MODULE_2__lists__["g"])(ascent);
              var key = Object(__WEBPACK_IMPORTED_MODULE_0__ascent__["a"])(oldHead);
              var ancestors = Object(__WEBPACK_IMPORTED_MODULE_2__lists__["l"])(ascent);
              var parentNode;
              if (ancestors) {
                parentNode = Object(__WEBPACK_IMPORTED_MODULE_0__ascent__["c"])(Object(__WEBPACK_IMPORTED_MODULE_2__lists__["g"])(ancestors));
                delete parentNode[key];
              }
            });
            oboeBus(__WEBPACK_IMPORTED_MODULE_1__events__["a"]).on(function() {
              for (var eventName2 in handlers) {
                oboeBus(eventName2).un(listenerId);
              }
            });
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return patternAdapter;
          });
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(3);
          var __WEBPACK_IMPORTED_MODULE_1__lists__ = __webpack_require__(1);
          var __WEBPACK_IMPORTED_MODULE_2__ascent__ = __webpack_require__(4);
          function patternAdapter(oboeBus, jsonPathCompiler) {
            var predicateEventMap = {
              node: oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["d"]),
              path: oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["f"])
            };
            function emitMatchingNode(emitMatch, node, ascent) {
              var descent = Object(__WEBPACK_IMPORTED_MODULE_1__lists__["k"])(ascent);
              emitMatch(node, Object(__WEBPACK_IMPORTED_MODULE_1__lists__["i"])(Object(__WEBPACK_IMPORTED_MODULE_1__lists__["l"])(Object(__WEBPACK_IMPORTED_MODULE_1__lists__["j"])(__WEBPACK_IMPORTED_MODULE_2__ascent__["a"], descent))), Object(__WEBPACK_IMPORTED_MODULE_1__lists__["i"])(Object(__WEBPACK_IMPORTED_MODULE_1__lists__["j"])(__WEBPACK_IMPORTED_MODULE_2__ascent__["c"], descent)));
            }
            function addUnderlyingListener(fullEventName, predicateEvent, compiledJsonPath) {
              var emitMatch = oboeBus(fullEventName).emit;
              predicateEvent.on(function(ascent) {
                var maybeMatchingMapping = compiledJsonPath(ascent);
                if (maybeMatchingMapping !== false) {
                  emitMatchingNode(emitMatch, Object(__WEBPACK_IMPORTED_MODULE_2__ascent__["c"])(maybeMatchingMapping), ascent);
                }
              }, fullEventName);
              oboeBus("removeListener").on(function(removedEventName) {
                if (removedEventName === fullEventName) {
                  if (!oboeBus(removedEventName).listeners()) {
                    predicateEvent.un(fullEventName);
                  }
                }
              });
            }
            oboeBus("newListener").on(function(fullEventName) {
              var match = /(node|path):(.*)/.exec(fullEventName);
              if (match) {
                var predicateEvent = predicateEventMap[match[1]];
                if (!predicateEvent.hasListener(fullEventName)) {
                  addUnderlyingListener(fullEventName, predicateEvent, jsonPathCompiler(match[2]));
                }
              }
            });
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return jsonPathCompiler;
          });
          var __WEBPACK_IMPORTED_MODULE_0__functional__ = __webpack_require__(0);
          var __WEBPACK_IMPORTED_MODULE_1__lists__ = __webpack_require__(1);
          var __WEBPACK_IMPORTED_MODULE_2__ascent__ = __webpack_require__(4);
          var __WEBPACK_IMPORTED_MODULE_3__util__ = __webpack_require__(2);
          var __WEBPACK_IMPORTED_MODULE_4__incrementalContentBuilder__ = __webpack_require__(6);
          var __WEBPACK_IMPORTED_MODULE_5__jsonPathSyntax__ = __webpack_require__(15);
          var jsonPathCompiler = Object(__WEBPACK_IMPORTED_MODULE_5__jsonPathSyntax__["a"])(function(pathNodeSyntax, doubleDotSyntax, dotSyntax, bangSyntax, emptySyntax) {
            var CAPTURING_INDEX = 1;
            var NAME_INDEX = 2;
            var FIELD_LIST_INDEX = 3;
            var headKey = Object(__WEBPACK_IMPORTED_MODULE_0__functional__["d"])(__WEBPACK_IMPORTED_MODULE_2__ascent__["a"], __WEBPACK_IMPORTED_MODULE_1__lists__["g"]);
            var headNode = Object(__WEBPACK_IMPORTED_MODULE_0__functional__["d"])(__WEBPACK_IMPORTED_MODULE_2__ascent__["c"], __WEBPACK_IMPORTED_MODULE_1__lists__["g"]);
            function nameClause(previousExpr, detection) {
              var name = detection[NAME_INDEX];
              var matchesName = !name || name === "*" ? __WEBPACK_IMPORTED_MODULE_0__functional__["a"] : function(ascent) {
                return String(headKey(ascent)) === name;
              };
              return Object(__WEBPACK_IMPORTED_MODULE_0__functional__["g"])(matchesName, previousExpr);
            }
            function duckTypeClause(previousExpr, detection) {
              var fieldListStr = detection[FIELD_LIST_INDEX];
              if (!fieldListStr) {
                return previousExpr;
              }
              var hasAllrequiredFields = Object(__WEBPACK_IMPORTED_MODULE_0__functional__["j"])(__WEBPACK_IMPORTED_MODULE_3__util__["b"], Object(__WEBPACK_IMPORTED_MODULE_1__lists__["c"])(fieldListStr.split(/\W+/)));
              var isMatch = Object(__WEBPACK_IMPORTED_MODULE_0__functional__["d"])(hasAllrequiredFields, headNode);
              return Object(__WEBPACK_IMPORTED_MODULE_0__functional__["g"])(isMatch, previousExpr);
            }
            function capture(previousExpr, detection) {
              var capturing = !!detection[CAPTURING_INDEX];
              if (!capturing) {
                return previousExpr;
              }
              return Object(__WEBPACK_IMPORTED_MODULE_0__functional__["g"])(previousExpr, __WEBPACK_IMPORTED_MODULE_1__lists__["g"]);
            }
            function skip1(previousExpr) {
              if (previousExpr === __WEBPACK_IMPORTED_MODULE_0__functional__["a"]) {
                return __WEBPACK_IMPORTED_MODULE_0__functional__["a"];
              }
              function notAtRoot(ascent) {
                return headKey(ascent) !== __WEBPACK_IMPORTED_MODULE_4__incrementalContentBuilder__["a"];
              }
              return Object(__WEBPACK_IMPORTED_MODULE_0__functional__["g"])(notAtRoot, Object(__WEBPACK_IMPORTED_MODULE_0__functional__["d"])(previousExpr, __WEBPACK_IMPORTED_MODULE_1__lists__["l"]));
            }
            function skipMany(previousExpr) {
              if (previousExpr === __WEBPACK_IMPORTED_MODULE_0__functional__["a"]) {
                return __WEBPACK_IMPORTED_MODULE_0__functional__["a"];
              }
              var terminalCaseWhenArrivingAtRoot = rootExpr();
              var terminalCaseWhenPreviousExpressionIsSatisfied = previousExpr;
              var recursiveCase = skip1(function(ascent) {
                return cases(ascent);
              });
              var cases = Object(__WEBPACK_IMPORTED_MODULE_0__functional__["h"])(terminalCaseWhenArrivingAtRoot, terminalCaseWhenPreviousExpressionIsSatisfied, recursiveCase);
              return cases;
            }
            function rootExpr() {
              return function(ascent) {
                return headKey(ascent) === __WEBPACK_IMPORTED_MODULE_4__incrementalContentBuilder__["a"];
              };
            }
            function statementExpr(lastClause) {
              return function(ascent) {
                var exprMatch = lastClause(ascent);
                return exprMatch === true ? Object(__WEBPACK_IMPORTED_MODULE_1__lists__["g"])(ascent) : exprMatch;
              };
            }
            function expressionsReader(exprs, parserGeneratedSoFar, detection) {
              return Object(__WEBPACK_IMPORTED_MODULE_1__lists__["f"])(function(parserGeneratedSoFar2, expr) {
                return expr(parserGeneratedSoFar2, detection);
              }, parserGeneratedSoFar, exprs);
            }
            function generateClauseReaderIfTokenFound(tokenDetector, clauseEvaluatorGenerators, jsonPath, parserGeneratedSoFar, onSuccess) {
              var detected = tokenDetector(jsonPath);
              if (detected) {
                var compiledParser = expressionsReader(clauseEvaluatorGenerators, parserGeneratedSoFar, detected);
                var remainingUnparsedJsonPath = jsonPath.substr(Object(__WEBPACK_IMPORTED_MODULE_3__util__["e"])(detected[0]));
                return onSuccess(remainingUnparsedJsonPath, compiledParser);
              }
            }
            function clauseMatcher(tokenDetector, exprs) {
              return Object(__WEBPACK_IMPORTED_MODULE_0__functional__["j"])(generateClauseReaderIfTokenFound, tokenDetector, exprs);
            }
            var clauseForJsonPath = Object(__WEBPACK_IMPORTED_MODULE_0__functional__["h"])(clauseMatcher(pathNodeSyntax, Object(__WEBPACK_IMPORTED_MODULE_1__lists__["h"])(capture, duckTypeClause, nameClause, skip1)), clauseMatcher(doubleDotSyntax, Object(__WEBPACK_IMPORTED_MODULE_1__lists__["h"])(skipMany)), clauseMatcher(dotSyntax, Object(__WEBPACK_IMPORTED_MODULE_1__lists__["h"])()), clauseMatcher(bangSyntax, Object(__WEBPACK_IMPORTED_MODULE_1__lists__["h"])(capture, rootExpr)), clauseMatcher(emptySyntax, Object(__WEBPACK_IMPORTED_MODULE_1__lists__["h"])(statementExpr)), function(jsonPath) {
              throw Error('"' + jsonPath + '" could not be tokenised');
            });
            function returnFoundParser(_remainingJsonPath, compiledParser) {
              return compiledParser;
            }
            function compileJsonPathToFunction(uncompiledJsonPath, parserGeneratedSoFar) {
              var onFind = uncompiledJsonPath ? compileJsonPathToFunction : returnFoundParser;
              return clauseForJsonPath(uncompiledJsonPath, parserGeneratedSoFar, onFind);
            }
            return function(jsonPath) {
              try {
                return compileJsonPathToFunction(jsonPath, __WEBPACK_IMPORTED_MODULE_0__functional__["a"]);
              } catch (e) {
                throw Error('Could not compile "' + jsonPath + '" because ' + e.message);
              }
            };
          });
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return jsonPathSyntax;
          });
          var __WEBPACK_IMPORTED_MODULE_0__functional__ = __webpack_require__(0);
          var jsonPathSyntax = function() {
            var regexDescriptor = function regexDescriptor2(regex) {
              return regex.exec.bind(regex);
            };
            var jsonPathClause = Object(__WEBPACK_IMPORTED_MODULE_0__functional__["k"])(function(componentRegexes) {
              componentRegexes.unshift(/^/);
              return regexDescriptor(RegExp(componentRegexes.map(Object(__WEBPACK_IMPORTED_MODULE_0__functional__["c"])("source")).join("")));
            });
            var possiblyCapturing = /(\$?)/;
            var namedNode = /([\w-_]+|\*)/;
            var namePlaceholder = /()/;
            var nodeInArrayNotation = /\["([^"]+)"\]/;
            var numberedNodeInArrayNotation = /\[(\d+|\*)\]/;
            var fieldList = /{([\w ]*?)}/;
            var optionalFieldList = /(?:{([\w ]*?)})?/;
            var jsonPathNamedNodeInObjectNotation = jsonPathClause(possiblyCapturing, namedNode, optionalFieldList);
            var jsonPathNamedNodeInArrayNotation = jsonPathClause(possiblyCapturing, nodeInArrayNotation, optionalFieldList);
            var jsonPathNumberedNodeInArrayNotation = jsonPathClause(possiblyCapturing, numberedNodeInArrayNotation, optionalFieldList);
            var jsonPathPureDuckTyping = jsonPathClause(possiblyCapturing, namePlaceholder, fieldList);
            var jsonPathDoubleDot = jsonPathClause(/\.\./);
            var jsonPathDot = jsonPathClause(/\./);
            var jsonPathBang = jsonPathClause(possiblyCapturing, /!/);
            var emptyString = jsonPathClause(/$/);
            return function(fn) {
              return fn(Object(__WEBPACK_IMPORTED_MODULE_0__functional__["h"])(jsonPathNamedNodeInObjectNotation, jsonPathNamedNodeInArrayNotation, jsonPathNumberedNodeInArrayNotation, jsonPathPureDuckTyping), jsonPathDoubleDot, jsonPathDot, jsonPathBang, emptyString);
            };
          }();
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return instanceApi;
          });
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(3);
          var __WEBPACK_IMPORTED_MODULE_1__functional__ = __webpack_require__(0);
          var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(2);
          var __WEBPACK_IMPORTED_MODULE_3__publicApi__ = __webpack_require__(5);
          function instanceApi(oboeBus, contentSource) {
            var oboeApi;
            var fullyQualifiedNamePattern = /^(node|path):./;
            var rootNodeFinishedEvent = oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["h"]);
            var emitNodeDrop = oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["e"]).emit;
            var emitNodeSwap = oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["g"]).emit;
            var addListener = Object(__WEBPACK_IMPORTED_MODULE_1__functional__["k"])(function(eventId, parameters) {
              if (oboeApi[eventId]) {
                Object(__WEBPACK_IMPORTED_MODULE_1__functional__["b"])(parameters, oboeApi[eventId]);
              } else {
                var event = oboeBus(eventId);
                var listener = parameters[0];
                if (fullyQualifiedNamePattern.test(eventId)) {
                  addForgettableCallback(event, wrapCallbackToSwapNodeIfSomethingReturned(listener));
                } else {
                  event.on(listener);
                }
              }
              return oboeApi;
            });
            var removeListener = function(eventId, p2, p3) {
              if (eventId === "done") {
                rootNodeFinishedEvent.un(p2);
              } else if (eventId === "node" || eventId === "path") {
                oboeBus.un(eventId + ":" + p2, p3);
              } else {
                var listener = p2;
                oboeBus(eventId).un(listener);
              }
              return oboeApi;
            };
            function addProtectedCallback(eventName, callback) {
              oboeBus(eventName).on(protectedCallback(callback), callback);
              return oboeApi;
            }
            function addForgettableCallback(event, callback, listenerId) {
              listenerId = listenerId || callback;
              var safeCallback = protectedCallback(callback);
              event.on(function() {
                var discard = false;
                oboeApi.forget = function() {
                  discard = true;
                };
                Object(__WEBPACK_IMPORTED_MODULE_1__functional__["b"])(arguments, safeCallback);
                delete oboeApi.forget;
                if (discard) {
                  event.un(listenerId);
                }
              }, listenerId);
              return oboeApi;
            }
            function protectedCallback(callback) {
              return function() {
                try {
                  return callback.apply(oboeApi, arguments);
                } catch (e) {
                  setTimeout(function() {
                    throw new Error(e.message);
                  });
                }
              };
            }
            function fullyQualifiedPatternMatchEvent(type, pattern) {
              return oboeBus(type + ":" + pattern);
            }
            function wrapCallbackToSwapNodeIfSomethingReturned(callback) {
              return function() {
                var returnValueFromCallback = callback.apply(this, arguments);
                if (Object(__WEBPACK_IMPORTED_MODULE_2__util__["a"])(returnValueFromCallback)) {
                  if (returnValueFromCallback === __WEBPACK_IMPORTED_MODULE_3__publicApi__["a"].drop) {
                    emitNodeDrop();
                  } else {
                    emitNodeSwap(returnValueFromCallback);
                  }
                }
              };
            }
            function addSingleNodeOrPathListener(eventId, pattern, callback) {
              var effectiveCallback;
              if (eventId === "node") {
                effectiveCallback = wrapCallbackToSwapNodeIfSomethingReturned(callback);
              } else {
                effectiveCallback = callback;
              }
              addForgettableCallback(fullyQualifiedPatternMatchEvent(eventId, pattern), effectiveCallback, callback);
            }
            function addMultipleNodeOrPathListeners(eventId, listenerMap) {
              for (var pattern in listenerMap) {
                addSingleNodeOrPathListener(eventId, pattern, listenerMap[pattern]);
              }
            }
            function addNodeOrPathListenerApi(eventId, jsonPathOrListenerMap, callback) {
              if (Object(__WEBPACK_IMPORTED_MODULE_2__util__["d"])(jsonPathOrListenerMap)) {
                addSingleNodeOrPathListener(eventId, jsonPathOrListenerMap, callback);
              } else {
                addMultipleNodeOrPathListeners(eventId, jsonPathOrListenerMap);
              }
              return oboeApi;
            }
            oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["i"]).on(function(rootNode) {
              oboeApi.root = Object(__WEBPACK_IMPORTED_MODULE_1__functional__["f"])(rootNode);
            });
            oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["c"]).on(function(_statusCode, headers) {
              oboeApi.header = function(name) {
                return name ? headers[name] : headers;
              };
            });
            oboeApi = {
              on: addListener,
              addListener,
              removeListener,
              emit: oboeBus.emit,
              node: Object(__WEBPACK_IMPORTED_MODULE_1__functional__["j"])(addNodeOrPathListenerApi, "node"),
              path: Object(__WEBPACK_IMPORTED_MODULE_1__functional__["j"])(addNodeOrPathListenerApi, "path"),
              done: Object(__WEBPACK_IMPORTED_MODULE_1__functional__["j"])(addForgettableCallback, rootNodeFinishedEvent),
              start: Object(__WEBPACK_IMPORTED_MODULE_1__functional__["j"])(addProtectedCallback, __WEBPACK_IMPORTED_MODULE_0__events__["c"]),
              fail: oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["b"]).on,
              abort: oboeBus(__WEBPACK_IMPORTED_MODULE_0__events__["a"]).emit,
              header: __WEBPACK_IMPORTED_MODULE_1__functional__["i"],
              root: __WEBPACK_IMPORTED_MODULE_1__functional__["i"],
              source: contentSource
            };
            return oboeApi;
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return clarinet;
          });
          var __WEBPACK_IMPORTED_MODULE_0__events__ = __webpack_require__(3);
          function clarinet(eventBus) {
            "use strict";
            var emitSaxKey = eventBus(__WEBPACK_IMPORTED_MODULE_0__events__["j"]).emit;
            var emitValueOpen = eventBus(__WEBPACK_IMPORTED_MODULE_0__events__["l"]).emit;
            var emitValueClose = eventBus(__WEBPACK_IMPORTED_MODULE_0__events__["k"]).emit;
            var emitFail = eventBus(__WEBPACK_IMPORTED_MODULE_0__events__["b"]).emit;
            var MAX_BUFFER_LENGTH = 64 * 1024;
            var stringTokenPattern = /[\\"\n]/g;
            var _n = 0;
            var BEGIN = _n++;
            var VALUE = _n++;
            var OPEN_OBJECT = _n++;
            var CLOSE_OBJECT = _n++;
            var OPEN_ARRAY = _n++;
            var CLOSE_ARRAY = _n++;
            var STRING = _n++;
            var OPEN_KEY = _n++;
            var CLOSE_KEY = _n++;
            var TRUE = _n++;
            var TRUE2 = _n++;
            var TRUE3 = _n++;
            var FALSE = _n++;
            var FALSE2 = _n++;
            var FALSE3 = _n++;
            var FALSE4 = _n++;
            var NULL = _n++;
            var NULL2 = _n++;
            var NULL3 = _n++;
            var NUMBER_DECIMAL_POINT = _n++;
            var NUMBER_DIGIT = _n;
            var bufferCheckPosition = MAX_BUFFER_LENGTH;
            var latestError;
            var c;
            var p;
            var textNode;
            var numberNode = "";
            var slashed = false;
            var closed = false;
            var state = BEGIN;
            var stack = [];
            var unicodeS = null;
            var unicodeI = 0;
            var depth = 0;
            var position = 0;
            var column = 0;
            var line = 1;
            function checkBufferLength() {
              var maxActual = 0;
              if (textNode !== void 0 && textNode.length > MAX_BUFFER_LENGTH) {
                emitError("Max buffer length exceeded: textNode");
                maxActual = Math.max(maxActual, textNode.length);
              }
              if (numberNode.length > MAX_BUFFER_LENGTH) {
                emitError("Max buffer length exceeded: numberNode");
                maxActual = Math.max(maxActual, numberNode.length);
              }
              bufferCheckPosition = MAX_BUFFER_LENGTH - maxActual + position;
            }
            eventBus(__WEBPACK_IMPORTED_MODULE_0__events__["m"]).on(handleData);
            eventBus(__WEBPACK_IMPORTED_MODULE_0__events__["n"]).on(handleStreamEnd);
            function emitError(errorString) {
              if (textNode !== void 0) {
                emitValueOpen(textNode);
                emitValueClose();
                textNode = void 0;
              }
              latestError = Error(errorString + "\nLn: " + line + "\nCol: " + column + "\nChr: " + c);
              emitFail(Object(__WEBPACK_IMPORTED_MODULE_0__events__["o"])(void 0, void 0, latestError));
            }
            function handleStreamEnd() {
              if (state === BEGIN) {
                emitValueOpen({});
                emitValueClose();
                closed = true;
                return;
              }
              if (state !== VALUE || depth !== 0) {
                emitError("Unexpected end");
              }
              if (textNode !== void 0) {
                emitValueOpen(textNode);
                emitValueClose();
                textNode = void 0;
              }
              closed = true;
            }
            function whitespace(c2) {
              return c2 === "\r" || c2 === "\n" || c2 === " " || c2 === "	";
            }
            function handleData(chunk) {
              if (latestError) {
                return;
              }
              if (closed) {
                return emitError("Cannot write after close");
              }
              var i = 0;
              c = chunk[0];
              while (c) {
                if (i > 0) {
                  p = c;
                }
                c = chunk[i++];
                if (!c)
                  break;
                position++;
                if (c === "\n") {
                  line++;
                  column = 0;
                } else
                  column++;
                switch (state) {
                  case BEGIN:
                    if (c === "{")
                      state = OPEN_OBJECT;
                    else if (c === "[")
                      state = OPEN_ARRAY;
                    else if (!whitespace(c)) {
                      return emitError("Non-whitespace before {[.");
                    }
                    continue;
                  case OPEN_KEY:
                  case OPEN_OBJECT:
                    if (whitespace(c))
                      continue;
                    if (state === OPEN_KEY)
                      stack.push(CLOSE_KEY);
                    else {
                      if (c === "}") {
                        emitValueOpen({});
                        emitValueClose();
                        state = stack.pop() || VALUE;
                        continue;
                      } else
                        stack.push(CLOSE_OBJECT);
                    }
                    if (c === '"') {
                      state = STRING;
                    } else {
                      return emitError('Malformed object key should start with " ');
                    }
                    continue;
                  case CLOSE_KEY:
                  case CLOSE_OBJECT:
                    if (whitespace(c))
                      continue;
                    if (c === ":") {
                      if (state === CLOSE_OBJECT) {
                        stack.push(CLOSE_OBJECT);
                        if (textNode !== void 0) {
                          emitValueOpen({});
                          emitSaxKey(textNode);
                          textNode = void 0;
                        }
                        depth++;
                      } else {
                        if (textNode !== void 0) {
                          emitSaxKey(textNode);
                          textNode = void 0;
                        }
                      }
                      state = VALUE;
                    } else if (c === "}") {
                      if (textNode !== void 0) {
                        emitValueOpen(textNode);
                        emitValueClose();
                        textNode = void 0;
                      }
                      emitValueClose();
                      depth--;
                      state = stack.pop() || VALUE;
                    } else if (c === ",") {
                      if (state === CLOSE_OBJECT) {
                        stack.push(CLOSE_OBJECT);
                      }
                      if (textNode !== void 0) {
                        emitValueOpen(textNode);
                        emitValueClose();
                        textNode = void 0;
                      }
                      state = OPEN_KEY;
                    } else {
                      return emitError("Bad object");
                    }
                    continue;
                  case OPEN_ARRAY:
                  case VALUE:
                    if (whitespace(c))
                      continue;
                    if (state === OPEN_ARRAY) {
                      emitValueOpen([]);
                      depth++;
                      state = VALUE;
                      if (c === "]") {
                        emitValueClose();
                        depth--;
                        state = stack.pop() || VALUE;
                        continue;
                      } else {
                        stack.push(CLOSE_ARRAY);
                      }
                    }
                    if (c === '"')
                      state = STRING;
                    else if (c === "{")
                      state = OPEN_OBJECT;
                    else if (c === "[")
                      state = OPEN_ARRAY;
                    else if (c === "t")
                      state = TRUE;
                    else if (c === "f")
                      state = FALSE;
                    else if (c === "n")
                      state = NULL;
                    else if (c === "-") {
                      numberNode += c;
                    } else if (c === "0") {
                      numberNode += c;
                      state = NUMBER_DIGIT;
                    } else if ("123456789".indexOf(c) !== -1) {
                      numberNode += c;
                      state = NUMBER_DIGIT;
                    } else {
                      return emitError("Bad value");
                    }
                    continue;
                  case CLOSE_ARRAY:
                    if (c === ",") {
                      stack.push(CLOSE_ARRAY);
                      if (textNode !== void 0) {
                        emitValueOpen(textNode);
                        emitValueClose();
                        textNode = void 0;
                      }
                      state = VALUE;
                    } else if (c === "]") {
                      if (textNode !== void 0) {
                        emitValueOpen(textNode);
                        emitValueClose();
                        textNode = void 0;
                      }
                      emitValueClose();
                      depth--;
                      state = stack.pop() || VALUE;
                    } else if (whitespace(c)) {
                      continue;
                    } else {
                      return emitError("Bad array");
                    }
                    continue;
                  case STRING:
                    if (textNode === void 0) {
                      textNode = "";
                    }
                    var starti = i - 1;
                    STRING_BIGLOOP:
                      while (true) {
                        while (unicodeI > 0) {
                          unicodeS += c;
                          c = chunk.charAt(i++);
                          if (unicodeI === 4) {
                            textNode += String.fromCharCode(parseInt(unicodeS, 16));
                            unicodeI = 0;
                            starti = i - 1;
                          } else {
                            unicodeI++;
                          }
                          if (!c)
                            break STRING_BIGLOOP;
                        }
                        if (c === '"' && !slashed) {
                          state = stack.pop() || VALUE;
                          textNode += chunk.substring(starti, i - 1);
                          break;
                        }
                        if (c === "\\" && !slashed) {
                          slashed = true;
                          textNode += chunk.substring(starti, i - 1);
                          c = chunk.charAt(i++);
                          if (!c)
                            break;
                        }
                        if (slashed) {
                          slashed = false;
                          if (c === "n") {
                            textNode += "\n";
                          } else if (c === "r") {
                            textNode += "\r";
                          } else if (c === "t") {
                            textNode += "	";
                          } else if (c === "f") {
                            textNode += "\f";
                          } else if (c === "b") {
                            textNode += "\b";
                          } else if (c === "u") {
                            unicodeI = 1;
                            unicodeS = "";
                          } else {
                            textNode += c;
                          }
                          c = chunk.charAt(i++);
                          starti = i - 1;
                          if (!c)
                            break;
                          else
                            continue;
                        }
                        stringTokenPattern.lastIndex = i;
                        var reResult = stringTokenPattern.exec(chunk);
                        if (!reResult) {
                          i = chunk.length + 1;
                          textNode += chunk.substring(starti, i - 1);
                          break;
                        }
                        i = reResult.index + 1;
                        c = chunk.charAt(reResult.index);
                        if (!c) {
                          textNode += chunk.substring(starti, i - 1);
                          break;
                        }
                      }
                    continue;
                  case TRUE:
                    if (!c)
                      continue;
                    if (c === "r")
                      state = TRUE2;
                    else {
                      return emitError("Invalid true started with t" + c);
                    }
                    continue;
                  case TRUE2:
                    if (!c)
                      continue;
                    if (c === "u")
                      state = TRUE3;
                    else {
                      return emitError("Invalid true started with tr" + c);
                    }
                    continue;
                  case TRUE3:
                    if (!c)
                      continue;
                    if (c === "e") {
                      emitValueOpen(true);
                      emitValueClose();
                      state = stack.pop() || VALUE;
                    } else {
                      return emitError("Invalid true started with tru" + c);
                    }
                    continue;
                  case FALSE:
                    if (!c)
                      continue;
                    if (c === "a")
                      state = FALSE2;
                    else {
                      return emitError("Invalid false started with f" + c);
                    }
                    continue;
                  case FALSE2:
                    if (!c)
                      continue;
                    if (c === "l")
                      state = FALSE3;
                    else {
                      return emitError("Invalid false started with fa" + c);
                    }
                    continue;
                  case FALSE3:
                    if (!c)
                      continue;
                    if (c === "s")
                      state = FALSE4;
                    else {
                      return emitError("Invalid false started with fal" + c);
                    }
                    continue;
                  case FALSE4:
                    if (!c)
                      continue;
                    if (c === "e") {
                      emitValueOpen(false);
                      emitValueClose();
                      state = stack.pop() || VALUE;
                    } else {
                      return emitError("Invalid false started with fals" + c);
                    }
                    continue;
                  case NULL:
                    if (!c)
                      continue;
                    if (c === "u")
                      state = NULL2;
                    else {
                      return emitError("Invalid null started with n" + c);
                    }
                    continue;
                  case NULL2:
                    if (!c)
                      continue;
                    if (c === "l")
                      state = NULL3;
                    else {
                      return emitError("Invalid null started with nu" + c);
                    }
                    continue;
                  case NULL3:
                    if (!c)
                      continue;
                    if (c === "l") {
                      emitValueOpen(null);
                      emitValueClose();
                      state = stack.pop() || VALUE;
                    } else {
                      return emitError("Invalid null started with nul" + c);
                    }
                    continue;
                  case NUMBER_DECIMAL_POINT:
                    if (c === ".") {
                      numberNode += c;
                      state = NUMBER_DIGIT;
                    } else {
                      return emitError("Leading zero not followed by .");
                    }
                    continue;
                  case NUMBER_DIGIT:
                    if ("0123456789".indexOf(c) !== -1)
                      numberNode += c;
                    else if (c === ".") {
                      if (numberNode.indexOf(".") !== -1) {
                        return emitError("Invalid number has two dots");
                      }
                      numberNode += c;
                    } else if (c === "e" || c === "E") {
                      if (numberNode.indexOf("e") !== -1 || numberNode.indexOf("E") !== -1) {
                        return emitError("Invalid number has two exponential");
                      }
                      numberNode += c;
                    } else if (c === "+" || c === "-") {
                      if (!(p === "e" || p === "E")) {
                        return emitError("Invalid symbol in number");
                      }
                      numberNode += c;
                    } else {
                      if (numberNode) {
                        emitValueOpen(parseFloat(numberNode));
                        emitValueClose();
                        numberNode = "";
                      }
                      i--;
                      state = stack.pop() || VALUE;
                    }
                    continue;
                  default:
                    return emitError("Unknown state: " + state);
                }
              }
              if (position >= bufferCheckPosition) {
                checkBufferLength();
              }
            }
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return httpTransport;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return streamingHttp;
          });
          var __WEBPACK_IMPORTED_MODULE_0__detectCrossOrigin_browser__ = __webpack_require__(19);
          var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(3);
          var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(2);
          var __WEBPACK_IMPORTED_MODULE_3__parseResponseHeaders_browser__ = __webpack_require__(20);
          var __WEBPACK_IMPORTED_MODULE_4__functional__ = __webpack_require__(0);
          function httpTransport() {
            return new XMLHttpRequest();
          }
          function streamingHttp(oboeBus, xhr, method, url, data, headers, withCredentials) {
            "use strict";
            var emitStreamData = oboeBus(__WEBPACK_IMPORTED_MODULE_1__events__["m"]).emit;
            var emitFail = oboeBus(__WEBPACK_IMPORTED_MODULE_1__events__["b"]).emit;
            var numberOfCharsAlreadyGivenToCallback = 0;
            var stillToSendStartEvent = true;
            oboeBus(__WEBPACK_IMPORTED_MODULE_1__events__["a"]).on(function() {
              xhr.onreadystatechange = null;
              xhr.abort();
            });
            function handleProgress() {
              if (String(xhr.status)[0] === "2") {
                var textSoFar = xhr.responseText;
                var newText = (" " + textSoFar.substr(numberOfCharsAlreadyGivenToCallback)).substr(1);
                if (newText) {
                  emitStreamData(newText);
                }
                numberOfCharsAlreadyGivenToCallback = Object(__WEBPACK_IMPORTED_MODULE_2__util__["e"])(textSoFar);
              }
            }
            if ("onprogress" in xhr) {
              xhr.onprogress = handleProgress;
            }
            function sendStartIfNotAlready(xhr2) {
              try {
                stillToSendStartEvent && oboeBus(__WEBPACK_IMPORTED_MODULE_1__events__["c"]).emit(xhr2.status, Object(__WEBPACK_IMPORTED_MODULE_3__parseResponseHeaders_browser__["a"])(xhr2.getAllResponseHeaders()));
                stillToSendStartEvent = false;
              } catch (e) {
              }
            }
            xhr.onreadystatechange = function() {
              switch (xhr.readyState) {
                case 2:
                case 3:
                  return sendStartIfNotAlready(xhr);
                case 4:
                  sendStartIfNotAlready(xhr);
                  var successful = String(xhr.status)[0] === "2";
                  if (successful) {
                    handleProgress();
                    oboeBus(__WEBPACK_IMPORTED_MODULE_1__events__["n"]).emit();
                  } else {
                    emitFail(Object(__WEBPACK_IMPORTED_MODULE_1__events__["o"])(xhr.status, xhr.responseText));
                  }
              }
            };
            try {
              xhr.open(method, url, true);
              for (var headerName in headers) {
                xhr.setRequestHeader(headerName, headers[headerName]);
              }
              if (!Object(__WEBPACK_IMPORTED_MODULE_0__detectCrossOrigin_browser__["a"])(window.location, Object(__WEBPACK_IMPORTED_MODULE_0__detectCrossOrigin_browser__["b"])(url))) {
                xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
              }
              xhr.withCredentials = withCredentials;
              xhr.send(data);
            } catch (e) {
              window.setTimeout(Object(__WEBPACK_IMPORTED_MODULE_4__functional__["j"])(emitFail, Object(__WEBPACK_IMPORTED_MODULE_1__events__["o"])(void 0, void 0, e)), 0);
            }
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return isCrossOrigin;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return parseUrlOrigin;
          });
          function isCrossOrigin(pageLocation, ajaxHost) {
            function defaultPort(protocol) {
              return { "http:": 80, "https:": 443 }[protocol];
            }
            function portOf(location) {
              return String(location.port || defaultPort(location.protocol || pageLocation.protocol));
            }
            return !!(ajaxHost.protocol && ajaxHost.protocol !== pageLocation.protocol || ajaxHost.host && ajaxHost.host !== pageLocation.host || ajaxHost.host && portOf(ajaxHost) !== portOf(pageLocation));
          }
          function parseUrlOrigin(url) {
            var URL_HOST_PATTERN = /(\w+:)?(?:\/\/)([\w.-]+)?(?::(\d+))?\/?/;
            var urlHostMatch = URL_HOST_PATTERN.exec(url) || [];
            return {
              protocol: urlHostMatch[1] || "",
              host: urlHostMatch[2] || "",
              port: urlHostMatch[3] || ""
            };
          }
        },
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return parseResponseHeaders;
          });
          function parseResponseHeaders(headerStr) {
            var headers = {};
            headerStr && headerStr.split("\r\n").forEach(function(headerPair) {
              var index = headerPair.indexOf(": ");
              headers[headerPair.substring(0, index)] = headerPair.substring(index + 2);
            });
            return headers;
          }
        }
      ])["default"];
    });
  }
});

// node_modules/web3-eth-contract/node_modules/web3-providers-ipc/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/web3-eth-contract/node_modules/web3-providers-ipc/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var errors = require_lib4().errors;
    var oboe = require_oboe_browser();
    var IpcProvider = function IpcProvider2(path, net) {
      var _this = this;
      this.responseCallbacks = {};
      this.notificationCallbacks = [];
      this.path = path;
      this.connected = false;
      this.connection = net.connect({ path: this.path });
      this.addDefaultEvents();
      var callback = function(result) {
        var id2 = null;
        if (Array.isArray(result)) {
          result.forEach(function(load) {
            if (_this.responseCallbacks[load.id])
              id2 = load.id;
          });
        } else {
          id2 = result.id;
        }
        if (!id2 && result.method.indexOf("_subscription") !== -1) {
          _this.notificationCallbacks.forEach(function(callback2) {
            if (typeof callback2 === "function")
              callback2(result);
          });
        } else if (_this.responseCallbacks[id2]) {
          _this.responseCallbacks[id2](null, result);
          delete _this.responseCallbacks[id2];
        }
      };
      if (net.constructor.name === "Socket") {
        oboe(this.connection).done(callback);
      } else {
        this.connection.on("data", function(data) {
          _this._parseResponse(data.toString()).forEach(callback);
        });
      }
    };
    IpcProvider.prototype.addDefaultEvents = function() {
      var _this = this;
      this.connection.on("connect", function() {
        _this.connected = true;
      });
      this.connection.on("close", function() {
        _this.connected = false;
      });
      this.connection.on("error", function() {
        _this._timeout();
      });
      this.connection.on("end", function() {
        _this._timeout();
      });
      this.connection.on("timeout", function() {
        _this._timeout();
      });
    };
    IpcProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            _this._timeout();
            throw errors.InvalidResponse(data2);
          }, 1e3 * 15);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    IpcProvider.prototype._addResponseCallback = function(payload, callback) {
      var id2 = payload.id || payload[0].id;
      var method = payload.method || payload[0].method;
      this.responseCallbacks[id2] = callback;
      this.responseCallbacks[id2].method = method;
    };
    IpcProvider.prototype._timeout = function() {
      for (var key in this.responseCallbacks) {
        if (this.responseCallbacks.hasOwnProperty(key)) {
          this.responseCallbacks[key](errors.InvalidConnection("on IPC"));
          delete this.responseCallbacks[key];
        }
      }
    };
    IpcProvider.prototype.reconnect = function() {
      this.connection.connect({ path: this.path });
    };
    IpcProvider.prototype.send = function(payload, callback) {
      if (!this.connection.writable)
        this.connection.connect({ path: this.path });
      this.connection.write(JSON.stringify(payload));
      this._addResponseCallback(payload, callback);
    };
    IpcProvider.prototype.on = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      switch (type) {
        case "data":
          this.notificationCallbacks.push(callback);
          break;
        default:
          this.connection.on(type, callback);
          break;
      }
    };
    IpcProvider.prototype.once = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      this.connection.once(type, callback);
    };
    IpcProvider.prototype.removeListener = function(type, callback) {
      var _this = this;
      switch (type) {
        case "data":
          this.notificationCallbacks.forEach(function(cb, index) {
            if (cb === callback)
              _this.notificationCallbacks.splice(index, 1);
          });
          break;
        default:
          this.connection.removeListener(type, callback);
          break;
      }
    };
    IpcProvider.prototype.removeAllListeners = function(type) {
      switch (type) {
        case "data":
          this.notificationCallbacks = [];
          break;
        default:
          this.connection.removeAllListeners(type);
          break;
      }
    };
    IpcProvider.prototype.reset = function() {
      this._timeout();
      this.notificationCallbacks = [];
      this.connection.removeAllListeners("error");
      this.connection.removeAllListeners("end");
      this.connection.removeAllListeners("timeout");
      this.addDefaultEvents();
    };
    IpcProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    module.exports = IpcProvider;
  }
});

// node_modules/web3-eth-contract/node_modules/web3-core-requestmanager/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/web3-eth-contract/node_modules/web3-core-requestmanager/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { callbackify } = require_util();
    var errors = require_lib4().errors;
    var Jsonrpc = require_jsonrpc();
    var BatchManager = require_batch();
    var givenProvider = require_givenProvider();
    var RequestManager = function RequestManager2(provider, net) {
      this.provider = null;
      this.providers = RequestManager2.providers;
      this.setProvider(provider, net);
      this.subscriptions = /* @__PURE__ */ new Map();
    };
    RequestManager.givenProvider = givenProvider;
    RequestManager.providers = {
      WebsocketProvider: require_lib5(),
      HttpProvider: require_lib6(),
      IpcProvider: require_lib7()
    };
    RequestManager.prototype.setProvider = function(provider, net) {
      var _this = this;
      if (provider && typeof provider === "string" && this.providers) {
        if (/^http(s)?:\/\//i.test(provider)) {
          provider = new this.providers.HttpProvider(provider);
        } else if (/^ws(s)?:\/\//i.test(provider)) {
          provider = new this.providers.WebsocketProvider(provider);
        } else if (provider && typeof net === "object" && typeof net.connect === "function") {
          provider = new this.providers.IpcProvider(provider, net);
        } else if (provider) {
          throw new Error(`Can't autodetect provider for "` + provider + '"');
        }
      }
      if (this.provider && this.provider.connected)
        this.clearSubscriptions();
      this.provider = provider || null;
      if (this.provider && this.provider.on) {
        if (typeof provider.request === "function") {
          this.provider.on("message", function(payload) {
            if (payload && payload.type === "eth_subscription" && payload.data) {
              const data = payload.data;
              if (data.subscription && _this.subscriptions.has(data.subscription)) {
                _this.subscriptions.get(data.subscription).callback(null, data.result);
              }
            }
          });
        } else {
          this.provider.on("data", function data(result, deprecatedResult) {
            result = result || deprecatedResult;
            if (result.method && result.params && result.params.subscription && _this.subscriptions.has(result.params.subscription)) {
              _this.subscriptions.get(result.params.subscription).callback(null, result.params.result);
            }
          });
        }
        this.provider.on("connect", function connect() {
          _this.subscriptions.forEach(function(subscription) {
            subscription.subscription.resubscribe();
          });
        });
        this.provider.on("error", function error(error) {
          _this.subscriptions.forEach(function(subscription) {
            subscription.callback(error);
          });
        });
        const disconnect = function disconnect2(event) {
          if (!_this._isCleanCloseEvent(event) || _this._isIpcCloseError(event)) {
            _this.subscriptions.forEach(function(subscription) {
              subscription.callback(errors.ConnectionCloseError(event));
              _this.subscriptions.delete(subscription.subscription.id);
            });
            if (_this.provider && _this.provider.emit) {
              _this.provider.emit("error", errors.ConnectionCloseError(event));
            }
          }
          if (_this.provider && _this.provider.emit) {
            _this.provider.emit("end", event);
          }
        };
        this.provider.on("disconnect", disconnect);
      }
    };
    RequestManager.prototype.send = function(data, callback) {
      callback = callback || function() {
      };
      if (!this.provider) {
        return callback(errors.InvalidProvider());
      }
      const { method, params } = data;
      const jsonrpcPayload = Jsonrpc.toPayload(method, params);
      const jsonrpcResultCallback = this._jsonrpcResultCallback(callback, jsonrpcPayload);
      if (this.provider.request) {
        const callbackRequest = callbackify(this.provider.request.bind(this.provider));
        const requestArgs = { method, params };
        callbackRequest(requestArgs, callback);
      } else if (this.provider.sendAsync) {
        this.provider.sendAsync(jsonrpcPayload, jsonrpcResultCallback);
      } else if (this.provider.send) {
        this.provider.send(jsonrpcPayload, jsonrpcResultCallback);
      } else {
        throw new Error("Provider does not have a request or send method to use.");
      }
    };
    RequestManager.prototype.sendBatch = function(data, callback) {
      if (!this.provider) {
        return callback(errors.InvalidProvider());
      }
      var payload = Jsonrpc.toBatchPayload(data);
      this.provider[this.provider.sendAsync ? "sendAsync" : "send"](payload, function(err, results) {
        if (err) {
          return callback(err);
        }
        if (!Array.isArray(results)) {
          return callback(errors.InvalidResponse(results));
        }
        callback(null, results);
      });
    };
    RequestManager.prototype.addSubscription = function(subscription, callback) {
      if (this.provider.on) {
        this.subscriptions.set(subscription.id, {
          callback,
          subscription
        });
      } else {
        throw new Error("The provider doesn't support subscriptions: " + this.provider.constructor.name);
      }
    };
    RequestManager.prototype.removeSubscription = function(id2, callback) {
      if (this.subscriptions.has(id2)) {
        var type = this.subscriptions.get(id2).subscription.options.type;
        this.subscriptions.delete(id2);
        this.send({
          method: type + "_unsubscribe",
          params: [id2]
        }, callback);
        return;
      }
      if (typeof callback === "function") {
        callback(null);
      }
    };
    RequestManager.prototype.clearSubscriptions = function(keepIsSyncing) {
      try {
        var _this = this;
        if (this.subscriptions.size > 0) {
          this.subscriptions.forEach(function(value, id2) {
            if (!keepIsSyncing || value.name !== "syncing")
              _this.removeSubscription(id2);
          });
        }
        if (this.provider.reset)
          this.provider.reset();
        return true;
      } catch (e) {
        throw new Error(`Error while clearing subscriptions: ${e}`);
      }
    };
    RequestManager.prototype._isCleanCloseEvent = function(event) {
      return typeof event === "object" && ([1e3].includes(event.code) || event.wasClean === true);
    };
    RequestManager.prototype._isIpcCloseError = function(event) {
      return typeof event === "boolean" && event;
    };
    RequestManager.prototype._jsonrpcResultCallback = function(callback, payload) {
      return function(err, result) {
        if (result && result.id && payload.id !== result.id) {
          return callback(new Error(`Wrong response id ${result.id} (expected: ${payload.id}) in ${JSON.stringify(payload)}`));
        }
        if (err) {
          return callback(err);
        }
        if (result && result.error) {
          return callback(errors.ErrorResponse(result));
        }
        if (!Jsonrpc.isValidResponse(result)) {
          return callback(errors.InvalidResponse(result));
        }
        callback(null, result.result);
      };
    };
    module.exports = {
      Manager: RequestManager,
      BatchManager
    };
  }
});

// node_modules/web3-core-promievent/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/web3-core-promievent/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var EventEmitter = require_eventemitter3();
    var PromiEvent = function PromiEvent2(justPromise) {
      var resolve, reject, eventEmitter = new Promise(function() {
        resolve = arguments[0];
        reject = arguments[1];
      });
      if (justPromise) {
        return {
          resolve,
          reject,
          eventEmitter
        };
      }
      var emitter = new EventEmitter();
      eventEmitter._events = emitter._events;
      eventEmitter.emit = emitter.emit;
      eventEmitter.on = emitter.on;
      eventEmitter.once = emitter.once;
      eventEmitter.off = emitter.off;
      eventEmitter.listeners = emitter.listeners;
      eventEmitter.addListener = emitter.addListener;
      eventEmitter.removeListener = emitter.removeListener;
      eventEmitter.removeAllListeners = emitter.removeAllListeners;
      return {
        resolve,
        reject,
        eventEmitter
      };
    };
    PromiEvent.resolve = function(value) {
      var promise = PromiEvent(true);
      promise.resolve(value);
      return promise.eventEmitter;
    };
    module.exports = PromiEvent;
  }
});

// node_modules/web3-core-subscriptions/lib/subscription.js
var require_subscription = __commonJS({
  "node_modules/web3-core-subscriptions/lib/subscription.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var errors = require_lib4().errors;
    var EventEmitter = require_eventemitter3();
    var formatters = require_lib4().formatters;
    function identity(value) {
      return value;
    }
    function Subscription(options) {
      EventEmitter.call(this);
      this.id = null;
      this.callback = identity;
      this.arguments = null;
      this.lastBlock = null;
      this.options = {
        subscription: options.subscription,
        type: options.type,
        requestManager: options.requestManager
      };
    }
    Subscription.prototype = Object.create(EventEmitter.prototype);
    Subscription.prototype.constructor = Subscription;
    Subscription.prototype._extractCallback = function(args) {
      if (typeof args[args.length - 1] === "function") {
        return args.pop();
      }
    };
    Subscription.prototype._validateArgs = function(args) {
      var subscription = this.options.subscription;
      if (!subscription)
        subscription = {};
      if (!subscription.params)
        subscription.params = 0;
      if (args.length !== subscription.params) {
        throw errors.InvalidNumberOfParams(args.length, subscription.params, subscription.subscriptionName);
      }
    };
    Subscription.prototype._formatInput = function(args) {
      var subscription = this.options.subscription;
      if (!subscription) {
        return args;
      }
      if (!subscription.inputFormatter) {
        return args;
      }
      var formattedArgs = subscription.inputFormatter.map(function(formatter, index) {
        return formatter ? formatter(args[index]) : args[index];
      });
      return formattedArgs;
    };
    Subscription.prototype._formatOutput = function(result) {
      var subscription = this.options.subscription;
      return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result;
    };
    Subscription.prototype._toPayload = function(args) {
      var params = [];
      this.callback = this._extractCallback(args) || identity;
      if (!this.subscriptionMethod) {
        this.subscriptionMethod = args.shift();
        if (this.options.subscription.subscriptionName) {
          this.subscriptionMethod = this.options.subscription.subscriptionName;
        }
      }
      if (!this.arguments) {
        this.arguments = this._formatInput(args);
        this._validateArgs(this.arguments);
        args = [];
      }
      params.push(this.subscriptionMethod);
      params = params.concat(this.arguments);
      if (args.length) {
        throw new Error("Only a callback is allowed as parameter on an already instantiated subscription.");
      }
      return {
        method: this.options.type + "_subscribe",
        params
      };
    };
    Subscription.prototype.unsubscribe = function(callback) {
      this.options.requestManager.removeSubscription(this.id, callback);
      this.id = null;
      this.lastBlock = null;
      this.removeAllListeners();
    };
    Subscription.prototype.subscribe = function() {
      var _this = this;
      var args = Array.prototype.slice.call(arguments);
      var payload = this._toPayload(args);
      if (!payload) {
        return this;
      }
      if (!this.options.requestManager.provider) {
        setTimeout(function() {
          var err1 = new Error("No provider set.");
          _this.callback(err1, null, _this);
          _this.emit("error", err1);
        }, 0);
        return this;
      }
      if (!this.options.requestManager.provider.on) {
        setTimeout(function() {
          var err2 = new Error("The current provider doesn't support subscriptions: " + _this.options.requestManager.provider.constructor.name);
          _this.callback(err2, null, _this);
          _this.emit("error", err2);
        }, 0);
        return this;
      }
      if (this.lastBlock && !!this.options.params && typeof this.options.params === "object") {
        payload.params[1] = this.options.params;
        payload.params[1].fromBlock = formatters.inputBlockNumberFormatter(this.lastBlock + 1);
      }
      if (this.id) {
        this.unsubscribe();
      }
      this.options.params = payload.params[1];
      if (payload.params[0] === "logs" && !!payload.params[1] && typeof payload.params[1] === "object" && payload.params[1].hasOwnProperty("fromBlock") && isFinite(payload.params[1].fromBlock)) {
        var blockParams = Object.assign({}, payload.params[1]);
        this.options.requestManager.send({
          method: "eth_getLogs",
          params: [blockParams]
        }, function(err, logs) {
          if (!err) {
            logs.forEach(function(log) {
              var output = _this._formatOutput(log);
              _this.callback(null, output, _this);
              _this.emit("data", output);
            });
          } else {
            setTimeout(function() {
              _this.callback(err, null, _this);
              _this.emit("error", err);
            }, 0);
          }
        });
      }
      if (typeof payload.params[1] === "object")
        delete payload.params[1].fromBlock;
      this.options.requestManager.send(payload, function(err, result) {
        if (!err && result) {
          _this.id = result;
          _this.method = payload.params[0];
          _this.options.requestManager.addSubscription(_this, function(error, result2) {
            if (!error) {
              if (!Array.isArray(result2)) {
                result2 = [result2];
              }
              result2.forEach(function(resultItem) {
                var output = _this._formatOutput(resultItem);
                _this.lastBlock = !!output && typeof output === "object" ? output.blockNumber : null;
                if (typeof _this.options.subscription.subscriptionHandler === "function") {
                  return _this.options.subscription.subscriptionHandler.call(_this, output);
                } else {
                  _this.emit("data", output);
                }
                _this.callback(null, output, _this);
              });
            } else {
              _this.callback(error, false, _this);
              _this.emit("error", error);
            }
          });
          _this.emit("connected", result);
        } else {
          setTimeout(function() {
            _this.callback(err, false, _this);
            _this.emit("error", err);
          }, 0);
        }
      });
      return this;
    };
    Subscription.prototype.resubscribe = function() {
      this.options.requestManager.removeSubscription(this.id);
      this.id = null;
      this.subscribe(this.callback);
    };
    module.exports = Subscription;
  }
});

// node_modules/web3-core-subscriptions/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/web3-core-subscriptions/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Subscription = require_subscription();
    var Subscriptions = function Subscriptions2(options) {
      this.name = options.name;
      this.type = options.type;
      this.subscriptions = options.subscriptions || {};
      this.requestManager = null;
    };
    Subscriptions.prototype.setRequestManager = function(rm) {
      this.requestManager = rm;
    };
    Subscriptions.prototype.attachToObject = function(obj) {
      var func = this.buildCall();
      var name = this.name.split(".");
      if (name.length > 1) {
        obj[name[0]] = obj[name[0]] || {};
        obj[name[0]][name[1]] = func;
      } else {
        obj[name[0]] = func;
      }
    };
    Subscriptions.prototype.buildCall = function() {
      var _this = this;
      return function() {
        if (!_this.subscriptions[arguments[0]]) {
          console.warn("Subscription " + JSON.stringify(arguments[0]) + " doesn't exist. Subscribing anyway.");
        }
        var subscription = new Subscription({
          subscription: _this.subscriptions[arguments[0]] || {},
          requestManager: _this.requestManager,
          type: _this.type
        });
        return subscription.subscribe.apply(subscription, arguments);
      };
    };
    module.exports = {
      subscriptions: Subscriptions,
      subscription: Subscription
    };
  }
});

// node_modules/web3-core-method/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/web3-core-method/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var errors = require_lib4().errors;
    var formatters = require_lib4().formatters;
    var utils = require_lib2();
    var promiEvent = require_lib9();
    var Subscriptions = require_lib10().subscriptions;
    var EthersTransactionUtils = (init_lib10(), __toCommonJS(lib_exports));
    var Method = function Method2(options) {
      if (!options.call || !options.name) {
        throw new Error('When creating a method you need to provide at least the "name" and "call" property.');
      }
      this.name = options.name;
      this.call = options.call;
      this.params = options.params || 0;
      this.inputFormatter = options.inputFormatter;
      this.outputFormatter = options.outputFormatter;
      this.transformPayload = options.transformPayload;
      this.extraFormatters = options.extraFormatters;
      this.abiCoder = options.abiCoder;
      this.requestManager = options.requestManager;
      this.accounts = options.accounts;
      this.defaultBlock = options.defaultBlock || "latest";
      this.defaultAccount = options.defaultAccount || null;
      this.transactionBlockTimeout = options.transactionBlockTimeout || 50;
      this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;
      this.transactionPollingTimeout = options.transactionPollingTimeout || 750;
      this.transactionPollingInterval = options.transactionPollingInterval || 1e3;
      this.blockHeaderTimeout = options.blockHeaderTimeout || 10;
      this.defaultCommon = options.defaultCommon;
      this.defaultChain = options.defaultChain;
      this.defaultHardfork = options.defaultHardfork;
      this.handleRevert = options.handleRevert;
    };
    Method.prototype.setRequestManager = function(requestManager, accounts) {
      this.requestManager = requestManager;
      if (accounts) {
        this.accounts = accounts;
      }
    };
    Method.prototype.createFunction = function(requestManager, accounts) {
      var func = this.buildCall();
      func.call = this.call;
      this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);
      return func;
    };
    Method.prototype.attachToObject = function(obj) {
      var func = this.buildCall();
      func.call = this.call;
      var name = this.name.split(".");
      if (name.length > 1) {
        obj[name[0]] = obj[name[0]] || {};
        obj[name[0]][name[1]] = func;
      } else {
        obj[name[0]] = func;
      }
    };
    Method.prototype.getCall = function(args) {
      return typeof this.call === "function" ? this.call(args) : this.call;
    };
    Method.prototype.extractCallback = function(args) {
      if (typeof args[args.length - 1] === "function") {
        return args.pop();
      }
    };
    Method.prototype.validateArgs = function(args) {
      if (args.length !== this.params) {
        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);
      }
    };
    Method.prototype.formatInput = function(args) {
      var _this = this;
      if (!this.inputFormatter) {
        return args;
      }
      return this.inputFormatter.map(function(formatter, index) {
        return formatter ? formatter.call(_this, args[index]) : args[index];
      });
    };
    Method.prototype.formatOutput = function(result) {
      var _this = this;
      if (Array.isArray(result)) {
        return result.map(function(res) {
          return _this.outputFormatter && res ? _this.outputFormatter(res) : res;
        });
      } else {
        return this.outputFormatter && result ? this.outputFormatter(result) : result;
      }
    };
    Method.prototype.toPayload = function(args) {
      var call = this.getCall(args);
      var callback = this.extractCallback(args);
      var params = this.formatInput(args);
      this.validateArgs(params);
      var payload = {
        method: call,
        params,
        callback
      };
      if (this.transformPayload) {
        payload = this.transformPayload(payload);
      }
      return payload;
    };
    Method.prototype._confirmTransaction = function(defer, result, payload) {
      var method = this, promiseResolved = false, canUnsubscribe = true, timeoutCount = 0, confirmationCount = 0, intervalId = null, blockHeaderTimeoutId = null, lastBlock = null, receiptJSON = "", gasProvided = !!payload.params[0] && typeof payload.params[0] === "object" && payload.params[0].gas ? payload.params[0].gas : null, isContractDeployment = !!payload.params[0] && typeof payload.params[0] === "object" && payload.params[0].data && payload.params[0].from && !payload.params[0].to, hasBytecode = isContractDeployment && payload.params[0].data.length > 2;
      var _ethereumCalls = [
        new Method({
          name: "getBlockByNumber",
          call: "eth_getBlockByNumber",
          params: 2,
          inputFormatter: [formatters.inputBlockNumberFormatter, function(val) {
            return !!val;
          }],
          outputFormatter: formatters.outputBlockFormatter
        }),
        new Method({
          name: "getTransactionReceipt",
          call: "eth_getTransactionReceipt",
          params: 1,
          inputFormatter: [null],
          outputFormatter: formatters.outputTransactionReceiptFormatter
        }),
        new Method({
          name: "getCode",
          call: "eth_getCode",
          params: 2,
          inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]
        }),
        new Method({
          name: "getTransactionByHash",
          call: "eth_getTransactionByHash",
          params: 1,
          inputFormatter: [null],
          outputFormatter: formatters.outputTransactionFormatter
        }),
        new Subscriptions({
          name: "subscribe",
          type: "eth",
          subscriptions: {
            "newBlockHeaders": {
              subscriptionName: "newHeads",
              params: 0,
              outputFormatter: formatters.outputBlockFormatter
            }
          }
        })
      ];
      var _ethereumCall = {};
      _ethereumCalls.forEach((mthd) => {
        mthd.attachToObject(_ethereumCall);
        mthd.requestManager = method.requestManager;
      });
      var checkConfirmation = function(existingReceipt, isPolling, err, blockHeader, sub) {
        if (!err) {
          if (!sub) {
            sub = {
              unsubscribe: function() {
                clearInterval(intervalId);
                clearTimeout(blockHeaderTimeoutId);
              }
            };
          }
          return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result)).catch(function(err2) {
            sub.unsubscribe();
            promiseResolved = true;
            utils._fireError({
              message: "Failed to check for transaction receipt:",
              data: err2
            }, defer.eventEmitter, defer.reject);
          }).then(async function(receipt) {
            if (!receipt || !receipt.blockHash) {
              throw new Error("Receipt missing or blockHash null");
            }
            if (method.extraFormatters && method.extraFormatters.receiptFormatter) {
              receipt = method.extraFormatters.receiptFormatter(receipt);
            }
            if (defer.eventEmitter.listeners("confirmation").length > 0) {
              var block;
              if (existingReceipt === void 0 || confirmationCount !== 0) {
                var latestBlock = await _ethereumCall.getBlockByNumber("latest");
                var latestBlockHash = latestBlock ? latestBlock.hash : null;
                if (isPolling) {
                  if (lastBlock) {
                    block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);
                    if (block) {
                      lastBlock = block;
                      defer.eventEmitter.emit("confirmation", confirmationCount, receipt, latestBlockHash);
                    }
                  } else {
                    block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);
                    lastBlock = block;
                    defer.eventEmitter.emit("confirmation", confirmationCount, receipt, latestBlockHash);
                  }
                } else {
                  defer.eventEmitter.emit("confirmation", confirmationCount, receipt, latestBlockHash);
                }
              }
              if (isPolling && block || !isPolling) {
                confirmationCount++;
              }
              canUnsubscribe = false;
              if (confirmationCount === method.transactionConfirmationBlocks + 1) {
                sub.unsubscribe();
                defer.eventEmitter.removeAllListeners();
              }
            }
            return receipt;
          }).then(async function(receipt) {
            if (isContractDeployment && !promiseResolved) {
              if (!receipt.contractAddress) {
                if (canUnsubscribe) {
                  sub.unsubscribe();
                  promiseResolved = true;
                }
                utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);
                return;
              }
              var code;
              try {
                code = await _ethereumCall.getCode(receipt.contractAddress);
              } catch (err2) {
              }
              if (!code) {
                return;
              }
              var deploymentSuccess = receipt.status === true && hasBytecode;
              if (deploymentSuccess || code.length > 2) {
                defer.eventEmitter.emit("receipt", receipt);
                if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {
                  defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));
                } else {
                  defer.resolve(receipt);
                }
                if (canUnsubscribe) {
                  defer.eventEmitter.removeAllListeners();
                }
              } else {
                utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);
              }
              if (canUnsubscribe) {
                sub.unsubscribe();
              }
              promiseResolved = true;
            }
            return receipt;
          }).then(async function(receipt) {
            if (!isContractDeployment && !promiseResolved) {
              if (!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === "0x1" || typeof receipt.status === "undefined")) {
                defer.eventEmitter.emit("receipt", receipt);
                defer.resolve(receipt);
                if (canUnsubscribe) {
                  defer.eventEmitter.removeAllListeners();
                }
              } else {
                receiptJSON = JSON.stringify(receipt, null, 2);
                if (receipt.status === false || receipt.status === "0x0") {
                  try {
                    var revertMessage = null;
                    if (method.handleRevert && (method.call === "eth_sendTransaction" || method.call === "eth_sendRawTransaction")) {
                      var txReplayOptions = payload.params[0];
                      if (method.call === "eth_sendRawTransaction") {
                        var rawTransactionHex = payload.params[0];
                        var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);
                        txReplayOptions = formatters.inputTransactionFormatter({
                          data: parsedTx.data,
                          to: parsedTx.to,
                          from: parsedTx.from,
                          gas: parsedTx.gasLimit.toHexString(),
                          gasPrice: parsedTx.gasPrice.toHexString(),
                          value: parsedTx.value.toHexString()
                        });
                      }
                      revertMessage = await method.getRevertReason(txReplayOptions, receipt.blockNumber);
                      if (revertMessage) {
                        utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);
                      } else {
                        throw false;
                      }
                    } else {
                      throw false;
                    }
                  } catch (error) {
                    utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);
                  }
                } else {
                  utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);
                }
              }
              if (canUnsubscribe) {
                sub.unsubscribe();
              }
              promiseResolved = true;
            }
          }).catch(function() {
            timeoutCount++;
            if (!!isPolling) {
              if (timeoutCount - 1 >= method.transactionPollingTimeout) {
                sub.unsubscribe();
                promiseResolved = true;
                utils._fireError(errors.TransactionError("Transaction was not mined within " + method.transactionPollingTimeout + " seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!"), defer.eventEmitter, defer.reject);
              }
            } else {
              if (timeoutCount - 1 >= method.transactionBlockTimeout) {
                sub.unsubscribe();
                promiseResolved = true;
                utils._fireError(errors.TransactionError("Transaction was not mined within " + method.transactionBlockTimeout + " blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!"), defer.eventEmitter, defer.reject);
              }
            }
          });
        } else {
          sub.unsubscribe();
          promiseResolved = true;
          utils._fireError({
            message: "Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.",
            data: err
          }, defer.eventEmitter, defer.reject);
        }
      };
      var startWatching = function(existingReceipt) {
        let blockHeaderArrived = false;
        const startInterval = () => {
          intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), method.transactionPollingInterval);
        };
        if (!this.requestManager.provider.on) {
          return startInterval();
        }
        _ethereumCall.subscribe("newBlockHeaders", function(err, blockHeader, sub) {
          blockHeaderArrived = true;
          if (err || !blockHeader) {
            return startInterval();
          }
          checkConfirmation(existingReceipt, false, err, blockHeader, sub);
        });
        blockHeaderTimeoutId = setTimeout(() => {
          if (!blockHeaderArrived) {
            startInterval();
          }
        }, this.blockHeaderTimeout * 1e3);
      }.bind(this);
      _ethereumCall.getTransactionReceipt(result).then(function(receipt) {
        if (receipt && receipt.blockHash) {
          if (defer.eventEmitter.listeners("confirmation").length > 0) {
            startWatching(receipt);
          }
          checkConfirmation(receipt, false);
        } else if (!promiseResolved) {
          startWatching();
        }
      }).catch(function() {
        if (!promiseResolved)
          startWatching();
      });
    };
    var getWallet = function(from, accounts) {
      var wallet = null;
      if (typeof from === "number") {
        wallet = accounts.wallet[from];
      } else if (!!from && typeof from === "object" && from.address && from.privateKey) {
        wallet = from;
      } else {
        wallet = accounts.wallet[from.toLowerCase()];
      }
      return wallet;
    };
    Method.prototype.buildCall = function() {
      var method = this, isSendTx = method.call === "eth_sendTransaction" || method.call === "eth_sendRawTransaction", isCall = method.call === "eth_call";
      var send = function() {
        var defer = promiEvent(!isSendTx), payload = method.toPayload(Array.prototype.slice.call(arguments));
        var sendTxCallback = function(err, result) {
          if (method.handleRevert && isCall && method.abiCoder) {
            var reasonData;
            if (!err && method.isRevertReasonString(result)) {
              reasonData = result.substring(10);
            } else if (err && err.data) {
              reasonData = err.data.substring(10);
            }
            if (reasonData) {
              var reason = method.abiCoder.decodeParameter("string", "0x" + reasonData);
              var signature = "Error(String)";
              utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {
                reason,
                signature
              });
              return;
            }
          }
          try {
            result = method.formatOutput(result);
          } catch (e) {
            err = e;
          }
          if (result instanceof Error) {
            err = result;
          }
          if (!err) {
            if (payload.callback) {
              payload.callback(null, result);
            }
          } else {
            if (err.error) {
              err = err.error;
            }
            return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);
          }
          if (!isSendTx) {
            if (!err) {
              defer.resolve(result);
            }
          } else {
            defer.eventEmitter.emit("transactionHash", result);
            method._confirmTransaction(defer, result, payload);
          }
        };
        var sendSignedTx = function(sign) {
          var signedPayload = __spreadProps(__spreadValues({}, payload), {
            method: "eth_sendRawTransaction",
            params: [sign.rawTransaction]
          });
          method.requestManager.send(signedPayload, sendTxCallback);
        };
        var sendRequest = function(payload2, method2) {
          if (method2 && method2.accounts && method2.accounts.wallet && method2.accounts.wallet.length) {
            var wallet;
            if (payload2.method === "eth_sendTransaction") {
              var tx = payload2.params[0];
              wallet = getWallet(!!tx && typeof tx === "object" ? tx.from : null, method2.accounts);
              if (wallet && wallet.privateKey) {
                var tx = JSON.parse(JSON.stringify(tx));
                delete tx.from;
                if (method2.defaultChain && !tx.chain) {
                  tx.chain = method2.defaultChain;
                }
                if (method2.defaultHardfork && !tx.hardfork) {
                  tx.hardfork = method2.defaultHardfork;
                }
                if (method2.defaultCommon && !tx.common) {
                  tx.common = method2.defaultCommon;
                }
                method2.accounts.signTransaction(tx, wallet.privateKey).then(sendSignedTx).catch(function(err) {
                  if (typeof defer.eventEmitter.listeners === "function" && defer.eventEmitter.listeners("error").length) {
                    try {
                      defer.eventEmitter.emit("error", err);
                    } catch (err2) {
                    }
                    defer.eventEmitter.removeAllListeners();
                    defer.eventEmitter.catch(function() {
                    });
                  }
                  defer.reject(err);
                });
                return;
              }
            } else if (payload2.method === "eth_sign") {
              var data = payload2.params[1];
              wallet = getWallet(payload2.params[0], method2.accounts);
              if (wallet && wallet.privateKey) {
                var sign = method2.accounts.sign(data, wallet.privateKey);
                if (payload2.callback) {
                  payload2.callback(null, sign.signature);
                }
                defer.resolve(sign.signature);
                return;
              }
            }
          }
          return method2.requestManager.send(payload2, sendTxCallback);
        };
        if (isSendTx && !!payload.params[0] && typeof payload.params[0] === "object" && (typeof payload.params[0].gasPrice === "undefined" && (typeof payload.params[0].maxPriorityFeePerGas === "undefined" || typeof payload.params[0].maxFeePerGas === "undefined"))) {
          _handleTxPricing(method, payload.params[0]).then((txPricing) => {
            if (txPricing.gasPrice !== void 0) {
              payload.params[0].gasPrice = txPricing.gasPrice;
            } else if (txPricing.maxPriorityFeePerGas !== void 0 && txPricing.maxFeePerGas !== void 0) {
              payload.params[0].maxPriorityFeePerGas = txPricing.maxPriorityFeePerGas;
              payload.params[0].maxFeePerGas = txPricing.maxFeePerGas;
            }
            if (isSendTx) {
              setTimeout(() => {
                defer.eventEmitter.emit("sending", payload);
              }, 0);
            }
            sendRequest(payload, method);
          });
        } else {
          if (isSendTx) {
            setTimeout(() => {
              defer.eventEmitter.emit("sending", payload);
            }, 0);
          }
          sendRequest(payload, method);
        }
        if (isSendTx) {
          setTimeout(() => {
            defer.eventEmitter.emit("sent", payload);
          }, 0);
        }
        return defer.eventEmitter;
      };
      send.method = method;
      send.request = this.request.bind(this);
      return send;
    };
    function _handleTxPricing(method, tx) {
      return new Promise((resolve, reject) => {
        try {
          var getBlockByNumber = new Method({
            name: "getBlockByNumber",
            call: "eth_getBlockByNumber",
            params: 2,
            inputFormatter: [function(blockNumber) {
              return blockNumber ? utils.toHex(blockNumber) : "latest";
            }, function() {
              return false;
            }]
          }).createFunction(method.requestManager);
          var getGasPrice = new Method({
            name: "getGasPrice",
            call: "eth_gasPrice",
            params: 0
          }).createFunction(method.requestManager);
          Promise.all([
            getBlockByNumber(),
            getGasPrice()
          ]).then((responses) => {
            const [block, gasPrice] = responses;
            if ((tx.type === "0x2" || tx.type === void 0) && (block && block.baseFeePerGas)) {
              let maxPriorityFeePerGas, maxFeePerGas;
              if (tx.gasPrice) {
                maxPriorityFeePerGas = tx.gasPrice;
                maxFeePerGas = tx.gasPrice;
                delete tx.gasPrice;
              } else {
                maxPriorityFeePerGas = tx.maxPriorityFeePerGas || "0x9502F900";
                maxFeePerGas = tx.maxFeePerGas || utils.toHex(utils.toBN(block.baseFeePerGas).mul(utils.toBN(2)).add(utils.toBN(maxPriorityFeePerGas)));
              }
              resolve({ maxFeePerGas, maxPriorityFeePerGas });
            } else {
              if (tx.maxPriorityFeePerGas || tx.maxFeePerGas)
                throw Error("Network doesn't support eip-1559");
              resolve({ gasPrice });
            }
          });
        } catch (error) {
          reject(error);
        }
      });
    }
    Method.prototype.getRevertReason = function(txOptions, blockNumber) {
      var self2 = this;
      return new Promise(function(resolve, reject) {
        new Method({
          name: "call",
          call: "eth_call",
          params: 2,
          abiCoder: self2.abiCoder,
          handleRevert: true
        }).createFunction(self2.requestManager)(txOptions, utils.numberToHex(blockNumber)).then(function() {
          resolve(false);
        }).catch(function(error) {
          if (error.reason) {
            resolve({
              reason: error.reason,
              signature: error.signature
            });
          } else {
            reject(error);
          }
        });
      });
    };
    Method.prototype.isRevertReasonString = function(data) {
      return typeof data === "string" && (data.length - 2) / 2 % 32 === 4 && data.substring(0, 10) === "0x08c379a0";
    };
    Method.prototype.request = function() {
      var payload = this.toPayload(Array.prototype.slice.call(arguments));
      payload.format = this.formatOutput.bind(this);
      return payload;
    };
    module.exports = Method;
  }
});

// node_modules/web3-eth-contract/node_modules/web3-core/lib/extend.js
var require_extend = __commonJS({
  "node_modules/web3-eth-contract/node_modules/web3-core/lib/extend.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var formatters = require_lib4().formatters;
    var Method = require_lib11();
    var utils = require_lib2();
    var extend = function(pckg) {
      var ex = function(extension) {
        var extendedObject;
        if (extension.property) {
          if (!pckg[extension.property]) {
            pckg[extension.property] = {};
          }
          extendedObject = pckg[extension.property];
        } else {
          extendedObject = pckg;
        }
        if (extension.methods) {
          extension.methods.forEach(function(method) {
            if (!(method instanceof Method)) {
              method = new Method(method);
            }
            method.attachToObject(extendedObject);
            method.setRequestManager(pckg._requestManager);
          });
        }
        return pckg;
      };
      ex.formatters = formatters;
      ex.utils = utils;
      ex.Method = Method;
      return ex;
    };
    module.exports = extend;
  }
});

// node_modules/web3-eth-contract/node_modules/web3-core/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/web3-eth-contract/node_modules/web3-core/lib/index.js"(exports, module) {
    init_define_process_env();
    var requestManager = require_lib8();
    var extend = require_extend();
    var packageInit = (pkg, args) => {
      args = Array.prototype.slice.call(args);
      if (!pkg) {
        throw new Error('You need to instantiate using the "new" keyword.');
      }
      Object.defineProperty(pkg, "currentProvider", {
        get: () => {
          return pkg._provider;
        },
        set: (value) => {
          return pkg.setProvider(value);
        },
        enumerable: true,
        configurable: true
      });
      if (args[0] && args[0]._requestManager) {
        pkg._requestManager = args[0]._requestManager;
      } else {
        pkg._requestManager = new requestManager.Manager(args[0], args[1]);
      }
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
      pkg._provider = pkg._requestManager.provider;
      if (!pkg.setProvider) {
        pkg.setProvider = (provider, net) => {
          pkg._requestManager.setProvider(provider, net);
          pkg._provider = pkg._requestManager.provider;
          return true;
        };
      }
      pkg.setRequestManager = (manager) => {
        pkg._requestManager = manager;
        pkg._provider = manager.provider;
      };
      pkg.BatchRequest = requestManager.BatchManager.bind(null, pkg._requestManager);
      pkg.extend = extend(pkg);
    };
    var addProviders = (pkg) => {
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
    };
    module.exports = {
      packageInit,
      addProviders
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/_version.js
var version;
var init_version = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/_version.js"() {
    init_define_process_env();
    version = "abi/5.0.7";
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/fragments.js
function checkModifier(type, name) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name]) {
      return true;
    }
  } else if (type === "address") {
    if (name === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name]) {
      return true;
    }
  }
  if (ModifiersBytes[name] || name === "payable") {
    logger.throwArgumentError("invalid modifier", "name", name);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i) {
    logger.throwArgumentError(`unexpected character at position ${i}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i = 0; i < param.length; i++) {
    let c = param[i];
    switch (c) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError(i);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError(i);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i);
              }
              if (node.indexed) {
                throwError(i);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError(i);
        }
        node.type += c;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError(i);
        }
        node.type += c;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c;
        } else {
          throwError(i);
        }
    }
  }
  if (node.parent) {
    logger.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key in params) {
    defineReadOnly(object, key, params[key]);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c = value[offset];
    if (c === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c;
      if (c === "(") {
        depth++;
      } else if (c === ")") {
        depth--;
        if (depth === -1) {
          logger.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
var logger, _constructorGuard, ModifiersBytes, ModifiersNest, FormatTypes, paramTypeArray, ParamType, Fragment, EventFragment, ConstructorFragment, FunctionFragment, regexIdentifier, regexParen;
var init_fragments = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/fragments.js"() {
    "use strict";
    init_define_process_env();
    init_lib3();
    init_lib4();
    init_lib();
    init_version();
    logger = new Logger(version);
    _constructorGuard = {};
    ModifiersBytes = { calldata: true, memory: true, storage: true };
    ModifiersNest = { calldata: true, memory: true };
    FormatTypes = Object.freeze({
      sighash: "sighash",
      minimal: "minimal",
      full: "full",
      json: "json"
    });
    paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
    ParamType = class {
      constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
          logger.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
          });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
          populate(this, {
            arrayLength: parseInt(match[2] || "-1"),
            arrayChildren: ParamType.fromObject({
              type: match[1],
              components: this.components
            }),
            baseType: "array"
          });
        } else {
          populate(this, {
            arrayLength: null,
            arrayChildren: null,
            baseType: this.components != null ? "tuple" : this.type
          });
        }
        this._isParamType = true;
        Object.freeze(this);
      }
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          let result2 = {
            type: this.baseType === "tuple" ? "tuple" : this.type,
            name: this.name || void 0
          };
          if (typeof this.indexed === "boolean") {
            result2.indexed = this.indexed;
          }
          if (this.components) {
            result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
          }
          return JSON.stringify(result2);
        }
        let result = "";
        if (this.baseType === "array") {
          result += this.arrayChildren.format(format);
          result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        } else {
          if (this.baseType === "tuple") {
            if (format !== FormatTypes.sighash) {
              result += this.type;
            }
            result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
          } else {
            result += this.type;
          }
        }
        if (format !== FormatTypes.sighash) {
          if (this.indexed === true) {
            result += " indexed";
          }
          if (format === FormatTypes.full && this.name) {
            result += " " + this.name;
          }
        }
        return result;
      }
      static from(value, allowIndexed) {
        if (typeof value === "string") {
          return ParamType.fromString(value, allowIndexed);
        }
        return ParamType.fromObject(value);
      }
      static fromObject(value) {
        if (ParamType.isParamType(value)) {
          return value;
        }
        return new ParamType(_constructorGuard, {
          name: value.name || null,
          type: verifyType(value.type),
          indexed: value.indexed == null ? null : !!value.indexed,
          components: value.components ? value.components.map(ParamType.fromObject) : null
        });
      }
      static fromString(value, allowIndexed) {
        function ParamTypify(node) {
          return ParamType.fromObject({
            name: node.name,
            type: node.type,
            indexed: node.indexed,
            components: node.components
          });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
      }
      static isParamType(value) {
        return !!(value != null && value._isParamType);
      }
    };
    Fragment = class {
      constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
          logger.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
          });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
      }
      static from(value) {
        if (Fragment.isFragment(value)) {
          return value;
        }
        if (typeof value === "string") {
          return Fragment.fromString(value);
        }
        return Fragment.fromObject(value);
      }
      static fromObject(value) {
        if (Fragment.isFragment(value)) {
          return value;
        }
        switch (value.type) {
          case "function":
            return FunctionFragment.fromObject(value);
          case "event":
            return EventFragment.fromObject(value);
          case "constructor":
            return ConstructorFragment.fromObject(value);
          case "fallback":
          case "receive":
            return null;
        }
        return logger.throwArgumentError("invalid fragment object", "value", value);
      }
      static fromString(value) {
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
          return EventFragment.fromString(value.substring(5).trim());
        } else if (value.split(" ")[0] === "function") {
          return FunctionFragment.fromString(value.substring(8).trim());
        } else if (value.split("(")[0].trim() === "constructor") {
          return ConstructorFragment.fromString(value.trim());
        }
        return logger.throwArgumentError("unsupported fragment", "value", value);
      }
      static isFragment(value) {
        return !!(value && value._isFragment);
      }
    };
    EventFragment = class extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
          if (this.anonymous) {
            result += "anonymous ";
          }
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
      }
      static fromObject(value) {
        if (EventFragment.isEventFragment(value)) {
          return value;
        }
        if (value.type !== "event") {
          logger.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
          name: verifyIdentifier(value.name),
          anonymous: value.anonymous,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          type: "event"
        };
        return new EventFragment(_constructorGuard, params);
      }
      static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
          logger.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
          switch (modifier.trim()) {
            case "anonymous":
              anonymous = true;
              break;
            case "":
              break;
            default:
              logger.warn("unknown modifier: " + modifier);
          }
        });
        return EventFragment.fromObject({
          name: match[1].trim(),
          anonymous,
          inputs: parseParams(match[2], true),
          type: "event"
        });
      }
      static isEventFragment(value) {
        return value && value._isFragment && value.type === "event";
      }
    };
    ConstructorFragment = class extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "constructor",
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payble: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        if (format === FormatTypes.sighash) {
          logger.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
          });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
      }
      static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
          return value;
        }
        if (value.type !== "constructor") {
          logger.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
          logger.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
          name: null,
          type: value.type,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value.gas ? BigNumber.from(value.gas) : null
        };
        return new ConstructorFragment(_constructorGuard, params);
      }
      static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
          logger.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
      }
      static isConstructorFragment(value) {
        return value && value._isFragment && value.type === "constructor";
      }
    };
    FunctionFragment = class extends ConstructorFragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payble: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            ouputs: this.outputs.map((output) => JSON.parse(output.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
          if (this.stateMutability) {
            if (this.stateMutability !== "nonpayable") {
              result += this.stateMutability + " ";
            }
          } else if (this.constant) {
            result += "view ";
          }
          if (this.outputs && this.outputs.length) {
            result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
          }
          if (this.gas != null) {
            result += "@" + this.gas.toString() + " ";
          }
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
      }
      static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) {
          return value;
        }
        if (value.type !== "function") {
          logger.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
          type: value.type,
          name: verifyIdentifier(value.name),
          constant: state.constant,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value.gas ? BigNumber.from(value.gas) : null
        };
        return new FunctionFragment(_constructorGuard, params);
      }
      static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
          logger.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
          logger.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        if (comps.length > 1) {
          let returns = comps[1].match(regexParen);
          if (returns[1].trim() != "" || returns[3].trim() != "") {
            logger.throwArgumentError("unexpected tokens", "value", value);
          }
          params.outputs = parseParams(returns[2], false);
        } else {
          params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
      }
      static isFunctionFragment(value) {
        return value && value._isFragment && value.type === "function";
      }
    };
    regexIdentifier = new RegExp("^[A-Za-z_][A-Za-z0-9_]*$");
    regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key in object) {
      const childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object[key]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
var logger2, Coder, Writer, Reader;
var init_abstract_coder = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js"() {
    "use strict";
    init_define_process_env();
    init_lib2();
    init_lib3();
    init_lib4();
    init_lib();
    init_version();
    logger2 = new Logger(version);
    Coder = class {
      constructor(name, type, localName, dynamic) {
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
      }
      _throwError(message, value) {
        logger2.throwArgumentError(message, this.localName, value);
      }
    };
    Writer = class {
      constructor(wordSize) {
        defineReadOnly(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
      }
      get data() {
        return hexConcat(this._data);
      }
      get length() {
        return this._dataLength;
      }
      _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
      }
      appendWriter(writer) {
        return this._writeData(concat(writer._data));
      }
      writeBytes(value) {
        let bytes = arrayify(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
          bytes = concat([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
      }
      _getValue(value) {
        let bytes = arrayify(BigNumber.from(value));
        if (bytes.length > this.wordSize) {
          logger2.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: bytes.length
          });
        }
        if (bytes.length % this.wordSize) {
          bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
      }
      writeValue(value) {
        return this._writeData(this._getValue(value));
      }
      writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
          this._data[offset] = this._getValue(value);
        };
      }
    };
    Reader = class {
      constructor(data, wordSize, coerceFunc, allowLoose) {
        defineReadOnly(this, "_data", arrayify(data));
        defineReadOnly(this, "wordSize", wordSize || 32);
        defineReadOnly(this, "_coerceFunc", coerceFunc);
        defineReadOnly(this, "allowLoose", allowLoose);
        this._offset = 0;
      }
      get data() {
        return hexlify(this._data);
      }
      get consumed() {
        return this._offset;
      }
      static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
          value = value.toNumber();
        }
        return value;
      }
      coerce(name, value) {
        if (this._coerceFunc) {
          return this._coerceFunc(name, value);
        }
        return Reader.coerce(name, value);
      }
      _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
          if (this.allowLoose && loose && this._offset + length <= this._data.length) {
            alignedLength = length;
          } else {
            logger2.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
              length: this._data.length,
              offset: this._offset + alignedLength
            });
          }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
      }
      subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
      }
      readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        return bytes.slice(0, length);
      }
      readValue() {
        return BigNumber.from(this.readBytes(this.wordSize));
      }
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/address.js
var AddressCoder;
var init_address = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/address.js"() {
    "use strict";
    init_define_process_env();
    init_lib6();
    init_lib2();
    init_abstract_coder();
    AddressCoder = class extends Coder {
      constructor(localName) {
        super("address", "address", localName, false);
      }
      encode(writer, value) {
        try {
          getAddress(value);
        } catch (error) {
          this._throwError(error.message, value);
        }
        return writer.writeValue(value);
      }
      decode(reader) {
        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
      }
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
var AnonymousCoder;
var init_anonymous = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js"() {
    "use strict";
    init_define_process_env();
    init_abstract_coder();
    AnonymousCoder = class extends Coder {
      constructor(coder) {
        super(coder.name, coder.type, void 0, coder.dynamic);
        this.coder = coder;
      }
      encode(writer, value) {
        return this.coder.encode(writer, value);
      }
      decode(reader) {
        return this.coder.decode(reader);
      }
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/array.js
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      if (!name) {
        logger3.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name]) {
        logger3.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name] = true;
      return values[name];
    });
  } else {
    logger3.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger3.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name = coder.localName;
    if (name) {
      if (!accum[name]) {
        accum[name] = 0;
      }
      accum[name]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name = coder.localName;
    if (!name || uniqueNames[name] !== 1) {
      return;
    }
    if (name === "length") {
      name = "_length";
    }
    if (values[name] != null) {
      return;
    }
    const value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name, {
        get: () => {
          throw value;
        }
      });
    } else {
      values[name] = value;
    }
  });
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (value instanceof Error) {
      Object.defineProperty(values, i, {
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
var logger3, ArrayCoder;
var init_array = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/array.js"() {
    "use strict";
    init_define_process_env();
    init_lib();
    init_version();
    init_abstract_coder();
    init_anonymous();
    logger3 = new Logger(version);
    ArrayCoder = class extends Coder {
      constructor(coder, length, localName) {
        const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
        const dynamic = length === -1 || coder.dynamic;
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
      }
      encode(writer, value) {
        if (!Array.isArray(value)) {
          this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
          count = value.length;
          writer.writeValue(value.length);
        }
        logger3.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
          coders.push(this.coder);
        }
        return pack(writer, coders, value);
      }
      decode(reader) {
        let count = this.length;
        if (count === -1) {
          count = reader.readValue().toNumber();
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
          coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
      }
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
var BooleanCoder;
var init_boolean = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js"() {
    "use strict";
    init_define_process_env();
    init_abstract_coder();
    BooleanCoder = class extends Coder {
      constructor(localName) {
        super("bool", "bool", localName, false);
      }
      encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
      }
      decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
      }
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
var DynamicBytesCoder, BytesCoder;
var init_bytes = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js"() {
    "use strict";
    init_define_process_env();
    init_lib2();
    init_abstract_coder();
    DynamicBytesCoder = class extends Coder {
      constructor(type, localName) {
        super(type, type, localName, true);
      }
      encode(writer, value) {
        value = arrayify(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
      }
      decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
      }
    };
    BytesCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("bytes", localName);
      }
      decode(reader) {
        return reader.coerce(this.name, hexlify(super.decode(reader)));
      }
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
var FixedBytesCoder;
var init_fixed_bytes = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js"() {
    "use strict";
    init_define_process_env();
    init_lib2();
    init_abstract_coder();
    FixedBytesCoder = class extends Coder {
      constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
      }
      encode(writer, value) {
        let data = arrayify(value);
        if (data.length !== this.size) {
          this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
      }
      decode(reader) {
        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
      }
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/null.js
var NullCoder;
var init_null = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/null.js"() {
    "use strict";
    init_define_process_env();
    init_abstract_coder();
    NullCoder = class extends Coder {
      constructor(localName) {
        super("null", "", localName, false);
      }
      encode(writer, value) {
        if (value != null) {
          this._throwError("not null", value);
        }
        return writer.writeBytes([]);
      }
      decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
      }
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/number.js
var NumberCoder;
var init_number = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/number.js"() {
    "use strict";
    init_define_process_env();
    init_lib3();
    init_lib7();
    init_abstract_coder();
    NumberCoder = class extends Coder {
      constructor(size, signed, localName) {
        const name = (signed ? "int" : "uint") + size * 8;
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
      }
      encode(writer, value) {
        let v = BigNumber.from(value);
        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
          let bounds = maxUintValue.mask(this.size * 8 - 1);
          if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {
            this._throwError("value out-of-bounds", value);
          }
        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {
          this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
          v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
      }
      decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
          value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
      }
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/string.js
var StringCoder;
var init_string = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/string.js"() {
    "use strict";
    init_define_process_env();
    init_lib8();
    init_bytes();
    StringCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("string", localName);
      }
      encode(writer, value) {
        return super.encode(writer, toUtf8Bytes(value));
      }
      decode(reader) {
        return toUtf8String(super.decode(reader));
      }
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
var TupleCoder;
var init_tuple = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js"() {
    "use strict";
    init_define_process_env();
    init_abstract_coder();
    init_array();
    TupleCoder = class extends Coder {
      constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
          if (coder.dynamic) {
            dynamic = true;
          }
          types.push(coder.type);
        });
        const type = "tuple(" + types.join(",") + ")";
        super("tuple", type, localName, dynamic);
        this.coders = coders;
      }
      encode(writer, value) {
        return pack(writer, this.coders, value);
      }
      decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
      }
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/abi-coder.js
var logger4, paramTypeBytes, paramTypeNumber, AbiCoder, defaultAbiCoder;
var init_abi_coder = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/abi-coder.js"() {
    "use strict";
    init_define_process_env();
    init_lib2();
    init_lib4();
    init_lib();
    init_version();
    init_abstract_coder();
    init_address();
    init_array();
    init_boolean();
    init_bytes();
    init_fixed_bytes();
    init_null();
    init_number();
    init_string();
    init_tuple();
    init_fragments();
    logger4 = new Logger(version);
    paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
    paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
    AbiCoder = class {
      constructor(coerceFunc) {
        logger4.checkNew(new.target, AbiCoder);
        defineReadOnly(this, "coerceFunc", coerceFunc || null);
      }
      _getCoder(param) {
        switch (param.baseType) {
          case "address":
            return new AddressCoder(param.name);
          case "bool":
            return new BooleanCoder(param.name);
          case "string":
            return new StringCoder(param.name);
          case "bytes":
            return new BytesCoder(param.name);
          case "array":
            return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
          case "tuple":
            return new TupleCoder((param.components || []).map((component) => {
              return this._getCoder(component);
            }), param.name);
          case "":
            return new NullCoder(param.name);
        }
        let match = param.type.match(paramTypeNumber);
        if (match) {
          let size = parseInt(match[2] || "256");
          if (size === 0 || size > 256 || size % 8 !== 0) {
            logger4.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
          }
          return new NumberCoder(size / 8, match[1] === "int", param.name);
        }
        match = param.type.match(paramTypeBytes);
        if (match) {
          let size = parseInt(match[1]);
          if (size === 0 || size > 32) {
            logger4.throwArgumentError("invalid bytes length", "param", param);
          }
          return new FixedBytesCoder(size, param.name);
        }
        return logger4.throwArgumentError("invalid type", "type", param.type);
      }
      _getWordSize() {
        return 32;
      }
      _getReader(data, allowLoose) {
        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
      }
      _getWriter() {
        return new Writer(this._getWordSize());
      }
      encode(types, values) {
        if (types.length !== values.length) {
          logger4.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
            count: { types: types.length, values: values.length },
            value: { types, values }
          });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
      }
      decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader(arrayify(data), loose));
      }
    };
    defaultAbiCoder = new AbiCoder();
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/interface.js
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
var logger5, LogDescription, TransactionDescription, Indexed, Interface;
var init_interface = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/interface.js"() {
    "use strict";
    init_define_process_env();
    init_lib6();
    init_lib3();
    init_lib2();
    init_lib9();
    init_lib5();
    init_lib4();
    init_abi_coder();
    init_abstract_coder();
    init_fragments();
    init_lib();
    init_version();
    logger5 = new Logger(version);
    LogDescription = class extends Description {
    };
    TransactionDescription = class extends Description {
    };
    Indexed = class extends Description {
      static isIndexed(value) {
        return !!(value && value._isIndexed);
      }
    };
    Interface = class {
      constructor(fragments) {
        logger5.checkNew(new.target, Interface);
        let abi = [];
        if (typeof fragments === "string") {
          abi = JSON.parse(fragments);
        } else {
          abi = fragments;
        }
        defineReadOnly(this, "fragments", abi.map((fragment) => {
          return Fragment.from(fragment);
        }).filter((fragment) => fragment != null));
        defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "errors", {});
        defineReadOnly(this, "events", {});
        defineReadOnly(this, "structs", {});
        this.fragments.forEach((fragment) => {
          let bucket = null;
          switch (fragment.type) {
            case "constructor":
              if (this.deploy) {
                logger5.warn("duplicate definition - constructor");
                return;
              }
              defineReadOnly(this, "deploy", fragment);
              return;
            case "function":
              bucket = this.functions;
              break;
            case "event":
              bucket = this.events;
              break;
            default:
              return;
          }
          let signature = fragment.format();
          if (bucket[signature]) {
            logger5.warn("duplicate definition - " + signature);
            return;
          }
          bucket[signature] = fragment;
        });
        if (!this.deploy) {
          defineReadOnly(this, "deploy", ConstructorFragment.from({
            payable: false,
            type: "constructor"
          }));
        }
        defineReadOnly(this, "_isInterface", true);
      }
      format(format) {
        if (!format) {
          format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
          logger5.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        if (format === FormatTypes.json) {
          return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
      }
      static getAbiCoder() {
        return defaultAbiCoder;
      }
      static getAddress(address) {
        return getAddress(address);
      }
      static getSighash(functionFragment) {
        return hexDataSlice(id(functionFragment.format()), 0, 4);
      }
      static getEventTopic(eventFragment) {
        return id(eventFragment.format());
      }
      getFunction(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
          for (const name in this.functions) {
            if (nameOrSignatureOrSighash === this.getSighash(name)) {
              return this.functions[name];
            }
          }
          logger5.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          const name = nameOrSignatureOrSighash.trim();
          const matching = Object.keys(this.functions).filter((f) => f.split("(")[0] === name);
          if (matching.length === 0) {
            logger5.throwArgumentError("no matching function", "name", name);
          } else if (matching.length > 1) {
            logger5.throwArgumentError("multiple matching functions", "name", name);
          }
          return this.functions[matching[0]];
        }
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger5.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
      }
      getEvent(nameOrSignatureOrTopic) {
        if (isHexString(nameOrSignatureOrTopic)) {
          const topichash = nameOrSignatureOrTopic.toLowerCase();
          for (const name in this.events) {
            if (topichash === this.getEventTopic(name)) {
              return this.events[name];
            }
          }
          logger5.throwArgumentError("no matching event", "topichash", topichash);
        }
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
          const name = nameOrSignatureOrTopic.trim();
          const matching = Object.keys(this.events).filter((f) => f.split("(")[0] === name);
          if (matching.length === 0) {
            logger5.throwArgumentError("no matching event", "name", name);
          } else if (matching.length > 1) {
            logger5.throwArgumentError("multiple matching events", "name", name);
          }
          return this.events[matching[0]];
        }
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
          logger5.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
      }
      getSighash(functionFragment) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return getStatic(this.constructor, "getSighash")(functionFragment);
      }
      getEventTopic(eventFragment) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        return getStatic(this.constructor, "getEventTopic")(eventFragment);
      }
      _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
      }
      _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
      }
      encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
      }
      decodeFunctionData(functionFragment, data) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        const bytes = arrayify(data);
        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
          logger5.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
      }
      encodeFunctionData(functionFragment, values) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(concat([
          this.getSighash(functionFragment),
          this._encodeParams(functionFragment.inputs, values || [])
        ]));
      }
      decodeFunctionResult(functionFragment, data) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        let bytes = arrayify(data);
        let reason = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
          case 0:
            try {
              return this._abiCoder.decode(functionFragment.outputs, bytes);
            } catch (error) {
            }
            break;
          case 4:
            if (hexlify(bytes.slice(0, 4)) === "0x08c379a0") {
              errorSignature = "Error(string)";
              reason = this._abiCoder.decode(["string"], bytes.slice(4))[0];
            }
            break;
        }
        return logger5.throwError("call revert exception", Logger.errors.CALL_EXCEPTION, {
          method: functionFragment.format(),
          errorSignature,
          errorArgs: [reason],
          reason
        });
      }
      encodeFunctionResult(functionFragment, values) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
      }
      encodeFilterTopics(eventFragment, values) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
          logger5.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: values
          });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
          if (param.type === "string") {
            return id(value);
          } else if (param.type === "bytes") {
            return keccak256(hexlify(value));
          }
          if (param.type === "address") {
            this._abiCoder.encode(["address"], [value]);
          }
          return hexZeroPad(hexlify(value), 32);
        };
        values.forEach((value, index) => {
          let param = eventFragment.inputs[index];
          if (!param.indexed) {
            if (value != null) {
              logger5.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
            }
            return;
          }
          if (value == null) {
            topics.push(null);
          } else if (param.baseType === "array" || param.baseType === "tuple") {
            logger5.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
          } else if (Array.isArray(value)) {
            topics.push(value.map((value2) => encodeTopic(param, value2)));
          } else {
            topics.push(encodeTopic(param, value));
          }
        });
        while (topics.length && topics[topics.length - 1] === null) {
          topics.pop();
        }
        return topics;
      }
      encodeEventLog(eventFragment, values) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
          logger5.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
          const value = values[index];
          if (param.indexed) {
            if (param.type === "string") {
              topics.push(id(value));
            } else if (param.type === "bytes") {
              topics.push(keccak256(value));
            } else if (param.baseType === "tuple" || param.baseType === "array") {
              throw new Error("not implemented");
            } else {
              topics.push(this._abiCoder.encode([param.type], [value]));
            }
          } else {
            dataTypes.push(param);
            dataValues.push(value);
          }
        });
        return {
          data: this._abiCoder.encode(dataTypes, dataValues),
          topics
        };
      }
      decodeEventLog(eventFragment, data, topics) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
          let topicHash = this.getEventTopic(eventFragment);
          if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
            logger5.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
          }
          topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
          if (param.indexed) {
            if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
              indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
              dynamic.push(true);
            } else {
              indexed.push(param);
              dynamic.push(false);
            }
          } else {
            nonIndexed.push(param);
            dynamic.push(false);
          }
        });
        let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
          if (param.indexed) {
            if (resultIndexed == null) {
              result[index] = new Indexed({ _isIndexed: true, hash: null });
            } else if (dynamic[index]) {
              result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
            } else {
              try {
                result[index] = resultIndexed[indexedIndex++];
              } catch (error) {
                result[index] = error;
              }
            }
          } else {
            try {
              result[index] = resultNonIndexed[nonIndexedIndex++];
            } catch (error) {
              result[index] = error;
            }
          }
          if (param.name && result[param.name] == null) {
            const value = result[index];
            if (value instanceof Error) {
              Object.defineProperty(result, param.name, {
                get: () => {
                  throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
                }
              });
            } else {
              result[param.name] = value;
            }
          }
        });
        for (let i = 0; i < result.length; i++) {
          const value = result[i];
          if (value instanceof Error) {
            Object.defineProperty(result, i, {
              get: () => {
                throw wrapAccessError(`index ${i}`, value);
              }
            });
          }
        }
        return Object.freeze(result);
      }
      parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new TransactionDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
          functionFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment),
          value: BigNumber.from(tx.value || "0")
        });
      }
      parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
          return null;
        }
        return new LogDescription({
          eventFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          topic: this.getEventTopic(fragment),
          args: this.decodeEventLog(fragment, log.data, log.topics)
        });
      }
      static isInterface(value) {
        return !!(value && value._isInterface);
      }
    };
  }
});

// node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  ParamType: () => ParamType,
  TransactionDescription: () => TransactionDescription,
  checkResultErrors: () => checkResultErrors,
  defaultAbiCoder: () => defaultAbiCoder
});
var init_lib11 = __esm({
  "node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/index.js"() {
    "use strict";
    init_define_process_env();
    init_fragments();
    init_abi_coder();
    init_interface();
  }
});

// node_modules/web3-eth-abi/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/web3-eth-abi/lib/index.js"(exports, module) {
    init_define_process_env();
    var Buffer2 = require_buffer().Buffer;
    var utils = require_lib2();
    var EthersAbiCoder = (init_lib11(), __toCommonJS(lib_exports2)).AbiCoder;
    var ParamType2 = (init_lib11(), __toCommonJS(lib_exports2)).ParamType;
    var ethersAbiCoder = new EthersAbiCoder(function(type, value) {
      if (type.match(/^u?int/) && !Array.isArray(value) && (!(!!value && typeof value === "object") || value.constructor.name !== "BN")) {
        return value.toString();
      }
      return value;
    });
    function Result() {
    }
    var ABICoder = function() {
    };
    ABICoder.prototype.encodeFunctionSignature = function(functionName) {
      if (typeof functionName === "function" || typeof functionName === "object" && functionName) {
        functionName = utils._jsonInterfaceMethodToString(functionName);
      }
      return utils.sha3(functionName).slice(0, 10);
    };
    ABICoder.prototype.encodeEventSignature = function(functionName) {
      if (typeof functionName === "function" || typeof functionName === "object" && functionName) {
        functionName = utils._jsonInterfaceMethodToString(functionName);
      }
      return utils.sha3(functionName);
    };
    ABICoder.prototype.encodeParameter = function(type, param) {
      return this.encodeParameters([type], [param]);
    };
    ABICoder.prototype.encodeParameters = function(types, params) {
      var self2 = this;
      types = self2.mapTypes(types);
      params = params.map(function(param, index) {
        let type = types[index];
        if (typeof type === "object" && type.type) {
          type = type.type;
        }
        param = self2.formatParam(type, param);
        if (typeof type === "string" && type.includes("tuple")) {
          const coder2 = ethersAbiCoder._getCoder(ParamType2.from(type));
          const modifyParams = (coder3, param2) => {
            if (coder3.name === "array") {
              return param2.map((p) => modifyParams(ethersAbiCoder._getCoder(ParamType2.from(coder3.type.replace("[]", ""))), p));
            }
            coder3.coders.forEach((c, i) => {
              if (c.name === "tuple") {
                modifyParams(c, param2[i]);
              } else {
                param2[i] = self2.formatParam(c.name, param2[i]);
              }
            });
          };
          modifyParams(coder2, param);
        }
        return param;
      });
      return ethersAbiCoder.encode(types, params);
    };
    ABICoder.prototype.mapTypes = function(types) {
      var self2 = this;
      var mappedTypes = [];
      types.forEach(function(type) {
        if (typeof type === "object" && type.type === "function") {
          type = Object.assign({}, type, { type: "bytes24" });
        }
        if (self2.isSimplifiedStructFormat(type)) {
          var structName = Object.keys(type)[0];
          mappedTypes.push(Object.assign(self2.mapStructNameAndType(structName), {
            components: self2.mapStructToCoderFormat(type[structName])
          }));
          return;
        }
        mappedTypes.push(type);
      });
      return mappedTypes;
    };
    ABICoder.prototype.isSimplifiedStructFormat = function(type) {
      return typeof type === "object" && typeof type.components === "undefined" && typeof type.name === "undefined";
    };
    ABICoder.prototype.mapStructNameAndType = function(structName) {
      var type = "tuple";
      if (structName.indexOf("[]") > -1) {
        type = "tuple[]";
        structName = structName.slice(0, -2);
      }
      return { type, name: structName };
    };
    ABICoder.prototype.mapStructToCoderFormat = function(struct) {
      var self2 = this;
      var components = [];
      Object.keys(struct).forEach(function(key) {
        if (typeof struct[key] === "object") {
          components.push(Object.assign(self2.mapStructNameAndType(key), {
            components: self2.mapStructToCoderFormat(struct[key])
          }));
          return;
        }
        components.push({
          name: key,
          type: struct[key]
        });
      });
      return components;
    };
    ABICoder.prototype.formatParam = function(type, param) {
      const paramTypeBytes2 = new RegExp(/^bytes([0-9]*)$/);
      const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\[\]$/);
      const paramTypeNumber2 = new RegExp(/^(u?int)([0-9]*)$/);
      const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\[\]$/);
      if (utils.isBN(param) || utils.isBigNumber(param)) {
        return param.toString(10);
      }
      if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {
        return param.map((p) => this.formatParam(type.replace("[]", ""), p));
      }
      let match = type.match(paramTypeNumber2);
      if (match) {
        let size = parseInt(match[2] || "256");
        if (size / 8 < param.length) {
          param = utils.leftPad(param, size);
        }
      }
      match = type.match(paramTypeBytes2);
      if (match) {
        if (Buffer2.isBuffer(param)) {
          param = utils.toHex(param);
        }
        let size = parseInt(match[1]);
        if (size) {
          let maxSize = size * 2;
          if (param.substring(0, 2) === "0x") {
            maxSize += 2;
          }
          if (param.length < maxSize) {
            param = utils.rightPad(param, size * 2);
          }
        }
        if (param.length % 2 === 1) {
          param = "0x0" + param.substring(2);
        }
      }
      return param;
    };
    ABICoder.prototype.encodeFunctionCall = function(jsonInterface, params) {
      return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace("0x", "");
    };
    ABICoder.prototype.decodeParameter = function(type, bytes) {
      return this.decodeParameters([type], bytes)[0];
    };
    ABICoder.prototype.decodeParameters = function(outputs, bytes) {
      return this.decodeParametersWith(outputs, bytes, false);
    };
    ABICoder.prototype.decodeParametersWith = function(outputs, bytes, loose) {
      if (outputs.length > 0 && (!bytes || bytes === "0x" || bytes === "0X")) {
        throw new Error("Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.");
      }
      var res = ethersAbiCoder.decode(this.mapTypes(outputs), "0x" + bytes.replace(/0x/i, ""), loose);
      var returnValue = new Result();
      returnValue.__length__ = 0;
      outputs.forEach(function(output, i) {
        var decodedValue = res[returnValue.__length__];
        const isStringObject = typeof output === "object" && output.type && output.type === "string";
        const isStringType = typeof output === "string" && output === "string";
        decodedValue = decodedValue === "0x" && !isStringObject && !isStringType ? null : decodedValue;
        returnValue[i] = decodedValue;
        if ((typeof output === "function" || !!output && typeof output === "object") && output.name) {
          returnValue[output.name] = decodedValue;
        }
        returnValue.__length__++;
      });
      return returnValue;
    };
    ABICoder.prototype.decodeLog = function(inputs, data, topics) {
      var _this = this;
      topics = Array.isArray(topics) ? topics : [topics];
      data = data || "";
      var notIndexedInputs = [];
      var indexedParams = [];
      var topicCount = 0;
      inputs.forEach(function(input, i) {
        if (input.indexed) {
          indexedParams[i] = ["bool", "int", "uint", "address", "fixed", "ufixed"].find(function(staticType) {
            return input.type.indexOf(staticType) !== -1;
          }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];
          topicCount++;
        } else {
          notIndexedInputs[i] = input;
        }
      });
      var nonIndexedData = data;
      var notIndexedParams = nonIndexedData ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];
      var returnValue = new Result();
      returnValue.__length__ = 0;
      inputs.forEach(function(res, i) {
        returnValue[i] = res.type === "string" ? "" : null;
        if (typeof notIndexedParams[i] !== "undefined") {
          returnValue[i] = notIndexedParams[i];
        }
        if (typeof indexedParams[i] !== "undefined") {
          returnValue[i] = indexedParams[i];
        }
        if (res.name) {
          returnValue[res.name] = returnValue[i];
        }
        returnValue.__length__++;
      });
      return returnValue;
    };
    var coder = new ABICoder();
    module.exports = coder;
  }
});

// node_modules/web3-eth-contract/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/web3-eth-contract/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var core = require_lib12();
    var Method = require_lib11();
    var utils = require_lib2();
    var Subscription = require_lib10().subscription;
    var formatters = require_lib4().formatters;
    var errors = require_lib4().errors;
    var promiEvent = require_lib9();
    var abi = require_lib13();
    var Contract = function Contract2(jsonInterface, address, options) {
      var _this = this, args = Array.prototype.slice.call(arguments);
      if (!(this instanceof Contract2)) {
        throw new Error('Please use the "new" keyword to instantiate a web3.eth.Contract() object!');
      }
      this.setProvider = function() {
        core.packageInit(_this, arguments);
        _this.clearSubscriptions = _this._requestManager.clearSubscriptions;
      };
      core.packageInit(this, [this.constructor]);
      this.clearSubscriptions = this._requestManager.clearSubscriptions;
      if (!jsonInterface || !Array.isArray(jsonInterface)) {
        throw errors.ContractMissingABIError();
      }
      this.options = {};
      var lastArg = args[args.length - 1];
      if (!!lastArg && typeof lastArg === "object" && !Array.isArray(lastArg)) {
        options = lastArg;
        this.options = __spreadValues(__spreadValues({}, this.options), this._getOrSetDefaultOptions(options));
        if (!!address && typeof address === "object") {
          address = null;
        }
      }
      Object.defineProperty(this.options, "address", {
        set: function(value) {
          if (value) {
            _this._address = utils.toChecksumAddress(formatters.inputAddressFormatter(value));
          }
        },
        get: function() {
          return _this._address;
        },
        enumerable: true
      });
      Object.defineProperty(this.options, "jsonInterface", {
        set: function(value) {
          _this.methods = {};
          _this.events = {};
          _this._jsonInterface = value.map(function(method) {
            var func, funcName;
            method.constant = method.stateMutability === "view" || method.stateMutability === "pure" || method.constant;
            method.payable = method.stateMutability === "payable" || method.payable;
            if (method.name) {
              funcName = utils._jsonInterfaceMethodToString(method);
            }
            if (method.type === "function") {
              method.signature = abi.encodeFunctionSignature(funcName);
              func = _this._createTxObject.bind({
                method,
                parent: _this
              });
              if (!_this.methods[method.name]) {
                _this.methods[method.name] = func;
              } else {
                var cascadeFunc = _this._createTxObject.bind({
                  method,
                  parent: _this,
                  nextMethod: _this.methods[method.name]
                });
                _this.methods[method.name] = cascadeFunc;
              }
              _this.methods[method.signature] = func;
              _this.methods[funcName] = func;
            } else if (method.type === "event") {
              method.signature = abi.encodeEventSignature(funcName);
              var event = _this._on.bind(_this, method.signature);
              if (!_this.events[method.name] || _this.events[method.name].name === "bound ")
                _this.events[method.name] = event;
              _this.events[method.signature] = event;
              _this.events[funcName] = event;
            }
            return method;
          });
          _this.events.allEvents = _this._on.bind(_this, "allevents");
          return _this._jsonInterface;
        },
        get: function() {
          return _this._jsonInterface;
        },
        enumerable: true
      });
      var defaultAccount = this.constructor.defaultAccount;
      var defaultBlock = this.constructor.defaultBlock || "latest";
      Object.defineProperty(this, "handleRevert", {
        get: function() {
          if (_this.options.handleRevert === false || _this.options.handleRevert === true) {
            return _this.options.handleRevert;
          }
          return this.constructor.handleRevert;
        },
        set: function(val) {
          _this.options.handleRevert = val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "defaultCommon", {
        get: function() {
          return _this.options.common || this.constructor.defaultCommon;
        },
        set: function(val) {
          _this.options.common = val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "defaultHardfork", {
        get: function() {
          return _this.options.hardfork || this.constructor.defaultHardfork;
        },
        set: function(val) {
          _this.options.hardfork = val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "defaultChain", {
        get: function() {
          return _this.options.chain || this.constructor.defaultChain;
        },
        set: function(val) {
          _this.options.chain = val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "transactionPollingTimeout", {
        get: function() {
          if (_this.options.transactionPollingTimeout === 0) {
            return _this.options.transactionPollingTimeout;
          }
          return _this.options.transactionPollingTimeout || this.constructor.transactionPollingTimeout;
        },
        set: function(val) {
          _this.options.transactionPollingTimeout = val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "transactionPollingInterval", {
        get: function() {
          if (_this.options.transactionPollingInterval === 0) {
            return _this.options.transactionPollingInterval;
          }
          return _this.options.transactionPollingInterval || this.constructor.transactionPollingInterval;
        },
        set: function(val) {
          _this.options.transactionPollingInterval = val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "transactionConfirmationBlocks", {
        get: function() {
          if (_this.options.transactionConfirmationBlocks === 0) {
            return _this.options.transactionConfirmationBlocks;
          }
          return _this.options.transactionConfirmationBlocks || this.constructor.transactionConfirmationBlocks;
        },
        set: function(val) {
          _this.options.transactionConfirmationBlocks = val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "transactionBlockTimeout", {
        get: function() {
          if (_this.options.transactionBlockTimeout === 0) {
            return _this.options.transactionBlockTimeout;
          }
          return _this.options.transactionBlockTimeout || this.constructor.transactionBlockTimeout;
        },
        set: function(val) {
          _this.options.transactionBlockTimeout = val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "blockHeaderTimeout", {
        get: function() {
          if (_this.options.blockHeaderTimeout === 0) {
            return _this.options.blockHeaderTimeout;
          }
          return _this.options.blockHeaderTimeout || this.constructor.blockHeaderTimeout;
        },
        set: function(val) {
          _this.options.blockHeaderTimeout = val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "defaultAccount", {
        get: function() {
          return defaultAccount;
        },
        set: function(val) {
          if (val) {
            defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val));
          }
          return val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "defaultBlock", {
        get: function() {
          return defaultBlock;
        },
        set: function(val) {
          defaultBlock = val;
          return val;
        },
        enumerable: true
      });
      this.methods = {};
      this.events = {};
      this._address = null;
      this._jsonInterface = [];
      this.options.address = address;
      this.options.jsonInterface = jsonInterface;
    };
    Contract.setProvider = function(provider, accounts) {
      core.packageInit(this, [provider]);
      this._ethAccounts = accounts;
    };
    Contract.prototype._getCallback = function getCallback(args) {
      if (args && !!args[args.length - 1] && typeof args[args.length - 1] === "function") {
        return args.pop();
      }
    };
    Contract.prototype._checkListener = function(type, event) {
      if (event === type) {
        throw errors.ContractReservedEventError(type);
      }
    };
    Contract.prototype._getOrSetDefaultOptions = function getOrSetDefaultOptions(options) {
      var gasPrice = options.gasPrice ? String(options.gasPrice) : null;
      var from = options.from ? utils.toChecksumAddress(formatters.inputAddressFormatter(options.from)) : null;
      options.data = options.data || this.options.data;
      options.from = from || this.options.from;
      options.gasPrice = gasPrice || this.options.gasPrice;
      options.gas = options.gas || options.gasLimit || this.options.gas;
      delete options.gasLimit;
      return options;
    };
    Contract.prototype._encodeEventABI = function(event, options) {
      options = options || {};
      var filter = options.filter || {}, result = {};
      ["fromBlock", "toBlock"].filter(function(f) {
        return options[f] !== void 0;
      }).forEach(function(f) {
        result[f] = formatters.inputBlockNumberFormatter(options[f]);
      });
      if (Array.isArray(options.topics)) {
        result.topics = options.topics;
      } else {
        result.topics = [];
        if (event && !event.anonymous && event.name !== "ALLEVENTS") {
          result.topics.push(event.signature);
        }
        if (event.name !== "ALLEVENTS") {
          var indexedTopics = event.inputs.filter(function(i) {
            return i.indexed === true;
          }).map(function(i) {
            var value = filter[i.name];
            if (!value) {
              return null;
            }
            if (Array.isArray(value)) {
              return value.map(function(v) {
                return abi.encodeParameter(i.type, v);
              });
            }
            return abi.encodeParameter(i.type, value);
          });
          result.topics = result.topics.concat(indexedTopics);
        }
        if (!result.topics.length)
          delete result.topics;
      }
      if (this.options.address) {
        result.address = this.options.address.toLowerCase();
      }
      return result;
    };
    Contract.prototype._decodeEventABI = function(data) {
      var event = this;
      data.data = data.data || "";
      data.topics = data.topics || [];
      var result = formatters.outputLogFormatter(data);
      if (event.name === "ALLEVENTS") {
        event = event.jsonInterface.find(function(intf) {
          return intf.signature === data.topics[0];
        }) || { anonymous: true };
      }
      event.inputs = event.inputs || [];
      if (!event.anonymous) {
        let indexedInputs = 0;
        event.inputs.forEach((input) => input.indexed ? indexedInputs++ : null);
        if (indexedInputs > 0 && data.topics.length !== indexedInputs + 1) {
          event = {
            anonymous: true,
            inputs: []
          };
        }
      }
      var argTopics = event.anonymous ? data.topics : data.topics.slice(1);
      result.returnValues = abi.decodeLog(event.inputs, data.data, argTopics);
      delete result.returnValues.__length__;
      result.event = event.name;
      result.signature = event.anonymous || !data.topics[0] ? null : data.topics[0];
      result.raw = {
        data: result.data,
        topics: result.topics
      };
      delete result.data;
      delete result.topics;
      return result;
    };
    Contract.prototype._encodeMethodABI = function _encodeMethodABI() {
      var methodSignature = this._method.signature, args = this.arguments || [];
      var signature = false, paramsABI = this._parent.options.jsonInterface.filter(function(json) {
        return methodSignature === "constructor" && json.type === methodSignature || (json.signature === methodSignature || json.signature === methodSignature.replace("0x", "") || json.name === methodSignature) && json.type === "function";
      }).map(function(json) {
        var inputLength = Array.isArray(json.inputs) ? json.inputs.length : 0;
        if (inputLength !== args.length) {
          throw new Error("The number of arguments is not matching the methods required number. You need to pass " + inputLength + " arguments.");
        }
        if (json.type === "function") {
          signature = json.signature;
        }
        return Array.isArray(json.inputs) ? json.inputs : [];
      }).map(function(inputs) {
        return abi.encodeParameters(inputs, args).replace("0x", "");
      })[0] || "";
      if (methodSignature === "constructor") {
        if (!this._deployData)
          throw new Error("The contract has no contract data option set. This is necessary to append the constructor parameters.");
        if (!this._deployData.startsWith("0x")) {
          this._deployData = "0x" + this._deployData;
        }
        return this._deployData + paramsABI;
      }
      var returnValue = signature ? signature + paramsABI : paramsABI;
      if (!returnValue) {
        throw new Error(`Couldn't find a matching contract method named "` + this._method.name + '".');
      }
      return returnValue;
    };
    Contract.prototype._decodeMethodReturn = function(outputs, returnValues) {
      if (!returnValues) {
        return null;
      }
      returnValues = returnValues.length >= 2 ? returnValues.slice(2) : returnValues;
      var result = abi.decodeParameters(outputs, returnValues);
      if (result.__length__ === 1) {
        return result[0];
      }
      delete result.__length__;
      return result;
    };
    Contract.prototype.deploy = function(options, callback) {
      options = options || {};
      options.arguments = options.arguments || [];
      options = this._getOrSetDefaultOptions(options);
      if (!options.data) {
        if (typeof callback === "function") {
          return callback(errors.ContractMissingDeployDataError());
        }
        throw errors.ContractMissingDeployDataError();
      }
      var constructor = this.options.jsonInterface.find((method) => {
        return method.type === "constructor";
      }) || {};
      constructor.signature = "constructor";
      return this._createTxObject.apply({
        method: constructor,
        parent: this,
        deployData: options.data,
        _ethAccounts: this.constructor._ethAccounts
      }, options.arguments);
    };
    Contract.prototype._generateEventOptions = function() {
      var args = Array.prototype.slice.call(arguments);
      var callback = this._getCallback(args);
      var options = (!!args[args.length - 1] && typeof args[args.length - 1]) === "object" ? args.pop() : {};
      var eventName = typeof args[0] === "string" ? args[0] : "allevents";
      var event = eventName.toLowerCase() === "allevents" ? {
        name: "ALLEVENTS",
        jsonInterface: this.options.jsonInterface
      } : this.options.jsonInterface.find(function(json) {
        return json.type === "event" && (json.name === eventName || json.signature === "0x" + eventName.replace("0x", ""));
      });
      if (!event) {
        throw errors.ContractEventDoesNotExistError(eventName);
      }
      if (!utils.isAddress(this.options.address)) {
        throw errors.ContractNoAddressDefinedError();
      }
      return {
        params: this._encodeEventABI(event, options),
        event,
        callback
      };
    };
    Contract.prototype.clone = function() {
      return new this.constructor(this.options.jsonInterface, this.options.address, this.options);
    };
    Contract.prototype.once = function(event, options, callback) {
      var args = Array.prototype.slice.call(arguments);
      callback = this._getCallback(args);
      if (!callback) {
        throw errors.ContractOnceRequiresCallbackError();
      }
      if (options)
        delete options.fromBlock;
      this._on(event, options, function(err, res, sub) {
        sub.unsubscribe();
        if (typeof callback === "function") {
          callback(err, res, sub);
        }
      });
      return void 0;
    };
    Contract.prototype._on = function() {
      var subOptions = this._generateEventOptions.apply(this, arguments);
      if (subOptions.params && subOptions.params.toBlock) {
        delete subOptions.params.toBlock;
        console.warn("Invalid option: toBlock. Use getPastEvents for specific range.");
      }
      this._checkListener("newListener", subOptions.event.name);
      this._checkListener("removeListener", subOptions.event.name);
      var subscription = new Subscription({
        subscription: {
          params: 1,
          inputFormatter: [formatters.inputLogFormatter],
          outputFormatter: this._decodeEventABI.bind(subOptions.event),
          subscriptionHandler: function(output) {
            if (output.removed) {
              this.emit("changed", output);
            } else {
              this.emit("data", output);
            }
            if (typeof this.callback === "function") {
              this.callback(null, output, this);
            }
          }
        },
        type: "eth",
        requestManager: this._requestManager
      });
      subscription.subscribe("logs", subOptions.params, subOptions.callback || function() {
      });
      return subscription;
    };
    Contract.prototype.getPastEvents = function() {
      var subOptions = this._generateEventOptions.apply(this, arguments);
      var getPastLogs = new Method({
        name: "getPastLogs",
        call: "eth_getLogs",
        params: 1,
        inputFormatter: [formatters.inputLogFormatter],
        outputFormatter: this._decodeEventABI.bind(subOptions.event)
      });
      getPastLogs.setRequestManager(this._requestManager);
      var call = getPastLogs.buildCall();
      getPastLogs = null;
      return call(subOptions.params, subOptions.callback);
    };
    Contract.prototype._createTxObject = function _createTxObject() {
      var args = Array.prototype.slice.call(arguments);
      var txObject = {};
      if (this.method.type === "function") {
        txObject.call = this.parent._executeMethod.bind(txObject, "call");
        txObject.call.request = this.parent._executeMethod.bind(txObject, "call", true);
      }
      txObject.send = this.parent._executeMethod.bind(txObject, "send");
      txObject.send.request = this.parent._executeMethod.bind(txObject, "send", true);
      txObject.encodeABI = this.parent._encodeMethodABI.bind(txObject);
      txObject.estimateGas = this.parent._executeMethod.bind(txObject, "estimate");
      txObject.createAccessList = this.parent._executeMethod.bind(txObject, "createAccessList");
      if (args && this.method.inputs && args.length !== this.method.inputs.length) {
        if (this.nextMethod) {
          return this.nextMethod.apply(null, args);
        }
        throw errors.InvalidNumberOfParams(args.length, this.method.inputs.length, this.method.name);
      }
      txObject.arguments = args || [];
      txObject._method = this.method;
      txObject._parent = this.parent;
      txObject._ethAccounts = this.parent.constructor._ethAccounts || this._ethAccounts;
      if (this.deployData) {
        txObject._deployData = this.deployData;
      }
      return txObject;
    };
    Contract.prototype._processExecuteArguments = function _processExecuteArguments(args, defer) {
      var processedArgs = {};
      processedArgs.type = args.shift();
      processedArgs.callback = this._parent._getCallback(args);
      if (processedArgs.type === "call" && args[args.length - 1] !== true && (typeof args[args.length - 1] === "string" || isFinite(args[args.length - 1])))
        processedArgs.defaultBlock = args.pop();
      processedArgs.options = (!!args[args.length - 1] && typeof args[args.length - 1]) === "object" ? args.pop() : {};
      processedArgs.generateRequest = args[args.length - 1] === true ? args.pop() : false;
      processedArgs.options = this._parent._getOrSetDefaultOptions(processedArgs.options);
      processedArgs.options.data = this.encodeABI();
      if (!this._deployData && !utils.isAddress(this._parent.options.address))
        throw errors.ContractNoAddressDefinedError();
      if (!this._deployData)
        processedArgs.options.to = this._parent.options.address;
      if (!processedArgs.options.data)
        return utils._fireError(new Error("Couldn't find a matching contract method, or the number of parameters is wrong."), defer.eventEmitter, defer.reject, processedArgs.callback);
      return processedArgs;
    };
    Contract.prototype._executeMethod = function _executeMethod() {
      var _this = this, args = this._parent._processExecuteArguments.call(this, Array.prototype.slice.call(arguments), defer), defer = promiEvent(args.type !== "send"), ethAccounts = _this.constructor._ethAccounts || _this._ethAccounts;
      if (args.generateRequest) {
        var payload = {
          params: [formatters.inputCallFormatter.call(this._parent, args.options)],
          callback: args.callback
        };
        if (args.type === "call") {
          payload.params.push(formatters.inputDefaultBlockNumberFormatter.call(this._parent, args.defaultBlock));
          payload.method = "eth_call";
          payload.format = this._parent._decodeMethodReturn.bind(null, this._method.outputs);
        } else {
          payload.method = "eth_sendTransaction";
        }
        return payload;
      }
      switch (args.type) {
        case "createAccessList":
          if (!utils.isAddress(args.options.from)) {
            return utils._fireError(errors.ContractNoFromAddressDefinedError(), defer.eventEmitter, defer.reject, args.callback);
          }
          var createAccessList = new Method({
            name: "createAccessList",
            call: "eth_createAccessList",
            params: 2,
            inputFormatter: [formatters.inputTransactionFormatter, formatters.inputDefaultBlockNumberFormatter],
            requestManager: _this._parent._requestManager,
            accounts: ethAccounts,
            defaultAccount: _this._parent.defaultAccount,
            defaultBlock: _this._parent.defaultBlock
          }).createFunction();
          return createAccessList(args.options, args.callback);
        case "estimate":
          var estimateGas = new Method({
            name: "estimateGas",
            call: "eth_estimateGas",
            params: 1,
            inputFormatter: [formatters.inputCallFormatter],
            outputFormatter: utils.hexToNumber,
            requestManager: _this._parent._requestManager,
            accounts: ethAccounts,
            defaultAccount: _this._parent.defaultAccount,
            defaultBlock: _this._parent.defaultBlock
          }).createFunction();
          return estimateGas(args.options, args.callback);
        case "call":
          var call = new Method({
            name: "call",
            call: "eth_call",
            params: 2,
            inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter],
            outputFormatter: function(result) {
              return _this._parent._decodeMethodReturn(_this._method.outputs, result);
            },
            requestManager: _this._parent._requestManager,
            accounts: ethAccounts,
            defaultAccount: _this._parent.defaultAccount,
            defaultBlock: _this._parent.defaultBlock,
            handleRevert: _this._parent.handleRevert,
            abiCoder: abi
          }).createFunction();
          return call(args.options, args.defaultBlock, args.callback);
        case "send":
          if (!utils.isAddress(args.options.from)) {
            return utils._fireError(errors.ContractNoFromAddressDefinedError(), defer.eventEmitter, defer.reject, args.callback);
          }
          if (typeof this._method.payable === "boolean" && !this._method.payable && args.options.value && args.options.value > 0) {
            return utils._fireError(new Error("Can not send value to non-payable contract method or constructor"), defer.eventEmitter, defer.reject, args.callback);
          }
          var extraFormatters = {
            receiptFormatter: function(receipt) {
              if (Array.isArray(receipt.logs)) {
                var events = receipt.logs.map((log) => {
                  return _this._parent._decodeEventABI.call({
                    name: "ALLEVENTS",
                    jsonInterface: _this._parent.options.jsonInterface
                  }, log);
                });
                receipt.events = {};
                var count = 0;
                events.forEach(function(ev) {
                  if (ev.event) {
                    if (receipt.events[ev.event]) {
                      if (Array.isArray(receipt.events[ev.event])) {
                        receipt.events[ev.event].push(ev);
                      } else {
                        receipt.events[ev.event] = [receipt.events[ev.event], ev];
                      }
                    } else {
                      receipt.events[ev.event] = ev;
                    }
                  } else {
                    receipt.events[count] = ev;
                    count++;
                  }
                });
                delete receipt.logs;
              }
              return receipt;
            },
            contractDeployFormatter: function(receipt) {
              var newContract = _this._parent.clone();
              newContract.options.address = receipt.contractAddress;
              return newContract;
            }
          };
          var sendTransaction = new Method({
            name: "sendTransaction",
            call: "eth_sendTransaction",
            params: 1,
            inputFormatter: [formatters.inputTransactionFormatter],
            requestManager: _this._parent._requestManager,
            accounts: _this.constructor._ethAccounts || _this._ethAccounts,
            defaultAccount: _this._parent.defaultAccount,
            defaultBlock: _this._parent.defaultBlock,
            transactionBlockTimeout: _this._parent.transactionBlockTimeout,
            transactionConfirmationBlocks: _this._parent.transactionConfirmationBlocks,
            transactionPollingTimeout: _this._parent.transactionPollingTimeout,
            transactionPollingInterval: _this._parent.transactionPollingInterval,
            defaultCommon: _this._parent.defaultCommon,
            defaultChain: _this._parent.defaultChain,
            defaultHardfork: _this._parent.defaultHardfork,
            handleRevert: _this._parent.handleRevert,
            extraFormatters,
            abiCoder: abi
          }).createFunction();
          return sendTransaction(args.options, args.callback);
        default:
          throw new Error('Method "' + args.type + '" not implemented.');
      }
    };
    module.exports = Contract;
  }
});

export {
  require_lib2 as require_lib,
  require_lib3 as require_lib2,
  require_lib4 as require_lib3,
  require_eventemitter3,
  require_browser2 as require_browser,
  http_exports,
  init_http,
  https_exports,
  init_https,
  require_dist3 as require_dist,
  require_oboe_browser,
  require_lib9 as require_lib4,
  require_lib10 as require_lib5,
  require_lib11 as require_lib6,
  require_lib13 as require_lib7,
  require_lib14 as require_lib8
};
/*!
 * v2.1.4-104-gc868b3a
 * 
 */
/*! https://mths.be/utf8js v3.0.0 by @mathias */
//# sourceMappingURL=chunk-FMALSK2Q.js.map
