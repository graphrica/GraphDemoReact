import {
  require_eth_json_rpc_filters,
  require_polling,
  require_subscriptionManager
} from "./chunk-XNEOYV3Z.js";
import {
  require_json_stable_stringify
} from "./chunk-37W4O3UC.js";
import "./chunk-HSX2HD22.js";
import {
  require_bip66
} from "./chunk-Y3PG3TJL.js";
import {
  require_immutable
} from "./chunk-7RFKSBT2.js";
import {
  require_ethereumjs_abi,
  require_lib
} from "./chunk-ESWKWXUO.js";
import "./chunk-HRG2DHFT.js";
import {
  require_dist,
  require_keccak,
  require_secp256k1
} from "./chunk-6XVHBKXF.js";
import "./chunk-QJBX42KY.js";
import {
  init_stream,
  require_assert,
  require_browser,
  require_elliptic,
  stream_exports
} from "./chunk-UTWHOSAQ.js";
import {
  require_safe_buffer,
  require_util
} from "./chunk-BTG65MVN.js";
import {
  require_events
} from "./chunk-K2K3O27I.js";
import "./chunk-557FO4FU.js";
import "./chunk-S5NSXQRL.js";
import "./chunk-QMSD3UEV.js";
import {
  require_inherits_browser
} from "./chunk-27CSTQIU.js";
import {
  require_bn
} from "./chunk-VIQ6GMKA.js";
import "./chunk-PX4IM7JA.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM,
  define_process_env_default,
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// node_modules/penpal/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/penpal/lib/index.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.ERR_NOT_IN_IFRAME = exports.ERR_CONNECTION_TIMEOUT = exports.ERR_CONNECTION_DESTROYED = void 0;
    var HANDSHAKE = "handshake";
    var HANDSHAKE_REPLY = "handshake-reply";
    var CALL = "call";
    var REPLY = "reply";
    var FULFILLED = "fulfilled";
    var REJECTED = "rejected";
    var MESSAGE = "message";
    var DATA_CLONE_ERROR = "DataCloneError";
    var ERR_CONNECTION_DESTROYED = "ConnectionDestroyed";
    exports.ERR_CONNECTION_DESTROYED = ERR_CONNECTION_DESTROYED;
    var ERR_CONNECTION_TIMEOUT = "ConnectionTimeout";
    exports.ERR_CONNECTION_TIMEOUT = ERR_CONNECTION_TIMEOUT;
    var ERR_NOT_IN_IFRAME = "NotInIframe";
    exports.ERR_NOT_IN_IFRAME = ERR_NOT_IN_IFRAME;
    var DEFAULT_PORTS = {
      "http:": "80",
      "https:": "443"
    };
    var URL_REGEX = /^(https?:)?\/\/([^/:]+)(:(\d+))?/;
    var Penpal2 = {
      ERR_CONNECTION_DESTROYED,
      ERR_CONNECTION_TIMEOUT,
      ERR_NOT_IN_IFRAME,
      Promise: function() {
        try {
          return window ? window.Promise : null;
        } catch (e) {
          return null;
        }
      }(),
      debug: false
    };
    var generateId = function() {
      var id = 0;
      return function() {
        return ++id;
      };
    }();
    var log = function log2() {
      if (Penpal2.debug) {
        var _console;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        (_console = console).log.apply(_console, ["[Penpal]"].concat(args));
      }
    };
    var getOriginFromUrl = function getOriginFromUrl2(url) {
      var location2 = document.location;
      var regexResult = URL_REGEX.exec(url);
      var protocol;
      var hostname;
      var port;
      if (regexResult) {
        protocol = regexResult[1] ? regexResult[1] : location2.protocol;
        hostname = regexResult[2];
        port = regexResult[4];
      } else {
        protocol = location2.protocol;
        hostname = location2.hostname;
        port = location2.port;
      }
      var portSuffix = port && port !== DEFAULT_PORTS[protocol] ? ":".concat(port) : "";
      return "".concat(protocol, "//").concat(hostname).concat(portSuffix);
    };
    var DestructionPromise = function DestructionPromise2(executor) {
      var handlers = [];
      executor(function() {
        handlers.forEach(function(handler) {
          handler();
        });
      });
      return {
        then: function then(handler) {
          handlers.push(handler);
        }
      };
    };
    var serializeError = function serializeError2(_ref) {
      var name = _ref.name, message = _ref.message, stack = _ref.stack;
      return {
        name,
        message,
        stack
      };
    };
    var deserializeError = function deserializeError2(obj) {
      var deserializedError = new Error();
      Object.keys(obj).forEach(function(key) {
        return deserializedError[key] = obj[key];
      });
      return deserializedError;
    };
    var connectCallSender = function connectCallSender2(callSender, info, methodNames, destructionPromise) {
      var localName = info.localName, local = info.local, remote = info.remote, remoteOrigin = info.remoteOrigin;
      var destroyed = false;
      log("".concat(localName, ": Connecting call sender"));
      var createMethodProxy = function createMethodProxy2(methodName) {
        return function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          log("".concat(localName, ": Sending ").concat(methodName, "() call"));
          if (destroyed) {
            var error = new Error("Unable to send ".concat(methodName, "() call due ") + "to destroyed connection");
            error.code = ERR_CONNECTION_DESTROYED;
            throw error;
          }
          return new Penpal2.Promise(function(resolve, reject) {
            var id = generateId();
            var handleMessageEvent = function handleMessageEvent2(event) {
              if (event.source === remote && event.origin === remoteOrigin && event.data.penpal === REPLY && event.data.id === id) {
                log("".concat(localName, ": Received ").concat(methodName, "() reply"));
                local.removeEventListener(MESSAGE, handleMessageEvent2);
                var returnValue = event.data.returnValue;
                if (event.data.returnValueIsError) {
                  returnValue = deserializeError(returnValue);
                }
                (event.data.resolution === FULFILLED ? resolve : reject)(returnValue);
              }
            };
            local.addEventListener(MESSAGE, handleMessageEvent);
            remote.postMessage({
              penpal: CALL,
              id,
              methodName,
              args
            }, remoteOrigin);
          });
        };
      };
      destructionPromise.then(function() {
        destroyed = true;
      });
      methodNames.reduce(function(api, methodName) {
        api[methodName] = createMethodProxy(methodName);
        return api;
      }, callSender);
    };
    var connectCallReceiver = function connectCallReceiver2(info, methods, destructionPromise) {
      var localName = info.localName, local = info.local, remote = info.remote, remoteOrigin = info.remoteOrigin;
      var destroyed = false;
      log("".concat(localName, ": Connecting call receiver"));
      var handleMessageEvent = function handleMessageEvent2(event) {
        if (event.source === remote && event.origin === remoteOrigin && event.data.penpal === CALL) {
          var _event$data = event.data, methodName = _event$data.methodName, args = _event$data.args, id = _event$data.id;
          log("".concat(localName, ": Received ").concat(methodName, "() call"));
          if (methodName in methods) {
            var createPromiseHandler = function createPromiseHandler2(resolution) {
              return function(returnValue) {
                log("".concat(localName, ": Sending ").concat(methodName, "() reply"));
                if (destroyed) {
                  log("".concat(localName, ": Unable to send ").concat(methodName, "() reply due to destroyed connection"));
                  return;
                }
                var message = {
                  penpal: REPLY,
                  id,
                  resolution,
                  returnValue
                };
                if (resolution === REJECTED && returnValue instanceof Error) {
                  message.returnValue = serializeError(returnValue);
                  message.returnValueIsError = true;
                }
                try {
                  remote.postMessage(message, remoteOrigin);
                } catch (err) {
                  if (err.name === DATA_CLONE_ERROR) {
                    remote.postMessage({
                      penpal: REPLY,
                      id,
                      resolution: REJECTED,
                      returnValue: serializeError(err),
                      returnValueIsError: true
                    }, remoteOrigin);
                  }
                  throw err;
                }
              };
            };
            new Penpal2.Promise(function(resolve) {
              return resolve(methods[methodName].apply(methods, args));
            }).then(createPromiseHandler(FULFILLED), createPromiseHandler(REJECTED));
          }
        }
      };
      local.addEventListener(MESSAGE, handleMessageEvent);
      destructionPromise.then(function() {
        destroyed = true;
        local.removeEventListener(MESSAGE, handleMessageEvent);
      });
    };
    Penpal2.connectToChild = function(_ref2) {
      var url = _ref2.url, appendTo = _ref2.appendTo, _ref2$methods = _ref2.methods, methods = _ref2$methods === void 0 ? {} : _ref2$methods, timeout = _ref2.timeout;
      var destroy;
      var connectionDestructionPromise = new DestructionPromise(function(resolveConnectionDestructionPromise) {
        destroy = resolveConnectionDestructionPromise;
      });
      var parent = window;
      var iframe = document.createElement("iframe");
      (appendTo || document.body).appendChild(iframe);
      connectionDestructionPromise.then(function() {
        if (iframe.parentNode) {
          iframe.parentNode.removeChild(iframe);
        }
      });
      var child = iframe.contentWindow || iframe.contentDocument.parentWindow;
      var childOrigin = getOriginFromUrl(url);
      var promise = new Penpal2.Promise(function(resolveConnectionPromise, reject) {
        var connectionTimeoutId;
        if (timeout !== void 0) {
          connectionTimeoutId = setTimeout(function() {
            var error = new Error("Connection to child timed out after ".concat(timeout, "ms"));
            error.code = ERR_CONNECTION_TIMEOUT;
            reject(error);
            destroy();
          }, timeout);
        }
        var callSender = {};
        var receiverMethodNames;
        var destroyCallReceiver;
        var handleMessage = function handleMessage2(event) {
          if (event.source === child && event.origin === childOrigin && event.data.penpal === HANDSHAKE) {
            log("Parent: Received handshake, sending reply");
            event.source.postMessage({
              penpal: HANDSHAKE_REPLY,
              methodNames: Object.keys(methods)
            }, event.origin);
            var info = {
              localName: "Parent",
              local: parent,
              remote: child,
              remoteOrigin: event.origin
            };
            if (destroyCallReceiver) {
              destroyCallReceiver();
            }
            var callReceiverDestructionPromise = new DestructionPromise(function(resolveCallReceiverDestructionPromise) {
              connectionDestructionPromise.then(resolveCallReceiverDestructionPromise);
              destroyCallReceiver = resolveCallReceiverDestructionPromise;
            });
            connectCallReceiver(info, methods, callReceiverDestructionPromise);
            if (receiverMethodNames) {
              receiverMethodNames.forEach(function(receiverMethodName) {
                delete callSender[receiverMethodName];
              });
            }
            receiverMethodNames = event.data.methodNames;
            connectCallSender(callSender, info, receiverMethodNames, connectionDestructionPromise);
            clearTimeout(connectionTimeoutId);
            resolveConnectionPromise(callSender);
          }
        };
        parent.addEventListener(MESSAGE, handleMessage);
        connectionDestructionPromise.then(function() {
          parent.removeEventListener(MESSAGE, handleMessage);
          var error = new Error("Connection destroyed");
          error.code = ERR_CONNECTION_DESTROYED;
          reject(error);
        });
        log("Parent: Loading iframe");
        iframe.src = url;
      });
      return {
        promise,
        iframe,
        destroy
      };
    };
    Penpal2.connectToParent = function() {
      var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$parentOrigin = _ref3.parentOrigin, parentOrigin = _ref3$parentOrigin === void 0 ? "*" : _ref3$parentOrigin, _ref3$methods = _ref3.methods, methods = _ref3$methods === void 0 ? {} : _ref3$methods, timeout = _ref3.timeout;
      if (window === window.top) {
        var error = new Error("connectToParent() must be called within an iframe");
        error.code = ERR_NOT_IN_IFRAME;
        throw error;
      }
      var destroy;
      var connectionDestructionPromise = new DestructionPromise(function(resolveConnectionDestructionPromise) {
        destroy = resolveConnectionDestructionPromise;
      });
      var child = window;
      var parent = child.parent;
      var promise = new Penpal2.Promise(function(resolveConnectionPromise, reject) {
        var connectionTimeoutId;
        if (timeout !== void 0) {
          connectionTimeoutId = setTimeout(function() {
            var error2 = new Error("Connection to parent timed out after ".concat(timeout, "ms"));
            error2.code = ERR_CONNECTION_TIMEOUT;
            reject(error2);
            destroy();
          }, timeout);
        }
        var handleMessageEvent = function handleMessageEvent2(event) {
          if ((parentOrigin === "*" || parentOrigin === event.origin) && event.source === parent && event.data.penpal === HANDSHAKE_REPLY) {
            log("Child: Received handshake reply");
            child.removeEventListener(MESSAGE, handleMessageEvent2);
            var info = {
              localName: "Child",
              local: child,
              remote: parent,
              remoteOrigin: event.origin
            };
            var callSender = {};
            connectCallReceiver(info, methods, connectionDestructionPromise);
            connectCallSender(callSender, info, event.data.methodNames, connectionDestructionPromise);
            clearTimeout(connectionTimeoutId);
            resolveConnectionPromise(callSender);
          }
        };
        child.addEventListener(MESSAGE, handleMessageEvent);
        connectionDestructionPromise.then(function() {
          child.removeEventListener(MESSAGE, handleMessageEvent);
          var error2 = new Error("Connection destroyed");
          error2.code = ERR_CONNECTION_DESTROYED;
          reject(error2);
        });
        log("Child: Sending handshake");
        parent.postMessage({
          penpal: HANDSHAKE,
          methodNames: Object.keys(methods)
        }, parentOrigin);
      });
      return {
        promise,
        destroy
      };
    };
    var _default = Penpal2;
    exports.default = _default;
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/api/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/api/keccak.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = (init_stream(), __toCommonJS(stream_exports)).Transform;
    var inherits = require_inherits_browser();
    module.exports = function(KeccakState) {
      function Keccak(rate, capacity, delimitedSuffix, hashBitLength, options) {
        Transform.call(this, options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._hashBitLength = hashBitLength;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      inherits(Keccak, Transform);
      Keccak.prototype._transform = function(chunk, encoding, callback) {
        var error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      Keccak.prototype._flush = function(callback) {
        var error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      Keccak.prototype.update = function(data, encoding) {
        if (!Buffer2.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer2.isBuffer(data))
          data = Buffer2.from(data, encoding);
        this._state.absorb(data);
        return this;
      };
      Keccak.prototype.digest = function(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        if (this._delimitedSuffix)
          this._state.absorbLastFewBits(this._delimitedSuffix);
        var digest = this._state.squeeze(this._hashBitLength / 8);
        if (encoding !== void 0)
          digest = digest.toString(encoding);
        this._resetState();
        return digest;
      };
      Keccak.prototype._resetState = function() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      };
      Keccak.prototype._clone = function() {
        var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      };
      return Keccak;
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/api/shake.js
var require_shake = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/api/shake.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = (init_stream(), __toCommonJS(stream_exports)).Transform;
    var inherits = require_inherits_browser();
    module.exports = function(KeccakState) {
      function Shake(rate, capacity, delimitedSuffix, options) {
        Transform.call(this, options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      inherits(Shake, Transform);
      Shake.prototype._transform = function(chunk, encoding, callback) {
        var error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      Shake.prototype._flush = function() {
      };
      Shake.prototype._read = function(size) {
        this.push(this.squeeze(size));
      };
      Shake.prototype.update = function(data, encoding) {
        if (!Buffer2.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Squeeze already called");
        if (!Buffer2.isBuffer(data))
          data = Buffer2.from(data, encoding);
        this._state.absorb(data);
        return this;
      };
      Shake.prototype.squeeze = function(dataByteLength, encoding) {
        if (!this._finalized) {
          this._finalized = true;
          this._state.absorbLastFewBits(this._delimitedSuffix);
        }
        var data = this._state.squeeze(dataByteLength);
        if (encoding !== void 0)
          data = data.toString(encoding);
        return data;
      };
      Shake.prototype._resetState = function() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      };
      Shake.prototype._clone = function() {
        var clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      };
      return Shake;
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/api/index.js
var require_api = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/api/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var createKeccak = require_keccak2();
    var createShake = require_shake();
    module.exports = function(KeccakState) {
      var Keccak = createKeccak(KeccakState);
      var Shake = createShake(KeccakState);
      return function(algorithm, options) {
        var hash = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
        switch (hash) {
          case "keccak224":
            return new Keccak(1152, 448, null, 224, options);
          case "keccak256":
            return new Keccak(1088, 512, null, 256, options);
          case "keccak384":
            return new Keccak(832, 768, null, 384, options);
          case "keccak512":
            return new Keccak(576, 1024, null, 512, options);
          case "sha3-224":
            return new Keccak(1152, 448, 6, 224, options);
          case "sha3-256":
            return new Keccak(1088, 512, 6, 256, options);
          case "sha3-384":
            return new Keccak(832, 768, 6, 384, options);
          case "sha3-512":
            return new Keccak(576, 1024, 6, 512, options);
          case "shake128":
            return new Shake(1344, 256, 31, options);
          case "shake256":
            return new Shake(1088, 512, 31, options);
          default:
            throw new Error("Invald algorithm: " + algorithm);
        }
      };
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/keccak-state-unroll.js
var require_keccak_state_unroll = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/keccak-state-unroll.js"(exports) {
    "use strict";
    init_define_process_env();
    var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    exports.p1600 = function(s) {
      for (var round = 0; round < 24; ++round) {
        var lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        var hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        var lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        var hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        var lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        var hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        var lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        var hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        var lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        var hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
        var lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
        var hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
        var t1slo0 = s[0] ^ lo;
        var t1shi0 = s[1] ^ hi;
        var t1slo5 = s[10] ^ lo;
        var t1shi5 = s[11] ^ hi;
        var t1slo10 = s[20] ^ lo;
        var t1shi10 = s[21] ^ hi;
        var t1slo15 = s[30] ^ lo;
        var t1shi15 = s[31] ^ hi;
        var t1slo20 = s[40] ^ lo;
        var t1shi20 = s[41] ^ hi;
        lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
        hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
        var t1slo1 = s[2] ^ lo;
        var t1shi1 = s[3] ^ hi;
        var t1slo6 = s[12] ^ lo;
        var t1shi6 = s[13] ^ hi;
        var t1slo11 = s[22] ^ lo;
        var t1shi11 = s[23] ^ hi;
        var t1slo16 = s[32] ^ lo;
        var t1shi16 = s[33] ^ hi;
        var t1slo21 = s[42] ^ lo;
        var t1shi21 = s[43] ^ hi;
        lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
        hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
        var t1slo2 = s[4] ^ lo;
        var t1shi2 = s[5] ^ hi;
        var t1slo7 = s[14] ^ lo;
        var t1shi7 = s[15] ^ hi;
        var t1slo12 = s[24] ^ lo;
        var t1shi12 = s[25] ^ hi;
        var t1slo17 = s[34] ^ lo;
        var t1shi17 = s[35] ^ hi;
        var t1slo22 = s[44] ^ lo;
        var t1shi22 = s[45] ^ hi;
        lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
        hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
        var t1slo3 = s[6] ^ lo;
        var t1shi3 = s[7] ^ hi;
        var t1slo8 = s[16] ^ lo;
        var t1shi8 = s[17] ^ hi;
        var t1slo13 = s[26] ^ lo;
        var t1shi13 = s[27] ^ hi;
        var t1slo18 = s[36] ^ lo;
        var t1shi18 = s[37] ^ hi;
        var t1slo23 = s[46] ^ lo;
        var t1shi23 = s[47] ^ hi;
        lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
        hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
        var t1slo4 = s[8] ^ lo;
        var t1shi4 = s[9] ^ hi;
        var t1slo9 = s[18] ^ lo;
        var t1shi9 = s[19] ^ hi;
        var t1slo14 = s[28] ^ lo;
        var t1shi14 = s[29] ^ hi;
        var t1slo19 = s[38] ^ lo;
        var t1shi19 = s[39] ^ hi;
        var t1slo24 = s[48] ^ lo;
        var t1shi24 = s[49] ^ hi;
        var t2slo0 = t1slo0;
        var t2shi0 = t1shi0;
        var t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
        var t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
        var t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
        var t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
        var t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
        var t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
        var t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
        var t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
        var t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
        var t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
        var t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
        var t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
        var t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
        var t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
        var t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
        var t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
        var t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
        var t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
        var t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
        var t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
        var t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
        var t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
        var t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
        var t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
        var t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
        var t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
        var t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
        var t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
        var t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
        var t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
        var t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
        var t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
        var t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
        var t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
        var t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
        var t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
        var t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
        var t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
        var t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
        var t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
        var t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
        var t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
        var t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
        var t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
        var t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
        var t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
        var t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
        var t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
        s[0] = t2slo0 ^ ~t2slo1 & t2slo2;
        s[1] = t2shi0 ^ ~t2shi1 & t2shi2;
        s[10] = t2slo5 ^ ~t2slo6 & t2slo7;
        s[11] = t2shi5 ^ ~t2shi6 & t2shi7;
        s[20] = t2slo10 ^ ~t2slo11 & t2slo12;
        s[21] = t2shi10 ^ ~t2shi11 & t2shi12;
        s[30] = t2slo15 ^ ~t2slo16 & t2slo17;
        s[31] = t2shi15 ^ ~t2shi16 & t2shi17;
        s[40] = t2slo20 ^ ~t2slo21 & t2slo22;
        s[41] = t2shi20 ^ ~t2shi21 & t2shi22;
        s[2] = t2slo1 ^ ~t2slo2 & t2slo3;
        s[3] = t2shi1 ^ ~t2shi2 & t2shi3;
        s[12] = t2slo6 ^ ~t2slo7 & t2slo8;
        s[13] = t2shi6 ^ ~t2shi7 & t2shi8;
        s[22] = t2slo11 ^ ~t2slo12 & t2slo13;
        s[23] = t2shi11 ^ ~t2shi12 & t2shi13;
        s[32] = t2slo16 ^ ~t2slo17 & t2slo18;
        s[33] = t2shi16 ^ ~t2shi17 & t2shi18;
        s[42] = t2slo21 ^ ~t2slo22 & t2slo23;
        s[43] = t2shi21 ^ ~t2shi22 & t2shi23;
        s[4] = t2slo2 ^ ~t2slo3 & t2slo4;
        s[5] = t2shi2 ^ ~t2shi3 & t2shi4;
        s[14] = t2slo7 ^ ~t2slo8 & t2slo9;
        s[15] = t2shi7 ^ ~t2shi8 & t2shi9;
        s[24] = t2slo12 ^ ~t2slo13 & t2slo14;
        s[25] = t2shi12 ^ ~t2shi13 & t2shi14;
        s[34] = t2slo17 ^ ~t2slo18 & t2slo19;
        s[35] = t2shi17 ^ ~t2shi18 & t2shi19;
        s[44] = t2slo22 ^ ~t2slo23 & t2slo24;
        s[45] = t2shi22 ^ ~t2shi23 & t2shi24;
        s[6] = t2slo3 ^ ~t2slo4 & t2slo0;
        s[7] = t2shi3 ^ ~t2shi4 & t2shi0;
        s[16] = t2slo8 ^ ~t2slo9 & t2slo5;
        s[17] = t2shi8 ^ ~t2shi9 & t2shi5;
        s[26] = t2slo13 ^ ~t2slo14 & t2slo10;
        s[27] = t2shi13 ^ ~t2shi14 & t2shi10;
        s[36] = t2slo18 ^ ~t2slo19 & t2slo15;
        s[37] = t2shi18 ^ ~t2shi19 & t2shi15;
        s[46] = t2slo23 ^ ~t2slo24 & t2slo20;
        s[47] = t2shi23 ^ ~t2shi24 & t2shi20;
        s[8] = t2slo4 ^ ~t2slo0 & t2slo1;
        s[9] = t2shi4 ^ ~t2shi0 & t2shi1;
        s[18] = t2slo9 ^ ~t2slo5 & t2slo6;
        s[19] = t2shi9 ^ ~t2shi5 & t2shi6;
        s[28] = t2slo14 ^ ~t2slo10 & t2slo11;
        s[29] = t2shi14 ^ ~t2shi10 & t2shi11;
        s[38] = t2slo19 ^ ~t2slo15 & t2slo16;
        s[39] = t2shi19 ^ ~t2shi15 & t2shi16;
        s[48] = t2slo24 ^ ~t2slo20 & t2slo21;
        s[49] = t2shi24 ^ ~t2shi20 & t2shi21;
        s[0] ^= P1600_ROUND_CONSTANTS[round * 2];
        s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
      }
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/keccak.js
var require_keccak3 = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/keccak.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Buffer2 = require_safe_buffer().Buffer;
    var keccakState = require_keccak_state_unroll();
    function Keccak() {
      this.state = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      this.blockSize = null;
      this.count = 0;
      this.squeezing = false;
    }
    Keccak.prototype.initialize = function(rate, capacity) {
      for (var i = 0; i < 50; ++i)
        this.state[i] = 0;
      this.blockSize = rate / 8;
      this.count = 0;
      this.squeezing = false;
    };
    Keccak.prototype.absorb = function(data) {
      for (var i = 0; i < data.length; ++i) {
        this.state[~~(this.count / 4)] ^= data[i] << 8 * (this.count % 4);
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
    };
    Keccak.prototype.absorbLastFewBits = function(bits) {
      this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
      if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
        keccakState.p1600(this.state);
      this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
      keccakState.p1600(this.state);
      this.count = 0;
      this.squeezing = true;
    };
    Keccak.prototype.squeeze = function(length) {
      if (!this.squeezing)
        this.absorbLastFewBits(1);
      var output = Buffer2.alloc(length);
      for (var i = 0; i < length; ++i) {
        output[i] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
      return output;
    };
    Keccak.prototype.copy = function(dest) {
      for (var i = 0; i < 50; ++i)
        dest.state[i] = this.state[i];
      dest.blockSize = this.blockSize;
      dest.count = this.count;
      dest.squeezing = this.squeezing;
    };
    module.exports = Keccak;
  }
});

// node_modules/@portis/web3/node_modules/keccak/js.js
var require_js = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/js.js"(exports, module) {
    "use strict";
    init_define_process_env();
    module.exports = require_api()(require_keccak3());
  }
});

// node_modules/@portis/web3/node_modules/secp256k1/lib/assert.js
var require_assert2 = __commonJS({
  "node_modules/@portis/web3/node_modules/secp256k1/lib/assert.js"(exports) {
    "use strict";
    init_define_process_env();
    var toString = Object.prototype.toString;
    exports.isArray = function(value, message) {
      if (!Array.isArray(value))
        throw TypeError(message);
    };
    exports.isBoolean = function(value, message) {
      if (toString.call(value) !== "[object Boolean]")
        throw TypeError(message);
    };
    exports.isBuffer = function(value, message) {
      if (!Buffer.isBuffer(value))
        throw TypeError(message);
    };
    exports.isFunction = function(value, message) {
      if (toString.call(value) !== "[object Function]")
        throw TypeError(message);
    };
    exports.isNumber = function(value, message) {
      if (toString.call(value) !== "[object Number]")
        throw TypeError(message);
    };
    exports.isObject = function(value, message) {
      if (toString.call(value) !== "[object Object]")
        throw TypeError(message);
    };
    exports.isBufferLength = function(buffer, length, message) {
      if (buffer.length !== length)
        throw RangeError(message);
    };
    exports.isBufferLength2 = function(buffer, length1, length2, message) {
      if (buffer.length !== length1 && buffer.length !== length2)
        throw RangeError(message);
    };
    exports.isLengthGTZero = function(value, message) {
      if (value.length === 0)
        throw RangeError(message);
    };
    exports.isNumberInInterval = function(number, x, y, message) {
      if (number <= x || number >= y)
        throw RangeError(message);
    };
  }
});

// node_modules/@portis/web3/node_modules/secp256k1/lib/der.js
var require_der = __commonJS({
  "node_modules/@portis/web3/node_modules/secp256k1/lib/der.js"(exports) {
    "use strict";
    init_define_process_env();
    var Buffer2 = require_safe_buffer().Buffer;
    var bip66 = require_bip66();
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer2.from([
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer2.from([
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.privateKeyExport = function(privateKey, publicKey, compressed) {
      var result = Buffer2.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports.privateKeyImport = function(privateKey) {
      var length = privateKey.length;
      var index = 0;
      if (length < index + 1 || privateKey[index] !== 48)
        return;
      index += 1;
      if (length < index + 1 || !(privateKey[index] & 128))
        return;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return;
      if (length < index + lenb)
        return;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length < index + len)
        return;
      if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return;
      }
      index += 3;
      if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
        return;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports.signatureExport = function(sigObj) {
      var r = Buffer2.concat([Buffer2.from([0]), sigObj.r]);
      for (var lenR = 33, posR = 0; lenR > 1 && r[posR] === 0 && !(r[posR + 1] & 128); --lenR, ++posR)
        ;
      var s = Buffer2.concat([Buffer2.from([0]), sigObj.s]);
      for (var lenS = 33, posS = 0; lenS > 1 && s[posS] === 0 && !(s[posS + 1] & 128); --lenS, ++posS)
        ;
      return bip66.encode(r.slice(posR), s.slice(posS));
    };
    exports.signatureImport = function(sig) {
      var r = Buffer2.alloc(32, 0);
      var s = Buffer2.alloc(32, 0);
      try {
        var sigObj = bip66.decode(sig);
        if (sigObj.r.length === 33 && sigObj.r[0] === 0)
          sigObj.r = sigObj.r.slice(1);
        if (sigObj.r.length > 32)
          throw new Error("R length is too long");
        if (sigObj.s.length === 33 && sigObj.s[0] === 0)
          sigObj.s = sigObj.s.slice(1);
        if (sigObj.s.length > 32)
          throw new Error("S length is too long");
      } catch (err) {
        return;
      }
      sigObj.r.copy(r, 32 - sigObj.r.length);
      sigObj.s.copy(s, 32 - sigObj.s.length);
      return { r, s };
    };
    exports.signatureImportLax = function(sig) {
      var r = Buffer2.alloc(32, 0);
      var s = Buffer2.alloc(32, 0);
      var length = sig.length;
      var index = 0;
      if (sig[index++] !== 48)
        return;
      var lenbyte = sig[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length)
          return;
      }
      if (sig[index++] !== 2)
        return;
      var rlen = sig[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length)
          return;
        for (; lenbyte > 0 && sig[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          rlen = (rlen << 8) + sig[index];
      }
      if (rlen > length - index)
        return;
      var rindex = index;
      index += rlen;
      if (sig[index++] !== 2)
        return;
      var slen = sig[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length)
          return;
        for (; lenbyte > 0 && sig[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          slen = (slen << 8) + sig[index];
      }
      if (slen > length - index)
        return;
      var sindex = index;
      index += slen;
      for (; rlen > 0 && sig[rindex] === 0; rlen -= 1, rindex += 1)
        ;
      if (rlen > 32)
        return;
      var rvalue = sig.slice(rindex, rindex + rlen);
      rvalue.copy(r, 32 - rvalue.length);
      for (; slen > 0 && sig[sindex] === 0; slen -= 1, sindex += 1)
        ;
      if (slen > 32)
        return;
      var svalue = sig.slice(sindex, sindex + slen);
      svalue.copy(s, 32 - svalue.length);
      return { r, s };
    };
  }
});

// node_modules/@portis/web3/node_modules/secp256k1/lib/messages.json
var require_messages = __commonJS({
  "node_modules/@portis/web3/node_modules/secp256k1/lib/messages.json"(exports, module) {
    module.exports = {
      COMPRESSED_TYPE_INVALID: "compressed should be a boolean",
      EC_PRIVATE_KEY_TYPE_INVALID: "private key should be a Buffer",
      EC_PRIVATE_KEY_LENGTH_INVALID: "private key length is invalid",
      EC_PRIVATE_KEY_RANGE_INVALID: "private key range is invalid",
      EC_PRIVATE_KEY_TWEAK_ADD_FAIL: "tweak out of range or resulting private key is invalid",
      EC_PRIVATE_KEY_TWEAK_MUL_FAIL: "tweak out of range",
      EC_PRIVATE_KEY_EXPORT_DER_FAIL: "couldn't export to DER format",
      EC_PRIVATE_KEY_IMPORT_DER_FAIL: "couldn't import from DER format",
      EC_PUBLIC_KEYS_TYPE_INVALID: "public keys should be an Array",
      EC_PUBLIC_KEYS_LENGTH_INVALID: "public keys Array should have at least 1 element",
      EC_PUBLIC_KEY_TYPE_INVALID: "public key should be a Buffer",
      EC_PUBLIC_KEY_LENGTH_INVALID: "public key length is invalid",
      EC_PUBLIC_KEY_PARSE_FAIL: "the public key could not be parsed or is invalid",
      EC_PUBLIC_KEY_CREATE_FAIL: "private was invalid, try again",
      EC_PUBLIC_KEY_TWEAK_ADD_FAIL: "tweak out of range or resulting public key is invalid",
      EC_PUBLIC_KEY_TWEAK_MUL_FAIL: "tweak out of range",
      EC_PUBLIC_KEY_COMBINE_FAIL: "the sum of the public keys is not valid",
      ECDH_FAIL: "scalar was invalid (zero or overflow)",
      ECDSA_SIGNATURE_TYPE_INVALID: "signature should be a Buffer",
      ECDSA_SIGNATURE_LENGTH_INVALID: "signature length is invalid",
      ECDSA_SIGNATURE_PARSE_FAIL: "couldn't parse signature",
      ECDSA_SIGNATURE_PARSE_DER_FAIL: "couldn't parse DER signature",
      ECDSA_SIGNATURE_SERIALIZE_DER_FAIL: "couldn't serialize signature to DER format",
      ECDSA_SIGN_FAIL: "nonce generation function failed or private key is invalid",
      ECDSA_RECOVER_FAIL: "couldn't recover public key from signature",
      MSG32_TYPE_INVALID: "message should be a Buffer",
      MSG32_LENGTH_INVALID: "message length is invalid",
      OPTIONS_TYPE_INVALID: "options should be an Object",
      OPTIONS_DATA_TYPE_INVALID: "options.data should be a Buffer",
      OPTIONS_DATA_LENGTH_INVALID: "options.data length is invalid",
      OPTIONS_NONCEFN_TYPE_INVALID: "options.noncefn should be a Function",
      RECOVERY_ID_TYPE_INVALID: "recovery should be a Number",
      RECOVERY_ID_VALUE_INVALID: "recovery should have value between -1 and 4",
      TWEAK_TYPE_INVALID: "tweak should be a Buffer",
      TWEAK_LENGTH_INVALID: "tweak length is invalid"
    };
  }
});

// node_modules/@portis/web3/node_modules/secp256k1/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@portis/web3/node_modules/secp256k1/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var assert = require_assert2();
    var der = require_der();
    var messages = require_messages();
    function initCompressedValue(value, defaultValue) {
      if (value === void 0)
        return defaultValue;
      assert.isBoolean(value, messages.COMPRESSED_TYPE_INVALID);
      return value;
    }
    module.exports = function(secp256k1) {
      return {
        privateKeyVerify: function(privateKey) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          return privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey);
        },
        privateKeyExport: function(privateKey, compressed) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          var publicKey = secp256k1.privateKeyExport(privateKey, compressed);
          return der.privateKeyExport(privateKey, publicKey, compressed);
        },
        privateKeyImport: function(privateKey) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          privateKey = der.privateKeyImport(privateKey);
          if (privateKey && privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey))
            return privateKey;
          throw new Error(messages.EC_PRIVATE_KEY_IMPORT_DER_FAIL);
        },
        privateKeyNegate: function(privateKey) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          return secp256k1.privateKeyNegate(privateKey);
        },
        privateKeyModInverse: function(privateKey) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          return secp256k1.privateKeyModInverse(privateKey);
        },
        privateKeyTweakAdd: function(privateKey, tweak) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
          assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
          return secp256k1.privateKeyTweakAdd(privateKey, tweak);
        },
        privateKeyTweakMul: function(privateKey, tweak) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
          assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
          return secp256k1.privateKeyTweakMul(privateKey, tweak);
        },
        publicKeyCreate: function(privateKey, compressed) {
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k1.publicKeyCreate(privateKey, compressed);
        },
        publicKeyConvert: function(publicKey, compressed) {
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k1.publicKeyConvert(publicKey, compressed);
        },
        publicKeyVerify: function(publicKey) {
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          return secp256k1.publicKeyVerify(publicKey);
        },
        publicKeyTweakAdd: function(publicKey, tweak, compressed) {
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
          assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k1.publicKeyTweakAdd(publicKey, tweak, compressed);
        },
        publicKeyTweakMul: function(publicKey, tweak, compressed) {
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
          assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k1.publicKeyTweakMul(publicKey, tweak, compressed);
        },
        publicKeyCombine: function(publicKeys, compressed) {
          assert.isArray(publicKeys, messages.EC_PUBLIC_KEYS_TYPE_INVALID);
          assert.isLengthGTZero(publicKeys, messages.EC_PUBLIC_KEYS_LENGTH_INVALID);
          for (var i = 0; i < publicKeys.length; ++i) {
            assert.isBuffer(publicKeys[i], messages.EC_PUBLIC_KEY_TYPE_INVALID);
            assert.isBufferLength2(publicKeys[i], 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          }
          compressed = initCompressedValue(compressed, true);
          return secp256k1.publicKeyCombine(publicKeys, compressed);
        },
        signatureNormalize: function(signature) {
          assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          return secp256k1.signatureNormalize(signature);
        },
        signatureExport: function(signature) {
          assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          var sigObj = secp256k1.signatureExport(signature);
          return der.signatureExport(sigObj);
        },
        signatureImport: function(sig) {
          assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          var sigObj = der.signatureImport(sig);
          if (sigObj)
            return secp256k1.signatureImport(sigObj);
          throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL);
        },
        signatureImportLax: function(sig) {
          assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          var sigObj = der.signatureImportLax(sig);
          if (sigObj)
            return secp256k1.signatureImport(sigObj);
          throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL);
        },
        sign: function(message, privateKey, options) {
          assert.isBuffer(message, messages.MSG32_TYPE_INVALID);
          assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID);
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          var data = null;
          var noncefn = null;
          if (options !== void 0) {
            assert.isObject(options, messages.OPTIONS_TYPE_INVALID);
            if (options.data !== void 0) {
              assert.isBuffer(options.data, messages.OPTIONS_DATA_TYPE_INVALID);
              assert.isBufferLength(options.data, 32, messages.OPTIONS_DATA_LENGTH_INVALID);
              data = options.data;
            }
            if (options.noncefn !== void 0) {
              assert.isFunction(options.noncefn, messages.OPTIONS_NONCEFN_TYPE_INVALID);
              noncefn = options.noncefn;
            }
          }
          return secp256k1.sign(message, privateKey, noncefn, data);
        },
        verify: function(message, signature, publicKey) {
          assert.isBuffer(message, messages.MSG32_TYPE_INVALID);
          assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID);
          assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          return secp256k1.verify(message, signature, publicKey);
        },
        recover: function(message, signature, recovery, compressed) {
          assert.isBuffer(message, messages.MSG32_TYPE_INVALID);
          assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID);
          assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
          assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
          assert.isNumber(recovery, messages.RECOVERY_ID_TYPE_INVALID);
          assert.isNumberInInterval(recovery, -1, 4, messages.RECOVERY_ID_VALUE_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k1.recover(message, signature, recovery, compressed);
        },
        ecdh: function(publicKey, privateKey) {
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          return secp256k1.ecdh(publicKey, privateKey);
        },
        ecdhUnsafe: function(publicKey, privateKey, compressed) {
          assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
          assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
          assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
          assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
          compressed = initCompressedValue(compressed, true);
          return secp256k1.ecdhUnsafe(publicKey, privateKey, compressed);
        }
      };
    };
  }
});

// node_modules/@portis/web3/node_modules/secp256k1/lib/elliptic/index.js
var require_elliptic2 = __commonJS({
  "node_modules/@portis/web3/node_modules/secp256k1/lib/elliptic/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var Buffer2 = require_safe_buffer().Buffer;
    var createHash = require_browser();
    var BN2 = require_bn();
    var EC = require_elliptic().ec;
    var messages = require_messages();
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    function loadCompressedPublicKey(first, xBuffer) {
      var x = new BN2(xBuffer);
      if (x.cmp(ecparams.p) >= 0)
        return null;
      x = x.toRed(ecparams.red);
      var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
      if (first === 3 !== y.isOdd())
        y = y.redNeg();
      return ec.keyPair({ pub: { x, y } });
    }
    function loadUncompressedPublicKey(first, xBuffer, yBuffer) {
      var x = new BN2(xBuffer);
      var y = new BN2(yBuffer);
      if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0)
        return null;
      x = x.toRed(ecparams.red);
      y = y.toRed(ecparams.red);
      if ((first === 6 || first === 7) && y.isOdd() !== (first === 7))
        return null;
      var x3 = x.redSqr().redIMul(x);
      if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero())
        return null;
      return ec.keyPair({ pub: { x, y } });
    }
    function loadPublicKey(publicKey) {
      var first = publicKey[0];
      switch (first) {
        case 2:
        case 3:
          if (publicKey.length !== 33)
            return null;
          return loadCompressedPublicKey(first, publicKey.slice(1, 33));
        case 4:
        case 6:
        case 7:
          if (publicKey.length !== 65)
            return null;
          return loadUncompressedPublicKey(first, publicKey.slice(1, 33), publicKey.slice(33, 65));
        default:
          return null;
      }
    }
    exports.privateKeyVerify = function(privateKey) {
      var bn = new BN2(privateKey);
      return bn.cmp(ecparams.n) < 0 && !bn.isZero();
    };
    exports.privateKeyExport = function(privateKey, compressed) {
      var d = new BN2(privateKey);
      if (d.cmp(ecparams.n) >= 0 || d.isZero())
        throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL);
      return Buffer2.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true));
    };
    exports.privateKeyNegate = function(privateKey) {
      var bn = new BN2(privateKey);
      return bn.isZero() ? Buffer2.alloc(32) : ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Buffer2, "be", 32);
    };
    exports.privateKeyModInverse = function(privateKey) {
      var bn = new BN2(privateKey);
      if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
        throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID);
      return bn.invm(ecparams.n).toArrayLike(Buffer2, "be", 32);
    };
    exports.privateKeyTweakAdd = function(privateKey, tweak) {
      var bn = new BN2(tweak);
      if (bn.cmp(ecparams.n) >= 0)
        throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
      bn.iadd(new BN2(privateKey));
      if (bn.cmp(ecparams.n) >= 0)
        bn.isub(ecparams.n);
      if (bn.isZero())
        throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
      return bn.toArrayLike(Buffer2, "be", 32);
    };
    exports.privateKeyTweakMul = function(privateKey, tweak) {
      var bn = new BN2(tweak);
      if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
        throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL);
      bn.imul(new BN2(privateKey));
      if (bn.cmp(ecparams.n))
        bn = bn.umod(ecparams.n);
      return bn.toArrayLike(Buffer2, "be", 32);
    };
    exports.publicKeyCreate = function(privateKey, compressed) {
      var d = new BN2(privateKey);
      if (d.cmp(ecparams.n) >= 0 || d.isZero())
        throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL);
      return Buffer2.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true));
    };
    exports.publicKeyConvert = function(publicKey, compressed) {
      var pair = loadPublicKey(publicKey);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      return Buffer2.from(pair.getPublic(compressed, true));
    };
    exports.publicKeyVerify = function(publicKey) {
      return loadPublicKey(publicKey) !== null;
    };
    exports.publicKeyTweakAdd = function(publicKey, tweak, compressed) {
      var pair = loadPublicKey(publicKey);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      tweak = new BN2(tweak);
      if (tweak.cmp(ecparams.n) >= 0)
        throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
      var point = ecparams.g.mul(tweak).add(pair.pub);
      if (point.isInfinity())
        throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
      return Buffer2.from(point.encode(true, compressed));
    };
    exports.publicKeyTweakMul = function(publicKey, tweak, compressed) {
      var pair = loadPublicKey(publicKey);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      tweak = new BN2(tweak);
      if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
        throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL);
      return Buffer2.from(pair.pub.mul(tweak).encode(true, compressed));
    };
    exports.publicKeyCombine = function(publicKeys, compressed) {
      var pairs = new Array(publicKeys.length);
      for (var i = 0; i < publicKeys.length; ++i) {
        pairs[i] = loadPublicKey(publicKeys[i]);
        if (pairs[i] === null)
          throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      }
      var point = pairs[0].pub;
      for (var j = 1; j < pairs.length; ++j)
        point = point.add(pairs[j].pub);
      if (point.isInfinity())
        throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL);
      return Buffer2.from(point.encode(true, compressed));
    };
    exports.signatureNormalize = function(signature) {
      var r = new BN2(signature.slice(0, 32));
      var s = new BN2(signature.slice(32, 64));
      if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0)
        throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
      var result = Buffer2.from(signature);
      if (s.cmp(ec.nh) === 1)
        ecparams.n.sub(s).toArrayLike(Buffer2, "be", 32).copy(result, 32);
      return result;
    };
    exports.signatureExport = function(signature) {
      var r = signature.slice(0, 32);
      var s = signature.slice(32, 64);
      if (new BN2(r).cmp(ecparams.n) >= 0 || new BN2(s).cmp(ecparams.n) >= 0)
        throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
      return { r, s };
    };
    exports.signatureImport = function(sigObj) {
      var r = new BN2(sigObj.r);
      if (r.cmp(ecparams.n) >= 0)
        r = new BN2(0);
      var s = new BN2(sigObj.s);
      if (s.cmp(ecparams.n) >= 0)
        s = new BN2(0);
      return Buffer2.concat([
        r.toArrayLike(Buffer2, "be", 32),
        s.toArrayLike(Buffer2, "be", 32)
      ]);
    };
    exports.sign = function(message, privateKey, noncefn, data) {
      if (typeof noncefn === "function") {
        var getNonce = noncefn;
        noncefn = function(counter) {
          var nonce = getNonce(message, privateKey, null, data, counter);
          if (!Buffer2.isBuffer(nonce) || nonce.length !== 32)
            throw new Error(messages.ECDSA_SIGN_FAIL);
          return new BN2(nonce);
        };
      }
      var d = new BN2(privateKey);
      if (d.cmp(ecparams.n) >= 0 || d.isZero())
        throw new Error(messages.ECDSA_SIGN_FAIL);
      var result = ec.sign(message, privateKey, { canonical: true, k: noncefn, pers: data });
      return {
        signature: Buffer2.concat([
          result.r.toArrayLike(Buffer2, "be", 32),
          result.s.toArrayLike(Buffer2, "be", 32)
        ]),
        recovery: result.recoveryParam
      };
    };
    exports.verify = function(message, signature, publicKey) {
      var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) };
      var sigr = new BN2(sigObj.r);
      var sigs = new BN2(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
        throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
      if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero())
        return false;
      var pair = loadPublicKey(publicKey);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      return ec.verify(message, sigObj, { x: pair.pub.x, y: pair.pub.y });
    };
    exports.recover = function(message, signature, recovery, compressed) {
      var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) };
      var sigr = new BN2(sigObj.r);
      var sigs = new BN2(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
        throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
      try {
        if (sigr.isZero() || sigs.isZero())
          throw new Error();
        var point = ec.recoverPubKey(message, sigObj, recovery);
        return Buffer2.from(point.encode(true, compressed));
      } catch (err) {
        throw new Error(messages.ECDSA_RECOVER_FAIL);
      }
    };
    exports.ecdh = function(publicKey, privateKey) {
      var shared = exports.ecdhUnsafe(publicKey, privateKey, true);
      return createHash("sha256").update(shared).digest();
    };
    exports.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      var pair = loadPublicKey(publicKey);
      if (pair === null)
        throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
      var scalar = new BN2(privateKey);
      if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
        throw new Error(messages.ECDH_FAIL);
      return Buffer2.from(pair.pub.mul(scalar).encode(true, compressed));
    };
  }
});

// node_modules/@portis/web3/node_modules/secp256k1/elliptic.js
var require_elliptic3 = __commonJS({
  "node_modules/@portis/web3/node_modules/secp256k1/elliptic.js"(exports, module) {
    "use strict";
    init_define_process_env();
    module.exports = require_lib3()(require_elliptic2());
  }
});

// node_modules/@portis/web3/node_modules/ethereumjs-util/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@portis/web3/node_modules/ethereumjs-util/dist/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var createKeccakHash = require_js();
    var secp256k1 = require_elliptic3();
    var assert = require_assert();
    var rlp = require_dist();
    var BN2 = require_bn();
    var createHash = require_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    Object.assign(exports, require_lib());
    exports.MAX_INTEGER = new BN2("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN2("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;
    exports.KECCAK256_NULL = Buffer2.from(exports.KECCAK256_NULL_S, "hex");
    exports.SHA3_NULL = exports.KECCAK256_NULL;
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;
    exports.KECCAK256_RLP_ARRAY = Buffer2.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;
    exports.KECCAK256_RLP = Buffer2.from(exports.KECCAK256_RLP_S, "hex");
    exports.SHA3_RLP = exports.KECCAK256_RLP;
    exports.BN = BN2;
    exports.rlp = rlp;
    exports.secp256k1 = secp256k1;
    exports.zeros = function(bytes) {
      return Buffer2.allocUnsafe(bytes).fill(0);
    };
    exports.zeroAddress = function() {
      var addressLength = 20;
      var zeroAddress = exports.zeros(addressLength);
      return exports.bufferToHex(zeroAddress);
    };
    exports.setLengthLeft = exports.setLength = function(msg, length, right) {
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = exports.stripZeros = function(a) {
      a = exports.stripHexPrefix(a);
      var first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    exports.toBuffer = function(v) {
      if (!Buffer2.isBuffer(v)) {
        if (Array.isArray(v)) {
          v = Buffer2.from(v);
        } else if (typeof v === "string") {
          if (exports.isHexString(v)) {
            v = Buffer2.from(exports.padToEven(exports.stripHexPrefix(v)), "hex");
          } else {
            v = Buffer2.from(v);
          }
        } else if (typeof v === "number") {
          v = exports.intToBuffer(v);
        } else if (v === null || v === void 0) {
          v = Buffer2.allocUnsafe(0);
        } else if (BN2.isBN(v)) {
          v = v.toArrayLike(Buffer2);
        } else if (v.toArray) {
          v = Buffer2.from(v.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v;
    };
    exports.bufferToInt = function(buf) {
      return new BN2(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN2(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer2.from(num.toTwos(256).toArray());
    };
    exports.keccak = function(a, bits) {
      a = exports.toBuffer(a);
      if (!bits)
        bits = 256;
      return createKeccakHash("keccak" + bits).update(a).digest();
    };
    exports.keccak256 = function(a) {
      return exports.keccak(a);
    };
    exports.sha3 = exports.keccak;
    exports.sha256 = function(a) {
      a = exports.toBuffer(a);
      return createHash("sha256").update(a).digest();
    };
    exports.ripemd160 = function(a, padded) {
      a = exports.toBuffer(a);
      var hash = createHash("rmd160").update(a).digest();
      if (padded === true) {
        return exports.setLength(hash, 32);
      } else {
        return hash;
      }
    };
    exports.rlphash = function(a) {
      return exports.keccak(rlp.encode(a));
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k1.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey, sanitize) {
      if (publicKey.length === 64) {
        return secp256k1.publicKeyVerify(Buffer2.concat([Buffer2.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k1.publicKeyVerify(publicKey);
    };
    exports.pubToAddress = exports.publicToAddress = function(pubKey, sanitize) {
      pubKey = exports.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
      }
      assert(pubKey.length === 64);
      return exports.keccak(pubKey).slice(-20);
    };
    var privateToPublic = exports.privateToPublic = function(privateKey) {
      privateKey = exports.toBuffer(privateKey);
      return secp256k1.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey) {
      publicKey = exports.toBuffer(publicKey);
      if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
      }
      return publicKey;
    };
    exports.ecsign = function(msgHash, privateKey) {
      var sig = secp256k1.sign(msgHash, privateKey);
      var ret = {};
      ret.r = sig.signature.slice(0, 32);
      ret.s = sig.signature.slice(32, 64);
      ret.v = sig.recovery + 27;
      return ret;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = exports.toBuffer("Ethereum Signed Message:\n" + message.length.toString());
      return exports.keccak(Buffer2.concat([prefix, message]));
    };
    exports.ecrecover = function(msgHash, v, r, s) {
      var signature = Buffer2.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
      var recovery = v - 27;
      if (recovery !== 0 && recovery !== 1) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
      return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v, r, s) {
      if (v !== 27 && v !== 28) {
        throw new Error("Invalid recovery id");
      }
      return exports.bufferToHex(Buffer2.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
    };
    exports.fromRpcSig = function(sig) {
      sig = exports.toBuffer(sig);
      if (sig.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v = sig[64];
      if (v < 27) {
        v += 27;
      }
      return {
        v,
        r: sig.slice(0, 32),
        s: sig.slice(32, 64)
      };
    };
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(privateToPublic(privateKey));
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddress = exports.zeroAddress();
      return zeroAddress === exports.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address) {
      address = exports.stripHexPrefix(address).toLowerCase();
      var hash = exports.keccak(address).toString("hex");
      var ret = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret += address[i].toUpperCase();
        } else {
          ret += address[i];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
    };
    exports.generateAddress = function(from, nonce) {
      from = exports.toBuffer(from);
      nonce = new BN2(nonce);
      if (nonce.isZero()) {
        nonce = null;
      } else {
        nonce = Buffer2.from(nonce.toArray());
      }
      return exports.rlphash([from, nonce]).slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a = exports.unpad(address);
      return a.length === 1 && a[0] >= 1 && a[0] <= 8;
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return exports.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.isValidSignature = function(v, r, s, homestead) {
      var SECP256K1_N_DIV_2 = new BN2("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r.length !== 32 || s.length !== 32) {
        return false;
      }
      if (v !== 27 && v !== 28) {
        return false;
      }
      r = new BN2(r);
      s = new BN2(s);
      if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
        return false;
      }
      if (homestead === false && new BN2(s).cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.baToJSON = function(ba) {
      if (Buffer2.isBuffer(ba)) {
        return "0x" + ba.toString("hex");
      } else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
          array.push(exports.baToJSON(ba[i]));
        }
        return array;
      }
    };
    exports.defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label) {
          var obj = {};
          self2._fields.forEach(function(field) {
            obj[field] = "0x" + self2[field].toString("hex");
          });
          return obj;
        }
        return exports.baToJSON(this.raw);
      };
      self2.serialize = function serialize() {
        return rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i];
        }
        function setter(v) {
          v = exports.toBuffer(v);
          if (v.toString("hex") === "00" && !field.allowZero) {
            v = Buffer2.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v = exports.stripZeros(v);
            assert(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v.length === 0) && field.length) {
            assert(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self2.raw[i] = v;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer2.from(exports.stripHexPrefix(data), "hex");
        }
        if (Buffer2.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d, i) {
            self2[self2._fields[i]] = exports.toBuffer(d);
          });
        } else if ((typeof data === "undefined" ? "undefined" : _typeof(data)) === "object") {
          var keys = Object.keys(data);
          fields.forEach(function(field) {
            if (keys.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// node_modules/web3-provider-engine/node_modules/ethereumjs-util/dist/secp256k1-lib/index.js
var require_secp256k1_lib = __commonJS({
  "node_modules/web3-provider-engine/node_modules/ethereumjs-util/dist/secp256k1-lib/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var BN2 = require_bn();
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    exports.privateKeyExport = function(privateKey, compressed) {
      var d = new BN2(privateKey);
      if (d.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
      }
      var point = ec.g.mul(d);
      return toPublicKey(point.getX(), point.getY(), compressed);
    };
    exports.privateKeyModInverse = function(privateKey) {
      var bn = new BN2(privateKey);
      if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
        throw new Error("private key range is invalid");
      }
      return bn.invm(ecparams.n).toArrayLike(Buffer, "be", 32);
    };
    exports.signatureImport = function(sigObj) {
      var r = new BN2(sigObj.r);
      if (r.ucmp(ecparams.n) >= 0) {
        r = new BN2(0);
      }
      var s = new BN2(sigObj.s);
      if (s.ucmp(ecparams.n) >= 0) {
        s = new BN2(0);
      }
      return Buffer.concat([r.toArrayLike(Buffer, "be", 32), s.toArrayLike(Buffer, "be", 32)]);
    };
    exports.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      var point = ec.keyFromPublic(publicKey);
      var scalar = new BN2(privateKey);
      if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error("scalar was invalid (zero or overflow)");
      }
      var shared = point.pub.mul(scalar);
      return toPublicKey(shared.getX(), shared.getY(), compressed);
    };
    var toPublicKey = function toPublicKey2(x, y, compressed) {
      var publicKey = void 0;
      if (compressed) {
        publicKey = Buffer.alloc(33);
        publicKey[0] = y.isOdd() ? 3 : 2;
        x.toArrayLike(Buffer, "be", 32).copy(publicKey, 1);
      } else {
        publicKey = Buffer.alloc(65);
        publicKey[0] = 4;
        x.toArrayLike(Buffer, "be", 32).copy(publicKey, 1);
        y.toArrayLike(Buffer, "be", 32).copy(publicKey, 33);
      }
      return publicKey;
    };
  }
});

// node_modules/web3-provider-engine/node_modules/ethereumjs-util/dist/secp256k1-lib/der.js
var require_der2 = __commonJS({
  "node_modules/web3-provider-engine/node_modules/ethereumjs-util/dist/secp256k1-lib/der.js"(exports) {
    "use strict";
    init_define_process_env();
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.privateKeyExport = function(privateKey, publicKey, compressed) {
      var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports.privateKeyImport = function(privateKey) {
      var length = privateKey.length;
      var index = 0;
      if (length < index + 1 || privateKey[index] !== 48)
        return null;
      index += 1;
      if (length < index + 1 || !(privateKey[index] & 128))
        return null;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return null;
      if (length < index + lenb)
        return null;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length < index + len)
        return null;
      if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return null;
      }
      index += 3;
      if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
        return null;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports.signatureImportLax = function(signature) {
      var r = Buffer.alloc(32, 0);
      var s = Buffer.alloc(32, 0);
      var length = signature.length;
      var index = 0;
      if (signature[index++] !== 48) {
        return null;
      }
      var lenbyte = signature[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length) {
          return null;
        }
      }
      if (signature[index++] !== 2) {
        return null;
      }
      var rlen = signature[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1) {
        }
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
          rlen = (rlen << 8) + signature[index];
        }
      }
      if (rlen > length - index) {
        return null;
      }
      var rindex = index;
      index += rlen;
      if (signature[index++] !== 2) {
        return null;
      }
      var slen = signature[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1) {
        }
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
          slen = (slen << 8) + signature[index];
        }
      }
      if (slen > length - index) {
        return null;
      }
      var sindex = index;
      index += slen;
      for (; rlen > 0 && signature[rindex] === 0; rlen -= 1, rindex += 1) {
      }
      if (rlen > 32) {
        return null;
      }
      var rvalue = signature.slice(rindex, rindex + rlen);
      rvalue.copy(r, 32 - rvalue.length);
      for (; slen > 0 && signature[sindex] === 0; slen -= 1, sindex += 1) {
      }
      if (slen > 32) {
        return null;
      }
      var svalue = signature.slice(sindex, sindex + slen);
      svalue.copy(s, 32 - svalue.length);
      return { r, s };
    };
  }
});

// node_modules/web3-provider-engine/node_modules/ethereumjs-util/dist/secp256k1-adapter.js
var require_secp256k1_adapter = __commonJS({
  "node_modules/web3-provider-engine/node_modules/ethereumjs-util/dist/secp256k1-adapter.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var secp256k1 = require_secp256k1();
    var secp256k1v3 = require_secp256k1_lib();
    var der = require_der2();
    var privateKeyVerify = function privateKeyVerify2(privateKey) {
      if (privateKey.length !== 32) {
        return false;
      }
      return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
    };
    var privateKeyExport = function privateKeyExport2(privateKey, compressed) {
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
      return der.privateKeyExport(privateKey, publicKey, compressed);
    };
    var privateKeyImport = function privateKeyImport2(privateKey) {
      privateKey = der.privateKeyImport(privateKey);
      if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
        return privateKey;
      }
      throw new Error("couldn't import from DER format");
    };
    var privateKeyNegate = function privateKeyNegate2(privateKey) {
      return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
    };
    var privateKeyModInverse = function privateKeyModInverse2(privateKey) {
      if (privateKey.length !== 32) {
        throw new Error("private key length is invalid");
      }
      return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
    };
    var privateKeyTweakAdd = function privateKeyTweakAdd2(privateKey, tweak) {
      return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
    };
    var privateKeyTweakMul = function privateKeyTweakMul2(privateKey, tweak) {
      return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
    };
    var publicKeyCreate = function publicKeyCreate2(privateKey, compressed) {
      return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
    };
    var publicKeyConvert = function publicKeyConvert2(publicKey, compressed) {
      return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
    };
    var publicKeyVerify = function publicKeyVerify2(publicKey) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
      }
      return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
    };
    var publicKeyTweakAdd = function publicKeyTweakAdd2(publicKey, tweak, compressed) {
      return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    var publicKeyTweakMul = function publicKeyTweakMul2(publicKey, tweak, compressed) {
      return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    var publicKeyCombine = function publicKeyCombine2(publicKeys, compressed) {
      var keys = [];
      publicKeys.forEach(function(publicKey) {
        keys.push(Uint8Array.from(publicKey));
      });
      return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
    };
    var signatureNormalize = function signatureNormalize2(signature) {
      return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
    };
    var signatureExport = function signatureExport2(signature) {
      return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
    };
    var signatureImport = function signatureImport2(signature) {
      return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
    };
    var signatureImportLax = function signatureImportLax2(signature) {
      if (signature.length === 0) {
        throw new RangeError("signature length is invalid");
      }
      var sigObj = der.signatureImportLax(signature);
      if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
      }
      return secp256k1v3.signatureImport(sigObj);
    };
    var sign = function sign2(message, privateKey, options) {
      if (options === null) {
        throw new TypeError("options should be an Object");
      }
      var signOptions = void 0;
      if (options) {
        signOptions = {};
        if (options.data === null) {
          throw new TypeError("options.data should be a Buffer");
        }
        if (options.data) {
          if (options.data.length !== 32) {
            throw new RangeError("options.data length is invalid");
          }
          signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
          throw new TypeError("options.noncefn should be a Function");
        }
        if (options.noncefn) {
          signOptions.noncefn = function(message2, privateKey2, algo, data, attempt) {
            var bufferAlgo = algo != null ? Buffer.from(algo) : null;
            var bufferData = data != null ? Buffer.from(data) : null;
            var buffer = Buffer.from("");
            if (options.noncefn) {
              buffer = options.noncefn(Buffer.from(message2), Buffer.from(privateKey2), bufferAlgo, bufferData, attempt);
            }
            return Uint8Array.from(buffer);
          };
        }
      }
      var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
      return {
        signature: Buffer.from(sig.signature),
        recovery: sig.recid
      };
    };
    var verify = function verify2(message, signature, publicKey) {
      return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
    };
    var recover = function recover2(message, signature, recid, compressed) {
      return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
    };
    var ecdh = function ecdh2(publicKey, privateKey) {
      return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
    };
    var ecdhUnsafe = function ecdhUnsafe2(publicKey, privateKey, compressed) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError("public key length is invalid");
      }
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
    };
    module.exports = {
      privateKeyVerify,
      privateKeyExport,
      privateKeyImport,
      privateKeyNegate,
      privateKeyModInverse,
      privateKeyTweakAdd,
      privateKeyTweakMul,
      publicKeyCreate,
      publicKeyConvert,
      publicKeyVerify,
      publicKeyTweakAdd,
      publicKeyTweakMul,
      publicKeyCombine,
      signatureNormalize,
      signatureExport,
      signatureImport,
      signatureImportLax,
      sign,
      verify,
      recover,
      ecdh,
      ecdhUnsafe
    };
  }
});

// node_modules/web3-provider-engine/node_modules/ethereumjs-util/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/web3-provider-engine/node_modules/ethereumjs-util/dist/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _require = require_keccak();
    var keccak224 = _require.keccak224;
    var keccak384 = _require.keccak384;
    var k256 = _require.keccak256;
    var keccak512 = _require.keccak512;
    var secp256k1 = require_secp256k1_adapter();
    var assert = require_assert();
    var rlp = require_dist();
    var BN2 = require_bn();
    var createHash = require_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    Object.assign(exports, require_lib());
    exports.MAX_INTEGER = new BN2("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN2("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;
    exports.KECCAK256_NULL = Buffer2.from(exports.KECCAK256_NULL_S, "hex");
    exports.SHA3_NULL = exports.KECCAK256_NULL;
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;
    exports.KECCAK256_RLP_ARRAY = Buffer2.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;
    exports.KECCAK256_RLP = Buffer2.from(exports.KECCAK256_RLP_S, "hex");
    exports.SHA3_RLP = exports.KECCAK256_RLP;
    exports.BN = BN2;
    exports.rlp = rlp;
    exports.secp256k1 = secp256k1;
    exports.zeros = function(bytes) {
      return Buffer2.allocUnsafe(bytes).fill(0);
    };
    exports.zeroAddress = function() {
      var addressLength = 20;
      var zeroAddress = exports.zeros(addressLength);
      return exports.bufferToHex(zeroAddress);
    };
    exports.setLengthLeft = exports.setLength = function(msg, length, right) {
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = exports.stripZeros = function(a) {
      a = exports.stripHexPrefix(a);
      var first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    exports.toBuffer = function(v) {
      if (!Buffer2.isBuffer(v)) {
        if (Array.isArray(v)) {
          v = Buffer2.from(v);
        } else if (typeof v === "string") {
          if (exports.isHexString(v)) {
            v = Buffer2.from(exports.padToEven(exports.stripHexPrefix(v)), "hex");
          } else {
            v = Buffer2.from(v);
          }
        } else if (typeof v === "number") {
          v = exports.intToBuffer(v);
        } else if (v === null || v === void 0) {
          v = Buffer2.allocUnsafe(0);
        } else if (BN2.isBN(v)) {
          v = v.toArrayLike(Buffer2);
        } else if (v.toArray) {
          v = Buffer2.from(v.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v;
    };
    exports.bufferToInt = function(buf) {
      return new BN2(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN2(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer2.from(num.toTwos(256).toArray());
    };
    exports.keccak = function(a, bits) {
      a = exports.toBuffer(a);
      if (!bits)
        bits = 256;
      switch (bits) {
        case 224: {
          return keccak224(a);
        }
        case 256: {
          return k256(a);
        }
        case 384: {
          return keccak384(a);
        }
        case 512: {
          return keccak512(a);
        }
        default: {
          throw new Error("Invald algorithm: keccak" + bits);
        }
      }
    };
    exports.keccak256 = function(a) {
      return exports.keccak(a);
    };
    exports.sha3 = exports.keccak;
    exports.sha256 = function(a) {
      a = exports.toBuffer(a);
      return createHash("sha256").update(a).digest();
    };
    exports.ripemd160 = function(a, padded) {
      a = exports.toBuffer(a);
      var hash = createHash("rmd160").update(a).digest();
      if (padded === true) {
        return exports.setLength(hash, 32);
      } else {
        return hash;
      }
    };
    exports.rlphash = function(a) {
      return exports.keccak(rlp.encode(a));
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k1.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey, sanitize) {
      if (publicKey.length === 64) {
        return secp256k1.publicKeyVerify(Buffer2.concat([Buffer2.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k1.publicKeyVerify(publicKey);
    };
    exports.pubToAddress = exports.publicToAddress = function(pubKey, sanitize) {
      pubKey = exports.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
      }
      assert(pubKey.length === 64);
      return exports.keccak(pubKey).slice(-20);
    };
    var privateToPublic = exports.privateToPublic = function(privateKey) {
      privateKey = exports.toBuffer(privateKey);
      return secp256k1.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey) {
      publicKey = exports.toBuffer(publicKey);
      if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
      }
      return publicKey;
    };
    exports.ecsign = function(msgHash, privateKey) {
      var sig = secp256k1.sign(msgHash, privateKey);
      var ret = {};
      ret.r = sig.signature.slice(0, 32);
      ret.s = sig.signature.slice(32, 64);
      ret.v = sig.recovery + 27;
      return ret;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = exports.toBuffer("Ethereum Signed Message:\n" + message.length.toString());
      return exports.keccak(Buffer2.concat([prefix, message]));
    };
    exports.ecrecover = function(msgHash, v, r, s) {
      var signature = Buffer2.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
      var recovery = v - 27;
      if (recovery !== 0 && recovery !== 1) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
      return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v, r, s) {
      if (v !== 27 && v !== 28) {
        throw new Error("Invalid recovery id");
      }
      return exports.bufferToHex(Buffer2.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
    };
    exports.fromRpcSig = function(sig) {
      sig = exports.toBuffer(sig);
      if (sig.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v = sig[64];
      if (v < 27) {
        v += 27;
      }
      return {
        v,
        r: sig.slice(0, 32),
        s: sig.slice(32, 64)
      };
    };
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(privateToPublic(privateKey));
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddress = exports.zeroAddress();
      return zeroAddress === exports.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address) {
      address = exports.stripHexPrefix(address).toLowerCase();
      var hash = exports.keccak(address).toString("hex");
      var ret = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret += address[i].toUpperCase();
        } else {
          ret += address[i];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
    };
    exports.generateAddress = function(from, nonce) {
      from = exports.toBuffer(from);
      nonce = new BN2(nonce);
      if (nonce.isZero()) {
        nonce = null;
      } else {
        nonce = Buffer2.from(nonce.toArray());
      }
      return exports.rlphash([from, nonce]).slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a = exports.unpad(address);
      return a.length === 1 && a[0] >= 1 && a[0] <= 8;
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return exports.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.isValidSignature = function(v, r, s, homestead) {
      var SECP256K1_N_DIV_2 = new BN2("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r.length !== 32 || s.length !== 32) {
        return false;
      }
      if (v !== 27 && v !== 28) {
        return false;
      }
      r = new BN2(r);
      s = new BN2(s);
      if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
        return false;
      }
      if (homestead === false && new BN2(s).cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.baToJSON = function(ba) {
      if (Buffer2.isBuffer(ba)) {
        return "0x" + ba.toString("hex");
      } else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
          array.push(exports.baToJSON(ba[i]));
        }
        return array;
      }
    };
    exports.defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label) {
          var obj = {};
          self2._fields.forEach(function(field) {
            obj[field] = "0x" + self2[field].toString("hex");
          });
          return obj;
        }
        return exports.baToJSON(this.raw);
      };
      self2.serialize = function serialize() {
        return rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i];
        }
        function setter(v) {
          v = exports.toBuffer(v);
          if (v.toString("hex") === "00" && !field.allowZero) {
            v = Buffer2.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v = exports.stripZeros(v);
            assert(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v.length === 0) && field.length) {
            assert(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self2.raw[i] = v;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer2.from(exports.stripHexPrefix(data), "hex");
        }
        if (Buffer2.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d, i) {
            self2[self2._fields[i]] = exports.toBuffer(d);
          });
        } else if ((typeof data === "undefined" ? "undefined" : _typeof(data)) === "object") {
          var keys = Object.keys(data);
          fields.forEach(function(field) {
            if (keys.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    init_define_process_env();
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    init_define_process_env();
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    init_define_process_env();
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    init_define_process_env();
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    init_define_process_env();
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    init_define_process_env();
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    init_define_process_env();
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    init_define_process_env();
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    init_define_process_env();
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    init_define_process_env();
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module.exports = isArrayLike;
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {};
    module.exports = exports["default"];
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    init_define_process_env();
    function noop() {
    }
    module.exports = noop;
  }
});

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = once;
    function once(fn) {
      return function() {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(coll) {
      return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
    };
    var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
    module.exports = exports["default"];
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    init_define_process_env();
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    init_define_process_env();
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    init_define_process_env();
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    init_define_process_env();
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    init_define_process_env();
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    init_define_process_env();
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    init_define_process_env();
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    init_define_process_env();
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    init_define_process_env();
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    init_define_process_env();
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    init_define_process_env();
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    init_define_process_env();
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    init_define_process_env();
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    init_define_process_env();
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    init_define_process_env();
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    init_define_process_env();
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    init_define_process_env();
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    init_define_process_env();
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys;
  }
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/async/internal/iterator.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterator;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    var _keys = require_keys();
    var _keys2 = _interopRequireDefault(_keys);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator2) {
      var i = -1;
      return function next() {
        var item = iterator2.next();
        if (item.done)
          return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = (0, _keys2.default)(obj);
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function iterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator2 = (0, _getIterator2.default)(coll);
      return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = onlyOnce;
    function onlyOnce(fn) {
      return function() {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _eachOfLimit;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _eachOfLimit(limit) {
      return function(obj, iteratee, callback) {
        callback = (0, _once2.default)(callback || _noop2.default);
        if (limit <= 0 || !obj) {
          return callback(null);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (value === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/slice.js
var require_slice = __commonJS({
  "node_modules/async/internal/slice.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = slice;
    function slice(arrayLike, start) {
      start = start | 0;
      var newLen = Math.max(arrayLike.length - start, 0);
      var newArr = Array(newLen);
      for (var idx = 0; idx < newLen; idx++) {
        newArr[idx] = arrayLike[start + idx];
      }
      return newArr;
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(fn) {
      return function() {
        var args = (0, _slice2.default)(arguments);
        var callback = args.pop();
        fn.call(this, args, callback);
      };
    };
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hasNextTick = exports.hasSetImmediate = void 0;
    exports.fallback = fallback;
    exports.wrap = wrap;
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return function(fn) {
        var args = (0, _slice2.default)(arguments, 1);
        defer(function() {
          fn.apply(null, args);
        });
      };
    }
    var _defer;
    if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports.default = wrap(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = asyncify;
    var _isObject = require_isObject();
    var _isObject2 = _interopRequireDefault(_isObject);
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if ((0, _isObject2.default)(result) && typeof result.then === "function") {
          result.then(function(value) {
            invokeCallback(callback, null, value);
          }, function(err) {
            invokeCallback(callback, err.message ? err : new Error(err));
          });
        } else {
          callback(null, result);
        }
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (e) {
        (0, _setImmediate2.default)(rethrow, e);
      }
    }
    function rethrow(error) {
      throw error;
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var supportsSymbol = typeof Symbol === "function";
    function isAsync(fn) {
      return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function wrapAsync(asyncFn) {
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports.default = wrapAsync;
    exports.isAsync = isAsync;
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = eachOfLimit;
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/doLimit.js
var require_doLimit = __commonJS({
  "node_modules/async/internal/doLimit.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = doLimit;
    function doLimit(fn, limit) {
      return function(iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/async/eachOf.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    };
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _doLimit = require_doLimit();
    var _doLimit2 = _interopRequireDefault(_doLimit);
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      var index = 0, completed = 0, length = coll.length;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    var eachOfGeneric = (0, _doLimit2.default)(_eachOfLimit2.default, Infinity);
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/doParallel.js
var require_doParallel = __commonJS({
  "node_modules/async/internal/doParallel.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = doParallel;
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function doParallel(fn) {
      return function(obj, iteratee, callback) {
        return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/map.js
var require_map = __commonJS({
  "node_modules/async/internal/map.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _asyncMap;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      callback = callback || _noop2.default;
      arr = arr || [];
      var results = [];
      var counter = 0;
      var _iteratee = (0, _wrapAsync2.default)(iteratee);
      eachfn(arr, function(value, _, callback2) {
        var index = counter++;
        _iteratee(value, function(err, v) {
          results[index] = v;
          callback2(err);
        });
      }, function(err) {
        callback(err, results);
      });
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/map.js
var require_map2 = __commonJS({
  "node_modules/async/map.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _doParallel = require_doParallel();
    var _doParallel2 = _interopRequireDefault(_doParallel);
    var _map = require_map();
    var _map2 = _interopRequireDefault(_map);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (0, _doParallel2.default)(_map2.default);
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return function(value, index, callback) {
        return iteratee(value, callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachLimit.js
var require_eachLimit = __commonJS({
  "node_modules/async/eachLimit.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = eachLimit;
    var _eachOfLimit = require_eachOfLimit();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, limit, iteratee, callback) {
      (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachSeries.js
var require_eachSeries = __commonJS({
  "node_modules/async/eachSeries.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _eachLimit = require_eachLimit();
    var _eachLimit2 = _interopRequireDefault(_eachLimit);
    var _doLimit = require_doLimit();
    var _doLimit2 = _interopRequireDefault(_doLimit);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (0, _doLimit2.default)(_eachLimit2.default, 1);
    module.exports = exports["default"];
  }
});

// node_modules/web3-provider-engine/util/stoplight.js
var require_stoplight = __commonJS({
  "node_modules/web3-provider-engine/util/stoplight.js"(exports, module) {
    init_define_process_env();
    var EventEmitter = require_events().EventEmitter;
    var inherits = require_util().inherits;
    module.exports = Stoplight;
    inherits(Stoplight, EventEmitter);
    function Stoplight() {
      const self2 = this;
      EventEmitter.call(self2);
      self2.isLocked = true;
    }
    Stoplight.prototype.go = function() {
      const self2 = this;
      self2.isLocked = false;
      self2.emit("unlock");
    };
    Stoplight.prototype.stop = function() {
      const self2 = this;
      self2.isLocked = true;
      self2.emit("lock");
    };
    Stoplight.prototype.await = function(fn) {
      const self2 = this;
      if (self2.isLocked) {
        self2.once("unlock", fn);
      } else {
        setTimeout(fn);
      }
    };
  }
});

// node_modules/web3-provider-engine/util/rpc-cache-utils.js
var require_rpc_cache_utils = __commonJS({
  "node_modules/web3-provider-engine/util/rpc-cache-utils.js"(exports, module) {
    init_define_process_env();
    var stringify = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload, opts = {}) {
      if (!canCache(payload))
        return null;
      const { includeBlockRef } = opts;
      const params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload);
      return payload.method + ":" + stringify(params);
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
          return "fork";
        case "eth_gasPrice":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "eth_blockNumber":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
          return "never";
      }
    }
  }
});

// node_modules/web3-provider-engine/util/random-id.js
var require_random_id = __commonJS({
  "node_modules/web3-provider-engine/util/random-id.js"(exports, module) {
    init_define_process_env();
    module.exports = createRandomId;
    function createRandomId() {
      return Math.floor(Number.MAX_SAFE_INTEGER * Math.random());
    }
  }
});

// node_modules/web3-provider-engine/util/create-payload.js
var require_create_payload = __commonJS({
  "node_modules/web3-provider-engine/util/create-payload.js"(exports, module) {
    init_define_process_env();
    var getRandomId = require_random_id();
    var extend = require_immutable();
    module.exports = createPayload;
    function createPayload(data) {
      return extend({
        id: getRandomId(),
        jsonrpc: "2.0",
        params: []
      }, data);
    }
  }
});

// node_modules/web3-provider-engine/index.js
var require_web3_provider_engine = __commonJS({
  "node_modules/web3-provider-engine/index.js"(exports, module) {
    init_define_process_env();
    var EventEmitter = require_events().EventEmitter;
    var inherits = require_util().inherits;
    var ethUtil = require_dist3();
    var EthBlockTracker = require_polling();
    var map = require_map2();
    var eachSeries = require_eachSeries();
    var Stoplight = require_stoplight();
    var cacheUtils = require_rpc_cache_utils();
    var createPayload = require_create_payload();
    var noop = function() {
    };
    module.exports = Web3ProviderEngine;
    inherits(Web3ProviderEngine, EventEmitter);
    function Web3ProviderEngine(opts) {
      const self2 = this;
      EventEmitter.call(self2);
      self2.setMaxListeners(30);
      opts = opts || {};
      const directProvider = { sendAsync: self2._handleAsync.bind(self2) };
      const blockTrackerProvider = opts.blockTrackerProvider || directProvider;
      self2._blockTracker = opts.blockTracker || new EthBlockTracker({
        provider: blockTrackerProvider,
        pollingInterval: opts.pollingInterval || 4e3,
        setSkipCacheFlag: true
      });
      self2._ready = new Stoplight();
      self2.currentBlock = null;
      self2._providers = [];
    }
    Web3ProviderEngine.prototype.start = function(cb = noop) {
      const self2 = this;
      self2._ready.go();
      self2._blockTracker.on("latest", (blockNumber) => {
        self2._getBlockByNumberWithRetry(blockNumber, (err, block) => {
          if (err) {
            this.emit("error", err);
            return;
          }
          if (!block) {
            console.log(block);
            this.emit("error", new Error("Could not find block"));
            return;
          }
          const bufferBlock = toBufferBlock(block);
          self2._setCurrentBlock(bufferBlock);
          self2.emit("rawBlock", block);
          self2.emit("latest", block);
        });
      });
      self2._blockTracker.on("sync", self2.emit.bind(self2, "sync"));
      self2._blockTracker.on("error", self2.emit.bind(self2, "error"));
      self2._running = true;
      self2.emit("start");
    };
    Web3ProviderEngine.prototype.stop = function() {
      const self2 = this;
      self2._blockTracker.removeAllListeners();
      self2._running = false;
      self2.emit("stop");
    };
    Web3ProviderEngine.prototype.isRunning = function() {
      const self2 = this;
      return self2._running;
    };
    Web3ProviderEngine.prototype.addProvider = function(source, index) {
      const self2 = this;
      if (typeof index === "number") {
        self2._providers.splice(index, 0, source);
      } else {
        self2._providers.push(source);
      }
      source.setEngine(this);
    };
    Web3ProviderEngine.prototype.removeProvider = function(source) {
      const self2 = this;
      const index = self2._providers.indexOf(source);
      if (index < 0)
        throw new Error("Provider not found.");
      self2._providers.splice(index, 1);
    };
    Web3ProviderEngine.prototype.send = function(payload) {
      throw new Error("Web3ProviderEngine does not support synchronous requests.");
    };
    Web3ProviderEngine.prototype.sendAsync = function(payload, cb) {
      const self2 = this;
      self2._ready.await(function() {
        if (Array.isArray(payload)) {
          map(payload, self2._handleAsync.bind(self2), cb);
        } else {
          self2._handleAsync(payload, cb);
        }
      });
    };
    Web3ProviderEngine.prototype._getBlockByNumberWithRetry = function(blockNumber, cb) {
      const self2 = this;
      let retriesRemaining = 5;
      attemptRequest();
      return;
      function attemptRequest() {
        self2._getBlockByNumber(blockNumber, afterRequest);
      }
      function afterRequest(err, block) {
        if (err)
          return cb(err);
        if (!block) {
          if (retriesRemaining > 0) {
            retriesRemaining--;
            setTimeout(function() {
              attemptRequest();
            }, 1e3);
            return;
          } else {
            cb(null, null);
            return;
          }
        }
        cb(null, block);
        return;
      }
    };
    Web3ProviderEngine.prototype._getBlockByNumber = function(blockNumber, cb) {
      const req = createPayload({ method: "eth_getBlockByNumber", params: [blockNumber, false], skipCache: true });
      this._handleAsync(req, (err, res) => {
        if (err)
          return cb(err);
        return cb(null, res.result);
      });
    };
    Web3ProviderEngine.prototype._handleAsync = function(payload, finished) {
      var self2 = this;
      var currentProvider = -1;
      var result = null;
      var error = null;
      var stack = [];
      next();
      function next(after) {
        currentProvider += 1;
        stack.unshift(after);
        if (currentProvider >= self2._providers.length) {
          end(new Error('Request for method "' + payload.method + '" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'));
        } else {
          try {
            var provider = self2._providers[currentProvider];
            provider.handleRequest(payload, next, end);
          } catch (e) {
            end(e);
          }
        }
      }
      function end(_error, _result) {
        error = _error;
        result = _result;
        eachSeries(stack, function(fn, callback) {
          if (fn) {
            fn(error, result, callback);
          } else {
            callback();
          }
        }, function() {
          var resultObj = {
            id: payload.id,
            jsonrpc: payload.jsonrpc,
            result
          };
          if (error != null) {
            resultObj.error = {
              message: error.stack || error.message || error,
              code: -32e3
            };
            finished(error, resultObj);
          } else {
            finished(null, resultObj);
          }
        });
      }
    };
    Web3ProviderEngine.prototype._setCurrentBlock = function(block) {
      const self2 = this;
      self2.currentBlock = block;
      self2.emit("block", block);
    };
    function toBufferBlock(jsonBlock) {
      return {
        number: ethUtil.toBuffer(jsonBlock.number),
        hash: ethUtil.toBuffer(jsonBlock.hash),
        parentHash: ethUtil.toBuffer(jsonBlock.parentHash),
        nonce: ethUtil.toBuffer(jsonBlock.nonce),
        mixHash: ethUtil.toBuffer(jsonBlock.mixHash),
        sha3Uncles: ethUtil.toBuffer(jsonBlock.sha3Uncles),
        logsBloom: ethUtil.toBuffer(jsonBlock.logsBloom),
        transactionsRoot: ethUtil.toBuffer(jsonBlock.transactionsRoot),
        stateRoot: ethUtil.toBuffer(jsonBlock.stateRoot),
        receiptsRoot: ethUtil.toBuffer(jsonBlock.receiptRoot || jsonBlock.receiptsRoot),
        miner: ethUtil.toBuffer(jsonBlock.miner),
        difficulty: ethUtil.toBuffer(jsonBlock.difficulty),
        totalDifficulty: ethUtil.toBuffer(jsonBlock.totalDifficulty),
        size: ethUtil.toBuffer(jsonBlock.size),
        extraData: ethUtil.toBuffer(jsonBlock.extraData),
        gasLimit: ethUtil.toBuffer(jsonBlock.gasLimit),
        gasUsed: ethUtil.toBuffer(jsonBlock.gasUsed),
        timestamp: ethUtil.toBuffer(jsonBlock.timestamp),
        transactions: jsonBlock.transactions
      };
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/util/random-id.js
var require_random_id2 = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/util/random-id.js"(exports, module) {
    "use strict";
    init_define_process_env();
    module.exports = createRandomId;
    function createRandomId() {
      return Math.floor(Number.MAX_SAFE_INTEGER * Math.random());
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/util/create-payload.js
var require_create_payload2 = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/util/create-payload.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var getRandomId = require_random_id2();
    var extend = require_immutable();
    module.exports = createPayload;
    function createPayload(data) {
      return extend({
        id: getRandomId(),
        jsonrpc: "2.0",
        params: []
      }, data);
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/subprovider.js
var require_subprovider = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/subprovider.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var createPayload = require_create_payload2();
    module.exports = SubProvider;
    function SubProvider() {
    }
    SubProvider.prototype.setEngine = function(engine) {
      var self2 = this;
      if (self2.engine)
        return;
      self2.engine = engine;
      engine.on("block", function(block) {
        self2.currentBlock = block;
      });
      engine.on("start", function() {
        self2.start();
      });
      engine.on("stop", function() {
        self2.stop();
      });
    };
    SubProvider.prototype.handleRequest = function(payload, next, end) {
      throw new Error("Subproviders should override `handleRequest`.");
    };
    SubProvider.prototype.emitPayload = function(payload, cb) {
      var self2 = this;
      self2.engine.sendAsync(createPayload(payload), cb);
    };
    SubProvider.prototype.stop = function() {
    };
    SubProvider.prototype.start = function() {
    };
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/json-rpc-engine-middleware.js
var require_json_rpc_engine_middleware = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/json-rpc-engine-middleware.js"(exports, module) {
    "use strict";
    init_define_process_env();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var Subprovider = require_subprovider();
    var JsonRpcEngineMiddlewareSubprovider = function(_Subprovider) {
      _inherits(JsonRpcEngineMiddlewareSubprovider2, _Subprovider);
      var _super = _createSuper(JsonRpcEngineMiddlewareSubprovider2);
      function JsonRpcEngineMiddlewareSubprovider2(constructorFn) {
        var _this;
        _classCallCheck(this, JsonRpcEngineMiddlewareSubprovider2);
        _this = _super.call(this);
        if (!constructorFn)
          throw new Error("JsonRpcEngineMiddlewareSubprovider - no constructorFn specified");
        _this._constructorFn = constructorFn;
        return _this;
      }
      _createClass(JsonRpcEngineMiddlewareSubprovider2, [{
        key: "setEngine",
        value: function setEngine(engine) {
          if (this.middleware)
            throw new Error("JsonRpcEngineMiddlewareSubprovider - subprovider added to engine twice");
          var blockTracker = engine._blockTracker;
          var middleware = this._constructorFn({
            engine,
            provider: engine,
            blockTracker
          });
          if (!middleware)
            throw new Error("JsonRpcEngineMiddlewareSubprovider - _constructorFn did not return middleware");
          if (typeof middleware !== "function")
            throw new Error("JsonRpcEngineMiddlewareSubprovider - specified middleware is not a function");
          this.middleware = middleware;
        }
      }, {
        key: "handleRequest",
        value: function handleRequest(req, provEngNext, provEngEnd) {
          var res = {
            id: req.id
          };
          this.middleware(req, res, middlewareNext, middlewareEnd);
          function middlewareNext(handler) {
            provEngNext(function(err, result, cb) {
              if (err) {
                delete res.result;
                res.error = {
                  message: err.message || err
                };
              } else {
                res.result = result;
              }
              if (handler) {
                handler(cb);
              } else {
                cb();
              }
            });
          }
          function middlewareEnd(err) {
            if (err)
              return provEngEnd(err);
            provEngEnd(null, res.result);
          }
        }
      }]);
      return JsonRpcEngineMiddlewareSubprovider2;
    }(Subprovider);
    module.exports = JsonRpcEngineMiddlewareSubprovider;
  }
});

// node_modules/eth-json-rpc-middleware/cache-utils.js
var require_cache_utils = __commonJS({
  "node_modules/eth-json-rpc-middleware/cache-utils.js"(exports, module) {
    init_define_process_env();
    var stringify = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload, skipBlockRef) {
      const simpleParams = skipBlockRef ? paramsWithoutBlockTag(payload) : payload.params;
      if (canCache(payload)) {
        return payload.method + ":" + stringify(simpleParams);
      } else {
        return null;
      }
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      let index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      const index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
        case "test_permaCache":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
        case "test_forkCache":
          return "fork";
        case "eth_gasPrice":
        case "eth_blockNumber":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "test_blockCache":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
        case "test_neverCache":
          return "never";
      }
    }
  }
});

// node_modules/json-rpc-engine/src/createAsyncMiddleware.js
var require_createAsyncMiddleware = __commonJS({
  "node_modules/json-rpc-engine/src/createAsyncMiddleware.js"(exports, module) {
    init_define_process_env();
    module.exports = function createAsyncMiddleware(asyncMiddleware) {
      return (req, res, next, end) => {
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
          resolveNextPromise = resolve;
        });
        let returnHandlerCallback, nextWasCalled;
        const asyncNext = async () => {
          nextWasCalled = true;
          next((callback) => {
            returnHandlerCallback = callback;
            resolveNextPromise();
          });
          await nextPromise;
        };
        asyncMiddleware(req, res, asyncNext).then(async () => {
          if (nextWasCalled) {
            await nextPromise;
            returnHandlerCallback(null);
          } else {
            end(null);
          }
        }).catch((error) => {
          if (returnHandlerCallback) {
            returnHandlerCallback(error);
          } else {
            end(error);
          }
        });
      };
    };
  }
});

// node_modules/eth-json-rpc-middleware/block-cache.js
var require_block_cache = __commonJS({
  "node_modules/eth-json-rpc-middleware/block-cache.js"(exports, module) {
    init_define_process_env();
    var cacheUtils = require_cache_utils();
    var createAsyncMiddleware = require_createAsyncMiddleware();
    var emptyValues = [void 0, null, "<nil>"];
    module.exports = createBlockCacheMiddleware;
    function createBlockCacheMiddleware(opts = {}) {
      const { blockTracker } = opts;
      if (!blockTracker)
        throw new Error("createBlockCacheMiddleware - No BlockTracker specified");
      const blockCache = new BlockCacheStrategy();
      const strategies = {
        perma: blockCache,
        block: blockCache,
        fork: blockCache
      };
      return createAsyncMiddleware(async (req, res, next) => {
        if (req.skipCache) {
          return next();
        }
        const type = cacheUtils.cacheTypeForPayload(req);
        const strategy = strategies[type];
        if (!strategy) {
          return next();
        }
        if (!strategy.canCacheRequest(req)) {
          return next();
        }
        let blockTag = cacheUtils.blockTagForPayload(req);
        if (!blockTag)
          blockTag = "latest";
        let requestedBlockNumber;
        if (blockTag === "earliest") {
          requestedBlockNumber = "0x00";
        } else if (blockTag === "latest") {
          const latestBlockNumber = await blockTracker.getLatestBlock();
          blockCache.clearBefore(latestBlockNumber);
          requestedBlockNumber = latestBlockNumber;
        } else {
          requestedBlockNumber = blockTag;
        }
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === void 0) {
          await next();
          await strategy.set(req, requestedBlockNumber, res.result);
        } else {
          res.result = cacheResult;
        }
      });
    }
    var BlockCacheStrategy = class {
      constructor() {
        this.cache = {};
      }
      getBlockCacheForPayload(payload, blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        if (!blockCache) {
          const newCache = {};
          this.cache[blockNumber] = newCache;
          blockCache = newCache;
        }
        return blockCache;
      }
      async get(payload, requestedBlockNumber) {
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        if (!blockCache)
          return;
        const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
        const cached = blockCache[identifier];
        return cached;
      }
      async set(payload, requestedBlockNumber, result) {
        const canCache = this.canCacheResult(payload, result);
        if (!canCache)
          return;
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
        blockCache[identifier] = result;
      }
      canCacheRequest(payload) {
        if (!cacheUtils.canCache(payload)) {
          return false;
        }
        const blockTag = cacheUtils.blockTagForPayload(payload);
        if (blockTag === "pending") {
          return false;
        }
        return true;
      }
      canCacheResult(payload, result) {
        if (emptyValues.includes(result))
          return;
        if (["eth_getTransactionByHash", "eth_getTransactionReceipt"].includes(payload.method)) {
          if (!result || !result.blockHash || result.blockHash === "0x0000000000000000000000000000000000000000000000000000000000000000") {
            return false;
          }
        }
        return true;
      }
      clearBefore(oldBlockHex) {
        const self2 = this;
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        Object.keys(self2.cache).map(Number).filter((num) => num < oldBlockNumber).forEach((num) => delete self2.cache[num]);
      }
    };
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/cache.js
var require_cache = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/cache.js"(exports, module) {
    "use strict";
    init_define_process_env();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createBlockCacheMiddleware = require_block_cache();
    var BlockCacheSubprovider = function(_ProviderSubprovider) {
      _inherits(BlockCacheSubprovider2, _ProviderSubprovider);
      var _super = _createSuper(BlockCacheSubprovider2);
      function BlockCacheSubprovider2(opts) {
        _classCallCheck(this, BlockCacheSubprovider2);
        return _super.call(this, function(_ref) {
          var blockTracker = _ref.blockTracker;
          return createBlockCacheMiddleware(Object.assign({
            blockTracker
          }, opts));
        });
      }
      return BlockCacheSubprovider2;
    }(ProviderSubprovider);
    module.exports = BlockCacheSubprovider;
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/fixture.js
var require_fixture = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/fixture.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var inherits = require_util().inherits;
    var Subprovider = require_subprovider();
    module.exports = FixtureProvider;
    inherits(FixtureProvider, Subprovider);
    function FixtureProvider(staticResponses) {
      var self2 = this;
      staticResponses = staticResponses || {};
      self2.staticResponses = staticResponses;
    }
    FixtureProvider.prototype.handleRequest = function(payload, next, end) {
      var self2 = this;
      var staticResponse = self2.staticResponses[payload.method];
      if (typeof staticResponse === "function") {
        staticResponse(payload, next, end);
      } else if (staticResponse !== void 0) {
        setTimeout(function() {
          return end(null, staticResponse);
        });
      } else {
        next();
      }
    };
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/filters.js
var require_filters = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/filters.js"(exports, module) {
    "use strict";
    init_define_process_env();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var SubscriptionsSubprovider2 = function(_ProviderSubprovider) {
      _inherits(SubscriptionsSubprovider3, _ProviderSubprovider);
      var _super = _createSuper(SubscriptionsSubprovider3);
      function SubscriptionsSubprovider3() {
        _classCallCheck(this, SubscriptionsSubprovider3);
        return _super.call(this, function(_ref) {
          var blockTracker = _ref.blockTracker, provider = _ref.provider, engine = _ref.engine;
          return createFilterMiddleware({
            blockTracker,
            provider
          });
        });
      }
      return SubscriptionsSubprovider3;
    }(ProviderSubprovider);
    module.exports = SubscriptionsSubprovider2;
  }
});

// node_modules/async/waterfall.js
var require_waterfall = __commonJS({
  "node_modules/async/waterfall.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(tasks, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      if (!(0, _isArray2.default)(tasks))
        return callback(new Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args) {
        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
        args.push((0, _onlyOnce2.default)(next));
        task.apply(null, args);
      }
      function next(err) {
        if (err || taskIndex === tasks.length) {
          return callback.apply(null, arguments);
        }
        nextTask((0, _slice2.default)(arguments, 1));
      }
      nextTask([]);
    };
    var _isArray = require_isArray();
    var _isArray2 = _interopRequireDefault(_isArray);
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/async/internal/parallel.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _parallel;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _parallel(eachfn, tasks, callback) {
      callback = callback || _noop2.default;
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, function(task, key, callback2) {
        (0, _wrapAsync2.default)(task)(function(err, result) {
          if (arguments.length > 2) {
            result = (0, _slice2.default)(arguments, 1);
          }
          results[key] = result;
          callback2(err);
        });
      }, function(err) {
        callback(err, results);
      });
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/parallel.js
var require_parallel2 = __commonJS({
  "node_modules/async/parallel.js"(exports, module) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = parallelLimit;
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _parallel = require_parallel();
    var _parallel2 = _interopRequireDefault(_parallel);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parallelLimit(tasks, callback) {
      (0, _parallel2.default)(_eachOf2.default, tasks, callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/secp256k1-lib/index.js
var require_secp256k1_lib2 = __commonJS({
  "node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/secp256k1-lib/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var BN2 = require_bn();
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    exports.privateKeyExport = function(privateKey, compressed) {
      var d = new BN2(privateKey);
      if (d.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
      }
      var point = ec.g.mul(d);
      return toPublicKey(point.getX(), point.getY(), compressed);
    };
    exports.privateKeyModInverse = function(privateKey) {
      var bn = new BN2(privateKey);
      if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
        throw new Error("private key range is invalid");
      }
      return bn.invm(ecparams.n).toArrayLike(Buffer, "be", 32);
    };
    exports.signatureImport = function(sigObj) {
      var r = new BN2(sigObj.r);
      if (r.ucmp(ecparams.n) >= 0) {
        r = new BN2(0);
      }
      var s = new BN2(sigObj.s);
      if (s.ucmp(ecparams.n) >= 0) {
        s = new BN2(0);
      }
      return Buffer.concat([r.toArrayLike(Buffer, "be", 32), s.toArrayLike(Buffer, "be", 32)]);
    };
    exports.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      var point = ec.keyFromPublic(publicKey);
      var scalar = new BN2(privateKey);
      if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error("scalar was invalid (zero or overflow)");
      }
      var shared = point.pub.mul(scalar);
      return toPublicKey(shared.getX(), shared.getY(), compressed);
    };
    var toPublicKey = function toPublicKey2(x, y, compressed) {
      var publicKey = void 0;
      if (compressed) {
        publicKey = Buffer.alloc(33);
        publicKey[0] = y.isOdd() ? 3 : 2;
        x.toArrayLike(Buffer, "be", 32).copy(publicKey, 1);
      } else {
        publicKey = Buffer.alloc(65);
        publicKey[0] = 4;
        x.toArrayLike(Buffer, "be", 32).copy(publicKey, 1);
        y.toArrayLike(Buffer, "be", 32).copy(publicKey, 33);
      }
      return publicKey;
    };
  }
});

// node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/secp256k1-lib/der.js
var require_der3 = __commonJS({
  "node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/secp256k1-lib/der.js"(exports) {
    "use strict";
    init_define_process_env();
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.privateKeyExport = function(privateKey, publicKey, compressed) {
      var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports.privateKeyImport = function(privateKey) {
      var length = privateKey.length;
      var index = 0;
      if (length < index + 1 || privateKey[index] !== 48)
        return null;
      index += 1;
      if (length < index + 1 || !(privateKey[index] & 128))
        return null;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return null;
      if (length < index + lenb)
        return null;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length < index + len)
        return null;
      if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return null;
      }
      index += 3;
      if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
        return null;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports.signatureImportLax = function(signature) {
      var r = Buffer.alloc(32, 0);
      var s = Buffer.alloc(32, 0);
      var length = signature.length;
      var index = 0;
      if (signature[index++] !== 48) {
        return null;
      }
      var lenbyte = signature[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length) {
          return null;
        }
      }
      if (signature[index++] !== 2) {
        return null;
      }
      var rlen = signature[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1) {
        }
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
          rlen = (rlen << 8) + signature[index];
        }
      }
      if (rlen > length - index) {
        return null;
      }
      var rindex = index;
      index += rlen;
      if (signature[index++] !== 2) {
        return null;
      }
      var slen = signature[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1) {
        }
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
          slen = (slen << 8) + signature[index];
        }
      }
      if (slen > length - index) {
        return null;
      }
      var sindex = index;
      index += slen;
      for (; rlen > 0 && signature[rindex] === 0; rlen -= 1, rindex += 1) {
      }
      if (rlen > 32) {
        return null;
      }
      var rvalue = signature.slice(rindex, rindex + rlen);
      rvalue.copy(r, 32 - rvalue.length);
      for (; slen > 0 && signature[sindex] === 0; slen -= 1, sindex += 1) {
      }
      if (slen > 32) {
        return null;
      }
      var svalue = signature.slice(sindex, sindex + slen);
      svalue.copy(s, 32 - svalue.length);
      return { r, s };
    };
  }
});

// node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/secp256k1-adapter.js
var require_secp256k1_adapter2 = __commonJS({
  "node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/secp256k1-adapter.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var secp256k1 = require_secp256k1();
    var secp256k1v3 = require_secp256k1_lib2();
    var der = require_der3();
    var privateKeyVerify = function privateKeyVerify2(privateKey) {
      if (privateKey.length !== 32) {
        return false;
      }
      return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
    };
    var privateKeyExport = function privateKeyExport2(privateKey, compressed) {
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
      return der.privateKeyExport(privateKey, publicKey, compressed);
    };
    var privateKeyImport = function privateKeyImport2(privateKey) {
      privateKey = der.privateKeyImport(privateKey);
      if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
        return privateKey;
      }
      throw new Error("couldn't import from DER format");
    };
    var privateKeyNegate = function privateKeyNegate2(privateKey) {
      return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
    };
    var privateKeyModInverse = function privateKeyModInverse2(privateKey) {
      if (privateKey.length !== 32) {
        throw new Error("private key length is invalid");
      }
      return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
    };
    var privateKeyTweakAdd = function privateKeyTweakAdd2(privateKey, tweak) {
      return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
    };
    var privateKeyTweakMul = function privateKeyTweakMul2(privateKey, tweak) {
      return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
    };
    var publicKeyCreate = function publicKeyCreate2(privateKey, compressed) {
      return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
    };
    var publicKeyConvert = function publicKeyConvert2(publicKey, compressed) {
      return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
    };
    var publicKeyVerify = function publicKeyVerify2(publicKey) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
      }
      return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
    };
    var publicKeyTweakAdd = function publicKeyTweakAdd2(publicKey, tweak, compressed) {
      return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    var publicKeyTweakMul = function publicKeyTweakMul2(publicKey, tweak, compressed) {
      return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    var publicKeyCombine = function publicKeyCombine2(publicKeys, compressed) {
      var keys = [];
      publicKeys.forEach(function(publicKey) {
        keys.push(Uint8Array.from(publicKey));
      });
      return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
    };
    var signatureNormalize = function signatureNormalize2(signature) {
      return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
    };
    var signatureExport = function signatureExport2(signature) {
      return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
    };
    var signatureImport = function signatureImport2(signature) {
      return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
    };
    var signatureImportLax = function signatureImportLax2(signature) {
      if (signature.length === 0) {
        throw new RangeError("signature length is invalid");
      }
      var sigObj = der.signatureImportLax(signature);
      if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
      }
      return secp256k1v3.signatureImport(sigObj);
    };
    var sign = function sign2(message, privateKey, options) {
      if (options === null) {
        throw new TypeError("options should be an Object");
      }
      var signOptions = void 0;
      if (options) {
        signOptions = {};
        if (options.data === null) {
          throw new TypeError("options.data should be a Buffer");
        }
        if (options.data) {
          if (options.data.length !== 32) {
            throw new RangeError("options.data length is invalid");
          }
          signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
          throw new TypeError("options.noncefn should be a Function");
        }
        if (options.noncefn) {
          signOptions.noncefn = function(message2, privateKey2, algo, data, attempt) {
            var bufferAlgo = algo != null ? Buffer.from(algo) : null;
            var bufferData = data != null ? Buffer.from(data) : null;
            var buffer = Buffer.from("");
            if (options.noncefn) {
              buffer = options.noncefn(Buffer.from(message2), Buffer.from(privateKey2), bufferAlgo, bufferData, attempt);
            }
            return Uint8Array.from(buffer);
          };
        }
      }
      var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
      return {
        signature: Buffer.from(sig.signature),
        recovery: sig.recid
      };
    };
    var verify = function verify2(message, signature, publicKey) {
      return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
    };
    var recover = function recover2(message, signature, recid, compressed) {
      return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
    };
    var ecdh = function ecdh2(publicKey, privateKey) {
      return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
    };
    var ecdhUnsafe = function ecdhUnsafe2(publicKey, privateKey, compressed) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError("public key length is invalid");
      }
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
    };
    module.exports = {
      privateKeyVerify,
      privateKeyExport,
      privateKeyImport,
      privateKeyNegate,
      privateKeyModInverse,
      privateKeyTweakAdd,
      privateKeyTweakMul,
      publicKeyCreate,
      publicKeyConvert,
      publicKeyVerify,
      publicKeyTweakAdd,
      publicKeyTweakMul,
      publicKeyCombine,
      signatureNormalize,
      signatureExport,
      signatureImport,
      signatureImportLax,
      sign,
      verify,
      recover,
      ecdh,
      ecdhUnsafe
    };
  }
});

// node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _require = require_keccak();
    var keccak224 = _require.keccak224;
    var keccak384 = _require.keccak384;
    var k256 = _require.keccak256;
    var keccak512 = _require.keccak512;
    var secp256k1 = require_secp256k1_adapter2();
    var assert = require_assert();
    var rlp = require_dist();
    var BN2 = require_bn();
    var createHash = require_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    Object.assign(exports, require_lib());
    exports.MAX_INTEGER = new BN2("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN2("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;
    exports.KECCAK256_NULL = Buffer2.from(exports.KECCAK256_NULL_S, "hex");
    exports.SHA3_NULL = exports.KECCAK256_NULL;
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;
    exports.KECCAK256_RLP_ARRAY = Buffer2.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;
    exports.KECCAK256_RLP = Buffer2.from(exports.KECCAK256_RLP_S, "hex");
    exports.SHA3_RLP = exports.KECCAK256_RLP;
    exports.BN = BN2;
    exports.rlp = rlp;
    exports.secp256k1 = secp256k1;
    exports.zeros = function(bytes) {
      return Buffer2.allocUnsafe(bytes).fill(0);
    };
    exports.zeroAddress = function() {
      var addressLength = 20;
      var zeroAddress = exports.zeros(addressLength);
      return exports.bufferToHex(zeroAddress);
    };
    exports.setLengthLeft = exports.setLength = function(msg, length, right) {
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = exports.stripZeros = function(a) {
      a = exports.stripHexPrefix(a);
      var first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    exports.toBuffer = function(v) {
      if (!Buffer2.isBuffer(v)) {
        if (Array.isArray(v)) {
          v = Buffer2.from(v);
        } else if (typeof v === "string") {
          if (exports.isHexString(v)) {
            v = Buffer2.from(exports.padToEven(exports.stripHexPrefix(v)), "hex");
          } else {
            v = Buffer2.from(v);
          }
        } else if (typeof v === "number") {
          v = exports.intToBuffer(v);
        } else if (v === null || v === void 0) {
          v = Buffer2.allocUnsafe(0);
        } else if (BN2.isBN(v)) {
          v = v.toArrayLike(Buffer2);
        } else if (v.toArray) {
          v = Buffer2.from(v.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v;
    };
    exports.bufferToInt = function(buf) {
      return new BN2(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN2(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer2.from(num.toTwos(256).toArray());
    };
    exports.keccak = function(a, bits) {
      a = exports.toBuffer(a);
      if (!bits)
        bits = 256;
      switch (bits) {
        case 224: {
          return keccak224(a);
        }
        case 256: {
          return k256(a);
        }
        case 384: {
          return keccak384(a);
        }
        case 512: {
          return keccak512(a);
        }
        default: {
          throw new Error("Invald algorithm: keccak" + bits);
        }
      }
    };
    exports.keccak256 = function(a) {
      return exports.keccak(a);
    };
    exports.sha3 = exports.keccak;
    exports.sha256 = function(a) {
      a = exports.toBuffer(a);
      return createHash("sha256").update(a).digest();
    };
    exports.ripemd160 = function(a, padded) {
      a = exports.toBuffer(a);
      var hash = createHash("rmd160").update(a).digest();
      if (padded === true) {
        return exports.setLength(hash, 32);
      } else {
        return hash;
      }
    };
    exports.rlphash = function(a) {
      return exports.keccak(rlp.encode(a));
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k1.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey, sanitize) {
      if (publicKey.length === 64) {
        return secp256k1.publicKeyVerify(Buffer2.concat([Buffer2.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k1.publicKeyVerify(publicKey);
    };
    exports.pubToAddress = exports.publicToAddress = function(pubKey, sanitize) {
      pubKey = exports.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
      }
      assert(pubKey.length === 64);
      return exports.keccak(pubKey).slice(-20);
    };
    var privateToPublic = exports.privateToPublic = function(privateKey) {
      privateKey = exports.toBuffer(privateKey);
      return secp256k1.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey) {
      publicKey = exports.toBuffer(publicKey);
      if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
      }
      return publicKey;
    };
    exports.ecsign = function(msgHash, privateKey) {
      var sig = secp256k1.sign(msgHash, privateKey);
      var ret = {};
      ret.r = sig.signature.slice(0, 32);
      ret.s = sig.signature.slice(32, 64);
      ret.v = sig.recovery + 27;
      return ret;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = exports.toBuffer("Ethereum Signed Message:\n" + message.length.toString());
      return exports.keccak(Buffer2.concat([prefix, message]));
    };
    exports.ecrecover = function(msgHash, v, r, s) {
      var signature = Buffer2.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
      var recovery = v - 27;
      if (recovery !== 0 && recovery !== 1) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
      return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v, r, s) {
      if (v !== 27 && v !== 28) {
        throw new Error("Invalid recovery id");
      }
      return exports.bufferToHex(Buffer2.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
    };
    exports.fromRpcSig = function(sig) {
      sig = exports.toBuffer(sig);
      if (sig.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v = sig[64];
      if (v < 27) {
        v += 27;
      }
      return {
        v,
        r: sig.slice(0, 32),
        s: sig.slice(32, 64)
      };
    };
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(privateToPublic(privateKey));
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddress = exports.zeroAddress();
      return zeroAddress === exports.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address) {
      address = exports.stripHexPrefix(address).toLowerCase();
      var hash = exports.keccak(address).toString("hex");
      var ret = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret += address[i].toUpperCase();
        } else {
          ret += address[i];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
    };
    exports.generateAddress = function(from, nonce) {
      from = exports.toBuffer(from);
      nonce = new BN2(nonce);
      if (nonce.isZero()) {
        nonce = null;
      } else {
        nonce = Buffer2.from(nonce.toArray());
      }
      return exports.rlphash([from, nonce]).slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a = exports.unpad(address);
      return a.length === 1 && a[0] >= 1 && a[0] <= 8;
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return exports.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.isValidSignature = function(v, r, s, homestead) {
      var SECP256K1_N_DIV_2 = new BN2("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r.length !== 32 || s.length !== 32) {
        return false;
      }
      if (v !== 27 && v !== 28) {
        return false;
      }
      r = new BN2(r);
      s = new BN2(s);
      if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
        return false;
      }
      if (homestead === false && new BN2(s).cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.baToJSON = function(ba) {
      if (Buffer2.isBuffer(ba)) {
        return "0x" + ba.toString("hex");
      } else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
          array.push(exports.baToJSON(ba[i]));
        }
        return array;
      }
    };
    exports.defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label) {
          var obj = {};
          self2._fields.forEach(function(field) {
            obj[field] = "0x" + self2[field].toString("hex");
          });
          return obj;
        }
        return exports.baToJSON(this.raw);
      };
      self2.serialize = function serialize() {
        return rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i];
        }
        function setter(v) {
          v = exports.toBuffer(v);
          if (v.toString("hex") === "00" && !field.allowZero) {
            v = Buffer2.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v = exports.stripZeros(v);
            assert(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v.length === 0) && field.length) {
            assert(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self2.raw[i] = v;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer2.from(exports.stripHexPrefix(data), "hex");
        }
        if (Buffer2.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d, i) {
            self2[self2._fields[i]] = exports.toBuffer(d);
          });
        } else if ((typeof data === "undefined" ? "undefined" : _typeof(data)) === "object") {
          var keys = Object.keys(data);
          fields.forEach(function(field) {
            if (keys.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// node_modules/eth-sig-util/index.js
var require_eth_sig_util = __commonJS({
  "node_modules/eth-sig-util/index.js"(exports, module) {
    init_define_process_env();
    var ethUtil = require_dist4();
    var ethAbi = require_ethereumjs_abi();
    module.exports = {
      concatSig: function(v, r, s) {
        const rSig = ethUtil.fromSigned(r);
        const sSig = ethUtil.fromSigned(s);
        const vSig = ethUtil.bufferToInt(v);
        const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString("hex"), 64);
        const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString("hex"), 64);
        const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));
        return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString("hex");
      },
      normalize: function(input) {
        if (!input)
          return;
        if (typeof input === "number") {
          const buffer = ethUtil.toBuffer(input);
          input = ethUtil.bufferToHex(buffer);
        }
        if (typeof input !== "string") {
          var msg = "eth-sig-util.normalize() requires hex string or integer input.";
          msg += " received " + typeof input + ": " + input;
          throw new Error(msg);
        }
        return ethUtil.addHexPrefix(input.toLowerCase());
      },
      personalSign: function(privateKey, msgParams) {
        var message = ethUtil.toBuffer(msgParams.data);
        var msgHash = ethUtil.hashPersonalMessage(message);
        var sig = ethUtil.ecsign(msgHash, privateKey);
        var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
        return serialized;
      },
      recoverPersonalSignature: function(msgParams) {
        const publicKey = getPublicKeyFor(msgParams);
        const sender = ethUtil.publicToAddress(publicKey);
        const senderHex = ethUtil.bufferToHex(sender);
        return senderHex;
      },
      extractPublicKey: function(msgParams) {
        const publicKey = getPublicKeyFor(msgParams);
        return "0x" + publicKey.toString("hex");
      },
      typedSignatureHash: function(typedData) {
        const hashBuffer = typedSignatureHash(typedData);
        return ethUtil.bufferToHex(hashBuffer);
      },
      signTypedData: function(privateKey, msgParams) {
        const msgHash = typedSignatureHash(msgParams.data);
        const sig = ethUtil.ecsign(msgHash, privateKey);
        return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
      },
      recoverTypedSignature: function(msgParams) {
        const msgHash = typedSignatureHash(msgParams.data);
        const publicKey = recoverPublicKey(msgHash, msgParams.sig);
        const sender = ethUtil.publicToAddress(publicKey);
        return ethUtil.bufferToHex(sender);
      }
    };
    function typedSignatureHash(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length)
        throw error;
      const data = typedData.map(function(e) {
        return e.type === "bytes" ? ethUtil.toBuffer(e.value) : e.value;
      });
      const types = typedData.map(function(e) {
        return e.type;
      });
      const schema = typedData.map(function(e) {
        if (!e.name)
          throw error;
        return e.type + " " + e.name;
      });
      return ethAbi.soliditySHA3(["bytes32", "bytes32"], [
        ethAbi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
        ethAbi.soliditySHA3(types, data)
      ]);
    }
    function recoverPublicKey(hash, sig) {
      const signature = ethUtil.toBuffer(sig);
      const sigParams = ethUtil.fromRpcSig(signature);
      return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);
    }
    function getPublicKeyFor(msgParams) {
      const message = ethUtil.toBuffer(msgParams.data);
      const msgHash = ethUtil.hashPersonalMessage(message);
      return recoverPublicKey(msgHash, msgParams.sig);
    }
    function padWithZeroes(number, length) {
      var myString = "" + number;
      while (myString.length < length) {
        myString = "0" + myString;
      }
      return myString;
    }
  }
});

// node_modules/semaphore/lib/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/semaphore/lib/semaphore.js"(exports, module) {
    init_define_process_env();
    (function(global2) {
      "use strict";
      var nextTick = function(fn) {
        setTimeout(fn, 0);
      };
      if (typeof process != "undefined" && process && typeof process.nextTick == "function") {
        nextTick = process.nextTick;
      }
      function semaphore(capacity) {
        var semaphore2 = {
          capacity: capacity || 1,
          current: 0,
          queue: [],
          firstHere: false,
          take: function() {
            if (semaphore2.firstHere === false) {
              semaphore2.current++;
              semaphore2.firstHere = true;
              var isFirst = 1;
            } else {
              var isFirst = 0;
            }
            var item = { n: 1 };
            if (typeof arguments[0] == "function") {
              item.task = arguments[0];
            } else {
              item.n = arguments[0];
            }
            if (arguments.length >= 2) {
              if (typeof arguments[1] == "function")
                item.task = arguments[1];
              else
                item.n = arguments[1];
            }
            var task = item.task;
            item.task = function() {
              task(semaphore2.leave);
            };
            if (semaphore2.current + item.n - isFirst > semaphore2.capacity) {
              if (isFirst === 1) {
                semaphore2.current--;
                semaphore2.firstHere = false;
              }
              return semaphore2.queue.push(item);
            }
            semaphore2.current += item.n - isFirst;
            item.task(semaphore2.leave);
            if (isFirst === 1)
              semaphore2.firstHere = false;
          },
          leave: function(n) {
            n = n || 1;
            semaphore2.current -= n;
            if (!semaphore2.queue.length) {
              if (semaphore2.current < 0) {
                throw new Error("leave called too many times.");
              }
              return;
            }
            var item = semaphore2.queue[0];
            if (item.n + semaphore2.current > semaphore2.capacity) {
              return;
            }
            semaphore2.queue.shift();
            semaphore2.current += item.n;
            nextTick(item.task);
          },
          available: function(n) {
            n = n || 1;
            return semaphore2.current + n <= semaphore2.capacity;
          }
        };
        return semaphore2;
      }
      ;
      if (typeof exports === "object") {
        module.exports = semaphore;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return semaphore;
        });
      } else {
        global2.semaphore = semaphore;
      }
    })(exports);
  }
});

// node_modules/web3-provider-engine/dist/es5/util/estimate-gas.js
var require_estimate_gas = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/util/estimate-gas.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var createPayload = require_create_payload2();
    module.exports = estimateGas;
    function estimateGas(provider, txParams, cb) {
      provider.sendAsync(createPayload({
        method: "eth_estimateGas",
        params: [txParams]
      }), function(err, res) {
        if (err) {
          if (err.message === "no contract code at given address") {
            return cb(null, "0xcf08");
          } else {
            return cb(err);
          }
        }
        cb(null, res.result);
      });
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/hooked-wallet.js
var require_hooked_wallet = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/hooked-wallet.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var waterfall = require_waterfall();
    var parallel = require_parallel2();
    var inherits = require_util().inherits;
    var ethUtil = require_dist3();
    var sigUtil = require_eth_sig_util();
    var extend = require_immutable();
    var Semaphore = require_semaphore();
    var Subprovider = require_subprovider();
    var estimateGas = require_estimate_gas();
    var hexRegex = /^[0-9A-Fa-f]+$/g;
    module.exports = HookedWalletSubprovider2;
    inherits(HookedWalletSubprovider2, Subprovider);
    function HookedWalletSubprovider2(opts) {
      var self2 = this;
      self2.nonceLock = Semaphore(1);
      if (opts.getAccounts)
        self2.getAccounts = opts.getAccounts;
      if (opts.processTransaction)
        self2.processTransaction = opts.processTransaction;
      if (opts.processMessage)
        self2.processMessage = opts.processMessage;
      if (opts.processPersonalMessage)
        self2.processPersonalMessage = opts.processPersonalMessage;
      if (opts.processTypedMessage)
        self2.processTypedMessage = opts.processTypedMessage;
      self2.approveTransaction = opts.approveTransaction || self2.autoApprove;
      self2.approveMessage = opts.approveMessage || self2.autoApprove;
      self2.approvePersonalMessage = opts.approvePersonalMessage || self2.autoApprove;
      self2.approveDecryptMessage = opts.approveDecryptMessage || self2.autoApprove;
      self2.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self2.autoApprove;
      self2.approveTypedMessage = opts.approveTypedMessage || self2.autoApprove;
      if (opts.signTransaction)
        self2.signTransaction = opts.signTransaction || mustProvideInConstructor("signTransaction");
      if (opts.signMessage)
        self2.signMessage = opts.signMessage || mustProvideInConstructor("signMessage");
      if (opts.signPersonalMessage)
        self2.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor("signPersonalMessage");
      if (opts.decryptMessage)
        self2.decryptMessage = opts.decryptMessage || mustProvideInConstructor("decryptMessage");
      if (opts.encryptionPublicKey)
        self2.encryptionPublicKey = opts.encryptionPublicKey || mustProvideInConstructor("encryptionPublicKey");
      if (opts.signTypedMessage)
        self2.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor("signTypedMessage");
      if (opts.recoverPersonalSignature)
        self2.recoverPersonalSignature = opts.recoverPersonalSignature;
      if (opts.publishTransaction)
        self2.publishTransaction = opts.publishTransaction;
      self2.estimateGas = opts.estimateGas || self2.estimateGas;
      self2.getGasPrice = opts.getGasPrice || self2.getGasPrice;
    }
    HookedWalletSubprovider2.prototype.handleRequest = function(payload, next, end) {
      var self2 = this;
      self2._parityRequests = {};
      self2._parityRequestCount = 0;
      var txParams, msgParams, extraParams;
      var message, address;
      switch (payload.method) {
        case "eth_coinbase":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            var result = accounts[0] || null;
            end(null, result);
          });
          return;
        case "eth_accounts":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            end(null, accounts);
          });
          return;
        case "eth_sendTransaction":
          txParams = payload.params[0];
          waterfall([function(cb) {
            return self2.validateTransaction(txParams, cb);
          }, function(cb) {
            return self2.processTransaction(txParams, cb);
          }], end);
          return;
        case "eth_signTransaction":
          txParams = payload.params[0];
          waterfall([function(cb) {
            return self2.validateTransaction(txParams, cb);
          }, function(cb) {
            return self2.processSignTransaction(txParams, cb);
          }], end);
          return;
        case "eth_sign":
          address = payload.params[0];
          message = payload.params[1];
          extraParams = payload.params[2] || {};
          msgParams = extend(extraParams, {
            from: address,
            data: message
          });
          waterfall([function(cb) {
            return self2.validateMessage(msgParams, cb);
          }, function(cb) {
            return self2.processMessage(msgParams, cb);
          }], end);
          return;
        case "personal_sign":
          return function() {
            var first = payload.params[0];
            var second = payload.params[1];
            if (resemblesData(second) && resemblesAddress(first)) {
              var warning = "The eth_personalSign method requires params ordered ";
              warning += "[message, address]. This was previously handled incorrectly, ";
              warning += "and has been corrected automatically. ";
              warning += "Please switch this param order for smooth behavior in the future.";
              console.warn(warning);
              address = payload.params[0];
              message = payload.params[1];
            } else {
              message = payload.params[0];
              address = payload.params[1];
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([function(cb) {
              return self2.validatePersonalMessage(msgParams, cb);
            }, function(cb) {
              return self2.processPersonalMessage(msgParams, cb);
            }], end);
          }();
        case "eth_decryptMessage":
          return function() {
            var first = payload.params[0];
            var second = payload.params[1];
            if (resemblesData(second) && resemblesAddress(first)) {
              var warning = "The eth_decryptMessage method requires params ordered ";
              warning += "[message, address]. This was previously handled incorrectly, ";
              warning += "and has been corrected automatically. ";
              warning += "Please switch this param order for smooth behavior in the future.";
              console.warn(warning);
              address = payload.params[0];
              message = payload.params[1];
            } else {
              message = payload.params[0];
              address = payload.params[1];
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([function(cb) {
              return self2.validateDecryptMessage(msgParams, cb);
            }, function(cb) {
              return self2.processDecryptMessage(msgParams, cb);
            }], end);
          }();
        case "encryption_public_key":
          return function() {
            var address2 = payload.params[0];
            waterfall([function(cb) {
              return self2.validateEncryptionPublicKey(address2, cb);
            }, function(cb) {
              return self2.processEncryptionPublicKey(address2, cb);
            }], end);
          }();
        case "personal_ecRecover":
          return function() {
            message = payload.params[0];
            var signature = payload.params[1];
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              sig: signature,
              data: message
            });
            self2.recoverPersonalSignature(msgParams, end);
          }();
        case "eth_signTypedData":
        case "eth_signTypedData_v3":
        case "eth_signTypedData_v4":
          return function() {
            var first = payload.params[0];
            var second = payload.params[1];
            if (resemblesAddress(first)) {
              address = first;
              message = second;
            } else {
              message = first;
              address = second;
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([function(cb) {
              return self2.validateTypedMessage(msgParams, cb);
            }, function(cb) {
              return self2.processTypedMessage(msgParams, cb);
            }], end);
          }();
        case "parity_postTransaction":
          txParams = payload.params[0];
          self2.parityPostTransaction(txParams, end);
          return;
        case "parity_postSign":
          address = payload.params[0];
          message = payload.params[1];
          self2.parityPostSign(address, message, end);
          return;
        case "parity_checkRequest":
          return function() {
            var requestId = payload.params[0];
            self2.parityCheckRequest(requestId, end);
          }();
        case "parity_defaultAccount":
          self2.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            var account = accounts[0] || null;
            end(null, account);
          });
          return;
        default:
          next();
          return;
      }
    };
    HookedWalletSubprovider2.prototype.getAccounts = function(cb) {
      cb(null, []);
    };
    HookedWalletSubprovider2.prototype.processTransaction = function(txParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approveTransaction(txParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("transaction", didApprove, cb2);
      }, function(cb2) {
        return self2.finalizeAndSubmitTx(txParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.processSignTransaction = function(txParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approveTransaction(txParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("transaction", didApprove, cb2);
      }, function(cb2) {
        return self2.finalizeTx(txParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.processMessage = function(msgParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approveMessage(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("message", didApprove, cb2);
      }, function(cb2) {
        return self2.signMessage(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.processPersonalMessage = function(msgParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approvePersonalMessage(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("message", didApprove, cb2);
      }, function(cb2) {
        return self2.signPersonalMessage(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.processDecryptMessage = function(msgParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approveDecryptMessage(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("decryptMessage", didApprove, cb2);
      }, function(cb2) {
        return self2.decryptMessage(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.processEncryptionPublicKey = function(msgParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approveEncryptionPublicKey(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("encryptionPublicKey", didApprove, cb2);
      }, function(cb2) {
        return self2.encryptionPublicKey(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.processTypedMessage = function(msgParams, cb) {
      var self2 = this;
      waterfall([function(cb2) {
        return self2.approveTypedMessage(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self2.checkApproval("message", didApprove, cb2);
      }, function(cb2) {
        return self2.signTypedMessage(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.autoApprove = function(txParams, cb) {
      cb(null, true);
    };
    HookedWalletSubprovider2.prototype.checkApproval = function(type, didApprove, cb) {
      cb(didApprove ? null : new Error("User denied " + type + " signature."));
    };
    HookedWalletSubprovider2.prototype.parityPostTransaction = function(txParams, cb) {
      var self2 = this;
      var count = self2._parityRequestCount;
      var reqId = "0x".concat(count.toString(16));
      self2._parityRequestCount++;
      self2.emitPayload({
        method: "eth_sendTransaction",
        params: [txParams]
      }, function(error, res) {
        if (error) {
          self2._parityRequests[reqId] = {
            error
          };
          return;
        }
        var txHash = res.result;
        self2._parityRequests[reqId] = txHash;
      });
      cb(null, reqId);
    };
    HookedWalletSubprovider2.prototype.parityPostSign = function(address, message, cb) {
      var self2 = this;
      var count = self2._parityRequestCount;
      var reqId = "0x".concat(count.toString(16));
      self2._parityRequestCount++;
      self2.emitPayload({
        method: "eth_sign",
        params: [address, message]
      }, function(error, res) {
        if (error) {
          self2._parityRequests[reqId] = {
            error
          };
          return;
        }
        var result = res.result;
        self2._parityRequests[reqId] = result;
      });
      cb(null, reqId);
    };
    HookedWalletSubprovider2.prototype.parityCheckRequest = function(reqId, cb) {
      var self2 = this;
      var result = self2._parityRequests[reqId] || null;
      if (!result)
        return cb(null, null);
      if (result.error)
        return cb(result.error);
      cb(null, result);
    };
    HookedWalletSubprovider2.prototype.recoverPersonalSignature = function(msgParams, cb) {
      var senderHex;
      try {
        senderHex = sigUtil.recoverPersonalSignature(msgParams);
      } catch (err) {
        return cb(err);
      }
      cb(null, senderHex);
    };
    HookedWalletSubprovider2.prototype.validateTransaction = function(txParams, cb) {
      var self2 = this;
      if (txParams.from === void 0)
        return cb(new Error("Undefined address - from address required to sign transaction."));
      self2.validateSender(txParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to sign transaction for this address: "'.concat(txParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateMessage = function(msgParams, cb) {
      var self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error("Undefined address - from address required to sign message."));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to sign message for this address: "'.concat(msgParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validatePersonalMessage = function(msgParams, cb) {
      var self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error("Undefined address - from address required to sign personal message."));
      if (msgParams.data === void 0)
        return cb(new Error("Undefined message - message required to sign personal message."));
      if (!isValidHex(msgParams.data))
        return cb(new Error("HookedWalletSubprovider - validateMessage - message was not encoded as hex."));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to sign message for this address: "'.concat(msgParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateDecryptMessage = function(msgParams, cb) {
      var self2 = this;
      if (msgParams.from === void 0)
        return cb(new Error("Undefined address - from address required to decrypt message."));
      if (msgParams.data === void 0)
        return cb(new Error("Undefined message - message required to decrypt message."));
      if (!isValidHex(msgParams.data))
        return cb(new Error("HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex."));
      self2.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to decrypt message for this address: "'.concat(msgParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateEncryptionPublicKey = function(address, cb) {
      var self2 = this;
      self2.validateSender(address, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to obtain encryption public key for this address: "'.concat(address, '"')));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateTypedMessage = function(msgParams, cb) {
      if (msgParams.from === void 0)
        return cb(new Error("Undefined address - from address required to sign typed data."));
      if (msgParams.data === void 0)
        return cb(new Error("Undefined data - message required to sign typed data."));
      this.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to sign message for this address: "'.concat(msgParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateSender = function(senderAddress, cb) {
      var self2 = this;
      if (!senderAddress)
        return cb(null, false);
      self2.getAccounts(function(err, accounts) {
        if (err)
          return cb(err);
        var senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;
        cb(null, senderIsValid);
      });
    };
    HookedWalletSubprovider2.prototype.finalizeAndSubmitTx = function(txParams, cb) {
      var self2 = this;
      self2.nonceLock.take(function() {
        waterfall([self2.fillInTxExtras.bind(self2, txParams), self2.signTransaction.bind(self2), self2.publishTransaction.bind(self2)], function(err, txHash) {
          self2.nonceLock.leave();
          if (err)
            return cb(err);
          cb(null, txHash);
        });
      });
    };
    HookedWalletSubprovider2.prototype.finalizeTx = function(txParams, cb) {
      var self2 = this;
      self2.nonceLock.take(function() {
        waterfall([self2.fillInTxExtras.bind(self2, txParams), self2.signTransaction.bind(self2)], function(err, signedTx) {
          self2.nonceLock.leave();
          if (err)
            return cb(err);
          cb(null, {
            raw: signedTx,
            tx: txParams
          });
        });
      });
    };
    HookedWalletSubprovider2.prototype.publishTransaction = function(rawTx, cb) {
      var self2 = this;
      self2.emitPayload({
        method: "eth_sendRawTransaction",
        params: [rawTx]
      }, function(err, res) {
        if (err)
          return cb(err);
        cb(null, res.result);
      });
    };
    HookedWalletSubprovider2.prototype.estimateGas = function(txParams, cb) {
      var self2 = this;
      estimateGas(self2.engine, txParams, cb);
    };
    HookedWalletSubprovider2.prototype.getGasPrice = function(cb) {
      var self2 = this;
      self2.emitPayload({
        method: "eth_gasPrice",
        params: []
      }, function(err, res) {
        if (err)
          return cb(err);
        cb(null, res.result);
      });
    };
    HookedWalletSubprovider2.prototype.fillInTxExtras = function(txParams, cb) {
      var self2 = this;
      var address = txParams.from;
      var tasks = {};
      if (txParams.gasPrice === void 0) {
        tasks.gasPrice = self2.getGasPrice.bind(self2);
      }
      if (txParams.nonce === void 0) {
        tasks.nonce = self2.emitPayload.bind(self2, {
          method: "eth_getTransactionCount",
          params: [address, "pending"]
        });
      }
      if (txParams.gas === void 0) {
        tasks.gas = self2.estimateGas.bind(self2, cloneTxParams(txParams));
      }
      parallel(tasks, function(err, taskResults) {
        if (err)
          return cb(err);
        var result = {};
        if (taskResults.gasPrice)
          result.gasPrice = taskResults.gasPrice;
        if (taskResults.nonce)
          result.nonce = taskResults.nonce.result;
        if (taskResults.gas)
          result.gas = taskResults.gas;
        cb(null, extend(txParams, result));
      });
    };
    function cloneTxParams(txParams) {
      return {
        from: txParams.from,
        to: txParams.to,
        value: txParams.value,
        data: txParams.data,
        gas: txParams.gas,
        gasPrice: txParams.gasPrice,
        nonce: txParams.nonce
      };
    }
    function toLowerCase(string) {
      return string.toLowerCase();
    }
    function resemblesAddress(string) {
      var fixed = ethUtil.addHexPrefix(string);
      var isValid = ethUtil.isValidAddress(fixed);
      return isValid;
    }
    function resemblesData(string) {
      var fixed = ethUtil.addHexPrefix(string);
      var isValidAddress = ethUtil.isValidAddress(fixed);
      return !isValidAddress && isValidHex(string);
    }
    function isValidHex(data) {
      var isString = typeof data === "string";
      if (!isString)
        return false;
      var isHexPrefixed = data.slice(0, 2) === "0x";
      if (!isHexPrefixed)
        return false;
      var nonPrefixed = data.slice(2);
      var isValid = nonPrefixed.match(hexRegex);
      return isValid;
    }
    function mustProvideInConstructor(methodName) {
      return function(params, cb) {
        cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide "' + methodName + '" fn in constructor options'));
      };
    }
  }
});

// node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/secp256k1-lib/index.js
var require_secp256k1_lib3 = __commonJS({
  "node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/secp256k1-lib/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var BN2 = require_bn();
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    exports.privateKeyExport = function(privateKey, compressed) {
      var d = new BN2(privateKey);
      if (d.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
      }
      var point = ec.g.mul(d);
      return toPublicKey(point.getX(), point.getY(), compressed);
    };
    exports.privateKeyModInverse = function(privateKey) {
      var bn = new BN2(privateKey);
      if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
        throw new Error("private key range is invalid");
      }
      return bn.invm(ecparams.n).toArrayLike(Buffer, "be", 32);
    };
    exports.signatureImport = function(sigObj) {
      var r = new BN2(sigObj.r);
      if (r.ucmp(ecparams.n) >= 0) {
        r = new BN2(0);
      }
      var s = new BN2(sigObj.s);
      if (s.ucmp(ecparams.n) >= 0) {
        s = new BN2(0);
      }
      return Buffer.concat([r.toArrayLike(Buffer, "be", 32), s.toArrayLike(Buffer, "be", 32)]);
    };
    exports.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      var point = ec.keyFromPublic(publicKey);
      var scalar = new BN2(privateKey);
      if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error("scalar was invalid (zero or overflow)");
      }
      var shared = point.pub.mul(scalar);
      return toPublicKey(shared.getX(), shared.getY(), compressed);
    };
    var toPublicKey = function toPublicKey2(x, y, compressed) {
      var publicKey = void 0;
      if (compressed) {
        publicKey = Buffer.alloc(33);
        publicKey[0] = y.isOdd() ? 3 : 2;
        x.toArrayLike(Buffer, "be", 32).copy(publicKey, 1);
      } else {
        publicKey = Buffer.alloc(65);
        publicKey[0] = 4;
        x.toArrayLike(Buffer, "be", 32).copy(publicKey, 1);
        y.toArrayLike(Buffer, "be", 32).copy(publicKey, 33);
      }
      return publicKey;
    };
  }
});

// node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/secp256k1-lib/der.js
var require_der4 = __commonJS({
  "node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/secp256k1-lib/der.js"(exports) {
    "use strict";
    init_define_process_env();
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.privateKeyExport = function(privateKey, publicKey, compressed) {
      var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports.privateKeyImport = function(privateKey) {
      var length = privateKey.length;
      var index = 0;
      if (length < index + 1 || privateKey[index] !== 48)
        return null;
      index += 1;
      if (length < index + 1 || !(privateKey[index] & 128))
        return null;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return null;
      if (length < index + lenb)
        return null;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length < index + len)
        return null;
      if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return null;
      }
      index += 3;
      if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
        return null;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports.signatureImportLax = function(signature) {
      var r = Buffer.alloc(32, 0);
      var s = Buffer.alloc(32, 0);
      var length = signature.length;
      var index = 0;
      if (signature[index++] !== 48) {
        return null;
      }
      var lenbyte = signature[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length) {
          return null;
        }
      }
      if (signature[index++] !== 2) {
        return null;
      }
      var rlen = signature[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1) {
        }
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
          rlen = (rlen << 8) + signature[index];
        }
      }
      if (rlen > length - index) {
        return null;
      }
      var rindex = index;
      index += rlen;
      if (signature[index++] !== 2) {
        return null;
      }
      var slen = signature[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1) {
        }
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
          slen = (slen << 8) + signature[index];
        }
      }
      if (slen > length - index) {
        return null;
      }
      var sindex = index;
      index += slen;
      for (; rlen > 0 && signature[rindex] === 0; rlen -= 1, rindex += 1) {
      }
      if (rlen > 32) {
        return null;
      }
      var rvalue = signature.slice(rindex, rindex + rlen);
      rvalue.copy(r, 32 - rvalue.length);
      for (; slen > 0 && signature[sindex] === 0; slen -= 1, sindex += 1) {
      }
      if (slen > 32) {
        return null;
      }
      var svalue = signature.slice(sindex, sindex + slen);
      svalue.copy(s, 32 - svalue.length);
      return { r, s };
    };
  }
});

// node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/secp256k1-adapter.js
var require_secp256k1_adapter3 = __commonJS({
  "node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/secp256k1-adapter.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var secp256k1 = require_secp256k1();
    var secp256k1v3 = require_secp256k1_lib3();
    var der = require_der4();
    var privateKeyVerify = function privateKeyVerify2(privateKey) {
      if (privateKey.length !== 32) {
        return false;
      }
      return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
    };
    var privateKeyExport = function privateKeyExport2(privateKey, compressed) {
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
      return der.privateKeyExport(privateKey, publicKey, compressed);
    };
    var privateKeyImport = function privateKeyImport2(privateKey) {
      privateKey = der.privateKeyImport(privateKey);
      if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
        return privateKey;
      }
      throw new Error("couldn't import from DER format");
    };
    var privateKeyNegate = function privateKeyNegate2(privateKey) {
      return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
    };
    var privateKeyModInverse = function privateKeyModInverse2(privateKey) {
      if (privateKey.length !== 32) {
        throw new Error("private key length is invalid");
      }
      return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
    };
    var privateKeyTweakAdd = function privateKeyTweakAdd2(privateKey, tweak) {
      return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
    };
    var privateKeyTweakMul = function privateKeyTweakMul2(privateKey, tweak) {
      return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
    };
    var publicKeyCreate = function publicKeyCreate2(privateKey, compressed) {
      return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
    };
    var publicKeyConvert = function publicKeyConvert2(publicKey, compressed) {
      return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
    };
    var publicKeyVerify = function publicKeyVerify2(publicKey) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
      }
      return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
    };
    var publicKeyTweakAdd = function publicKeyTweakAdd2(publicKey, tweak, compressed) {
      return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    var publicKeyTweakMul = function publicKeyTweakMul2(publicKey, tweak, compressed) {
      return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    var publicKeyCombine = function publicKeyCombine2(publicKeys, compressed) {
      var keys = [];
      publicKeys.forEach(function(publicKey) {
        keys.push(Uint8Array.from(publicKey));
      });
      return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
    };
    var signatureNormalize = function signatureNormalize2(signature) {
      return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
    };
    var signatureExport = function signatureExport2(signature) {
      return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
    };
    var signatureImport = function signatureImport2(signature) {
      return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
    };
    var signatureImportLax = function signatureImportLax2(signature) {
      if (signature.length === 0) {
        throw new RangeError("signature length is invalid");
      }
      var sigObj = der.signatureImportLax(signature);
      if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
      }
      return secp256k1v3.signatureImport(sigObj);
    };
    var sign = function sign2(message, privateKey, options) {
      if (options === null) {
        throw new TypeError("options should be an Object");
      }
      var signOptions = void 0;
      if (options) {
        signOptions = {};
        if (options.data === null) {
          throw new TypeError("options.data should be a Buffer");
        }
        if (options.data) {
          if (options.data.length !== 32) {
            throw new RangeError("options.data length is invalid");
          }
          signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
          throw new TypeError("options.noncefn should be a Function");
        }
        if (options.noncefn) {
          signOptions.noncefn = function(message2, privateKey2, algo, data, attempt) {
            var bufferAlgo = algo != null ? Buffer.from(algo) : null;
            var bufferData = data != null ? Buffer.from(data) : null;
            var buffer = Buffer.from("");
            if (options.noncefn) {
              buffer = options.noncefn(Buffer.from(message2), Buffer.from(privateKey2), bufferAlgo, bufferData, attempt);
            }
            return Uint8Array.from(buffer);
          };
        }
      }
      var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
      return {
        signature: Buffer.from(sig.signature),
        recovery: sig.recid
      };
    };
    var verify = function verify2(message, signature, publicKey) {
      return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
    };
    var recover = function recover2(message, signature, recid, compressed) {
      return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
    };
    var ecdh = function ecdh2(publicKey, privateKey) {
      return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
    };
    var ecdhUnsafe = function ecdhUnsafe2(publicKey, privateKey, compressed) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError("public key length is invalid");
      }
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
    };
    module.exports = {
      privateKeyVerify,
      privateKeyExport,
      privateKeyImport,
      privateKeyNegate,
      privateKeyModInverse,
      privateKeyTweakAdd,
      privateKeyTweakMul,
      publicKeyCreate,
      publicKeyConvert,
      publicKeyVerify,
      publicKeyTweakAdd,
      publicKeyTweakMul,
      publicKeyCombine,
      signatureNormalize,
      signatureExport,
      signatureImport,
      signatureImportLax,
      sign,
      verify,
      recover,
      ecdh,
      ecdhUnsafe
    };
  }
});

// node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/ethereumjs-tx/node_modules/ethereumjs-util/dist/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _require = require_keccak();
    var keccak224 = _require.keccak224;
    var keccak384 = _require.keccak384;
    var k256 = _require.keccak256;
    var keccak512 = _require.keccak512;
    var secp256k1 = require_secp256k1_adapter3();
    var assert = require_assert();
    var rlp = require_dist();
    var BN2 = require_bn();
    var createHash = require_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    Object.assign(exports, require_lib());
    exports.MAX_INTEGER = new BN2("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN2("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;
    exports.KECCAK256_NULL = Buffer2.from(exports.KECCAK256_NULL_S, "hex");
    exports.SHA3_NULL = exports.KECCAK256_NULL;
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;
    exports.KECCAK256_RLP_ARRAY = Buffer2.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;
    exports.KECCAK256_RLP = Buffer2.from(exports.KECCAK256_RLP_S, "hex");
    exports.SHA3_RLP = exports.KECCAK256_RLP;
    exports.BN = BN2;
    exports.rlp = rlp;
    exports.secp256k1 = secp256k1;
    exports.zeros = function(bytes) {
      return Buffer2.allocUnsafe(bytes).fill(0);
    };
    exports.zeroAddress = function() {
      var addressLength = 20;
      var zeroAddress = exports.zeros(addressLength);
      return exports.bufferToHex(zeroAddress);
    };
    exports.setLengthLeft = exports.setLength = function(msg, length, right) {
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = exports.stripZeros = function(a) {
      a = exports.stripHexPrefix(a);
      var first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    exports.toBuffer = function(v) {
      if (!Buffer2.isBuffer(v)) {
        if (Array.isArray(v)) {
          v = Buffer2.from(v);
        } else if (typeof v === "string") {
          if (exports.isHexString(v)) {
            v = Buffer2.from(exports.padToEven(exports.stripHexPrefix(v)), "hex");
          } else {
            v = Buffer2.from(v);
          }
        } else if (typeof v === "number") {
          v = exports.intToBuffer(v);
        } else if (v === null || v === void 0) {
          v = Buffer2.allocUnsafe(0);
        } else if (BN2.isBN(v)) {
          v = v.toArrayLike(Buffer2);
        } else if (v.toArray) {
          v = Buffer2.from(v.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v;
    };
    exports.bufferToInt = function(buf) {
      return new BN2(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN2(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer2.from(num.toTwos(256).toArray());
    };
    exports.keccak = function(a, bits) {
      a = exports.toBuffer(a);
      if (!bits)
        bits = 256;
      switch (bits) {
        case 224: {
          return keccak224(a);
        }
        case 256: {
          return k256(a);
        }
        case 384: {
          return keccak384(a);
        }
        case 512: {
          return keccak512(a);
        }
        default: {
          throw new Error("Invald algorithm: keccak" + bits);
        }
      }
    };
    exports.keccak256 = function(a) {
      return exports.keccak(a);
    };
    exports.sha3 = exports.keccak;
    exports.sha256 = function(a) {
      a = exports.toBuffer(a);
      return createHash("sha256").update(a).digest();
    };
    exports.ripemd160 = function(a, padded) {
      a = exports.toBuffer(a);
      var hash = createHash("rmd160").update(a).digest();
      if (padded === true) {
        return exports.setLength(hash, 32);
      } else {
        return hash;
      }
    };
    exports.rlphash = function(a) {
      return exports.keccak(rlp.encode(a));
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k1.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey, sanitize) {
      if (publicKey.length === 64) {
        return secp256k1.publicKeyVerify(Buffer2.concat([Buffer2.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k1.publicKeyVerify(publicKey);
    };
    exports.pubToAddress = exports.publicToAddress = function(pubKey, sanitize) {
      pubKey = exports.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
      }
      assert(pubKey.length === 64);
      return exports.keccak(pubKey).slice(-20);
    };
    var privateToPublic = exports.privateToPublic = function(privateKey) {
      privateKey = exports.toBuffer(privateKey);
      return secp256k1.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey) {
      publicKey = exports.toBuffer(publicKey);
      if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
      }
      return publicKey;
    };
    exports.ecsign = function(msgHash, privateKey) {
      var sig = secp256k1.sign(msgHash, privateKey);
      var ret = {};
      ret.r = sig.signature.slice(0, 32);
      ret.s = sig.signature.slice(32, 64);
      ret.v = sig.recovery + 27;
      return ret;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = exports.toBuffer("Ethereum Signed Message:\n" + message.length.toString());
      return exports.keccak(Buffer2.concat([prefix, message]));
    };
    exports.ecrecover = function(msgHash, v, r, s) {
      var signature = Buffer2.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
      var recovery = v - 27;
      if (recovery !== 0 && recovery !== 1) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
      return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v, r, s) {
      if (v !== 27 && v !== 28) {
        throw new Error("Invalid recovery id");
      }
      return exports.bufferToHex(Buffer2.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
    };
    exports.fromRpcSig = function(sig) {
      sig = exports.toBuffer(sig);
      if (sig.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v = sig[64];
      if (v < 27) {
        v += 27;
      }
      return {
        v,
        r: sig.slice(0, 32),
        s: sig.slice(32, 64)
      };
    };
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(privateToPublic(privateKey));
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddress = exports.zeroAddress();
      return zeroAddress === exports.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address) {
      address = exports.stripHexPrefix(address).toLowerCase();
      var hash = exports.keccak(address).toString("hex");
      var ret = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret += address[i].toUpperCase();
        } else {
          ret += address[i];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
    };
    exports.generateAddress = function(from, nonce) {
      from = exports.toBuffer(from);
      nonce = new BN2(nonce);
      if (nonce.isZero()) {
        nonce = null;
      } else {
        nonce = Buffer2.from(nonce.toArray());
      }
      return exports.rlphash([from, nonce]).slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a = exports.unpad(address);
      return a.length === 1 && a[0] >= 1 && a[0] <= 8;
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return exports.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.isValidSignature = function(v, r, s, homestead) {
      var SECP256K1_N_DIV_2 = new BN2("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r.length !== 32 || s.length !== 32) {
        return false;
      }
      if (v !== 27 && v !== 28) {
        return false;
      }
      r = new BN2(r);
      s = new BN2(s);
      if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
        return false;
      }
      if (homestead === false && new BN2(s).cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.baToJSON = function(ba) {
      if (Buffer2.isBuffer(ba)) {
        return "0x" + ba.toString("hex");
      } else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
          array.push(exports.baToJSON(ba[i]));
        }
        return array;
      }
    };
    exports.defineProperties = function(self2, fields, data) {
      self2.raw = [];
      self2._fields = [];
      self2.toJSON = function(label) {
        if (label) {
          var obj = {};
          self2._fields.forEach(function(field) {
            obj[field] = "0x" + self2[field].toString("hex");
          });
          return obj;
        }
        return exports.baToJSON(this.raw);
      };
      self2.serialize = function serialize() {
        return rlp.encode(self2.raw);
      };
      fields.forEach(function(field, i) {
        self2._fields.push(field.name);
        function getter() {
          return self2.raw[i];
        }
        function setter(v) {
          v = exports.toBuffer(v);
          if (v.toString("hex") === "00" && !field.allowZero) {
            v = Buffer2.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v = exports.stripZeros(v);
            assert(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v.length === 0) && field.length) {
            assert(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self2.raw[i] = v;
        }
        Object.defineProperty(self2, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self2[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self2, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer2.from(exports.stripHexPrefix(data), "hex");
        }
        if (Buffer2.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self2._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d, i) {
            self2[self2._fields[i]] = exports.toBuffer(d);
          });
        } else if ((typeof data === "undefined" ? "undefined" : _typeof(data)) === "object") {
          var keys = Object.keys(data);
          fields.forEach(function(field) {
            if (keys.indexOf(field.name) !== -1)
              self2[field.name] = data[field.name];
            if (keys.indexOf(field.alias) !== -1)
              self2[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// node_modules/ethereum-common/params.json
var require_params = __commonJS({
  "node_modules/ethereum-common/params.json"(exports, module) {
    module.exports = {
      genesisGasLimit: {
        v: 5e3,
        d: "Gas limit of the Genesis block."
      },
      genesisDifficulty: {
        v: 17179869184,
        d: "Difficulty of the Genesis block."
      },
      genesisNonce: {
        v: "0x0000000000000042",
        d: "the geneis nonce"
      },
      genesisExtraData: {
        v: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
        d: "extra data "
      },
      genesisHash: {
        v: "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3",
        d: "genesis hash"
      },
      genesisStateRoot: {
        v: "0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544",
        d: "the genesis state root"
      },
      minGasLimit: {
        v: 5e3,
        d: "Minimum the gas limit may ever be."
      },
      gasLimitBoundDivisor: {
        v: 1024,
        d: "The bound divisor of the gas limit, used in update calculations."
      },
      minimumDifficulty: {
        v: 131072,
        d: "The minimum that the difficulty may ever be."
      },
      difficultyBoundDivisor: {
        v: 2048,
        d: "The bound divisor of the difficulty, used in the update calculations."
      },
      durationLimit: {
        v: 13,
        d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not."
      },
      maximumExtraDataSize: {
        v: 32,
        d: "Maximum size extra data may be after Genesis."
      },
      epochDuration: {
        v: 3e4,
        d: "Duration between proof-of-work epochs."
      },
      stackLimit: {
        v: 1024,
        d: "Maximum size of VM stack allowed."
      },
      callCreateDepth: {
        v: 1024,
        d: "Maximum depth of call/create stack."
      },
      tierStepGas: {
        v: [0, 2, 3, 5, 8, 10, 20],
        d: "Once per operation, for a selection of them."
      },
      expGas: {
        v: 10,
        d: "Once per EXP instuction."
      },
      expByteGas: {
        v: 10,
        d: "Times ceil(log256(exponent)) for the EXP instruction."
      },
      sha3Gas: {
        v: 30,
        d: "Once per SHA3 operation."
      },
      sha3WordGas: {
        v: 6,
        d: "Once per word of the SHA3 operation's data."
      },
      sloadGas: {
        v: 50,
        d: "Once per SLOAD operation."
      },
      sstoreSetGas: {
        v: 2e4,
        d: "Once per SSTORE operation if the zeroness changes from zero."
      },
      sstoreResetGas: {
        v: 5e3,
        d: "Once per SSTORE operation if the zeroness does not change from zero."
      },
      sstoreRefundGas: {
        v: 15e3,
        d: "Once per SSTORE operation if the zeroness changes to zero."
      },
      jumpdestGas: {
        v: 1,
        d: "Refunded gas, once per SSTORE operation if the zeroness changes to zero."
      },
      logGas: {
        v: 375,
        d: "Per LOG* operation."
      },
      logDataGas: {
        v: 8,
        d: "Per byte in a LOG* operation's data."
      },
      logTopicGas: {
        v: 375,
        d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas."
      },
      createGas: {
        v: 32e3,
        d: "Once per CREATE operation & contract-creation transaction."
      },
      callGas: {
        v: 40,
        d: "Once per CALL operation & message call transaction."
      },
      callStipend: {
        v: 2300,
        d: "Free gas given at beginning of call."
      },
      callValueTransferGas: {
        v: 9e3,
        d: "Paid for CALL when the value transfor is non-zero."
      },
      callNewAccountGas: {
        v: 25e3,
        d: "Paid for CALL when the destination address didn't exist prior."
      },
      suicideRefundGas: {
        v: 24e3,
        d: "Refunded following a suicide operation."
      },
      memoryGas: {
        v: 3,
        d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL."
      },
      quadCoeffDiv: {
        v: 512,
        d: "Divisor for the quadratic particle of the memory cost equation."
      },
      createDataGas: {
        v: 200,
        d: ""
      },
      txGas: {
        v: 21e3,
        d: "Per transaction. NOTE: Not payable on data of calls between transactions."
      },
      txCreation: {
        v: 32e3,
        d: "the cost of creating a contract via tx"
      },
      txDataZeroGas: {
        v: 4,
        d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions."
      },
      txDataNonZeroGas: {
        v: 68,
        d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions."
      },
      copyGas: {
        v: 3,
        d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added."
      },
      ecrecoverGas: {
        v: 3e3,
        d: ""
      },
      sha256Gas: {
        v: 60,
        d: ""
      },
      sha256WordGas: {
        v: 12,
        d: ""
      },
      ripemd160Gas: {
        v: 600,
        d: ""
      },
      ripemd160WordGas: {
        v: 120,
        d: ""
      },
      identityGas: {
        v: 15,
        d: ""
      },
      identityWordGas: {
        v: 3,
        d: ""
      },
      minerReward: {
        v: "5000000000000000000",
        d: "the amount a miner get rewarded for mining a block"
      },
      ommerReward: {
        v: "625000000000000000",
        d: "The amount of wei a miner of an uncle block gets for being inculded in the blockchain"
      },
      niblingReward: {
        v: "156250000000000000",
        d: "the amount a miner gets for inculding a uncle"
      },
      homeSteadForkNumber: {
        v: 115e4,
        d: "the block that the Homestead fork started at"
      },
      homesteadRepriceForkNumber: {
        v: 2463e3,
        d: "the block that the Homestead Reprice (EIP150) fork started at"
      },
      timebombPeriod: {
        v: 1e5,
        d: "Exponential difficulty timebomb period"
      },
      freeBlockPeriod: {
        v: 2
      }
    };
  }
});

// node_modules/ethereumjs-tx/es5/index.js
var require_es5 = __commonJS({
  "node_modules/ethereumjs-tx/es5/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ethUtil = require_dist5();
    var fees = require_params();
    var BN2 = ethUtil.BN;
    var N_DIV_2 = new BN2("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
    var Transaction = function() {
      function Transaction2(data) {
        _classCallCheck(this, Transaction2);
        data = data || {};
        var fields = [{
          name: "nonce",
          length: 32,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "gasPrice",
          length: 32,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "gasLimit",
          alias: "gas",
          length: 32,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "to",
          allowZero: true,
          length: 20,
          default: new Buffer([])
        }, {
          name: "value",
          length: 32,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "data",
          alias: "input",
          allowZero: true,
          default: new Buffer([])
        }, {
          name: "v",
          allowZero: true,
          default: new Buffer([28])
        }, {
          name: "r",
          length: 32,
          allowZero: true,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "s",
          length: 32,
          allowZero: true,
          allowLess: true,
          default: new Buffer([])
        }];
        ethUtil.defineProperties(this, fields, data);
        Object.defineProperty(this, "from", {
          enumerable: true,
          configurable: true,
          get: this.getSenderAddress.bind(this)
        });
        var sigV = ethUtil.bufferToInt(this.v);
        var chainId = Math.floor((sigV - 35) / 2);
        if (chainId < 0)
          chainId = 0;
        this._chainId = chainId || data.chainId || 0;
        this._homestead = true;
      }
      Transaction2.prototype.toCreationAddress = function toCreationAddress() {
        return this.to.toString("hex") === "";
      };
      Transaction2.prototype.hash = function hash(includeSignature) {
        if (includeSignature === void 0)
          includeSignature = true;
        var items = void 0;
        if (includeSignature) {
          items = this.raw;
        } else {
          if (this._chainId > 0) {
            var raw = this.raw.slice();
            this.v = this._chainId;
            this.r = 0;
            this.s = 0;
            items = this.raw;
            this.raw = raw;
          } else {
            items = this.raw.slice(0, 6);
          }
        }
        return ethUtil.rlphash(items);
      };
      Transaction2.prototype.getChainId = function getChainId() {
        return this._chainId;
      };
      Transaction2.prototype.getSenderAddress = function getSenderAddress() {
        if (this._from) {
          return this._from;
        }
        var pubkey = this.getSenderPublicKey();
        this._from = ethUtil.publicToAddress(pubkey);
        return this._from;
      };
      Transaction2.prototype.getSenderPublicKey = function getSenderPublicKey() {
        if (!this._senderPubKey || !this._senderPubKey.length) {
          if (!this.verifySignature())
            throw new Error("Invalid Signature");
        }
        return this._senderPubKey;
      };
      Transaction2.prototype.verifySignature = function verifySignature() {
        var msgHash = this.hash(false);
        if (this._homestead && new BN2(this.s).cmp(N_DIV_2) === 1) {
          return false;
        }
        try {
          var v = ethUtil.bufferToInt(this.v);
          if (this._chainId > 0) {
            v -= this._chainId * 2 + 8;
          }
          this._senderPubKey = ethUtil.ecrecover(msgHash, v, this.r, this.s);
        } catch (e) {
          return false;
        }
        return !!this._senderPubKey;
      };
      Transaction2.prototype.sign = function sign(privateKey) {
        var msgHash = this.hash(false);
        var sig = ethUtil.ecsign(msgHash, privateKey);
        if (this._chainId > 0) {
          sig.v += this._chainId * 2 + 8;
        }
        Object.assign(this, sig);
      };
      Transaction2.prototype.getDataFee = function getDataFee() {
        var data = this.raw[5];
        var cost = new BN2(0);
        for (var i = 0; i < data.length; i++) {
          data[i] === 0 ? cost.iaddn(fees.txDataZeroGas.v) : cost.iaddn(fees.txDataNonZeroGas.v);
        }
        return cost;
      };
      Transaction2.prototype.getBaseFee = function getBaseFee() {
        var fee = this.getDataFee().iaddn(fees.txGas.v);
        if (this._homestead && this.toCreationAddress()) {
          fee.iaddn(fees.txCreation.v);
        }
        return fee;
      };
      Transaction2.prototype.getUpfrontCost = function getUpfrontCost() {
        return new BN2(this.gasLimit).imul(new BN2(this.gasPrice)).iadd(new BN2(this.value));
      };
      Transaction2.prototype.validate = function validate(stringError) {
        var errors = [];
        if (!this.verifySignature()) {
          errors.push("Invalid Signature");
        }
        if (this.getBaseFee().cmp(new BN2(this.gasLimit)) > 0) {
          errors.push(["gas limit is too low. Need at least " + this.getBaseFee()]);
        }
        if (stringError === void 0 || stringError === false) {
          return errors.length === 0;
        } else {
          return errors.join(" ");
        }
      };
      return Transaction2;
    }();
    module.exports = Transaction;
  }
});

// node_modules/web3-provider-engine/dist/es5/util/rpc-cache-utils.js
var require_rpc_cache_utils2 = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/util/rpc-cache-utils.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var stringify = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!canCache(payload))
        return null;
      var includeBlockRef = opts.includeBlockRef;
      var params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload);
      return payload.method + ":" + stringify(params);
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
          return "fork";
        case "eth_gasPrice":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "eth_blockNumber":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
          return "never";
      }
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/nonce-tracker.js
var require_nonce_tracker = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/nonce-tracker.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var inherits = require_util().inherits;
    var Transaction = require_es5();
    var ethUtil = require_dist3();
    var Subprovider = require_subprovider();
    var blockTagForPayload = require_rpc_cache_utils2().blockTagForPayload;
    module.exports = NonceTrackerSubprovider;
    inherits(NonceTrackerSubprovider, Subprovider);
    function NonceTrackerSubprovider(opts) {
      var self2 = this;
      self2.nonceCache = {};
    }
    NonceTrackerSubprovider.prototype.handleRequest = function(payload, next, end) {
      var self2 = this;
      switch (payload.method) {
        case "eth_getTransactionCount":
          var blockTag = blockTagForPayload(payload);
          var address = payload.params[0].toLowerCase();
          var cachedResult = self2.nonceCache[address];
          if (blockTag === "pending") {
            if (cachedResult) {
              end(null, cachedResult);
            } else {
              next(function(err, result, cb) {
                if (err)
                  return cb();
                if (self2.nonceCache[address] === void 0) {
                  self2.nonceCache[address] = result;
                }
                cb();
              });
            }
          } else {
            next();
          }
          return;
        case "eth_sendRawTransaction":
          next(function(err, result, cb) {
            if (err)
              return cb();
            var rawTx = payload.params[0];
            var stripped = ethUtil.stripHexPrefix(rawTx);
            var rawData = Buffer.from(ethUtil.stripHexPrefix(rawTx), "hex");
            var tx = new Transaction(Buffer.from(ethUtil.stripHexPrefix(rawTx), "hex"));
            var address2 = "0x" + tx.getSenderAddress().toString("hex").toLowerCase();
            var nonce = ethUtil.bufferToInt(tx.nonce);
            nonce++;
            var hexNonce = nonce.toString(16);
            if (hexNonce.length % 2)
              hexNonce = "0" + hexNonce;
            hexNonce = "0x" + hexNonce;
            self2.nonceCache[address2] = hexNonce;
            cb();
          });
          return;
        case "evm_revert":
          self2.nonceCache = {};
          next();
          return;
        default:
          next();
          return;
      }
    };
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/subscriptions.js
var require_subscriptions = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/subscriptions.js"(exports, module) {
    "use strict";
    init_define_process_env();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createSubscriptionManager = require_subscriptionManager();
    var SubscriptionsSubprovider2 = function(_ProviderSubprovider) {
      _inherits(SubscriptionsSubprovider3, _ProviderSubprovider);
      var _super = _createSuper(SubscriptionsSubprovider3);
      function SubscriptionsSubprovider3() {
        _classCallCheck(this, SubscriptionsSubprovider3);
        return _super.call(this, function(_ref) {
          var blockTracker = _ref.blockTracker, provider = _ref.provider, engine = _ref.engine;
          var _createSubscriptionMa = createSubscriptionManager({
            blockTracker,
            provider
          }), events = _createSubscriptionMa.events, middleware = _createSubscriptionMa.middleware;
          events.on("notification", function(data) {
            return engine.emit("data", null, data);
          });
          return middleware;
        });
      }
      return SubscriptionsSubprovider3;
    }(ProviderSubprovider);
    module.exports = SubscriptionsSubprovider2;
  }
});

// node_modules/@portis/web3/es/index.js
init_define_process_env();

// node_modules/@portis/web3/es/networks.js
init_define_process_env();
function networkAdapter(network, gasRelay) {
  var networkObj = typeof network === "string" ? Object.assign({}, networks[network]) : network;
  if (typeof networkObj !== "object") {
    throw new Error("[Portis] illegal 'network' parameter. Read more about it here: https://docs.portis.io/#/configuration?id=network");
  }
  if (!networkObj.nodeUrl) {
    throw new Error("[Portis] 'nodeUrl' is required. Read more about it here: https://docs.portis.io/#/configuration?id=network");
  }
  if (gasRelay && !networkObj.gasRelayHubAddress) {
    throw new Error("[Portis] can't find default gas relay hub for " + network);
  }
  if (typeof network === "string" && !gasRelay) {
    delete networkObj.gasRelayHubAddress;
  }
  return networkObj;
}
var networks = {
  mainnet: {
    nodeUrl: "https://mainnet.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "1",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  ropsten: {
    nodeUrl: "https://ropsten.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "3",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  rinkeby: {
    nodeUrl: "https://rinkeby.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "4",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  goerli: {
    nodeUrl: "https://goerli.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "5"
  },
  ubiq: {
    nodeUrl: "https://rpc1.ubiqscan.io",
    chainId: "8"
  },
  thundercoreTestnet: {
    nodeUrl: "https://testnet-rpc.thundercore.com:8544",
    chainId: "18"
  },
  orchid: {
    nodeUrl: "https://public-node.rsk.co",
    chainId: "30"
  },
  orchidTestnet: {
    nodeUrl: "https://public-node.testnet.rsk.co",
    chainId: "31"
  },
  kovan: {
    nodeUrl: "https://kovan.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "42",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  classic: {
    nodeUrl: "https://ethereumclassic.network",
    chainId: "61"
  },
  sokol: {
    nodeUrl: "https://sokol.poa.network",
    chainId: "77"
  },
  core: {
    nodeUrl: "https://core.poa.network",
    chainId: "99"
  },
  xdai: {
    nodeUrl: "https://dai.poa.network",
    chainId: "100",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  thundercore: {
    nodeUrl: "https://mainnet-rpc.thundercore.com",
    chainId: "108"
  },
  fuse: {
    nodeUrl: "https://rpc.fusenet.io",
    chainId: "122"
  },
  lightstreams: {
    nodeUrl: "https://node.mainnet.lightstreams.io",
    chainId: "163"
  },
  matic: {
    nodeUrl: "https://polygon-rpc.com",
    chainId: "137"
  },
  maticMumbai: {
    nodeUrl: "https://rpc-mumbai.matic.today",
    chainId: "80001"
  },
  maticAlpha: {
    nodeUrl: "https://alpha.ethereum.matic.network",
    chainId: "4626"
  },
  maticTestnet: {
    nodeUrl: "https://testnet2.matic.network",
    chainId: "8995"
  }
};

// node_modules/@portis/web3/es/utils/onWindowLoad.js
init_define_process_env();

// node_modules/@portis/web3/es/utils/isClientSide.js
init_define_process_env();
var isClientSide = function() {
  return !!(typeof window !== "undefined" && window.document);
};

// node_modules/@portis/web3/es/utils/onWindowLoad.js
var loaded = false;
function onWindowLoad() {
  return new Promise(function(resolve, reject) {
    if (!isClientSide()) {
      reject();
    } else if (loaded) {
      resolve();
    } else if (["loaded", "interactive", "complete"].indexOf(document.readyState) > -1) {
      loaded = true;
      resolve();
    } else {
      window.addEventListener("load", function() {
        loaded = true;
        resolve();
      }, false);
    }
  });
}

// node_modules/@portis/web3/es/utils/secureOrigin.js
init_define_process_env();
function validateSecureOrigin() {
  var isLocalhost = location.hostname === "localhost" || location.hostname === "127.0.0.1";
  var isSecureOrigin = location.protocol === "https:";
  var isSecure = isLocalhost || isSecureOrigin;
  if (!isSecure) {
    throw "[Portis] Access to the WebCrypto API is restricted to secure origins.\nIf this is a development environment please use http://localhost:" + location.port + " instead.\nOtherwise, please use an SSL certificate.";
  }
}

// node_modules/@portis/web3/es/widget/widgetManager.js
init_define_process_env();
var import_penpal = __toESM(require_lib2());

// node_modules/@portis/web3/es/styles.js
init_define_process_env();
var styles = "\n.por_portis-container {\n  position: fixed;\n  width: 0px;\n  height: 0px;\n  top: 0px;\n  right: 0px;\n  z-index: 2147483647;\n}\n\n@media (max-width: 576px) {\n  .por_portis-container {\n    bottom: 0;\n    top: auto;\n  }\n}\n\n.por_portis-widget-frame {\n  position: fixed;\n  width: 375px;\n  height: 0;\n  top: 20px;\n  right: 20px;\n  box-shadow: 0 5px 40px rgba(0,0,0,.16);\n  border-radius: 8px;\n  overflow: hidden;\n  z-index: 2147483000;\n}\n\n@media (max-width: 576px) {\n  .por_portis-widget-frame {\n    bottom: 0;\n    top: auto;\n    width: 100%;\n    right: 0;\n    left: 0;\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n}\n";

// node_modules/@portis/web3/es/widget/widgetManager.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var WIDGET_URL = define_process_env_default.PORTIS_WIDGET_URL || "https://widget.portis.io";
var STAGING_WIDGET_URL = "https://widget-staging.portis.io";
var FEATURE_WIDGET_URL = "https://widget-feature.portis.io";
var PORTIS_IFRAME_CLASS = "por_portis-widget-frame";
var PORTIS_CONTAINER_CLASS = "por_portis-container";
function windowLoadHandler() {
  if (document.getElementsByClassName(PORTIS_IFRAME_CLASS).length) {
    console.warn("Portis script was already loaded. This might cause unexpected behavior. If loading with a <script> tag, please make sure that you only load it once.");
  }
}
var WidgetManager = function() {
  function WidgetManager2(_widgetConfig, _clearProviderSession) {
    this._widgetConfig = _widgetConfig;
    this._clearProviderSession = _clearProviderSession;
    this._widgetUrl = WIDGET_URL;
    this._onLoginCallback = function() {
    };
    this._onLogoutCallback = function() {
    };
    this._onErrorCallback = function() {
    };
    validateSecureOrigin();
    if (_widgetConfig.staging) {
      console.warn("Please note: you are using the Portis STAGING environment.");
      this._widgetUrl = STAGING_WIDGET_URL;
    } else if (_widgetConfig.feature) {
      console.warn("Please note: you are using the Portis FEATURE environment.");
      this._widgetUrl = FEATURE_WIDGET_URL;
    }
    WidgetManager2._checkIfWidgetAlreadyInitialized();
  }
  WidgetManager2.prototype.getWidget = function() {
    return __awaiter(this, void 0, void 0, function() {
      var _a2;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (!!this.widgetInstance)
              return [3, 2];
            if (!this.widgetPromise) {
              this.widgetPromise = this._initWidget();
            }
            _a2 = this;
            return [4, this.widgetPromise];
          case 1:
            _a2.widgetInstance = _b.sent();
            _b.label = 2;
          case 2:
            return [2, this.widgetInstance];
        }
      });
    });
  };
  WidgetManager2.prototype.setDefaultEmail = function(email) {
    this._widgetConfig.defaultEmail = email;
  };
  WidgetManager2.prototype.setOnLoginCallback = function(callback) {
    this._onLoginCallback = callback;
  };
  WidgetManager2.prototype.setOnLogoutCallback = function(callback) {
    this._onLogoutCallback = callback;
  };
  WidgetManager2.prototype.setOnActiveWalletChangedCallback = function(callback) {
    this._onActiveWalletChangedCallback = callback;
  };
  WidgetManager2.prototype.setOnErrorCallback = function(callback) {
    this._onErrorCallback = callback;
  };
  WidgetManager2.prototype.showPortis = function() {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.showPortis(this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.getCampaignInfo = function(campaignId) {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.getCampaignInfo(campaignId)];
        }
      });
    });
  };
  WidgetManager2.prototype.claimVoucher = function(voucherId) {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.claimVoucher(voucherId, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.logout = function() {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.logout()];
        }
      });
    });
  };
  WidgetManager2.prototype.getExtendedPublicKey = function(path, coin) {
    if (path === void 0) {
      path = "m/44'/60'/0'/0/0";
    }
    if (coin === void 0) {
      coin = "Ethereum";
    }
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.getExtendedPublicKey(path, coin, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.importWallet = function(mnemonicOrPrivateKey) {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.importWallet(mnemonicOrPrivateKey, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.isLoggedIn = function() {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.isLoggedIn()];
        }
      });
    });
  };
  WidgetManager2.prototype.signBitcoinTransaction = function(params) {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.signBitcoinTransaction(params, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.showBitcoinWallet = function(path) {
    if (path === void 0) {
      path = "m/49'/0'/0'/0/0";
    }
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.showBitcoinWallet(path, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.purchaseERC20 = function(params) {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.purchaseERC20(params, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2._checkIfWidgetAlreadyInitialized = function() {
    if (document.getElementsByClassName(PORTIS_CONTAINER_CLASS).length) {
      console.warn("An instance of Portis was already initialized. This is probably a mistake. Make sure that you use the same Portis instance throughout your app.");
    }
  };
  WidgetManager2.prototype._initWidget = function() {
    return __awaiter(this, void 0, void 0, function() {
      var style, container, widgetFrame, connection, communication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, onWindowLoad()];
          case 1:
            _a2.sent();
            style = document.createElement("style");
            style.innerHTML = styles;
            container = document.createElement("div");
            container.className = PORTIS_CONTAINER_CLASS;
            widgetFrame = document.createElement("div");
            widgetFrame.id = "portis-container-" + Date.now();
            widgetFrame.className = PORTIS_IFRAME_CLASS;
            container.appendChild(widgetFrame);
            document.body.appendChild(container);
            document.head.appendChild(style);
            connection = import_penpal.default.connectToChild({
              url: this._widgetUrl,
              appendTo: document.getElementById(widgetFrame.id),
              methods: {
                setHeight: this._setHeight.bind(this),
                getWindowSize: WidgetManager2._getWindowSize.bind(this),
                onLogin: this._onLogin.bind(this),
                onLogout: this._onLogout.bind(this),
                onActiveWalletChanged: this._onActiveWalletChanged.bind(this),
                hasOnActiveWalletChanged: this.hasOnActiveWalletChanged.bind(this),
                onError: this._onError.bind(this)
              }
            });
            return [4, connection.promise];
          case 2:
            communication = _a2.sent();
            communication.setSdkConfig(this._widgetConfig);
            connection.iframe.style.position = "absolute";
            connection.iframe.style.height = "100%";
            connection.iframe.style.width = "100%";
            connection.iframe.style.border = "0 transparent";
            return [2, { communication, widgetFrame }];
        }
      });
    });
  };
  WidgetManager2.prototype._setHeight = function(height) {
    return __awaiter(this, void 0, void 0, function() {
      var widgetFrame;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetFrame = _a2.sent().widgetFrame;
            widgetFrame.style.height = height + "px";
            return [2];
        }
      });
    });
  };
  WidgetManager2._getWindowSize = function() {
    var body = document.getElementsByTagName("body")[0];
    var width = window.innerWidth || document.documentElement.clientWidth || body.clientWidth;
    var height = window.innerHeight || document.documentElement.clientHeight || body.clientHeight;
    return { width, height };
  };
  WidgetManager2.prototype._onLogin = function(walletAddress, email, reputation) {
    if (this._onLoginCallback) {
      this._onLoginCallback(walletAddress, email, reputation);
    }
  };
  WidgetManager2.prototype._onLogout = function() {
    this._clearProviderSession();
    if (this._onLogoutCallback) {
      this._onLogoutCallback();
    }
  };
  WidgetManager2.prototype._onActiveWalletChanged = function(walletAddress) {
    if (this._onActiveWalletChangedCallback) {
      this._onActiveWalletChangedCallback(walletAddress);
    }
  };
  WidgetManager2.prototype.hasOnActiveWalletChanged = function() {
    return !!this._onActiveWalletChangedCallback;
  };
  WidgetManager2.prototype._onError = function(error) {
    if (this._onErrorCallback) {
      this._onErrorCallback(error);
    }
  };
  return WidgetManager2;
}();
var widgetManager_default = WidgetManager;

// node_modules/@portis/web3/es/web3/web3Manager.js
init_define_process_env();

// node_modules/@portis/web3/es/utils/getTxGas.js
init_define_process_env();
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var _a = require_dist2();
var addHexPrefix = _a.addHexPrefix;
var stripHexPrefix = _a.stripHexPrefix;
var BN = _a.BN;
var SIMPLE_GAS_COST = "0x5208";
function getTxGas(query, txParams) {
  return __awaiter2(this, void 0, void 0, function() {
    var block, _a2, safeGas, simpleSend, gasLimitSpecified, gas, error_1;
    return __generator2(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, query.getBlockByNumber("latest", false)];
        case 1:
          block = _b.sent();
          return [4, safeTxGas(query, txParams, block.gasLimit)];
        case 2:
          _a2 = _b.sent(), safeGas = _a2.safeGas, simpleSend = _a2.simpleSend, gasLimitSpecified = _a2.gasLimitSpecified;
          if (simpleSend || gasLimitSpecified) {
            return [2, safeGas];
          }
          _b.label = 3;
        case 3:
          _b.trys.push([3, 5, , 6]);
          return [4, estimateTxGas(query, txParams, block.gasLimit, safeGas)];
        case 4:
          gas = _b.sent();
          return [2, gas];
        case 5:
          error_1 = _b.sent();
          return [2, safeGas];
        case 6:
          return [2];
      }
    });
  });
}
function safeTxGas(query, txParams, blockGasLimitHex) {
  return __awaiter2(this, void 0, void 0, function() {
    var gasLimitSpecified, recipient, hasRecipient, code, codeIsEmpty, err, blockGasLimitBN, saferGasLimitBN;
    return __generator2(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          gasLimitSpecified = Boolean(txParams.gas);
          if (gasLimitSpecified) {
            return [2, { safeGas: txParams.gas, simpleSend: false, gasLimitSpecified: true }];
          }
          recipient = txParams.to;
          hasRecipient = Boolean(recipient);
          if (!hasRecipient)
            return [3, 2];
          return [4, query.getCode(recipient)];
        case 1:
          code = _a2.sent();
          codeIsEmpty = !code || code === "0x" || code === "0x0";
          if (codeIsEmpty) {
            if (txParams.data) {
              err = new Error("Trying to call a function on a non-contract address");
              throw err;
            }
            return [2, { safeGas: SIMPLE_GAS_COST, simpleSend: true, gasLimitSpecified: false }];
          }
          _a2.label = 2;
        case 2:
          blockGasLimitBN = hexToBn(blockGasLimitHex);
          saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);
          return [2, { safeGas: bnToHex(saferGasLimitBN), simpleSend: false, gasLimitSpecified: false }];
      }
    });
  });
}
function estimateTxGas(query, txParams, blockGasLimitHex, safeGas) {
  return __awaiter2(this, void 0, void 0, function() {
    var estimatedGas, _a2;
    return __generator2(this, function(_b) {
      switch (_b.label) {
        case 0:
          txParams.gas = safeGas;
          _a2 = addHexPrefix;
          return [4, query.estimateGas(txParams)];
        case 1:
          estimatedGas = _a2.apply(void 0, [_b.sent()]);
          return [2, addGasBuffer(estimatedGas, blockGasLimitHex)];
      }
    });
  });
}
function addGasBuffer(initialGasLimitHex, blockGasLimitHex) {
  var initialGasLimitBn = hexToBn(initialGasLimitHex);
  var blockGasLimitBn = hexToBn(blockGasLimitHex);
  var upperGasLimitBn = blockGasLimitBn.muln(0.9);
  var bufferedGasLimitBn = initialGasLimitBn.muln(1.5);
  if (initialGasLimitBn.gt(upperGasLimitBn))
    return bnToHex(initialGasLimitBn);
  if (bufferedGasLimitBn.lt(upperGasLimitBn))
    return bnToHex(bufferedGasLimitBn);
  return bnToHex(upperGasLimitBn);
}
function hexToBn(inputHex) {
  return new BN(stripHexPrefix(inputHex), 16);
}
function bnToHex(inputBn) {
  return addHexPrefix(inputBn.toString(16));
}
function BnMultiplyByFraction(targetBN, numerator, denominator) {
  var numBN = new BN(numerator);
  var denomBN = new BN(denominator);
  return targetBN.mul(numBN).div(denomBN);
}

// node_modules/@portis/web3/es/utils/query.js
init_define_process_env();
var Query = function() {
  function Query2(provider) {
    this.provider = provider;
  }
  Query2.prototype.getBlockByNumber = function(blockNumber, fullTransaction) {
    return this.sendAsync("eth_getBlockByNumber", blockNumber, fullTransaction);
  };
  Query2.prototype.getCode = function(address, blockNumber) {
    if (blockNumber === void 0) {
      blockNumber = "latest";
    }
    return this.sendAsync("eth_getCode", address, blockNumber);
  };
  Query2.prototype.estimateGas = function(txParams) {
    return this.sendAsync("eth_estimateGas", txParams);
  };
  Query2.prototype.sendAsync = function(methodName) {
    var _this = this;
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return new Promise(function(resolve, reject) {
      _this.provider.sendAsync({
        id: 42,
        jsonrpc: "2.0",
        method: methodName,
        params: args
      }, function(error, response) {
        if (error) {
          reject(error);
        } else {
          resolve(response.result);
        }
      });
    });
  };
  return Query2;
}();

// node_modules/@portis/web3/es/web3/web3Manager.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator3 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var ProviderEngine = require_web3_provider_engine();
var CacheSubprovider = require_cache();
var FixtureSubprovider = require_fixture();
var FilterSubprovider = require_filters();
var HookedWalletSubprovider = require_hooked_wallet();
var NonceSubprovider = require_nonce_tracker();
var SubscriptionsSubprovider = require_subscriptions();
var Web3Manager = function() {
  function Web3Manager2(config, _getWidgetCommunication) {
    this.config = config;
    this._getWidgetCommunication = _getWidgetCommunication;
    this.provider = this._initProvider();
  }
  Web3Manager2.prototype.setSelectedAddress = function(selectedAddress) {
    this._selectedAddress = selectedAddress;
  };
  Web3Manager2.prototype.changeNetwork = function(network, gasRelay) {
    var newNetwork = networkAdapter(network, gasRelay);
    this.clearSubprovider(NonceSubprovider);
    this.clearSubprovider(CacheSubprovider);
    this.config.network = newNetwork;
  };
  Web3Manager2.prototype._initProvider = function() {
    var _this = this;
    if (this.engine) {
      return this.engine;
    }
    this.engine = new ProviderEngine();
    var query = new Query(this.engine);
    this.engine.send = function(payload, callback) {
      if (typeof payload === "string") {
        return new Promise(function(resolve, reject) {
          _this.engine.sendAsync({
            jsonrpc: "2.0",
            id: 42,
            method: payload,
            params: callback || []
          }, function(error, response) {
            if (error) {
              reject(error);
            } else {
              resolve(response.result);
            }
          });
        });
      }
      if (callback) {
        _this.engine.sendAsync(payload, callback);
        return;
      }
      var result = null;
      switch (payload.method) {
        case "eth_accounts":
          result = _this._selectedAddress ? [_this._selectedAddress] : [];
          break;
        case "eth_coinbase":
          result = _this._selectedAddress ? [_this._selectedAddress] : [];
          break;
        case "net_version":
          result = _this._network;
          break;
        case "eth_uninstallFilter":
          _this.engine.sendAsync(payload, function(_) {
            return _;
          });
          result = true;
          break;
        default:
          var message = "The Portis Web3 object does not support synchronous methods like " + payload.method + " without a callback parameter.";
          throw new Error(message);
      }
      return {
        id: payload.id,
        jsonrpc: payload.jsonrpc,
        result
      };
    };
    this.engine.addProvider(new FixtureSubprovider({
      web3_clientVersion: "Portis/v" + this.config.version + "/javascript",
      net_listening: true,
      eth_hashrate: "0x00",
      eth_mining: false,
      eth_syncing: true
    }));
    this.engine.addProvider(new CacheSubprovider());
    this.engine.addProvider(new SubscriptionsSubprovider());
    this.engine.addProvider(new FilterSubprovider());
    this.engine.addProvider(new NonceSubprovider());
    this.engine.addProvider({
      setEngine: function(_) {
        return _;
      },
      handleRequest: function(payload, next) {
        return __awaiter3(_this, void 0, void 0, function() {
          return __generator3(this, function(_a2) {
            if (!payload.id) {
              payload.id = 42;
            }
            next();
            return [2];
          });
        });
      }
    });
    this.engine.addProvider(new HookedWalletSubprovider({
      getAccounts: function(cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                return [4, widgetCommunication.getAccounts(this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                if (!error && result) {
                  this._selectedAddress = result[0];
                }
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signTransaction: function(txParams, cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                return [4, widgetCommunication.signTransaction(txParams, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signMessage: function(msgParams, cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, params, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                params = __assign({}, msgParams, { messageStandard: "signMessage" });
                return [4, widgetCommunication.signMessage(params, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signPersonalMessage: function(msgParams, cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, params, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                params = __assign({}, msgParams, { messageStandard: "signPersonalMessage" });
                return [4, widgetCommunication.signMessage(params, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signTypedMessage: function(msgParams, cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, params, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                params = __assign({}, msgParams, { messageStandard: "signTypedMessage" });
                return [4, widgetCommunication.signMessage(params, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signTypedMessageV3: function(msgParams, cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, params, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                params = __assign({}, msgParams, { messageStandard: "signTypedMessageV3" });
                return [4, widgetCommunication.signMessage(params, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      estimateGas: function(txParams, cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var gas;
          return __generator3(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, getTxGas(query, txParams)];
              case 1:
                gas = _a2.sent();
                cb(null, gas);
                return [2];
            }
          });
        });
      },
      getGasPrice: function(cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          return __generator3(this, function(_a2) {
            cb(null, "");
            return [2];
          });
        });
      }
    }));
    this.engine.addProvider({
      setEngine: function(_) {
        return _;
      },
      handleRequest: function(payload, next, end) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                return [4, widgetCommunication.relay(payload, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                if (payload.method === "net_version") {
                  this._network = result;
                  this.engine.networkVersion = this._network;
                }
                end(error, result);
                return [2];
            }
          });
        });
      }
    });
    this.engine.enable = function() {
      return new Promise(function(resolve, reject) {
        _this.engine.sendAsync({ method: "eth_accounts" }, function(error, response) {
          if (error) {
            reject(error);
          } else {
            resolve(response.result);
          }
        });
      });
    };
    this.engine.isConnected = function() {
      return true;
    };
    this.engine.isPortis = true;
    this.engine.on("error", function(error) {
      if (error && error.message && error.message.includes("PollingBlockTracker")) {
        console.warn("If you see this warning constantly, there might be an error with your RPC node.");
      } else {
        console.error(error);
      }
    });
    this.engine.start();
    return this.engine;
  };
  Web3Manager2.prototype.clearSubprovider = function(subproviderType) {
    var subprovider = this.provider._providers.find(function(subprovider2) {
      return subprovider2 instanceof subproviderType;
    });
    this.provider.removeProvider(subprovider);
    this.provider.addProvider(new subproviderType());
  };
  return Web3Manager2;
}();
var web3Manager_default = Web3Manager;

// node_modules/@portis/web3/es/utils/mockify.js
init_define_process_env();
var mockify = function(obj) {
  return new Proxy(obj, {
    get: function(target, prop) {
      if (target[prop] instanceof Function) {
        return function() {
        };
      } else {
        return void 0;
      }
    }
  });
};

// node_modules/@portis/web3/es/index.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator4 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var VERSION = "4.0.7";
var SUPPORTED_SCOPES = ["email", "reputation"];
onWindowLoad().then(windowLoadHandler).catch(function() {
});
var Portis = function() {
  function Portis2(dappId, network, options) {
    if (options === void 0) {
      options = {};
    }
    if (!isClientSide()) {
      return mockify(this);
    }
    validateSecureOrigin();
    this._validateParams(dappId, network, options);
    this._config = {
      dappId,
      network: networkAdapter(network, options.gasRelay),
      version: VERSION,
      scope: options.scope,
      registerPageByDefault: options.registerPageByDefault,
      staging: options.staging,
      feature: options.feature
    };
    this._getWidgetCommunication = this._getWidgetCommunication.bind(this);
    this._widgetManagerInstance = new widgetManager_default(this.config, this._clearProviderSession);
    this._web3ManagerInstance = new web3Manager_default(this.config, this._getWidgetCommunication);
    this.setDefaultEmail = this.setDefaultEmail.bind(this);
    this.changeNetwork = this.changeNetwork.bind(this);
    this.getWidget = this.getWidget.bind(this);
    this.onLogin = this.onLogin.bind(this);
    this.onLogout = this.onLogout.bind(this);
    this.onActiveWalletChanged = this.onActiveWalletChanged.bind(this);
    this.onError = this.onError.bind(this);
    this.showPortis = this.showPortis.bind(this);
    this.getCampaignInfo = this.getCampaignInfo.bind(this);
    this.claimVoucher = this.claimVoucher.bind(this);
    this.getExtendedPublicKey = this.getExtendedPublicKey.bind(this);
    this.importWallet = this.importWallet.bind(this);
    this.isLoggedIn = this.isLoggedIn.bind(this);
    this.signBitcoinTransaction = this.signBitcoinTransaction.bind(this);
    this.showBitcoinWallet = this.showBitcoinWallet.bind(this);
  }
  Object.defineProperty(Portis2.prototype, "_widgetManager", {
    get: function() {
      return this._widgetManagerInstance;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Portis2.prototype, "_web3Manager", {
    get: function() {
      return this._web3ManagerInstance;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Portis2.prototype, "config", {
    get: function() {
      return this._config;
    },
    enumerable: true,
    configurable: true
  });
  Portis2.prototype._clearProviderSession = function() {
    this._web3Manager.setSelectedAddress("");
  };
  Portis2.prototype._getWidgetCommunication = function() {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this._widgetManager.getWidget()];
          case 1:
            return [2, _a2.sent().communication];
        }
      });
    });
  };
  Object.defineProperty(Portis2.prototype, "web3Provider", {
    get: function() {
      return this._web3Manager.provider;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Portis2.prototype, "provider", {
    get: function() {
      return this.web3Provider;
    },
    enumerable: true,
    configurable: true
  });
  Portis2.prototype.changeNetwork = function(network, gasRelay) {
    this._web3Manager.changeNetwork(network, gasRelay);
  };
  Portis2.prototype.setDefaultEmail = function(email) {
    this._widgetManager.setDefaultEmail(email);
  };
  Portis2.prototype.getWidget = function() {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.getWidget()];
      });
    });
  };
  Portis2.prototype.onLogin = function(callback) {
    this._widgetManager.setOnLoginCallback(callback);
  };
  Portis2.prototype.onLogout = function(callback) {
    this._widgetManager.setOnLogoutCallback(callback);
  };
  Portis2.prototype.onActiveWalletChanged = function(callback) {
    this._widgetManager.setOnActiveWalletChangedCallback(callback);
  };
  Portis2.prototype.onError = function(callback) {
    this._widgetManager.setOnErrorCallback(callback);
  };
  Portis2.prototype.showPortis = function() {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.showPortis()];
      });
    });
  };
  Portis2.prototype.getCampaignInfo = function(campaignId) {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.getCampaignInfo(campaignId)];
      });
    });
  };
  Portis2.prototype.claimVoucher = function(voucherId) {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.claimVoucher(voucherId)];
      });
    });
  };
  Portis2.prototype.logout = function() {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.logout()];
      });
    });
  };
  Portis2.prototype.getExtendedPublicKey = function(path, coin) {
    if (path === void 0) {
      path = "m/44'/60'/0'/0/0";
    }
    if (coin === void 0) {
      coin = "Ethereum";
    }
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.getExtendedPublicKey(path, coin)];
      });
    });
  };
  Portis2.prototype.importWallet = function(mnemonicOrPrivateKey) {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.importWallet(mnemonicOrPrivateKey)];
      });
    });
  };
  Portis2.prototype.isLoggedIn = function() {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.isLoggedIn()];
      });
    });
  };
  Portis2.prototype.signBitcoinTransaction = function(params) {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.signBitcoinTransaction(params)];
      });
    });
  };
  Portis2.prototype.showBitcoinWallet = function(path) {
    if (path === void 0) {
      path = "m/49'/0'/0'/0/0";
    }
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.showBitcoinWallet(path)];
      });
    });
  };
  Portis2.prototype._validateParams = function(dappId, network, options) {
    if (!dappId) {
      throw new Error("[Portis] 'dappId' is required. Get your dappId here: https://dashboard.portis.io");
    }
    if (!network) {
      throw new Error("[Portis] 'network' is required. Read more about it here: https://docs.portis.io/#/configuration?id=network");
    }
    if (options.scope) {
      if (!Array.isArray(options.scope)) {
        throw new Error("[Portis] 'scope' must be an array. Read more about it here: https://docs.portis.io/#/configuration?id=scope");
      }
      var unknownScope = options.scope.filter(function(item) {
        return SUPPORTED_SCOPES.indexOf(item) < 0;
      });
      if (unknownScope.length > 0) {
        throw new Error("[Portis] invalid 'scope' parameter. Read more about it here: https://docs.portis.io/#/configuration?id=scope");
      }
    }
    if (options.registerPageByDefault !== void 0 && typeof options.registerPageByDefault !== "boolean") {
      throw new Error("[Portis] invalid 'registerPageByDefault' parameter, must be a boolean. Read more about it here: https://docs.portis.io/#/configuration?id=registerPageByDefault");
    }
  };
  return Portis2;
}();
var es_default = Portis;
export {
  es_default as default
};
//# sourceMappingURL=es-7HT6FS5O.js.map
