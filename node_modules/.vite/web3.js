import {
  http_exports,
  https_exports,
  init_http,
  init_https,
  require_browser,
  require_dist as require_dist2,
  require_eventemitter3,
  require_lib,
  require_lib2,
  require_lib3,
  require_lib4,
  require_lib5,
  require_lib6,
  require_lib7,
  require_lib8,
  require_oboe_browser
} from "./chunk-FMALSK2Q.js";
import {
  require_decode_uri_component
} from "./chunk-WV6IZDLR.js";
import {
  require_crypto_browserify,
  require_varint
} from "./chunk-PE7DEUGY.js";
import {
  require_url
} from "./chunk-SSQCKGNF.js";
import {
  require_immutable
} from "./chunk-7RFKSBT2.js";
import {
  require_src
} from "./chunk-3L2QOU6N.js";
import {
  require_dist as require_dist4
} from "./chunk-6DQSUYFA.js";
import {
  require_dist as require_dist3
} from "./chunk-P7FZ3CER.js";
import {
  require_dist
} from "./chunk-GY2U6V7C.js";
import "./chunk-HRG2DHFT.js";
import "./chunk-6XVHBKXF.js";
import "./chunk-QJBX42KY.js";
import {
  crypto_exports,
  init_crypto,
  require_elliptic
} from "./chunk-UTWHOSAQ.js";
import {
  require_util
} from "./chunk-BTG65MVN.js";
import "./chunk-K2K3O27I.js";
import "./chunk-557FO4FU.js";
import {
  require_base64_js,
  require_ieee754
} from "./chunk-S5NSXQRL.js";
import {
  require_object_assign
} from "./chunk-RFCOJ5N5.js";
import {
  require_scrypt
} from "./chunk-DJCW4LVW.js";
import "./chunk-VFG3R5NB.js";
import "./chunk-QLJNFGTT.js";
import "./chunk-HEQAI6WE.js";
import "./chunk-QMSD3UEV.js";
import "./chunk-27CSTQIU.js";
import {
  require_bn
} from "./chunk-VIQ6GMKA.js";
import "./chunk-PX4IM7JA.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __spreadProps,
  __spreadValues,
  __toCommonJS,
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// node_modules/web3/package.json
var require_package = __commonJS({
  "node_modules/web3/package.json"(exports, module) {
    module.exports = {
      name: "web3",
      version: "1.7.3",
      description: "Ethereum JavaScript API",
      repository: "https://github.com/ethereum/web3.js",
      license: "LGPL-3.0",
      engines: {
        node: ">=8.0.0"
      },
      main: "lib/index.js",
      bugs: {
        url: "https://github.com/ethereum/web3.js/issues"
      },
      keywords: [
        "Ethereum",
        "JavaScript",
        "API"
      ],
      author: "ethereum.org",
      types: "types/index.d.ts",
      scripts: {
        compile: "tsc -b tsconfig.json",
        dtslint: "dtslint --localTs ../../node_modules/typescript/lib types",
        postinstall: 'echo "WARNING: the web3-shh and web3-bzz api will be deprecated in the next version"'
      },
      authors: [
        {
          name: "Fabian Vogelsteller",
          email: "fabian@ethereum.org",
          homepage: "http://frozeman.de"
        },
        {
          name: "Marek Kotewicz",
          email: "marek@parity.io",
          url: "https://github.com/debris"
        },
        {
          name: "Marian Oancea",
          url: "https://github.com/cubedro"
        },
        {
          name: "Gav Wood",
          email: "g@parity.io",
          homepage: "http://gavwood.com"
        },
        {
          name: "Jeffery Wilcke",
          email: "jeffrey.wilcke@ethereum.org",
          url: "https://github.com/obscuren"
        }
      ],
      dependencies: {
        "web3-bzz": "1.7.3",
        "web3-core": "1.7.3",
        "web3-eth": "1.7.3",
        "web3-eth-personal": "1.7.3",
        "web3-net": "1.7.3",
        "web3-shh": "1.7.3",
        "web3-utils": "1.7.3"
      },
      devDependencies: {
        "@types/node": "^12.12.6",
        dtslint: "^3.4.1",
        typescript: "^3.9.5",
        "web3-core-helpers": "1.7.3"
      },
      gitHead: "f9bcad8ae63e3d0096859172cba35387f49f964e"
    };
  }
});

// node_modules/web3/node_modules/web3-core-requestmanager/lib/jsonrpc.js
var require_jsonrpc = __commonJS({
  "node_modules/web3/node_modules/web3-core-requestmanager/lib/jsonrpc.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = {
      messageId: 0
    };
    Jsonrpc.toPayload = function(method, params) {
      if (!method) {
        throw new Error('JSONRPC method should be specified for params: "' + JSON.stringify(params) + '"!');
      }
      Jsonrpc.messageId++;
      return {
        jsonrpc: "2.0",
        id: Jsonrpc.messageId,
        method,
        params: params || []
      };
    };
    Jsonrpc.isValidResponse = function(response) {
      return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);
      function validateSingleMessage(message) {
        return !!message && !message.error && message.jsonrpc === "2.0" && (typeof message.id === "number" || typeof message.id === "string") && message.result !== void 0;
      }
    };
    Jsonrpc.toBatchPayload = function(messages) {
      return messages.map(function(message) {
        return Jsonrpc.toPayload(message.method, message.params);
      });
    };
    module.exports = Jsonrpc;
  }
});

// node_modules/web3/node_modules/web3-core-requestmanager/lib/batch.js
var require_batch = __commonJS({
  "node_modules/web3/node_modules/web3-core-requestmanager/lib/batch.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = require_jsonrpc();
    var errors2 = require_lib3().errors;
    var Batch = function(requestManager) {
      this.requestManager = requestManager;
      this.requests = [];
    };
    Batch.prototype.add = function(request) {
      this.requests.push(request);
    };
    Batch.prototype.execute = function() {
      var requests = this.requests;
      var sortResponses = this._sortResponses.bind(this);
      this.requestManager.sendBatch(requests, function(err, results) {
        results = sortResponses(results);
        requests.map(function(request, index) {
          return results[index] || {};
        }).forEach(function(result, index) {
          if (requests[index].callback) {
            if (result && result.error) {
              return requests[index].callback(errors2.ErrorResponse(result));
            }
            if (!Jsonrpc.isValidResponse(result)) {
              return requests[index].callback(errors2.InvalidResponse(result));
            }
            try {
              requests[index].callback(null, requests[index].format ? requests[index].format(result.result) : result.result);
            } catch (err2) {
              requests[index].callback(err2);
            }
          }
        });
      });
    };
    Batch.prototype._sortResponses = function(responses) {
      return (responses || []).sort((a, b) => a.id - b.id);
    };
    module.exports = Batch;
  }
});

// node_modules/web3/node_modules/web3-core-requestmanager/lib/givenProvider.js
var require_givenProvider = __commonJS({
  "node_modules/web3/node_modules/web3-core-requestmanager/lib/givenProvider.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var givenProvider = null;
    var global2 = typeof globalThis === "object" ? globalThis : void 0;
    if (!global2) {
      try {
        global2 = Function("return this")();
      } catch (e) {
        global2 = self;
      }
    }
    if (typeof global2.ethereum !== "undefined") {
      givenProvider = global2.ethereum;
    } else if (typeof global2.web3 !== "undefined" && global2.web3.currentProvider) {
      if (global2.web3.currentProvider.sendAsync) {
        global2.web3.currentProvider.send = global2.web3.currentProvider.sendAsync;
        delete global2.web3.currentProvider.sendAsync;
      }
      if (!global2.web3.currentProvider.on && global2.web3.currentProvider.connection && global2.web3.currentProvider.connection.constructor.name === "ipcProviderWrapper") {
        global2.web3.currentProvider.on = function(type, callback) {
          if (typeof callback !== "function")
            throw new Error("The second parameter callback must be a function.");
          switch (type) {
            case "data":
              this.connection.on("data", function(data) {
                var result = "";
                data = data.toString();
                try {
                  result = JSON.parse(data);
                } catch (e) {
                  return callback(new Error("Couldn't parse response data" + data));
                }
                if (!result.id && result.method.indexOf("_subscription") !== -1) {
                  callback(null, result);
                }
              });
              break;
            default:
              this.connection.on(type, callback);
              break;
          }
        };
      }
      givenProvider = global2.web3.currentProvider;
    }
    module.exports = givenProvider;
  }
});

// node_modules/web3/node_modules/web3-providers-ws/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/web3/node_modules/web3-providers-ws/lib/helpers.js"(exports, module) {
    init_define_process_env();
    var isNode = Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
    var isRN = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var _btoa = null;
    var helpers = null;
    if (isNode || isRN) {
      _btoa = function(str) {
        return Buffer.from(str).toString("base64");
      };
      url = require_url();
      if (url.URL) {
        newURL = url.URL;
        helpers = function(url2) {
          return new newURL(url2);
        };
      } else {
        helpers = require_url().parse;
      }
    } else {
      _btoa = btoa.bind(typeof globalThis === "object" ? globalThis : self);
      helpers = function(url2) {
        return new URL(url2);
      };
    }
    var url;
    var newURL;
    module.exports = {
      parseURL: helpers,
      btoa: _btoa
    };
  }
});

// node_modules/web3/node_modules/web3-providers-ws/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/web3/node_modules/web3-providers-ws/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var EventEmitter = require_eventemitter3();
    var helpers = require_helpers();
    var errors2 = require_lib3().errors;
    var Ws = require_browser().w3cwebsocket;
    var WebsocketProvider = function WebsocketProvider2(url, options) {
      EventEmitter.call(this);
      options = options || {};
      this.url = url;
      this._customTimeout = options.timeout || 1e3 * 15;
      this.headers = options.headers || {};
      this.protocol = options.protocol || void 0;
      this.reconnectOptions = Object.assign({
        auto: false,
        delay: 5e3,
        maxAttempts: false,
        onTimeout: false
      }, options.reconnect);
      this.clientConfig = options.clientConfig || void 0;
      this.requestOptions = options.requestOptions || void 0;
      this.DATA = "data";
      this.CLOSE = "close";
      this.ERROR = "error";
      this.CONNECT = "connect";
      this.RECONNECT = "reconnect";
      this.connection = null;
      this.requestQueue = /* @__PURE__ */ new Map();
      this.responseQueue = /* @__PURE__ */ new Map();
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      var parsedURL = helpers.parseURL(url);
      if (parsedURL.username && parsedURL.password) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.username + ":" + parsedURL.password);
      }
      if (parsedURL.auth) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.auth);
      }
      Object.defineProperty(this, "connected", {
        get: function() {
          return this.connection && this.connection.readyState === this.connection.OPEN;
        },
        enumerable: true
      });
      this.connect();
    };
    WebsocketProvider.prototype = Object.create(EventEmitter.prototype);
    WebsocketProvider.prototype.constructor = WebsocketProvider;
    WebsocketProvider.prototype.connect = function() {
      this.connection = new Ws(this.url, this.protocol, void 0, this.headers, this.requestOptions, this.clientConfig);
      this._addSocketListeners();
    };
    WebsocketProvider.prototype._onMessage = function(e) {
      var _this = this;
      this._parseResponse(typeof e.data === "string" ? e.data : "").forEach(function(result) {
        if (result.method && result.method.indexOf("_subscription") !== -1) {
          _this.emit(_this.DATA, result);
          return;
        }
        var id = result.id;
        if (Array.isArray(result)) {
          id = result[0].id;
        }
        if (_this.responseQueue.has(id)) {
          if (_this.responseQueue.get(id).callback !== void 0) {
            _this.responseQueue.get(id).callback(false, result);
          }
          _this.responseQueue.delete(id);
        }
      });
    };
    WebsocketProvider.prototype._onConnect = function() {
      this.emit(this.CONNECT);
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        var _this = this;
        this.requestQueue.forEach(function(request, key) {
          _this.send(request.payload, request.callback);
          _this.requestQueue.delete(key);
        });
      }
    };
    WebsocketProvider.prototype._onClose = function(event) {
      var _this = this;
      if (this.reconnectOptions.auto && (![1e3, 1001].includes(event.code) || event.wasClean === false)) {
        this.reconnect();
        return;
      }
      this.emit(this.CLOSE, event);
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors2.ConnectionNotOpenError(event));
          _this.requestQueue.delete(key);
        });
      }
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors2.InvalidConnection("on WS", event));
          _this.responseQueue.delete(key);
        });
      }
      this._removeSocketListeners();
      this.removeAllListeners();
    };
    WebsocketProvider.prototype._addSocketListeners = function() {
      this.connection.addEventListener("message", this._onMessage.bind(this));
      this.connection.addEventListener("open", this._onConnect.bind(this));
      this.connection.addEventListener("close", this._onClose.bind(this));
    };
    WebsocketProvider.prototype._removeSocketListeners = function() {
      this.connection.removeEventListener("message", this._onMessage);
      this.connection.removeEventListener("open", this._onConnect);
      this.connection.removeEventListener("close", this._onClose);
    };
    WebsocketProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {
              _this.reconnect();
              return;
            }
            _this.emit(_this.ERROR, errors2.ConnectionTimeout(_this._customTimeout));
            if (_this.requestQueue.size > 0) {
              _this.requestQueue.forEach(function(request, key) {
                request.callback(errors2.ConnectionTimeout(_this._customTimeout));
                _this.requestQueue.delete(key);
              });
            }
          }, _this._customTimeout);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    WebsocketProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var id = payload.id;
      var request = { payload, callback };
      if (Array.isArray(payload)) {
        id = payload[0].id;
      }
      if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {
        this.requestQueue.set(id, request);
        return;
      }
      if (this.connection.readyState !== this.connection.OPEN) {
        this.requestQueue.delete(id);
        this.emit(this.ERROR, errors2.ConnectionNotOpenError());
        request.callback(errors2.ConnectionNotOpenError());
        return;
      }
      this.responseQueue.set(id, request);
      this.requestQueue.delete(id);
      try {
        this.connection.send(JSON.stringify(request.payload));
      } catch (error2) {
        request.callback(error2);
        _this.responseQueue.delete(id);
      }
    };
    WebsocketProvider.prototype.reset = function() {
      this.responseQueue.clear();
      this.requestQueue.clear();
      this.removeAllListeners();
      this._removeSocketListeners();
      this._addSocketListeners();
    };
    WebsocketProvider.prototype.disconnect = function(code, reason) {
      this._removeSocketListeners();
      this.connection.close(code || 1e3, reason);
    };
    WebsocketProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    WebsocketProvider.prototype.reconnect = function() {
      var _this = this;
      this.reconnecting = true;
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors2.PendingRequestsOnReconnectingError());
          _this.responseQueue.delete(key);
        });
      }
      if (!this.reconnectOptions.maxAttempts || this.reconnectAttempts < this.reconnectOptions.maxAttempts) {
        setTimeout(function() {
          _this.reconnectAttempts++;
          _this._removeSocketListeners();
          _this.emit(_this.RECONNECT, _this.reconnectAttempts);
          _this.connect();
        }, this.reconnectOptions.delay);
        return;
      }
      this.emit(this.ERROR, errors2.MaxAttemptsReachedOnReconnectingError());
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors2.MaxAttemptsReachedOnReconnectingError());
          _this.requestQueue.delete(key);
        });
      }
    };
    module.exports = WebsocketProvider;
  }
});

// node_modules/web3/node_modules/web3-providers-http/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/web3/node_modules/web3-providers-http/lib/index.js"(exports, module) {
    init_define_process_env();
    var errors2 = require_lib3().errors;
    var XHR2 = require_dist2().XMLHttpRequest;
    var http = (init_http(), __toCommonJS(http_exports));
    var https = (init_https(), __toCommonJS(https_exports));
    var HttpProvider = function HttpProvider2(host, options) {
      options = options || {};
      this.withCredentials = options.withCredentials || false;
      this.timeout = options.timeout || 0;
      this.headers = options.headers;
      this.agent = options.agent;
      this.connected = false;
      const keepAlive = options.keepAlive !== false;
      this.host = host || "http://localhost:8545";
      if (!this.agent) {
        if (this.host.substring(0, 5) === "https") {
          this.httpsAgent = new https.Agent({ keepAlive });
        } else {
          this.httpAgent = new http.Agent({ keepAlive });
        }
      }
    };
    HttpProvider.prototype._prepareRequest = function() {
      var request;
      if (typeof XMLHttpRequest !== "undefined") {
        request = new XMLHttpRequest();
      } else {
        request = new XHR2();
        var agents = { httpsAgent: this.httpsAgent, httpAgent: this.httpAgent, baseUrl: this.baseUrl };
        if (this.agent) {
          agents.httpsAgent = this.agent.https;
          agents.httpAgent = this.agent.http;
          agents.baseUrl = this.agent.baseUrl;
        }
        request.nodejsSet(agents);
      }
      request.open("POST", this.host, true);
      request.setRequestHeader("Content-Type", "application/json");
      request.timeout = this.timeout;
      request.withCredentials = this.withCredentials;
      if (this.headers) {
        this.headers.forEach(function(header) {
          request.setRequestHeader(header.name, header.value);
        });
      }
      return request;
    };
    HttpProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var request = this._prepareRequest();
      request.onreadystatechange = function() {
        if (request.readyState === 4 && request.timeout !== 1) {
          var result = request.responseText;
          var error2 = null;
          try {
            result = JSON.parse(result);
          } catch (e) {
            error2 = errors2.InvalidResponse(request.responseText);
          }
          _this.connected = true;
          callback(error2, result);
        }
      };
      request.ontimeout = function() {
        _this.connected = false;
        callback(errors2.ConnectionTimeout(this.timeout));
      };
      try {
        request.send(JSON.stringify(payload));
      } catch (error2) {
        this.connected = false;
        callback(errors2.InvalidConnection(this.host));
      }
    };
    HttpProvider.prototype.disconnect = function() {
    };
    HttpProvider.prototype.supportsSubscriptions = function() {
      return false;
    };
    module.exports = HttpProvider;
  }
});

// node_modules/web3/node_modules/web3-providers-ipc/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/web3/node_modules/web3-providers-ipc/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var errors2 = require_lib3().errors;
    var oboe = require_oboe_browser();
    var IpcProvider = function IpcProvider2(path, net) {
      var _this = this;
      this.responseCallbacks = {};
      this.notificationCallbacks = [];
      this.path = path;
      this.connected = false;
      this.connection = net.connect({ path: this.path });
      this.addDefaultEvents();
      var callback = function(result) {
        var id = null;
        if (Array.isArray(result)) {
          result.forEach(function(load) {
            if (_this.responseCallbacks[load.id])
              id = load.id;
          });
        } else {
          id = result.id;
        }
        if (!id && result.method.indexOf("_subscription") !== -1) {
          _this.notificationCallbacks.forEach(function(callback2) {
            if (typeof callback2 === "function")
              callback2(result);
          });
        } else if (_this.responseCallbacks[id]) {
          _this.responseCallbacks[id](null, result);
          delete _this.responseCallbacks[id];
        }
      };
      if (net.constructor.name === "Socket") {
        oboe(this.connection).done(callback);
      } else {
        this.connection.on("data", function(data) {
          _this._parseResponse(data.toString()).forEach(callback);
        });
      }
    };
    IpcProvider.prototype.addDefaultEvents = function() {
      var _this = this;
      this.connection.on("connect", function() {
        _this.connected = true;
      });
      this.connection.on("close", function() {
        _this.connected = false;
      });
      this.connection.on("error", function() {
        _this._timeout();
      });
      this.connection.on("end", function() {
        _this._timeout();
      });
      this.connection.on("timeout", function() {
        _this._timeout();
      });
    };
    IpcProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            _this._timeout();
            throw errors2.InvalidResponse(data2);
          }, 1e3 * 15);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    IpcProvider.prototype._addResponseCallback = function(payload, callback) {
      var id = payload.id || payload[0].id;
      var method = payload.method || payload[0].method;
      this.responseCallbacks[id] = callback;
      this.responseCallbacks[id].method = method;
    };
    IpcProvider.prototype._timeout = function() {
      for (var key in this.responseCallbacks) {
        if (this.responseCallbacks.hasOwnProperty(key)) {
          this.responseCallbacks[key](errors2.InvalidConnection("on IPC"));
          delete this.responseCallbacks[key];
        }
      }
    };
    IpcProvider.prototype.reconnect = function() {
      this.connection.connect({ path: this.path });
    };
    IpcProvider.prototype.send = function(payload, callback) {
      if (!this.connection.writable)
        this.connection.connect({ path: this.path });
      this.connection.write(JSON.stringify(payload));
      this._addResponseCallback(payload, callback);
    };
    IpcProvider.prototype.on = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      switch (type) {
        case "data":
          this.notificationCallbacks.push(callback);
          break;
        default:
          this.connection.on(type, callback);
          break;
      }
    };
    IpcProvider.prototype.once = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      this.connection.once(type, callback);
    };
    IpcProvider.prototype.removeListener = function(type, callback) {
      var _this = this;
      switch (type) {
        case "data":
          this.notificationCallbacks.forEach(function(cb, index) {
            if (cb === callback)
              _this.notificationCallbacks.splice(index, 1);
          });
          break;
        default:
          this.connection.removeListener(type, callback);
          break;
      }
    };
    IpcProvider.prototype.removeAllListeners = function(type) {
      switch (type) {
        case "data":
          this.notificationCallbacks = [];
          break;
        default:
          this.connection.removeAllListeners(type);
          break;
      }
    };
    IpcProvider.prototype.reset = function() {
      this._timeout();
      this.notificationCallbacks = [];
      this.connection.removeAllListeners("error");
      this.connection.removeAllListeners("end");
      this.connection.removeAllListeners("timeout");
      this.addDefaultEvents();
    };
    IpcProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    module.exports = IpcProvider;
  }
});

// node_modules/web3/node_modules/web3-core-requestmanager/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/web3/node_modules/web3-core-requestmanager/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { callbackify } = require_util();
    var errors2 = require_lib3().errors;
    var Jsonrpc = require_jsonrpc();
    var BatchManager = require_batch();
    var givenProvider = require_givenProvider();
    var RequestManager = function RequestManager2(provider, net) {
      this.provider = null;
      this.providers = RequestManager2.providers;
      this.setProvider(provider, net);
      this.subscriptions = /* @__PURE__ */ new Map();
    };
    RequestManager.givenProvider = givenProvider;
    RequestManager.providers = {
      WebsocketProvider: require_lib9(),
      HttpProvider: require_lib10(),
      IpcProvider: require_lib11()
    };
    RequestManager.prototype.setProvider = function(provider, net) {
      var _this = this;
      if (provider && typeof provider === "string" && this.providers) {
        if (/^http(s)?:\/\//i.test(provider)) {
          provider = new this.providers.HttpProvider(provider);
        } else if (/^ws(s)?:\/\//i.test(provider)) {
          provider = new this.providers.WebsocketProvider(provider);
        } else if (provider && typeof net === "object" && typeof net.connect === "function") {
          provider = new this.providers.IpcProvider(provider, net);
        } else if (provider) {
          throw new Error(`Can't autodetect provider for "` + provider + '"');
        }
      }
      if (this.provider && this.provider.connected)
        this.clearSubscriptions();
      this.provider = provider || null;
      if (this.provider && this.provider.on) {
        if (typeof provider.request === "function") {
          this.provider.on("message", function(payload) {
            if (payload && payload.type === "eth_subscription" && payload.data) {
              const data = payload.data;
              if (data.subscription && _this.subscriptions.has(data.subscription)) {
                _this.subscriptions.get(data.subscription).callback(null, data.result);
              }
            }
          });
        } else {
          this.provider.on("data", function data(result, deprecatedResult) {
            result = result || deprecatedResult;
            if (result.method && result.params && result.params.subscription && _this.subscriptions.has(result.params.subscription)) {
              _this.subscriptions.get(result.params.subscription).callback(null, result.params.result);
            }
          });
        }
        this.provider.on("connect", function connect() {
          _this.subscriptions.forEach(function(subscription) {
            subscription.subscription.resubscribe();
          });
        });
        this.provider.on("error", function error2(error2) {
          _this.subscriptions.forEach(function(subscription) {
            subscription.callback(error2);
          });
        });
        const disconnect = function disconnect2(event) {
          if (!_this._isCleanCloseEvent(event) || _this._isIpcCloseError(event)) {
            _this.subscriptions.forEach(function(subscription) {
              subscription.callback(errors2.ConnectionCloseError(event));
              _this.subscriptions.delete(subscription.subscription.id);
            });
            if (_this.provider && _this.provider.emit) {
              _this.provider.emit("error", errors2.ConnectionCloseError(event));
            }
          }
          if (_this.provider && _this.provider.emit) {
            _this.provider.emit("end", event);
          }
        };
        this.provider.on("disconnect", disconnect);
      }
    };
    RequestManager.prototype.send = function(data, callback) {
      callback = callback || function() {
      };
      if (!this.provider) {
        return callback(errors2.InvalidProvider());
      }
      const { method, params } = data;
      const jsonrpcPayload = Jsonrpc.toPayload(method, params);
      const jsonrpcResultCallback = this._jsonrpcResultCallback(callback, jsonrpcPayload);
      if (this.provider.request) {
        const callbackRequest = callbackify(this.provider.request.bind(this.provider));
        const requestArgs = { method, params };
        callbackRequest(requestArgs, callback);
      } else if (this.provider.sendAsync) {
        this.provider.sendAsync(jsonrpcPayload, jsonrpcResultCallback);
      } else if (this.provider.send) {
        this.provider.send(jsonrpcPayload, jsonrpcResultCallback);
      } else {
        throw new Error("Provider does not have a request or send method to use.");
      }
    };
    RequestManager.prototype.sendBatch = function(data, callback) {
      if (!this.provider) {
        return callback(errors2.InvalidProvider());
      }
      var payload = Jsonrpc.toBatchPayload(data);
      this.provider[this.provider.sendAsync ? "sendAsync" : "send"](payload, function(err, results) {
        if (err) {
          return callback(err);
        }
        if (!Array.isArray(results)) {
          return callback(errors2.InvalidResponse(results));
        }
        callback(null, results);
      });
    };
    RequestManager.prototype.addSubscription = function(subscription, callback) {
      if (this.provider.on) {
        this.subscriptions.set(subscription.id, {
          callback,
          subscription
        });
      } else {
        throw new Error("The provider doesn't support subscriptions: " + this.provider.constructor.name);
      }
    };
    RequestManager.prototype.removeSubscription = function(id, callback) {
      if (this.subscriptions.has(id)) {
        var type = this.subscriptions.get(id).subscription.options.type;
        this.subscriptions.delete(id);
        this.send({
          method: type + "_unsubscribe",
          params: [id]
        }, callback);
        return;
      }
      if (typeof callback === "function") {
        callback(null);
      }
    };
    RequestManager.prototype.clearSubscriptions = function(keepIsSyncing) {
      try {
        var _this = this;
        if (this.subscriptions.size > 0) {
          this.subscriptions.forEach(function(value, id) {
            if (!keepIsSyncing || value.name !== "syncing")
              _this.removeSubscription(id);
          });
        }
        if (this.provider.reset)
          this.provider.reset();
        return true;
      } catch (e) {
        throw new Error(`Error while clearing subscriptions: ${e}`);
      }
    };
    RequestManager.prototype._isCleanCloseEvent = function(event) {
      return typeof event === "object" && ([1e3].includes(event.code) || event.wasClean === true);
    };
    RequestManager.prototype._isIpcCloseError = function(event) {
      return typeof event === "boolean" && event;
    };
    RequestManager.prototype._jsonrpcResultCallback = function(callback, payload) {
      return function(err, result) {
        if (result && result.id && payload.id !== result.id) {
          return callback(new Error(`Wrong response id ${result.id} (expected: ${payload.id}) in ${JSON.stringify(payload)}`));
        }
        if (err) {
          return callback(err);
        }
        if (result && result.error) {
          return callback(errors2.ErrorResponse(result));
        }
        if (!Jsonrpc.isValidResponse(result)) {
          return callback(errors2.InvalidResponse(result));
        }
        callback(null, result.result);
      };
    };
    module.exports = {
      Manager: RequestManager,
      BatchManager
    };
  }
});

// node_modules/web3/node_modules/web3-core/lib/extend.js
var require_extend = __commonJS({
  "node_modules/web3/node_modules/web3-core/lib/extend.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var formatters = require_lib3().formatters;
    var Method = require_lib6();
    var utils = require_lib();
    var extend = function(pckg) {
      var ex = function(extension) {
        var extendedObject;
        if (extension.property) {
          if (!pckg[extension.property]) {
            pckg[extension.property] = {};
          }
          extendedObject = pckg[extension.property];
        } else {
          extendedObject = pckg;
        }
        if (extension.methods) {
          extension.methods.forEach(function(method) {
            if (!(method instanceof Method)) {
              method = new Method(method);
            }
            method.attachToObject(extendedObject);
            method.setRequestManager(pckg._requestManager);
          });
        }
        return pckg;
      };
      ex.formatters = formatters;
      ex.utils = utils;
      ex.Method = Method;
      return ex;
    };
    module.exports = extend;
  }
});

// node_modules/web3/node_modules/web3-core/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/web3/node_modules/web3-core/lib/index.js"(exports, module) {
    init_define_process_env();
    var requestManager = require_lib12();
    var extend = require_extend();
    var packageInit = (pkg, args) => {
      args = Array.prototype.slice.call(args);
      if (!pkg) {
        throw new Error('You need to instantiate using the "new" keyword.');
      }
      Object.defineProperty(pkg, "currentProvider", {
        get: () => {
          return pkg._provider;
        },
        set: (value) => {
          return pkg.setProvider(value);
        },
        enumerable: true,
        configurable: true
      });
      if (args[0] && args[0]._requestManager) {
        pkg._requestManager = args[0]._requestManager;
      } else {
        pkg._requestManager = new requestManager.Manager(args[0], args[1]);
      }
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
      pkg._provider = pkg._requestManager.provider;
      if (!pkg.setProvider) {
        pkg.setProvider = (provider, net) => {
          pkg._requestManager.setProvider(provider, net);
          pkg._provider = pkg._requestManager.provider;
          return true;
        };
      }
      pkg.setRequestManager = (manager) => {
        pkg._requestManager = manager;
        pkg._provider = manager.provider;
      };
      pkg.BatchRequest = requestManager.BatchManager.bind(null, pkg._requestManager);
      pkg.extend = extend(pkg);
    };
    var addProviders = (pkg) => {
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
    };
    module.exports = {
      packageInit,
      addProviders
    };
  }
});

// node_modules/web3-eth/node_modules/web3-core-requestmanager/lib/jsonrpc.js
var require_jsonrpc2 = __commonJS({
  "node_modules/web3-eth/node_modules/web3-core-requestmanager/lib/jsonrpc.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = {
      messageId: 0
    };
    Jsonrpc.toPayload = function(method, params) {
      if (!method) {
        throw new Error('JSONRPC method should be specified for params: "' + JSON.stringify(params) + '"!');
      }
      Jsonrpc.messageId++;
      return {
        jsonrpc: "2.0",
        id: Jsonrpc.messageId,
        method,
        params: params || []
      };
    };
    Jsonrpc.isValidResponse = function(response) {
      return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);
      function validateSingleMessage(message) {
        return !!message && !message.error && message.jsonrpc === "2.0" && (typeof message.id === "number" || typeof message.id === "string") && message.result !== void 0;
      }
    };
    Jsonrpc.toBatchPayload = function(messages) {
      return messages.map(function(message) {
        return Jsonrpc.toPayload(message.method, message.params);
      });
    };
    module.exports = Jsonrpc;
  }
});

// node_modules/web3-eth/node_modules/web3-core-requestmanager/lib/batch.js
var require_batch2 = __commonJS({
  "node_modules/web3-eth/node_modules/web3-core-requestmanager/lib/batch.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = require_jsonrpc2();
    var errors2 = require_lib3().errors;
    var Batch = function(requestManager) {
      this.requestManager = requestManager;
      this.requests = [];
    };
    Batch.prototype.add = function(request) {
      this.requests.push(request);
    };
    Batch.prototype.execute = function() {
      var requests = this.requests;
      var sortResponses = this._sortResponses.bind(this);
      this.requestManager.sendBatch(requests, function(err, results) {
        results = sortResponses(results);
        requests.map(function(request, index) {
          return results[index] || {};
        }).forEach(function(result, index) {
          if (requests[index].callback) {
            if (result && result.error) {
              return requests[index].callback(errors2.ErrorResponse(result));
            }
            if (!Jsonrpc.isValidResponse(result)) {
              return requests[index].callback(errors2.InvalidResponse(result));
            }
            try {
              requests[index].callback(null, requests[index].format ? requests[index].format(result.result) : result.result);
            } catch (err2) {
              requests[index].callback(err2);
            }
          }
        });
      });
    };
    Batch.prototype._sortResponses = function(responses) {
      return (responses || []).sort((a, b) => a.id - b.id);
    };
    module.exports = Batch;
  }
});

// node_modules/web3-eth/node_modules/web3-core-requestmanager/lib/givenProvider.js
var require_givenProvider2 = __commonJS({
  "node_modules/web3-eth/node_modules/web3-core-requestmanager/lib/givenProvider.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var givenProvider = null;
    var global2 = typeof globalThis === "object" ? globalThis : void 0;
    if (!global2) {
      try {
        global2 = Function("return this")();
      } catch (e) {
        global2 = self;
      }
    }
    if (typeof global2.ethereum !== "undefined") {
      givenProvider = global2.ethereum;
    } else if (typeof global2.web3 !== "undefined" && global2.web3.currentProvider) {
      if (global2.web3.currentProvider.sendAsync) {
        global2.web3.currentProvider.send = global2.web3.currentProvider.sendAsync;
        delete global2.web3.currentProvider.sendAsync;
      }
      if (!global2.web3.currentProvider.on && global2.web3.currentProvider.connection && global2.web3.currentProvider.connection.constructor.name === "ipcProviderWrapper") {
        global2.web3.currentProvider.on = function(type, callback) {
          if (typeof callback !== "function")
            throw new Error("The second parameter callback must be a function.");
          switch (type) {
            case "data":
              this.connection.on("data", function(data) {
                var result = "";
                data = data.toString();
                try {
                  result = JSON.parse(data);
                } catch (e) {
                  return callback(new Error("Couldn't parse response data" + data));
                }
                if (!result.id && result.method.indexOf("_subscription") !== -1) {
                  callback(null, result);
                }
              });
              break;
            default:
              this.connection.on(type, callback);
              break;
          }
        };
      }
      givenProvider = global2.web3.currentProvider;
    }
    module.exports = givenProvider;
  }
});

// node_modules/web3-eth/node_modules/web3-providers-ws/lib/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/web3-eth/node_modules/web3-providers-ws/lib/helpers.js"(exports, module) {
    init_define_process_env();
    var isNode = Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
    var isRN = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var _btoa = null;
    var helpers = null;
    if (isNode || isRN) {
      _btoa = function(str) {
        return Buffer.from(str).toString("base64");
      };
      url = require_url();
      if (url.URL) {
        newURL = url.URL;
        helpers = function(url2) {
          return new newURL(url2);
        };
      } else {
        helpers = require_url().parse;
      }
    } else {
      _btoa = btoa.bind(typeof globalThis === "object" ? globalThis : self);
      helpers = function(url2) {
        return new URL(url2);
      };
    }
    var url;
    var newURL;
    module.exports = {
      parseURL: helpers,
      btoa: _btoa
    };
  }
});

// node_modules/web3-eth/node_modules/web3-providers-ws/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/web3-eth/node_modules/web3-providers-ws/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var EventEmitter = require_eventemitter3();
    var helpers = require_helpers2();
    var errors2 = require_lib3().errors;
    var Ws = require_browser().w3cwebsocket;
    var WebsocketProvider = function WebsocketProvider2(url, options) {
      EventEmitter.call(this);
      options = options || {};
      this.url = url;
      this._customTimeout = options.timeout || 1e3 * 15;
      this.headers = options.headers || {};
      this.protocol = options.protocol || void 0;
      this.reconnectOptions = Object.assign({
        auto: false,
        delay: 5e3,
        maxAttempts: false,
        onTimeout: false
      }, options.reconnect);
      this.clientConfig = options.clientConfig || void 0;
      this.requestOptions = options.requestOptions || void 0;
      this.DATA = "data";
      this.CLOSE = "close";
      this.ERROR = "error";
      this.CONNECT = "connect";
      this.RECONNECT = "reconnect";
      this.connection = null;
      this.requestQueue = /* @__PURE__ */ new Map();
      this.responseQueue = /* @__PURE__ */ new Map();
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      var parsedURL = helpers.parseURL(url);
      if (parsedURL.username && parsedURL.password) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.username + ":" + parsedURL.password);
      }
      if (parsedURL.auth) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.auth);
      }
      Object.defineProperty(this, "connected", {
        get: function() {
          return this.connection && this.connection.readyState === this.connection.OPEN;
        },
        enumerable: true
      });
      this.connect();
    };
    WebsocketProvider.prototype = Object.create(EventEmitter.prototype);
    WebsocketProvider.prototype.constructor = WebsocketProvider;
    WebsocketProvider.prototype.connect = function() {
      this.connection = new Ws(this.url, this.protocol, void 0, this.headers, this.requestOptions, this.clientConfig);
      this._addSocketListeners();
    };
    WebsocketProvider.prototype._onMessage = function(e) {
      var _this = this;
      this._parseResponse(typeof e.data === "string" ? e.data : "").forEach(function(result) {
        if (result.method && result.method.indexOf("_subscription") !== -1) {
          _this.emit(_this.DATA, result);
          return;
        }
        var id = result.id;
        if (Array.isArray(result)) {
          id = result[0].id;
        }
        if (_this.responseQueue.has(id)) {
          if (_this.responseQueue.get(id).callback !== void 0) {
            _this.responseQueue.get(id).callback(false, result);
          }
          _this.responseQueue.delete(id);
        }
      });
    };
    WebsocketProvider.prototype._onConnect = function() {
      this.emit(this.CONNECT);
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        var _this = this;
        this.requestQueue.forEach(function(request, key) {
          _this.send(request.payload, request.callback);
          _this.requestQueue.delete(key);
        });
      }
    };
    WebsocketProvider.prototype._onClose = function(event) {
      var _this = this;
      if (this.reconnectOptions.auto && (![1e3, 1001].includes(event.code) || event.wasClean === false)) {
        this.reconnect();
        return;
      }
      this.emit(this.CLOSE, event);
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors2.ConnectionNotOpenError(event));
          _this.requestQueue.delete(key);
        });
      }
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors2.InvalidConnection("on WS", event));
          _this.responseQueue.delete(key);
        });
      }
      this._removeSocketListeners();
      this.removeAllListeners();
    };
    WebsocketProvider.prototype._addSocketListeners = function() {
      this.connection.addEventListener("message", this._onMessage.bind(this));
      this.connection.addEventListener("open", this._onConnect.bind(this));
      this.connection.addEventListener("close", this._onClose.bind(this));
    };
    WebsocketProvider.prototype._removeSocketListeners = function() {
      this.connection.removeEventListener("message", this._onMessage);
      this.connection.removeEventListener("open", this._onConnect);
      this.connection.removeEventListener("close", this._onClose);
    };
    WebsocketProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {
              _this.reconnect();
              return;
            }
            _this.emit(_this.ERROR, errors2.ConnectionTimeout(_this._customTimeout));
            if (_this.requestQueue.size > 0) {
              _this.requestQueue.forEach(function(request, key) {
                request.callback(errors2.ConnectionTimeout(_this._customTimeout));
                _this.requestQueue.delete(key);
              });
            }
          }, _this._customTimeout);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    WebsocketProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var id = payload.id;
      var request = { payload, callback };
      if (Array.isArray(payload)) {
        id = payload[0].id;
      }
      if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {
        this.requestQueue.set(id, request);
        return;
      }
      if (this.connection.readyState !== this.connection.OPEN) {
        this.requestQueue.delete(id);
        this.emit(this.ERROR, errors2.ConnectionNotOpenError());
        request.callback(errors2.ConnectionNotOpenError());
        return;
      }
      this.responseQueue.set(id, request);
      this.requestQueue.delete(id);
      try {
        this.connection.send(JSON.stringify(request.payload));
      } catch (error2) {
        request.callback(error2);
        _this.responseQueue.delete(id);
      }
    };
    WebsocketProvider.prototype.reset = function() {
      this.responseQueue.clear();
      this.requestQueue.clear();
      this.removeAllListeners();
      this._removeSocketListeners();
      this._addSocketListeners();
    };
    WebsocketProvider.prototype.disconnect = function(code, reason) {
      this._removeSocketListeners();
      this.connection.close(code || 1e3, reason);
    };
    WebsocketProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    WebsocketProvider.prototype.reconnect = function() {
      var _this = this;
      this.reconnecting = true;
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors2.PendingRequestsOnReconnectingError());
          _this.responseQueue.delete(key);
        });
      }
      if (!this.reconnectOptions.maxAttempts || this.reconnectAttempts < this.reconnectOptions.maxAttempts) {
        setTimeout(function() {
          _this.reconnectAttempts++;
          _this._removeSocketListeners();
          _this.emit(_this.RECONNECT, _this.reconnectAttempts);
          _this.connect();
        }, this.reconnectOptions.delay);
        return;
      }
      this.emit(this.ERROR, errors2.MaxAttemptsReachedOnReconnectingError());
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors2.MaxAttemptsReachedOnReconnectingError());
          _this.requestQueue.delete(key);
        });
      }
    };
    module.exports = WebsocketProvider;
  }
});

// node_modules/web3-eth/node_modules/web3-providers-http/lib/index.js
var require_lib15 = __commonJS({
  "node_modules/web3-eth/node_modules/web3-providers-http/lib/index.js"(exports, module) {
    init_define_process_env();
    var errors2 = require_lib3().errors;
    var XHR2 = require_dist2().XMLHttpRequest;
    var http = (init_http(), __toCommonJS(http_exports));
    var https = (init_https(), __toCommonJS(https_exports));
    var HttpProvider = function HttpProvider2(host, options) {
      options = options || {};
      this.withCredentials = options.withCredentials || false;
      this.timeout = options.timeout || 0;
      this.headers = options.headers;
      this.agent = options.agent;
      this.connected = false;
      const keepAlive = options.keepAlive !== false;
      this.host = host || "http://localhost:8545";
      if (!this.agent) {
        if (this.host.substring(0, 5) === "https") {
          this.httpsAgent = new https.Agent({ keepAlive });
        } else {
          this.httpAgent = new http.Agent({ keepAlive });
        }
      }
    };
    HttpProvider.prototype._prepareRequest = function() {
      var request;
      if (typeof XMLHttpRequest !== "undefined") {
        request = new XMLHttpRequest();
      } else {
        request = new XHR2();
        var agents = { httpsAgent: this.httpsAgent, httpAgent: this.httpAgent, baseUrl: this.baseUrl };
        if (this.agent) {
          agents.httpsAgent = this.agent.https;
          agents.httpAgent = this.agent.http;
          agents.baseUrl = this.agent.baseUrl;
        }
        request.nodejsSet(agents);
      }
      request.open("POST", this.host, true);
      request.setRequestHeader("Content-Type", "application/json");
      request.timeout = this.timeout;
      request.withCredentials = this.withCredentials;
      if (this.headers) {
        this.headers.forEach(function(header) {
          request.setRequestHeader(header.name, header.value);
        });
      }
      return request;
    };
    HttpProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var request = this._prepareRequest();
      request.onreadystatechange = function() {
        if (request.readyState === 4 && request.timeout !== 1) {
          var result = request.responseText;
          var error2 = null;
          try {
            result = JSON.parse(result);
          } catch (e) {
            error2 = errors2.InvalidResponse(request.responseText);
          }
          _this.connected = true;
          callback(error2, result);
        }
      };
      request.ontimeout = function() {
        _this.connected = false;
        callback(errors2.ConnectionTimeout(this.timeout));
      };
      try {
        request.send(JSON.stringify(payload));
      } catch (error2) {
        this.connected = false;
        callback(errors2.InvalidConnection(this.host));
      }
    };
    HttpProvider.prototype.disconnect = function() {
    };
    HttpProvider.prototype.supportsSubscriptions = function() {
      return false;
    };
    module.exports = HttpProvider;
  }
});

// node_modules/web3-eth/node_modules/web3-providers-ipc/lib/index.js
var require_lib16 = __commonJS({
  "node_modules/web3-eth/node_modules/web3-providers-ipc/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var errors2 = require_lib3().errors;
    var oboe = require_oboe_browser();
    var IpcProvider = function IpcProvider2(path, net) {
      var _this = this;
      this.responseCallbacks = {};
      this.notificationCallbacks = [];
      this.path = path;
      this.connected = false;
      this.connection = net.connect({ path: this.path });
      this.addDefaultEvents();
      var callback = function(result) {
        var id = null;
        if (Array.isArray(result)) {
          result.forEach(function(load) {
            if (_this.responseCallbacks[load.id])
              id = load.id;
          });
        } else {
          id = result.id;
        }
        if (!id && result.method.indexOf("_subscription") !== -1) {
          _this.notificationCallbacks.forEach(function(callback2) {
            if (typeof callback2 === "function")
              callback2(result);
          });
        } else if (_this.responseCallbacks[id]) {
          _this.responseCallbacks[id](null, result);
          delete _this.responseCallbacks[id];
        }
      };
      if (net.constructor.name === "Socket") {
        oboe(this.connection).done(callback);
      } else {
        this.connection.on("data", function(data) {
          _this._parseResponse(data.toString()).forEach(callback);
        });
      }
    };
    IpcProvider.prototype.addDefaultEvents = function() {
      var _this = this;
      this.connection.on("connect", function() {
        _this.connected = true;
      });
      this.connection.on("close", function() {
        _this.connected = false;
      });
      this.connection.on("error", function() {
        _this._timeout();
      });
      this.connection.on("end", function() {
        _this._timeout();
      });
      this.connection.on("timeout", function() {
        _this._timeout();
      });
    };
    IpcProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            _this._timeout();
            throw errors2.InvalidResponse(data2);
          }, 1e3 * 15);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    IpcProvider.prototype._addResponseCallback = function(payload, callback) {
      var id = payload.id || payload[0].id;
      var method = payload.method || payload[0].method;
      this.responseCallbacks[id] = callback;
      this.responseCallbacks[id].method = method;
    };
    IpcProvider.prototype._timeout = function() {
      for (var key in this.responseCallbacks) {
        if (this.responseCallbacks.hasOwnProperty(key)) {
          this.responseCallbacks[key](errors2.InvalidConnection("on IPC"));
          delete this.responseCallbacks[key];
        }
      }
    };
    IpcProvider.prototype.reconnect = function() {
      this.connection.connect({ path: this.path });
    };
    IpcProvider.prototype.send = function(payload, callback) {
      if (!this.connection.writable)
        this.connection.connect({ path: this.path });
      this.connection.write(JSON.stringify(payload));
      this._addResponseCallback(payload, callback);
    };
    IpcProvider.prototype.on = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      switch (type) {
        case "data":
          this.notificationCallbacks.push(callback);
          break;
        default:
          this.connection.on(type, callback);
          break;
      }
    };
    IpcProvider.prototype.once = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      this.connection.once(type, callback);
    };
    IpcProvider.prototype.removeListener = function(type, callback) {
      var _this = this;
      switch (type) {
        case "data":
          this.notificationCallbacks.forEach(function(cb, index) {
            if (cb === callback)
              _this.notificationCallbacks.splice(index, 1);
          });
          break;
        default:
          this.connection.removeListener(type, callback);
          break;
      }
    };
    IpcProvider.prototype.removeAllListeners = function(type) {
      switch (type) {
        case "data":
          this.notificationCallbacks = [];
          break;
        default:
          this.connection.removeAllListeners(type);
          break;
      }
    };
    IpcProvider.prototype.reset = function() {
      this._timeout();
      this.notificationCallbacks = [];
      this.connection.removeAllListeners("error");
      this.connection.removeAllListeners("end");
      this.connection.removeAllListeners("timeout");
      this.addDefaultEvents();
    };
    IpcProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    module.exports = IpcProvider;
  }
});

// node_modules/web3-eth/node_modules/web3-core-requestmanager/lib/index.js
var require_lib17 = __commonJS({
  "node_modules/web3-eth/node_modules/web3-core-requestmanager/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { callbackify } = require_util();
    var errors2 = require_lib3().errors;
    var Jsonrpc = require_jsonrpc2();
    var BatchManager = require_batch2();
    var givenProvider = require_givenProvider2();
    var RequestManager = function RequestManager2(provider, net) {
      this.provider = null;
      this.providers = RequestManager2.providers;
      this.setProvider(provider, net);
      this.subscriptions = /* @__PURE__ */ new Map();
    };
    RequestManager.givenProvider = givenProvider;
    RequestManager.providers = {
      WebsocketProvider: require_lib14(),
      HttpProvider: require_lib15(),
      IpcProvider: require_lib16()
    };
    RequestManager.prototype.setProvider = function(provider, net) {
      var _this = this;
      if (provider && typeof provider === "string" && this.providers) {
        if (/^http(s)?:\/\//i.test(provider)) {
          provider = new this.providers.HttpProvider(provider);
        } else if (/^ws(s)?:\/\//i.test(provider)) {
          provider = new this.providers.WebsocketProvider(provider);
        } else if (provider && typeof net === "object" && typeof net.connect === "function") {
          provider = new this.providers.IpcProvider(provider, net);
        } else if (provider) {
          throw new Error(`Can't autodetect provider for "` + provider + '"');
        }
      }
      if (this.provider && this.provider.connected)
        this.clearSubscriptions();
      this.provider = provider || null;
      if (this.provider && this.provider.on) {
        if (typeof provider.request === "function") {
          this.provider.on("message", function(payload) {
            if (payload && payload.type === "eth_subscription" && payload.data) {
              const data = payload.data;
              if (data.subscription && _this.subscriptions.has(data.subscription)) {
                _this.subscriptions.get(data.subscription).callback(null, data.result);
              }
            }
          });
        } else {
          this.provider.on("data", function data(result, deprecatedResult) {
            result = result || deprecatedResult;
            if (result.method && result.params && result.params.subscription && _this.subscriptions.has(result.params.subscription)) {
              _this.subscriptions.get(result.params.subscription).callback(null, result.params.result);
            }
          });
        }
        this.provider.on("connect", function connect() {
          _this.subscriptions.forEach(function(subscription) {
            subscription.subscription.resubscribe();
          });
        });
        this.provider.on("error", function error2(error2) {
          _this.subscriptions.forEach(function(subscription) {
            subscription.callback(error2);
          });
        });
        const disconnect = function disconnect2(event) {
          if (!_this._isCleanCloseEvent(event) || _this._isIpcCloseError(event)) {
            _this.subscriptions.forEach(function(subscription) {
              subscription.callback(errors2.ConnectionCloseError(event));
              _this.subscriptions.delete(subscription.subscription.id);
            });
            if (_this.provider && _this.provider.emit) {
              _this.provider.emit("error", errors2.ConnectionCloseError(event));
            }
          }
          if (_this.provider && _this.provider.emit) {
            _this.provider.emit("end", event);
          }
        };
        this.provider.on("disconnect", disconnect);
      }
    };
    RequestManager.prototype.send = function(data, callback) {
      callback = callback || function() {
      };
      if (!this.provider) {
        return callback(errors2.InvalidProvider());
      }
      const { method, params } = data;
      const jsonrpcPayload = Jsonrpc.toPayload(method, params);
      const jsonrpcResultCallback = this._jsonrpcResultCallback(callback, jsonrpcPayload);
      if (this.provider.request) {
        const callbackRequest = callbackify(this.provider.request.bind(this.provider));
        const requestArgs = { method, params };
        callbackRequest(requestArgs, callback);
      } else if (this.provider.sendAsync) {
        this.provider.sendAsync(jsonrpcPayload, jsonrpcResultCallback);
      } else if (this.provider.send) {
        this.provider.send(jsonrpcPayload, jsonrpcResultCallback);
      } else {
        throw new Error("Provider does not have a request or send method to use.");
      }
    };
    RequestManager.prototype.sendBatch = function(data, callback) {
      if (!this.provider) {
        return callback(errors2.InvalidProvider());
      }
      var payload = Jsonrpc.toBatchPayload(data);
      this.provider[this.provider.sendAsync ? "sendAsync" : "send"](payload, function(err, results) {
        if (err) {
          return callback(err);
        }
        if (!Array.isArray(results)) {
          return callback(errors2.InvalidResponse(results));
        }
        callback(null, results);
      });
    };
    RequestManager.prototype.addSubscription = function(subscription, callback) {
      if (this.provider.on) {
        this.subscriptions.set(subscription.id, {
          callback,
          subscription
        });
      } else {
        throw new Error("The provider doesn't support subscriptions: " + this.provider.constructor.name);
      }
    };
    RequestManager.prototype.removeSubscription = function(id, callback) {
      if (this.subscriptions.has(id)) {
        var type = this.subscriptions.get(id).subscription.options.type;
        this.subscriptions.delete(id);
        this.send({
          method: type + "_unsubscribe",
          params: [id]
        }, callback);
        return;
      }
      if (typeof callback === "function") {
        callback(null);
      }
    };
    RequestManager.prototype.clearSubscriptions = function(keepIsSyncing) {
      try {
        var _this = this;
        if (this.subscriptions.size > 0) {
          this.subscriptions.forEach(function(value, id) {
            if (!keepIsSyncing || value.name !== "syncing")
              _this.removeSubscription(id);
          });
        }
        if (this.provider.reset)
          this.provider.reset();
        return true;
      } catch (e) {
        throw new Error(`Error while clearing subscriptions: ${e}`);
      }
    };
    RequestManager.prototype._isCleanCloseEvent = function(event) {
      return typeof event === "object" && ([1e3].includes(event.code) || event.wasClean === true);
    };
    RequestManager.prototype._isIpcCloseError = function(event) {
      return typeof event === "boolean" && event;
    };
    RequestManager.prototype._jsonrpcResultCallback = function(callback, payload) {
      return function(err, result) {
        if (result && result.id && payload.id !== result.id) {
          return callback(new Error(`Wrong response id ${result.id} (expected: ${payload.id}) in ${JSON.stringify(payload)}`));
        }
        if (err) {
          return callback(err);
        }
        if (result && result.error) {
          return callback(errors2.ErrorResponse(result));
        }
        if (!Jsonrpc.isValidResponse(result)) {
          return callback(errors2.InvalidResponse(result));
        }
        callback(null, result.result);
      };
    };
    module.exports = {
      Manager: RequestManager,
      BatchManager
    };
  }
});

// node_modules/web3-eth/node_modules/web3-core/lib/extend.js
var require_extend2 = __commonJS({
  "node_modules/web3-eth/node_modules/web3-core/lib/extend.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var formatters = require_lib3().formatters;
    var Method = require_lib6();
    var utils = require_lib();
    var extend = function(pckg) {
      var ex = function(extension) {
        var extendedObject;
        if (extension.property) {
          if (!pckg[extension.property]) {
            pckg[extension.property] = {};
          }
          extendedObject = pckg[extension.property];
        } else {
          extendedObject = pckg;
        }
        if (extension.methods) {
          extension.methods.forEach(function(method) {
            if (!(method instanceof Method)) {
              method = new Method(method);
            }
            method.attachToObject(extendedObject);
            method.setRequestManager(pckg._requestManager);
          });
        }
        return pckg;
      };
      ex.formatters = formatters;
      ex.utils = utils;
      ex.Method = Method;
      return ex;
    };
    module.exports = extend;
  }
});

// node_modules/web3-eth/node_modules/web3-core/lib/index.js
var require_lib18 = __commonJS({
  "node_modules/web3-eth/node_modules/web3-core/lib/index.js"(exports, module) {
    init_define_process_env();
    var requestManager = require_lib17();
    var extend = require_extend2();
    var packageInit = (pkg, args) => {
      args = Array.prototype.slice.call(args);
      if (!pkg) {
        throw new Error('You need to instantiate using the "new" keyword.');
      }
      Object.defineProperty(pkg, "currentProvider", {
        get: () => {
          return pkg._provider;
        },
        set: (value) => {
          return pkg.setProvider(value);
        },
        enumerable: true,
        configurable: true
      });
      if (args[0] && args[0]._requestManager) {
        pkg._requestManager = args[0]._requestManager;
      } else {
        pkg._requestManager = new requestManager.Manager(args[0], args[1]);
      }
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
      pkg._provider = pkg._requestManager.provider;
      if (!pkg.setProvider) {
        pkg.setProvider = (provider, net) => {
          pkg._requestManager.setProvider(provider, net);
          pkg._provider = pkg._requestManager.provider;
          return true;
        };
      }
      pkg.setRequestManager = (manager) => {
        pkg._requestManager = manager;
        pkg._provider = manager.provider;
      };
      pkg.BatchRequest = requestManager.BatchManager.bind(null, pkg._requestManager);
      pkg.extend = extend(pkg);
    };
    var addProviders = (pkg) => {
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
    };
    module.exports = {
      packageInit,
      addProviders
    };
  }
});

// node_modules/web3-net/node_modules/web3-core-requestmanager/lib/jsonrpc.js
var require_jsonrpc3 = __commonJS({
  "node_modules/web3-net/node_modules/web3-core-requestmanager/lib/jsonrpc.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = {
      messageId: 0
    };
    Jsonrpc.toPayload = function(method, params) {
      if (!method) {
        throw new Error('JSONRPC method should be specified for params: "' + JSON.stringify(params) + '"!');
      }
      Jsonrpc.messageId++;
      return {
        jsonrpc: "2.0",
        id: Jsonrpc.messageId,
        method,
        params: params || []
      };
    };
    Jsonrpc.isValidResponse = function(response) {
      return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);
      function validateSingleMessage(message) {
        return !!message && !message.error && message.jsonrpc === "2.0" && (typeof message.id === "number" || typeof message.id === "string") && message.result !== void 0;
      }
    };
    Jsonrpc.toBatchPayload = function(messages) {
      return messages.map(function(message) {
        return Jsonrpc.toPayload(message.method, message.params);
      });
    };
    module.exports = Jsonrpc;
  }
});

// node_modules/web3-net/node_modules/web3-core-requestmanager/lib/batch.js
var require_batch3 = __commonJS({
  "node_modules/web3-net/node_modules/web3-core-requestmanager/lib/batch.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = require_jsonrpc3();
    var errors2 = require_lib3().errors;
    var Batch = function(requestManager) {
      this.requestManager = requestManager;
      this.requests = [];
    };
    Batch.prototype.add = function(request) {
      this.requests.push(request);
    };
    Batch.prototype.execute = function() {
      var requests = this.requests;
      var sortResponses = this._sortResponses.bind(this);
      this.requestManager.sendBatch(requests, function(err, results) {
        results = sortResponses(results);
        requests.map(function(request, index) {
          return results[index] || {};
        }).forEach(function(result, index) {
          if (requests[index].callback) {
            if (result && result.error) {
              return requests[index].callback(errors2.ErrorResponse(result));
            }
            if (!Jsonrpc.isValidResponse(result)) {
              return requests[index].callback(errors2.InvalidResponse(result));
            }
            try {
              requests[index].callback(null, requests[index].format ? requests[index].format(result.result) : result.result);
            } catch (err2) {
              requests[index].callback(err2);
            }
          }
        });
      });
    };
    Batch.prototype._sortResponses = function(responses) {
      return (responses || []).sort((a, b) => a.id - b.id);
    };
    module.exports = Batch;
  }
});

// node_modules/web3-net/node_modules/web3-core-requestmanager/lib/givenProvider.js
var require_givenProvider3 = __commonJS({
  "node_modules/web3-net/node_modules/web3-core-requestmanager/lib/givenProvider.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var givenProvider = null;
    var global2 = typeof globalThis === "object" ? globalThis : void 0;
    if (!global2) {
      try {
        global2 = Function("return this")();
      } catch (e) {
        global2 = self;
      }
    }
    if (typeof global2.ethereum !== "undefined") {
      givenProvider = global2.ethereum;
    } else if (typeof global2.web3 !== "undefined" && global2.web3.currentProvider) {
      if (global2.web3.currentProvider.sendAsync) {
        global2.web3.currentProvider.send = global2.web3.currentProvider.sendAsync;
        delete global2.web3.currentProvider.sendAsync;
      }
      if (!global2.web3.currentProvider.on && global2.web3.currentProvider.connection && global2.web3.currentProvider.connection.constructor.name === "ipcProviderWrapper") {
        global2.web3.currentProvider.on = function(type, callback) {
          if (typeof callback !== "function")
            throw new Error("The second parameter callback must be a function.");
          switch (type) {
            case "data":
              this.connection.on("data", function(data) {
                var result = "";
                data = data.toString();
                try {
                  result = JSON.parse(data);
                } catch (e) {
                  return callback(new Error("Couldn't parse response data" + data));
                }
                if (!result.id && result.method.indexOf("_subscription") !== -1) {
                  callback(null, result);
                }
              });
              break;
            default:
              this.connection.on(type, callback);
              break;
          }
        };
      }
      givenProvider = global2.web3.currentProvider;
    }
    module.exports = givenProvider;
  }
});

// node_modules/web3-net/node_modules/web3-providers-ws/lib/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/web3-net/node_modules/web3-providers-ws/lib/helpers.js"(exports, module) {
    init_define_process_env();
    var isNode = Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
    var isRN = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var _btoa = null;
    var helpers = null;
    if (isNode || isRN) {
      _btoa = function(str) {
        return Buffer.from(str).toString("base64");
      };
      url = require_url();
      if (url.URL) {
        newURL = url.URL;
        helpers = function(url2) {
          return new newURL(url2);
        };
      } else {
        helpers = require_url().parse;
      }
    } else {
      _btoa = btoa.bind(typeof globalThis === "object" ? globalThis : self);
      helpers = function(url2) {
        return new URL(url2);
      };
    }
    var url;
    var newURL;
    module.exports = {
      parseURL: helpers,
      btoa: _btoa
    };
  }
});

// node_modules/web3-net/node_modules/web3-providers-ws/lib/index.js
var require_lib19 = __commonJS({
  "node_modules/web3-net/node_modules/web3-providers-ws/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var EventEmitter = require_eventemitter3();
    var helpers = require_helpers3();
    var errors2 = require_lib3().errors;
    var Ws = require_browser().w3cwebsocket;
    var WebsocketProvider = function WebsocketProvider2(url, options) {
      EventEmitter.call(this);
      options = options || {};
      this.url = url;
      this._customTimeout = options.timeout || 1e3 * 15;
      this.headers = options.headers || {};
      this.protocol = options.protocol || void 0;
      this.reconnectOptions = Object.assign({
        auto: false,
        delay: 5e3,
        maxAttempts: false,
        onTimeout: false
      }, options.reconnect);
      this.clientConfig = options.clientConfig || void 0;
      this.requestOptions = options.requestOptions || void 0;
      this.DATA = "data";
      this.CLOSE = "close";
      this.ERROR = "error";
      this.CONNECT = "connect";
      this.RECONNECT = "reconnect";
      this.connection = null;
      this.requestQueue = /* @__PURE__ */ new Map();
      this.responseQueue = /* @__PURE__ */ new Map();
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      var parsedURL = helpers.parseURL(url);
      if (parsedURL.username && parsedURL.password) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.username + ":" + parsedURL.password);
      }
      if (parsedURL.auth) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.auth);
      }
      Object.defineProperty(this, "connected", {
        get: function() {
          return this.connection && this.connection.readyState === this.connection.OPEN;
        },
        enumerable: true
      });
      this.connect();
    };
    WebsocketProvider.prototype = Object.create(EventEmitter.prototype);
    WebsocketProvider.prototype.constructor = WebsocketProvider;
    WebsocketProvider.prototype.connect = function() {
      this.connection = new Ws(this.url, this.protocol, void 0, this.headers, this.requestOptions, this.clientConfig);
      this._addSocketListeners();
    };
    WebsocketProvider.prototype._onMessage = function(e) {
      var _this = this;
      this._parseResponse(typeof e.data === "string" ? e.data : "").forEach(function(result) {
        if (result.method && result.method.indexOf("_subscription") !== -1) {
          _this.emit(_this.DATA, result);
          return;
        }
        var id = result.id;
        if (Array.isArray(result)) {
          id = result[0].id;
        }
        if (_this.responseQueue.has(id)) {
          if (_this.responseQueue.get(id).callback !== void 0) {
            _this.responseQueue.get(id).callback(false, result);
          }
          _this.responseQueue.delete(id);
        }
      });
    };
    WebsocketProvider.prototype._onConnect = function() {
      this.emit(this.CONNECT);
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        var _this = this;
        this.requestQueue.forEach(function(request, key) {
          _this.send(request.payload, request.callback);
          _this.requestQueue.delete(key);
        });
      }
    };
    WebsocketProvider.prototype._onClose = function(event) {
      var _this = this;
      if (this.reconnectOptions.auto && (![1e3, 1001].includes(event.code) || event.wasClean === false)) {
        this.reconnect();
        return;
      }
      this.emit(this.CLOSE, event);
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors2.ConnectionNotOpenError(event));
          _this.requestQueue.delete(key);
        });
      }
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors2.InvalidConnection("on WS", event));
          _this.responseQueue.delete(key);
        });
      }
      this._removeSocketListeners();
      this.removeAllListeners();
    };
    WebsocketProvider.prototype._addSocketListeners = function() {
      this.connection.addEventListener("message", this._onMessage.bind(this));
      this.connection.addEventListener("open", this._onConnect.bind(this));
      this.connection.addEventListener("close", this._onClose.bind(this));
    };
    WebsocketProvider.prototype._removeSocketListeners = function() {
      this.connection.removeEventListener("message", this._onMessage);
      this.connection.removeEventListener("open", this._onConnect);
      this.connection.removeEventListener("close", this._onClose);
    };
    WebsocketProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {
              _this.reconnect();
              return;
            }
            _this.emit(_this.ERROR, errors2.ConnectionTimeout(_this._customTimeout));
            if (_this.requestQueue.size > 0) {
              _this.requestQueue.forEach(function(request, key) {
                request.callback(errors2.ConnectionTimeout(_this._customTimeout));
                _this.requestQueue.delete(key);
              });
            }
          }, _this._customTimeout);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    WebsocketProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var id = payload.id;
      var request = { payload, callback };
      if (Array.isArray(payload)) {
        id = payload[0].id;
      }
      if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {
        this.requestQueue.set(id, request);
        return;
      }
      if (this.connection.readyState !== this.connection.OPEN) {
        this.requestQueue.delete(id);
        this.emit(this.ERROR, errors2.ConnectionNotOpenError());
        request.callback(errors2.ConnectionNotOpenError());
        return;
      }
      this.responseQueue.set(id, request);
      this.requestQueue.delete(id);
      try {
        this.connection.send(JSON.stringify(request.payload));
      } catch (error2) {
        request.callback(error2);
        _this.responseQueue.delete(id);
      }
    };
    WebsocketProvider.prototype.reset = function() {
      this.responseQueue.clear();
      this.requestQueue.clear();
      this.removeAllListeners();
      this._removeSocketListeners();
      this._addSocketListeners();
    };
    WebsocketProvider.prototype.disconnect = function(code, reason) {
      this._removeSocketListeners();
      this.connection.close(code || 1e3, reason);
    };
    WebsocketProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    WebsocketProvider.prototype.reconnect = function() {
      var _this = this;
      this.reconnecting = true;
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors2.PendingRequestsOnReconnectingError());
          _this.responseQueue.delete(key);
        });
      }
      if (!this.reconnectOptions.maxAttempts || this.reconnectAttempts < this.reconnectOptions.maxAttempts) {
        setTimeout(function() {
          _this.reconnectAttempts++;
          _this._removeSocketListeners();
          _this.emit(_this.RECONNECT, _this.reconnectAttempts);
          _this.connect();
        }, this.reconnectOptions.delay);
        return;
      }
      this.emit(this.ERROR, errors2.MaxAttemptsReachedOnReconnectingError());
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors2.MaxAttemptsReachedOnReconnectingError());
          _this.requestQueue.delete(key);
        });
      }
    };
    module.exports = WebsocketProvider;
  }
});

// node_modules/web3-net/node_modules/web3-providers-http/lib/index.js
var require_lib20 = __commonJS({
  "node_modules/web3-net/node_modules/web3-providers-http/lib/index.js"(exports, module) {
    init_define_process_env();
    var errors2 = require_lib3().errors;
    var XHR2 = require_dist2().XMLHttpRequest;
    var http = (init_http(), __toCommonJS(http_exports));
    var https = (init_https(), __toCommonJS(https_exports));
    var HttpProvider = function HttpProvider2(host, options) {
      options = options || {};
      this.withCredentials = options.withCredentials || false;
      this.timeout = options.timeout || 0;
      this.headers = options.headers;
      this.agent = options.agent;
      this.connected = false;
      const keepAlive = options.keepAlive !== false;
      this.host = host || "http://localhost:8545";
      if (!this.agent) {
        if (this.host.substring(0, 5) === "https") {
          this.httpsAgent = new https.Agent({ keepAlive });
        } else {
          this.httpAgent = new http.Agent({ keepAlive });
        }
      }
    };
    HttpProvider.prototype._prepareRequest = function() {
      var request;
      if (typeof XMLHttpRequest !== "undefined") {
        request = new XMLHttpRequest();
      } else {
        request = new XHR2();
        var agents = { httpsAgent: this.httpsAgent, httpAgent: this.httpAgent, baseUrl: this.baseUrl };
        if (this.agent) {
          agents.httpsAgent = this.agent.https;
          agents.httpAgent = this.agent.http;
          agents.baseUrl = this.agent.baseUrl;
        }
        request.nodejsSet(agents);
      }
      request.open("POST", this.host, true);
      request.setRequestHeader("Content-Type", "application/json");
      request.timeout = this.timeout;
      request.withCredentials = this.withCredentials;
      if (this.headers) {
        this.headers.forEach(function(header) {
          request.setRequestHeader(header.name, header.value);
        });
      }
      return request;
    };
    HttpProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var request = this._prepareRequest();
      request.onreadystatechange = function() {
        if (request.readyState === 4 && request.timeout !== 1) {
          var result = request.responseText;
          var error2 = null;
          try {
            result = JSON.parse(result);
          } catch (e) {
            error2 = errors2.InvalidResponse(request.responseText);
          }
          _this.connected = true;
          callback(error2, result);
        }
      };
      request.ontimeout = function() {
        _this.connected = false;
        callback(errors2.ConnectionTimeout(this.timeout));
      };
      try {
        request.send(JSON.stringify(payload));
      } catch (error2) {
        this.connected = false;
        callback(errors2.InvalidConnection(this.host));
      }
    };
    HttpProvider.prototype.disconnect = function() {
    };
    HttpProvider.prototype.supportsSubscriptions = function() {
      return false;
    };
    module.exports = HttpProvider;
  }
});

// node_modules/web3-net/node_modules/web3-providers-ipc/lib/index.js
var require_lib21 = __commonJS({
  "node_modules/web3-net/node_modules/web3-providers-ipc/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var errors2 = require_lib3().errors;
    var oboe = require_oboe_browser();
    var IpcProvider = function IpcProvider2(path, net) {
      var _this = this;
      this.responseCallbacks = {};
      this.notificationCallbacks = [];
      this.path = path;
      this.connected = false;
      this.connection = net.connect({ path: this.path });
      this.addDefaultEvents();
      var callback = function(result) {
        var id = null;
        if (Array.isArray(result)) {
          result.forEach(function(load) {
            if (_this.responseCallbacks[load.id])
              id = load.id;
          });
        } else {
          id = result.id;
        }
        if (!id && result.method.indexOf("_subscription") !== -1) {
          _this.notificationCallbacks.forEach(function(callback2) {
            if (typeof callback2 === "function")
              callback2(result);
          });
        } else if (_this.responseCallbacks[id]) {
          _this.responseCallbacks[id](null, result);
          delete _this.responseCallbacks[id];
        }
      };
      if (net.constructor.name === "Socket") {
        oboe(this.connection).done(callback);
      } else {
        this.connection.on("data", function(data) {
          _this._parseResponse(data.toString()).forEach(callback);
        });
      }
    };
    IpcProvider.prototype.addDefaultEvents = function() {
      var _this = this;
      this.connection.on("connect", function() {
        _this.connected = true;
      });
      this.connection.on("close", function() {
        _this.connected = false;
      });
      this.connection.on("error", function() {
        _this._timeout();
      });
      this.connection.on("end", function() {
        _this._timeout();
      });
      this.connection.on("timeout", function() {
        _this._timeout();
      });
    };
    IpcProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            _this._timeout();
            throw errors2.InvalidResponse(data2);
          }, 1e3 * 15);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    IpcProvider.prototype._addResponseCallback = function(payload, callback) {
      var id = payload.id || payload[0].id;
      var method = payload.method || payload[0].method;
      this.responseCallbacks[id] = callback;
      this.responseCallbacks[id].method = method;
    };
    IpcProvider.prototype._timeout = function() {
      for (var key in this.responseCallbacks) {
        if (this.responseCallbacks.hasOwnProperty(key)) {
          this.responseCallbacks[key](errors2.InvalidConnection("on IPC"));
          delete this.responseCallbacks[key];
        }
      }
    };
    IpcProvider.prototype.reconnect = function() {
      this.connection.connect({ path: this.path });
    };
    IpcProvider.prototype.send = function(payload, callback) {
      if (!this.connection.writable)
        this.connection.connect({ path: this.path });
      this.connection.write(JSON.stringify(payload));
      this._addResponseCallback(payload, callback);
    };
    IpcProvider.prototype.on = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      switch (type) {
        case "data":
          this.notificationCallbacks.push(callback);
          break;
        default:
          this.connection.on(type, callback);
          break;
      }
    };
    IpcProvider.prototype.once = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      this.connection.once(type, callback);
    };
    IpcProvider.prototype.removeListener = function(type, callback) {
      var _this = this;
      switch (type) {
        case "data":
          this.notificationCallbacks.forEach(function(cb, index) {
            if (cb === callback)
              _this.notificationCallbacks.splice(index, 1);
          });
          break;
        default:
          this.connection.removeListener(type, callback);
          break;
      }
    };
    IpcProvider.prototype.removeAllListeners = function(type) {
      switch (type) {
        case "data":
          this.notificationCallbacks = [];
          break;
        default:
          this.connection.removeAllListeners(type);
          break;
      }
    };
    IpcProvider.prototype.reset = function() {
      this._timeout();
      this.notificationCallbacks = [];
      this.connection.removeAllListeners("error");
      this.connection.removeAllListeners("end");
      this.connection.removeAllListeners("timeout");
      this.addDefaultEvents();
    };
    IpcProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    module.exports = IpcProvider;
  }
});

// node_modules/web3-net/node_modules/web3-core-requestmanager/lib/index.js
var require_lib22 = __commonJS({
  "node_modules/web3-net/node_modules/web3-core-requestmanager/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { callbackify } = require_util();
    var errors2 = require_lib3().errors;
    var Jsonrpc = require_jsonrpc3();
    var BatchManager = require_batch3();
    var givenProvider = require_givenProvider3();
    var RequestManager = function RequestManager2(provider, net) {
      this.provider = null;
      this.providers = RequestManager2.providers;
      this.setProvider(provider, net);
      this.subscriptions = /* @__PURE__ */ new Map();
    };
    RequestManager.givenProvider = givenProvider;
    RequestManager.providers = {
      WebsocketProvider: require_lib19(),
      HttpProvider: require_lib20(),
      IpcProvider: require_lib21()
    };
    RequestManager.prototype.setProvider = function(provider, net) {
      var _this = this;
      if (provider && typeof provider === "string" && this.providers) {
        if (/^http(s)?:\/\//i.test(provider)) {
          provider = new this.providers.HttpProvider(provider);
        } else if (/^ws(s)?:\/\//i.test(provider)) {
          provider = new this.providers.WebsocketProvider(provider);
        } else if (provider && typeof net === "object" && typeof net.connect === "function") {
          provider = new this.providers.IpcProvider(provider, net);
        } else if (provider) {
          throw new Error(`Can't autodetect provider for "` + provider + '"');
        }
      }
      if (this.provider && this.provider.connected)
        this.clearSubscriptions();
      this.provider = provider || null;
      if (this.provider && this.provider.on) {
        if (typeof provider.request === "function") {
          this.provider.on("message", function(payload) {
            if (payload && payload.type === "eth_subscription" && payload.data) {
              const data = payload.data;
              if (data.subscription && _this.subscriptions.has(data.subscription)) {
                _this.subscriptions.get(data.subscription).callback(null, data.result);
              }
            }
          });
        } else {
          this.provider.on("data", function data(result, deprecatedResult) {
            result = result || deprecatedResult;
            if (result.method && result.params && result.params.subscription && _this.subscriptions.has(result.params.subscription)) {
              _this.subscriptions.get(result.params.subscription).callback(null, result.params.result);
            }
          });
        }
        this.provider.on("connect", function connect() {
          _this.subscriptions.forEach(function(subscription) {
            subscription.subscription.resubscribe();
          });
        });
        this.provider.on("error", function error2(error2) {
          _this.subscriptions.forEach(function(subscription) {
            subscription.callback(error2);
          });
        });
        const disconnect = function disconnect2(event) {
          if (!_this._isCleanCloseEvent(event) || _this._isIpcCloseError(event)) {
            _this.subscriptions.forEach(function(subscription) {
              subscription.callback(errors2.ConnectionCloseError(event));
              _this.subscriptions.delete(subscription.subscription.id);
            });
            if (_this.provider && _this.provider.emit) {
              _this.provider.emit("error", errors2.ConnectionCloseError(event));
            }
          }
          if (_this.provider && _this.provider.emit) {
            _this.provider.emit("end", event);
          }
        };
        this.provider.on("disconnect", disconnect);
      }
    };
    RequestManager.prototype.send = function(data, callback) {
      callback = callback || function() {
      };
      if (!this.provider) {
        return callback(errors2.InvalidProvider());
      }
      const { method, params } = data;
      const jsonrpcPayload = Jsonrpc.toPayload(method, params);
      const jsonrpcResultCallback = this._jsonrpcResultCallback(callback, jsonrpcPayload);
      if (this.provider.request) {
        const callbackRequest = callbackify(this.provider.request.bind(this.provider));
        const requestArgs = { method, params };
        callbackRequest(requestArgs, callback);
      } else if (this.provider.sendAsync) {
        this.provider.sendAsync(jsonrpcPayload, jsonrpcResultCallback);
      } else if (this.provider.send) {
        this.provider.send(jsonrpcPayload, jsonrpcResultCallback);
      } else {
        throw new Error("Provider does not have a request or send method to use.");
      }
    };
    RequestManager.prototype.sendBatch = function(data, callback) {
      if (!this.provider) {
        return callback(errors2.InvalidProvider());
      }
      var payload = Jsonrpc.toBatchPayload(data);
      this.provider[this.provider.sendAsync ? "sendAsync" : "send"](payload, function(err, results) {
        if (err) {
          return callback(err);
        }
        if (!Array.isArray(results)) {
          return callback(errors2.InvalidResponse(results));
        }
        callback(null, results);
      });
    };
    RequestManager.prototype.addSubscription = function(subscription, callback) {
      if (this.provider.on) {
        this.subscriptions.set(subscription.id, {
          callback,
          subscription
        });
      } else {
        throw new Error("The provider doesn't support subscriptions: " + this.provider.constructor.name);
      }
    };
    RequestManager.prototype.removeSubscription = function(id, callback) {
      if (this.subscriptions.has(id)) {
        var type = this.subscriptions.get(id).subscription.options.type;
        this.subscriptions.delete(id);
        this.send({
          method: type + "_unsubscribe",
          params: [id]
        }, callback);
        return;
      }
      if (typeof callback === "function") {
        callback(null);
      }
    };
    RequestManager.prototype.clearSubscriptions = function(keepIsSyncing) {
      try {
        var _this = this;
        if (this.subscriptions.size > 0) {
          this.subscriptions.forEach(function(value, id) {
            if (!keepIsSyncing || value.name !== "syncing")
              _this.removeSubscription(id);
          });
        }
        if (this.provider.reset)
          this.provider.reset();
        return true;
      } catch (e) {
        throw new Error(`Error while clearing subscriptions: ${e}`);
      }
    };
    RequestManager.prototype._isCleanCloseEvent = function(event) {
      return typeof event === "object" && ([1e3].includes(event.code) || event.wasClean === true);
    };
    RequestManager.prototype._isIpcCloseError = function(event) {
      return typeof event === "boolean" && event;
    };
    RequestManager.prototype._jsonrpcResultCallback = function(callback, payload) {
      return function(err, result) {
        if (result && result.id && payload.id !== result.id) {
          return callback(new Error(`Wrong response id ${result.id} (expected: ${payload.id}) in ${JSON.stringify(payload)}`));
        }
        if (err) {
          return callback(err);
        }
        if (result && result.error) {
          return callback(errors2.ErrorResponse(result));
        }
        if (!Jsonrpc.isValidResponse(result)) {
          return callback(errors2.InvalidResponse(result));
        }
        callback(null, result.result);
      };
    };
    module.exports = {
      Manager: RequestManager,
      BatchManager
    };
  }
});

// node_modules/web3-net/node_modules/web3-core/lib/extend.js
var require_extend3 = __commonJS({
  "node_modules/web3-net/node_modules/web3-core/lib/extend.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var formatters = require_lib3().formatters;
    var Method = require_lib6();
    var utils = require_lib();
    var extend = function(pckg) {
      var ex = function(extension) {
        var extendedObject;
        if (extension.property) {
          if (!pckg[extension.property]) {
            pckg[extension.property] = {};
          }
          extendedObject = pckg[extension.property];
        } else {
          extendedObject = pckg;
        }
        if (extension.methods) {
          extension.methods.forEach(function(method) {
            if (!(method instanceof Method)) {
              method = new Method(method);
            }
            method.attachToObject(extendedObject);
            method.setRequestManager(pckg._requestManager);
          });
        }
        return pckg;
      };
      ex.formatters = formatters;
      ex.utils = utils;
      ex.Method = Method;
      return ex;
    };
    module.exports = extend;
  }
});

// node_modules/web3-net/node_modules/web3-core/lib/index.js
var require_lib23 = __commonJS({
  "node_modules/web3-net/node_modules/web3-core/lib/index.js"(exports, module) {
    init_define_process_env();
    var requestManager = require_lib22();
    var extend = require_extend3();
    var packageInit = (pkg, args) => {
      args = Array.prototype.slice.call(args);
      if (!pkg) {
        throw new Error('You need to instantiate using the "new" keyword.');
      }
      Object.defineProperty(pkg, "currentProvider", {
        get: () => {
          return pkg._provider;
        },
        set: (value) => {
          return pkg.setProvider(value);
        },
        enumerable: true,
        configurable: true
      });
      if (args[0] && args[0]._requestManager) {
        pkg._requestManager = args[0]._requestManager;
      } else {
        pkg._requestManager = new requestManager.Manager(args[0], args[1]);
      }
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
      pkg._provider = pkg._requestManager.provider;
      if (!pkg.setProvider) {
        pkg.setProvider = (provider, net) => {
          pkg._requestManager.setProvider(provider, net);
          pkg._provider = pkg._requestManager.provider;
          return true;
        };
      }
      pkg.setRequestManager = (manager) => {
        pkg._requestManager = manager;
        pkg._provider = manager.provider;
      };
      pkg.BatchRequest = requestManager.BatchManager.bind(null, pkg._requestManager);
      pkg.extend = extend(pkg);
    };
    var addProviders = (pkg) => {
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
    };
    module.exports = {
      packageInit,
      addProviders
    };
  }
});

// node_modules/web3-net/lib/index.js
var require_lib24 = __commonJS({
  "node_modules/web3-net/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var core = require_lib23();
    var Method = require_lib6();
    var utils = require_lib();
    var Net = function() {
      var _this = this;
      core.packageInit(this, arguments);
      [
        new Method({
          name: "getId",
          call: "net_version",
          params: 0,
          outputFormatter: parseInt
        }),
        new Method({
          name: "isListening",
          call: "net_listening",
          params: 0
        }),
        new Method({
          name: "getPeerCount",
          call: "net_peerCount",
          params: 0,
          outputFormatter: utils.hexToNumber
        })
      ].forEach(function(method) {
        method.attachToObject(_this);
        method.setRequestManager(_this._requestManager);
      });
    };
    core.addProviders(Net);
    module.exports = Net;
  }
});

// node_modules/web3-eth-ens/lib/config.js
var require_config = __commonJS({
  "node_modules/web3-eth-ens/lib/config.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var config = {
      addresses: {
        main: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        ropsten: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        rinkeby: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        goerli: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      interfaceIds: {
        addr: "0x3b3b57de",
        setAddr: "0x3b3b57de",
        pubkey: "0xc8690233",
        setPubkey: "0xc8690233",
        contenthash: "0xbc1c58d1",
        setContenthash: "0xbc1c58d1",
        content: "0xd8389dc5",
        setContent: "0xd8389dc5"
      }
    };
    module.exports = config;
  }
});

// node_modules/eth-ens-namehash/node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/eth-ens-namehash/node_modules/js-sha3/src/sha3.js"(exports, module) {
    init_define_process_env();
    (function() {
      "use strict";
      var root = typeof window === "object" ? window : {};
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array"];
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createOutputMethod(bits2, padding, type);
        }
        return method;
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createShakeOutputMethod(bits2, padding, type);
        }
        return method;
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        var notString = typeof message !== "string";
        if (notString && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        }
        var length = message.length, blocks = this.blocks, byteCount = this.byteCount, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks[i2];
            }
            f(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak.prototype.finalize = function() {
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks[i2];
        }
        f(s);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          if (extraBytes > 0) {
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          }
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          array[i2] = s[i2];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          if (extraBytes > 0) {
            array[offset] = block & 255;
          }
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (var i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
      }
    })();
  }
});

// node_modules/idna-uts46-hx/node_modules/punycode/punycode.es6.js
var punycode_es6_exports = {};
__export(punycode_es6_exports, {
  default: () => punycode_es6_default
});
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, fn) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = fn(array[length]);
  }
  return result;
}
function mapDomain(string, fn) {
  const parts = string.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  const labels = string.split(".");
  const encoded = map(labels, fn).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexPunycode, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode, ucs2encode, basicToDigit, digitToBasic, adapt, decode, encode, toUnicode, toASCII, punycode, punycode_es6_default;
var init_punycode_es6 = __esm({
  "node_modules/idna-uts46-hx/node_modules/punycode/punycode.es6.js"() {
    "use strict";
    init_define_process_env();
    maxInt = 2147483647;
    base = 36;
    tMin = 1;
    tMax = 26;
    skew = 38;
    damp = 700;
    initialBias = 72;
    initialN = 128;
    delimiter = "-";
    regexPunycode = /^xn--/;
    regexNonASCII = /[^\0-\x7E]/;
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    baseMinusTMin = base - tMin;
    floor = Math.floor;
    stringFromCharCode = String.fromCharCode;
    ucs2encode = (array) => String.fromCodePoint(...array);
    basicToDigit = function(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    adapt = function(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i = 0;
      let n = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        let oldi = i;
        for (let w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          const baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint(...output);
    };
    encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      let inputLength = input.length;
      let n = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      let basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input) {
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue == n) {
            let q = delta;
            for (let k = base; ; k += base) {
              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              const qMinusT = q - t;
              const baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    punycode = {
      "version": "2.1.0",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    punycode_es6_default = punycode;
  }
});

// node_modules/idna-uts46-hx/idna-map.js
var require_idna_map = __commonJS({
  "node_modules/idna-uts46-hx/idna-map.js"(exports, module) {
    init_define_process_env();
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return factory();
        });
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.uts46_map = factory();
      }
    })(exports, function() {
      var blocks = [
        new Uint32Array([2157250, 2157314, 2157378, 2157442, 2157506, 2157570, 2157634, 0, 2157698, 2157762, 2157826, 2157890, 2157954, 0, 2158018, 0]),
        new Uint32Array([2179041, 6291456, 2179073, 6291456, 2179105, 6291456, 2179137, 6291456, 2179169, 6291456, 2179201, 6291456, 2179233, 6291456, 2179265, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 14680064, 14680064, 14680064, 14680064, 14680064]),
        new Uint32Array([0, 2113729, 2197345, 2197377, 2113825, 2197409, 2197441, 2113921, 2197473, 2114017, 2197505, 2197537, 2197569, 2197601, 2197633, 2197665]),
        new Uint32Array([6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 23068672, 23068672, 23068672, 0, 0, 0, 0, 23068672]),
        new Uint32Array([14680064, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 14680064, 14680064]),
        new Uint32Array([2196001, 2196033, 2196065, 2196097, 2196129, 2196161, 2196193, 2196225, 2196257, 2196289, 2196321, 2196353, 2196385, 2196417, 2196449, 2196481]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 0, 0, 0, 0, 0]),
        new Uint32Array([2097281, 2105921, 2097729, 2106081, 0, 2097601, 2162337, 2106017, 2133281, 2097505, 2105889, 2097185, 2097697, 2135777, 2097633, 2097441]),
        new Uint32Array([2177025, 6291456, 2177057, 6291456, 2177089, 6291456, 2177121, 6291456, 2177153, 6291456, 2177185, 6291456, 2177217, 6291456, 2177249, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 0, 6291456, 6291456, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456]),
        new Uint32Array([0, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 6291456]),
        new Uint32Array([2134435, 2134531, 2134627, 2134723, 2134723, 2134819, 2134819, 2134915, 2134915, 2135011, 2105987, 2135107, 2135203, 2135299, 2131587, 2135395]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 0, 6291456, 2168673, 2169249, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2147906, 2147970, 2148034, 2148098, 2148162, 2148226, 2148290, 2148354, 2147906, 2147970, 2148034, 2148098, 2148162, 2148226, 2148290, 2148354]),
        new Uint32Array([2125219, 2125315, 2152834, 2152898, 2125411, 2152962, 2153026, 2125506, 2125507, 2125603, 2153090, 2153154, 2153218, 2153282, 2153346, 2105348]),
        new Uint32Array([2203393, 6291456, 2203425, 6291456, 2203457, 6291456, 2203489, 6291456, 6291456, 6291456, 6291456, 2203521, 6291456, 2181281, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 23068672, 6291456, 2145538, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 6291456]),
        new Uint32Array([2139426, 2160834, 2160898, 2160962, 2134242, 2161026, 2161090, 2161154, 2161218, 2161282, 2161346, 2161410, 2138658, 2161474, 2161538, 2134722]),
        new Uint32Array([2119939, 2124930, 2125026, 2106658, 2125218, 2128962, 2129058, 2129154, 2129250, 2129346, 2129442, 2108866, 2108770, 2150466, 2150530, 2150594]),
        new Uint32Array([2201601, 6291456, 2201633, 6291456, 2201665, 6291456, 2201697, 6291456, 2201729, 6291456, 2201761, 6291456, 2201793, 6291456, 2201825, 6291456]),
        new Uint32Array([2193537, 2193569, 2193601, 2193633, 2193665, 2193697, 2193729, 2193761, 2193793, 2193825, 2193857, 2193889, 2193921, 2193953, 2193985, 2194017]),
        new Uint32Array([6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([0, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2190561, 6291456, 2190593, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2190625, 6291456, 2190657, 6291456, 23068672]),
        new Uint32Array([2215905, 2215937, 2215969, 2216001, 2216033, 2216065, 2216097, 2216129, 2216161, 2216193, 2216225, 2216257, 2105441, 2216289, 2216321, 2216353]),
        new Uint32Array([23068672, 18884130, 23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672]),
        new Uint32Array([23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([2191233, 2191265, 2191297, 2191329, 2191361, 2191393, 2191425, 2117377, 2191457, 2191489, 2191521, 2191553, 2191585, 2191617, 2191649, 2117953]),
        new Uint32Array([2132227, 2132323, 2132419, 2132419, 2132515, 2132515, 2132611, 2132707, 2132707, 2132803, 2132899, 2132899, 2132995, 2132995, 2133091, 2133187]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 6291456, 0, 0]),
        new Uint32Array([2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 10609889, 10610785, 10609921, 10610817, 2222241]),
        new Uint32Array([6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 0, 0]),
        new Uint32Array([2219969, 2157121, 2157441, 2157505, 2157889, 2157953, 2220001, 2158465, 2158529, 10575617, 2156994, 2157058, 2129923, 2130019, 2157122, 2157186]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0]),
        new Uint32Array([2185249, 6291456, 2185281, 6291456, 2185313, 6291456, 2185345, 6291456, 2185377, 6291456, 2185409, 6291456, 2185441, 6291456, 2185473, 6291456]),
        new Uint32Array([0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 23068672, 23068672, 0, 0, 23068672, 23068672, 23068672, 6291456, 0]),
        new Uint32Array([2183361, 6291456, 2183393, 6291456, 2183425, 6291456, 2183457, 6291456, 2183489, 6291456, 2183521, 6291456, 2183553, 6291456, 2183585, 6291456]),
        new Uint32Array([2192161, 2192193, 2192225, 2192257, 2192289, 2192321, 2192353, 2192385, 2192417, 2192449, 2192481, 2192513, 2192545, 2192577, 2192609, 2192641]),
        new Uint32Array([2212001, 2212033, 2212065, 2212097, 2212129, 2212161, 2212193, 2212225, 2212257, 2212289, 2212321, 2212353, 2212385, 2212417, 2212449, 2207265]),
        new Uint32Array([2249825, 2249857, 2249889, 2249921, 2249954, 2250018, 2250082, 2250145, 2250177, 2250209, 2250241, 2250274, 2250337, 2250370, 2250433, 2250465]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2147905, 2147969, 2148033, 2148097, 2148161, 2148225, 2148289, 2148353]),
        new Uint32Array([10485857, 6291456, 2197217, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 23068672, 23068672]),
        new Uint32Array([0, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456]),
        new Uint32Array([2180353, 2180385, 2144033, 2180417, 2180449, 2180481, 2180513, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 10610209, 10610465, 10610241, 10610753, 10609857]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 0, 0]),
        new Uint32Array([2223842, 2223906, 2223970, 2224034, 2224098, 2224162, 2224226, 2224290, 2224354, 2224418, 2224482, 2224546, 2224610, 2224674, 2224738, 2224802]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 18923650, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 18923714, 23068672, 23068672]),
        new Uint32Array([2126179, 2125538, 2126275, 2126371, 2126467, 2125634, 2126563, 2105603, 2105604, 2125346, 2126659, 2126755, 2126851, 2098179, 2098181, 2098182]),
        new Uint32Array([2227426, 2227490, 2227554, 2227618, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2192353, 2240642, 2240642, 2240705, 2240737, 2240737, 2240769, 2240802, 2240866, 2240929, 2240961, 2240993, 2241025, 2241057, 2241089, 2241121]),
        new Uint32Array([6291456, 2170881, 2170913, 2170945, 6291456, 2170977, 6291456, 2171009, 2171041, 6291456, 6291456, 6291456, 2171073, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([2132226, 2132514, 2163586, 2132610, 2160386, 2133090, 2133186, 2160450, 2160514, 2160578, 2133570, 2106178, 2160642, 2133858, 2160706, 2160770]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 10532162, 10532226, 10532290, 10532354, 10532418, 10532482, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 23068672]),
        new Uint32Array([2098209, 2108353, 2108193, 2108481, 2170241, 2111713, 2105473, 2105569, 2105601, 2112289, 2112481, 2098305, 2108321, 0, 0, 0]),
        new Uint32Array([2209121, 2209153, 2209185, 2209217, 2209249, 2209281, 2209313, 2209345, 2209377, 2209409, 2209441, 2209473, 2207265, 2209505, 2209537, 2209569]),
        new Uint32Array([2189025, 6291456, 2189057, 6291456, 2189089, 6291456, 2189121, 6291456, 2189153, 6291456, 2189185, 6291456, 2189217, 6291456, 2189249, 6291456]),
        new Uint32Array([2173825, 2153473, 2173857, 2173889, 2173921, 2173953, 2173985, 2173761, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2233057]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2165764, 2140004]),
        new Uint32Array([2215105, 6291456, 2215137, 6291456, 6291456, 2215169, 2215201, 6291456, 6291456, 6291456, 2215233, 2215265, 2215297, 2215329, 2215361, 2215393]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 6291456, 6291456, 6291456, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([10505091, 10505187, 10505283, 10505379, 10505475, 10505571, 10505667, 10505763, 10505859, 10505955, 10506051, 10506147, 10506243, 10506339, 10506435, 10506531]),
        new Uint32Array([2229730, 2229794, 2229858, 2229922, 2229986, 2230050, 2230114, 2230178, 2230242, 2230306, 2230370, 2230434, 2230498, 2230562, 2230626, 2230690]),
        new Uint32Array([2105505, 2098241, 2108353, 2108417, 2105825, 0, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193, 2112481, 2112577, 2098177]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 10502115, 10502178, 10502211, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([0, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456]),
        new Uint32Array([2190305, 6291456, 2190337, 6291456, 2190369, 6291456, 2190401, 6291456, 2190433, 6291456, 2190465, 6291456, 2190497, 6291456, 2190529, 6291456]),
        new Uint32Array([2173793, 2173985, 2174017, 6291456, 2173761, 2173697, 6291456, 2174689, 6291456, 2174017, 2174721, 6291456, 6291456, 2174753, 2174785, 2174817]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2099521, 2099105, 2120705, 2098369, 2120801, 2103361, 2097985, 2098433, 2121377, 2121473, 2099169, 2099873, 2098401, 2099393, 2152609, 2100033]),
        new Uint32Array([2132898, 2163842, 2163906, 2133282, 2132034, 2131938, 2137410, 2132802, 2132706, 2164866, 2133282, 2160578, 2165186, 2165186, 6291456, 6291456]),
        new Uint32Array([10500003, 10500099, 10500195, 10500291, 10500387, 10500483, 10500579, 10500675, 10500771, 10500867, 10500963, 10501059, 10501155, 10501251, 10501347, 10501443]),
        new Uint32Array([2163458, 2130978, 2131074, 2131266, 2131362, 2163522, 2160130, 2132066, 2131010, 2131106, 2106018, 2131618, 2131298, 2132034, 2131938, 2137410]),
        new Uint32Array([2212961, 2116993, 2212993, 2213025, 2213057, 2213089, 2213121, 2213153, 2213185, 2213217, 2213249, 2209633, 2213281, 2213313, 2213345, 2213377]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456]),
        new Uint32Array([2113729, 2113825, 2113921, 2114017, 2114113, 2114209, 2114305, 2114401, 2114497, 2114593, 2114689, 2114785, 2114881, 2114977, 2115073, 2115169]),
        new Uint32Array([2238177, 2238209, 2238241, 2238273, 2238305, 2238337, 2238337, 2217537, 2238369, 2238401, 2238433, 2238465, 2215649, 2238497, 2238529, 2238561]),
        new Uint32Array([2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905]),
        new Uint32Array([6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 0, 0]),
        new Uint32Array([6291456, 0, 6291456, 2145026, 0, 6291456, 2145090, 0, 6291456, 6291456, 0, 0, 23068672, 0, 23068672, 23068672]),
        new Uint32Array([2099233, 2122017, 2200673, 2098113, 2121537, 2103201, 2200705, 2104033, 2121857, 2121953, 2122401, 2099649, 2099969, 2123009, 2100129, 2100289]),
        new Uint32Array([6291456, 23068672, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 23068672, 23068672, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0]),
        new Uint32Array([2187681, 2187713, 2187745, 2187777, 2187809, 2187841, 2187873, 2187905, 2187937, 2187969, 2188001, 2188033, 2188065, 2188097, 2188129, 2188161]),
        new Uint32Array([0, 10554498, 10554562, 10554626, 10554690, 10554754, 10554818, 10554882, 10554946, 10555010, 10555074, 6291456, 6291456, 0, 0, 0]),
        new Uint32Array([2235170, 2235234, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2181153, 6291456, 2188897, 6291456, 6291456, 2188929, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2111905, 2100865, 2188961, 2188993]),
        new Uint32Array([2100833, 2100897, 0, 0, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 10575617, 2187041, 10502177, 10489601, 10489697, 2112289]),
        new Uint32Array([6291456, 2172833, 6291456, 2172865, 2172897, 2172929, 2172961, 6291456, 2172993, 6291456, 2173025, 6291456, 2173057, 6291456, 2173089, 6291456]),
        new Uint32Array([6291456, 0, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 23068672, 6291456, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 2190721]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456]),
        new Uint32Array([2184993, 6291456, 2185025, 6291456, 2185057, 6291456, 2185089, 6291456, 2185121, 6291456, 2185153, 6291456, 2185185, 6291456, 2185217, 6291456]),
        new Uint32Array([2115265, 2115361, 2115457, 2115553, 2115649, 2115745, 2115841, 2115937, 2116033, 2116129, 2116225, 2116321, 2150658, 2150722, 2200225, 6291456]),
        new Uint32Array([2168321, 6291456, 2168353, 6291456, 2168385, 6291456, 2168417, 6291456, 2168449, 6291456, 2168481, 6291456, 2168513, 6291456, 2168545, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([6291456, 0, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456, 0, 6291456, 0, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 2186625, 0, 0, 6291456, 6291456, 2186657, 2186689, 2186721, 2173505, 0, 10496067, 10496163, 10496259]),
        new Uint32Array([2178785, 6291456, 2178817, 6291456, 2178849, 6291456, 2178881, 6291456, 2178913, 6291456, 2178945, 6291456, 2178977, 6291456, 2179009, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0]),
        new Uint32Array([2097152, 0, 0, 0, 2097152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456]),
        new Uint32Array([6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([0, 0, 2197857, 2197889, 2197921, 2197953, 2197985, 2198017, 0, 0, 2198049, 2198081, 2198113, 2198145, 2198177, 2198209]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2098209, 2167297, 2111137, 6291456]),
        new Uint32Array([2171393, 6291456, 2171425, 6291456, 2171457, 6291456, 2171489, 6291456, 2171521, 6291456, 2171553, 6291456, 2171585, 6291456, 2171617, 6291456]),
        new Uint32Array([2206753, 2206785, 2195457, 2206817, 2206849, 2206881, 2206913, 2197153, 2197153, 2206945, 2117857, 2206977, 2207009, 2207041, 2207073, 2207105]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 0, 23068672, 0, 0, 0, 0, 2144834, 2144898, 0, 2144962]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 23068672]),
        new Uint32Array([2108193, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 0, 2105505, 2098241]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 2202049, 6291456, 2202081, 6291456, 2202113, 6291456, 2202145, 6291456, 2202177, 6291456, 2202209, 6291456, 2202241, 6291456]),
        new Uint32Array([10501155, 10501251, 10501347, 10501443, 10501539, 10501635, 10501731, 10501827, 10501923, 10502019, 2141731, 2105505, 2098177, 2155586, 2166530, 0]),
        new Uint32Array([2102081, 2102209, 2100833, 2100737, 2098337, 2101441, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 2100833, 2100737, 2098337, 2101441]),
        new Uint32Array([2146882, 2146946, 2147010, 2147074, 2147138, 2147202, 2147266, 2147330, 2146882, 2146946, 2147010, 2147074, 2147138, 2147202, 2147266, 2147330]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0]),
        new Uint32Array([10502307, 10502403, 10502499, 10502595, 10502691, 10502787, 10502883, 10502979, 10503075, 10503171, 10503267, 10503363, 10503459, 10503555, 10503651, 10503747]),
        new Uint32Array([2179937, 2179969, 2180001, 2180033, 2156545, 2180065, 2156577, 2180097, 2180129, 2180161, 2180193, 2180225, 2180257, 2180289, 2156737, 2180321]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 0, 0, 0, 6291456, 0, 0, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0]),
        new Uint32Array([2227682, 2227746, 2227810, 2227874, 2227938, 2228002, 2228066, 2228130, 2228194, 2228258, 2228322, 2228386, 2228450, 2228514, 2228578, 2228642]),
        new Uint32Array([2105601, 2169121, 2108193, 2170049, 2181025, 2181057, 2112481, 2108321, 2108289, 2181089, 2170497, 2100865, 2181121, 2173601, 2173633, 2173665]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2180641, 6291456, 6291456, 6291456]),
        new Uint32Array([0, 6291456, 6291456, 6291456, 0, 6291456, 0, 6291456, 0, 0, 6291456, 6291456, 0, 6291456, 6291456, 6291456]),
        new Uint32Array([2178273, 6291456, 2178305, 6291456, 2178337, 6291456, 2178369, 6291456, 2178401, 6291456, 2178433, 6291456, 2178465, 6291456, 2178497, 6291456]),
        new Uint32Array([6291456, 6291456, 23068672, 23068672, 23068672, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456]),
        new Uint32Array([2237377, 2237409, 2236225, 2237441, 2237473, 2217441, 2215521, 2215553, 2217473, 2237505, 2237537, 2209697, 2237569, 2215585, 2237601, 2237633]),
        new Uint32Array([2221985, 2165601, 2165601, 2165665, 2165665, 2222017, 2222017, 2165729, 2165729, 2158913, 2158913, 2158913, 2158913, 2097281, 2097281, 2105921]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2149634, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2176897, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 2176929, 6291456, 2176961, 6291456, 2176993, 6291456]),
        new Uint32Array([2172641, 6291456, 2172673, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2172705, 2172737, 6291456, 2172769, 2172801, 6291456]),
        new Uint32Array([2099173, 2104196, 2121667, 2099395, 2121763, 2152258, 2152322, 2098946, 2152386, 2121859, 2121955, 2099333, 2122051, 2104324, 2099493, 2122147]),
        new Uint32Array([6291456, 6291456, 6291456, 2145794, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 2145858, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 0, 0, 6291456, 0]),
        new Uint32Array([0, 2105921, 2097729, 0, 2097377, 0, 0, 2106017, 0, 2097505, 2105889, 2097185, 2097697, 2135777, 2097633, 2097441]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([2239074, 2239138, 2239201, 2239233, 2239265, 2239297, 2239329, 2239361, 0, 2239393, 2239425, 2239425, 2239458, 2239521, 2239553, 2209569]),
        new Uint32Array([14680064, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 6291456, 23068672]),
        new Uint32Array([2108321, 2108289, 2113153, 2098209, 2180897, 2180929, 2180961, 2111137, 2098241, 2108353, 2170241, 2170273, 2180993, 2105825, 6291456, 2105473]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2146114, 6291456, 6291456, 6291456, 0, 0, 0]),
        new Uint32Array([2105921, 2105921, 2105921, 2222049, 2222049, 2130977, 2130977, 2130977, 2130977, 2160065, 2160065, 2160065, 2160065, 2097729, 2097729, 2097729]),
        new Uint32Array([2218145, 2214785, 2207937, 2218177, 2218209, 2192993, 2210113, 2212769, 2218241, 2218273, 2216129, 2218305, 2216161, 2218337, 2218369, 2218401]),
        new Uint32Array([0, 0, 0, 2156546, 2156610, 2156674, 2156738, 2156802, 0, 0, 0, 0, 0, 2156866, 23068672, 2156930]),
        new Uint32Array([23068672, 23068672, 23068672, 0, 0, 0, 0, 23068672, 23068672, 0, 0, 23068672, 23068672, 23068672, 0, 0]),
        new Uint32Array([2213409, 2213441, 2213473, 2213505, 2213537, 2213569, 2213601, 2213633, 2213665, 2195681, 2213697, 2213729, 2213761, 2213793, 2213825, 2213857]),
        new Uint32Array([2100033, 2099233, 2122017, 2200673, 2098113, 2121537, 2103201, 2200705, 2104033, 2121857, 2121953, 2122401, 2099649, 2099969, 2123009, 2100129]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2201857, 6291456, 2201889, 6291456, 2201921, 6291456, 2201953, 6291456, 2201985, 6291456, 2202017, 6291456, 2176193, 2176257, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 23068672, 23068672, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2188193, 2188225, 2188257, 2188289, 2188321, 2188353, 2188385, 2188417, 2188449, 2188481, 2188513, 2188545, 2188577, 2188609, 2188641, 0]),
        new Uint32Array([10554529, 2221089, 0, 10502113, 10562017, 10537921, 10538049, 2221121, 2221153, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2213889, 2213921, 2213953, 2213985, 2214017, 2214049, 2214081, 2194177, 2214113, 2214145, 2214177, 2214209, 2214241, 2214273, 2214305, 2214337]),
        new Uint32Array([2166978, 2167042, 2099169, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2180545, 6291456, 6291456, 6291456]),
        new Uint32Array([10518915, 10519011, 10519107, 10519203, 2162242, 2162306, 2159554, 2162370, 2159362, 2159618, 2105922, 2162434, 2159746, 2162498, 2159810, 2159874]),
        new Uint32Array([2161730, 2161794, 2135586, 2161858, 2161922, 2137186, 2131810, 2160290, 2135170, 2161986, 2137954, 2162050, 2162114, 2162178, 10518723, 10518819]),
        new Uint32Array([10506627, 10506723, 10506819, 10506915, 10507011, 10507107, 10507203, 10507299, 10507395, 10507491, 10507587, 10507683, 10507779, 10507875, 10507971, 10508067]),
        new Uint32Array([6291456, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 0, 0, 0, 0, 0, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0]),
        new Uint32Array([2175873, 2175905, 2175937, 2175969, 2176001, 2176033, 2176065, 2176097, 2176129, 2176161, 2176193, 2176225, 2176257, 2176289, 2176321, 2176353]),
        new Uint32Array([2140006, 2140198, 2140390, 2140582, 2140774, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672]),
        new Uint32Array([2108193, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 2105505, 2098241]),
        new Uint32Array([0, 23068672, 0, 0, 0, 0, 0, 0, 0, 2145154, 2145218, 2145282, 6291456, 0, 2145346, 0]),
        new Uint32Array([0, 0, 0, 0, 10531458, 10495395, 2148545, 2143201, 2173473, 2148865, 2173505, 0, 2173537, 0, 2173569, 2149121]),
        new Uint32Array([10537282, 10495683, 2148738, 2148802, 2148866, 0, 6291456, 2148930, 2186593, 2173473, 2148737, 2148865, 2148802, 10495779, 10495875, 10495971]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2215425, 2215457, 2215489, 2215521, 2215553, 2215585, 2215617, 2215649, 2215681, 2215713, 2215745, 2215777, 2192033, 2215809, 2215841, 2215873]),
        new Uint32Array([2242049, 2242081, 2242113, 2242145, 2242177, 2242209, 2242241, 2242273, 2215937, 2242305, 2242338, 2242401, 2242433, 2242465, 2242497, 2216001]),
        new Uint32Array([10554529, 2221089, 0, 0, 10562017, 10502113, 10538049, 10537921, 2221185, 10489601, 10489697, 10609889, 10609921, 2141729, 2141793, 10610273]),
        new Uint32Array([2141923, 2142019, 2142115, 2142211, 2142307, 2142403, 2142499, 2142595, 2142691, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([0, 2221185, 2221217, 10609857, 10609857, 10489601, 10489697, 10609889, 10609921, 2141729, 2141793, 2221345, 2221377, 2221409, 2221441, 2187105]),
        new Uint32Array([6291456, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 18923970, 23068672, 23068672, 23068672, 0, 6291456, 6291456]),
        new Uint32Array([2183105, 6291456, 2183137, 6291456, 2183169, 6291456, 2183201, 6291456, 2183233, 6291456, 2183265, 6291456, 2183297, 6291456, 2183329, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2134434, 2134818, 2097666, 2097186, 2097474, 2097698, 2105986, 2131586, 2132450, 2131874, 2131778, 2135970, 2135778, 2161602, 2136162, 2161666]),
        new Uint32Array([2236865, 2236897, 2236930, 2236993, 2237025, 2235681, 2237058, 2237121, 2237153, 2237185, 2237217, 2217281, 2237250, 2191233, 2237313, 2237345]),
        new Uint32Array([2190049, 6291456, 2190081, 6291456, 2190113, 6291456, 2190145, 6291456, 2190177, 6291456, 2190209, 6291456, 2190241, 6291456, 2190273, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2101922, 2102050, 2102178, 2102306, 10498755, 10498851, 10498947, 10499043, 10499139, 10499235, 10499331, 10499427, 10499523, 10489604, 10489732, 10489860]),
        new Uint32Array([2166914, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0]),
        new Uint32Array([2181601, 2170561, 2181633, 2181665, 2170753, 2181697, 2172897, 2170881, 2181729, 2170913, 2172929, 2113441, 2181761, 2181793, 2171009, 2173761]),
        new Uint32Array([0, 2105921, 2097729, 2106081, 0, 2097601, 2162337, 2106017, 2133281, 2097505, 0, 2097185, 2097697, 2135777, 2097633, 2097441]),
        new Uint32Array([6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0]),
        new Uint32Array([2248001, 2248033, 2248066, 2248130, 2248193, 2248226, 2248289, 2248322, 2248385, 2248417, 2216673, 2248450, 2248514, 2248577, 2248610, 2248673]),
        new Uint32Array([6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 0, 0, 0]),
        new Uint32Array([2169729, 6291456, 2169761, 6291456, 2169793, 6291456, 2169825, 6291456, 2169857, 2169889, 6291456, 2169921, 6291456, 2143329, 6291456, 2098305]),
        new Uint32Array([2162178, 2163202, 2163266, 2135170, 2136226, 2161986, 2137954, 2159426, 2159490, 2163330, 2159554, 2163394, 2159682, 2139522, 2136450, 2159746]),
        new Uint32Array([2173953, 2173985, 0, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2174209, 2174241, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 4271169, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2174273]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 6291456, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 2190785, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2189793, 6291456, 2189825, 6291456, 2189857, 6291456, 2189889, 6291456, 2189921, 6291456, 2189953, 6291456, 2189985, 6291456, 2190017, 6291456]),
        new Uint32Array([2105601, 2112289, 2108193, 2112481, 2112577, 0, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 0, 2098209, 2111137]),
        new Uint32Array([2172129, 6291456, 2172161, 6291456, 2172193, 6291456, 2172225, 6291456, 2172257, 6291456, 2172289, 6291456, 2172321, 6291456, 2172353, 6291456]),
        new Uint32Array([2214753, 6291456, 2214785, 6291456, 6291456, 2214817, 2214849, 2214881, 2214913, 2214945, 2214977, 2215009, 2215041, 2215073, 2194401, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([0, 0, 0, 0, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([10610305, 10610337, 10575617, 2221761, 10610401, 10610433, 10502177, 0, 10610465, 10610497, 10610529, 10610561, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 23068672, 0, 0, 0, 0, 23068672]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2187105, 2187137, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2199393, 2199425, 2199457, 2199489, 2199521, 2199553, 2199585, 2199617, 2199649, 2199681, 2199713, 2199745, 2199777, 2199809, 2199841, 0]),
        new Uint32Array([2217249, 2217281, 2217313, 2217345, 2217377, 2217409, 2217441, 2217473, 2215617, 2217505, 2217537, 2217569, 2214753, 2217601, 2217633, 2217665]),
        new Uint32Array([2170273, 2170305, 6291456, 2170337, 2170369, 6291456, 2170401, 2170433, 2170465, 6291456, 6291456, 6291456, 2170497, 2170529, 6291456, 2170561]),
        new Uint32Array([2188673, 6291456, 2188705, 2188737, 2188769, 6291456, 6291456, 2188801, 6291456, 2188833, 6291456, 2188865, 6291456, 2180929, 2181505, 2180897]),
        new Uint32Array([10489988, 10490116, 10490244, 10490372, 10490500, 10490628, 10490756, 10490884, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2147393, 2147457, 2147521, 2147585, 2147649, 2147713, 2147777, 2147841]),
        new Uint32Array([23068672, 23068672, 0, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0]),
        new Uint32Array([2241153, 2241185, 2241217, 2215809, 2241250, 2241313, 2241345, 2241377, 2217921, 2241377, 2241409, 2215873, 2241441, 2241473, 2241505, 2241537]),
        new Uint32Array([23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2220417, 2220417, 2220449, 2220449, 2220481, 2220481, 2220513, 2220513, 2220545, 2220545, 2220577, 2220577, 2220609, 2220609, 2220641, 2220641]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2144002, 0, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456]),
        new Uint32Array([2167105, 2167137, 2167169, 2167201, 2167233, 2167265, 2167297, 2167329, 2167361, 2167393, 2167425, 2167457, 2167489, 2167521, 2167553, 2167585]),
        new Uint32Array([10575521, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193]),
        new Uint32Array([2234146, 2234210, 2234274, 2234338, 2234402, 2234466, 2234530, 2234594, 2234658, 2234722, 2234786, 2234850, 2234914, 2234978, 2235042, 2235106]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 0, 2180577, 0, 0, 0, 0, 0, 2180609, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 6291456, 6291456]),
        new Uint32Array([2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193, 2112481]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2242529, 2242561, 2242593, 2242625, 2242657, 2242689, 2242721, 2242753, 2207937, 2218177, 2242785, 2242817, 2242849, 2242882, 2242945, 2242977]),
        new Uint32Array([2118049, 2105345, 2118241, 2105441, 2118433, 2118529, 2118625, 2118721, 2118817, 2200257, 2200289, 2191809, 2200321, 2200353, 2200385, 2200417]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0]),
        new Uint32Array([2185505, 6291456, 2185537, 6291456, 2185569, 6291456, 2185601, 6291456, 2185633, 6291456, 2185665, 6291456, 2185697, 6291456, 2185729, 6291456]),
        new Uint32Array([2231970, 2232034, 2232098, 2232162, 2232226, 2232290, 2232354, 2232418, 2232482, 2232546, 2232610, 2232674, 2232738, 2232802, 2232866, 2232930]),
        new Uint32Array([2218625, 2246402, 2246466, 2246530, 2246594, 2246657, 2246689, 2246689, 2218657, 2219681, 2246721, 2246753, 2246785, 2246818, 2246881, 2208481]),
        new Uint32Array([2197025, 2197057, 2197089, 2197121, 2197153, 2197185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2219137, 2216961, 2219169, 2219201, 2219233, 2219265, 2219297, 2217025, 2215041, 2219329, 2217057, 2219361, 2217089, 2219393, 2197153, 2219426]),
        new Uint32Array([23068672, 23068672, 23068672, 0, 0, 0, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 0, 0]),
        new Uint32Array([2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713]),
        new Uint32Array([2243522, 2243585, 2243617, 2243649, 2243681, 2210113, 2243713, 2243746, 2243810, 2243874, 2243937, 2243970, 2244033, 2244065, 2244097, 2244129]),
        new Uint32Array([2178017, 6291456, 2178049, 6291456, 2178081, 6291456, 2178113, 6291456, 2178145, 6291456, 2178177, 6291456, 2178209, 6291456, 2178241, 6291456]),
        new Uint32Array([10553858, 2165314, 10518722, 6291456, 10518818, 0, 10518914, 2130690, 10519010, 2130786, 10519106, 2130882, 10519202, 2165378, 10554050, 2165506]),
        new Uint32Array([0, 0, 2135491, 2135587, 2135683, 2135779, 2135875, 2135971, 2135971, 2136067, 2136163, 2136259, 2136355, 2136355, 2136451, 2136547]),
        new Uint32Array([23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2220033, 2220033, 2220065, 2220065, 2220065, 2220065, 2220097, 2220097, 2220097, 2220097, 2220129, 2220129, 2220129, 2220129, 2220161, 2220161]),
        new Uint32Array([6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([2100897, 2100898, 2100899, 2150018, 2100865, 2100866, 2100867, 2100868, 2150082, 2108481, 2109858, 2109859, 2105569, 2105505, 2098241, 2105601]),
        new Uint32Array([2097217, 2097505, 2097505, 2097505, 2097505, 2165570, 2165570, 2165634, 2165634, 2165698, 2165698, 2097858, 2097858, 0, 0, 2097152]),
        new Uint32Array([23068672, 6291456, 23068672, 23068672, 23068672, 6291456, 6291456, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672]),
        new Uint32Array([23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0]),
        new Uint32Array([10503843, 10503939, 10504035, 10504131, 10504227, 10504323, 10504419, 10504515, 10504611, 10504707, 10504803, 10504899, 10504995, 10491140, 10491268, 0]),
        new Uint32Array([2173697, 2173729, 2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889, 2173921, 2173953, 2173985, 2173761, 2174017, 2174049]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([2134145, 2097153, 2134241, 2105953, 2132705, 2130977, 2160065, 2131297, 2162049, 2133089, 2160577, 2133857, 2235297, 2220769, 2235329, 2235361]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([2222401, 2222433, 2222465, 10531394, 2222497, 2222529, 2222561, 0, 2222593, 2222625, 2222657, 2222689, 2222721, 2222753, 2222785, 0]),
        new Uint32Array([2184481, 6291456, 2184513, 6291456, 2184545, 6291456, 2184577, 6291456, 2184609, 6291456, 2184641, 6291456, 2184673, 6291456, 2184705, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2105570, 2156034, 2126947, 2156098, 2153666, 2127043, 2127139, 2156162, 0, 2127235, 2156226, 2156290, 2156354, 2156418, 2127331, 2127427]),
        new Uint32Array([2215905, 2207041, 2153185, 2241569, 2241601, 2241633, 2241665, 2241697, 2241730, 2241793, 2241825, 2241857, 2241889, 2241921, 2241954, 2242017]),
        new Uint32Array([2203777, 6291456, 2203809, 6291456, 2203841, 6291456, 2203873, 6291456, 2203905, 6291456, 2173121, 2180993, 2181249, 2203937, 2181313, 0]),
        new Uint32Array([2168577, 6291456, 2168609, 6291456, 2168641, 6291456, 2168673, 6291456, 2168705, 6291456, 2168737, 6291456, 2168769, 6291456, 2168801, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 23068672, 23068672, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 0, 0]),
        new Uint32Array([2210113, 2195521, 2210145, 2210177, 2210209, 2210241, 2210273, 2210305, 2210337, 2210369, 2210401, 2210433, 2210465, 2210497, 2210529, 2210561]),
        new Uint32Array([6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0]),
        new Uint32Array([2228706, 2228770, 2228834, 2228898, 2228962, 2229026, 2229090, 2229154, 2229218, 2229282, 2229346, 2229410, 2229474, 2229538, 2229602, 2229666]),
        new Uint32Array([23068672, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 18874368, 18874368, 18874368, 0, 0]),
        new Uint32Array([2133089, 2133281, 2133281, 2133281, 2133281, 2160577, 2160577, 2160577, 2160577, 2097441, 2097441, 2097441, 2097441, 2133857, 2133857, 2133857]),
        new Uint32Array([6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2173825, 2153473, 2173857, 2173889, 2173921, 2173953, 2173985, 2174017, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2233089]),
        new Uint32Array([2178529, 6291456, 2178561, 6291456, 2178593, 6291456, 2178625, 6291456, 2178657, 6291456, 2178689, 6291456, 2178721, 6291456, 2178753, 6291456]),
        new Uint32Array([2221025, 2221025, 2221057, 2221057, 2159329, 2159329, 2159329, 2159329, 2097217, 2097217, 2158914, 2158914, 2158978, 2158978, 2159042, 2159042]),
        new Uint32Array([2208161, 2208193, 2208225, 2208257, 2194433, 2208289, 2208321, 2208353, 2208385, 2208417, 2208449, 2208481, 2208513, 2208545, 2208577, 2208609]),
        new Uint32Array([2169217, 6291456, 2169249, 6291456, 2169281, 6291456, 2169313, 6291456, 2169345, 6291456, 2169377, 6291456, 2169409, 6291456, 2169441, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2133187, 2133283, 2133283, 2133379, 2133475, 2133571, 2133667, 2133667, 2133763, 2133859, 2133955, 2134051, 2134147, 2134147, 2134243, 2134339]),
        new Uint32Array([2197697, 2114113, 2114209, 2197729, 2197761, 2114305, 2197793, 2114401, 2114497, 2197825, 2114593, 2114689, 2114785, 2114881, 2114977, 0]),
        new Uint32Array([2193089, 2193121, 2193153, 2193185, 2117665, 2117569, 2193217, 2193249, 2193281, 2193313, 2193345, 2193377, 2193409, 2193441, 2193473, 2193505]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2184225, 6291456, 2184257, 6291456, 2184289, 6291456, 2184321, 6291456, 2184353, 6291456, 2184385, 6291456, 2184417, 6291456, 2184449, 6291456]),
        new Uint32Array([2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2100833, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([2098657, 2098049, 2200737, 2123489, 2123681, 2200769, 2098625, 2100321, 2098145, 2100449, 2098017, 2098753, 2200801, 2200833, 2200865, 0]),
        new Uint32Array([23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0]),
        new Uint32Array([2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 0, 2098241, 2108353, 2108417, 2105825, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2181153, 2105505, 2181185, 2167617, 2180993]),
        new Uint32Array([2160002, 2160066, 2160130, 2160194, 2160258, 2132066, 2131010, 2131106, 2106018, 2131618, 2160322, 2131298, 2132034, 2131938, 2137410, 2132226]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6291456]),
        new Uint32Array([2183617, 6291456, 2183649, 6291456, 2183681, 6291456, 2183713, 6291456, 2183745, 6291456, 2183777, 6291456, 2183809, 6291456, 2183841, 6291456]),
        new Uint32Array([0, 6291456, 6291456, 0, 6291456, 0, 0, 6291456, 6291456, 0, 6291456, 0, 0, 6291456, 0, 0]),
        new Uint32Array([2250977, 2251009, 2251041, 2251073, 2195009, 2251106, 2251169, 2251201, 2251233, 2251265, 2251297, 2251330, 2251394, 2251457, 2251489, 2251521]),
        new Uint32Array([2205729, 2205761, 2205793, 2205825, 2205857, 2205889, 2205921, 2205953, 2205985, 2206017, 2206049, 2206081, 2206113, 2206145, 2206177, 2206209]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2143170, 2168993, 6291456, 2169025, 6291456, 2169057, 6291456, 2169089, 6291456, 2143234, 2169121, 6291456, 2169153, 6291456, 2169185, 6291456]),
        new Uint32Array([23068672, 23068672, 2190689, 6291456, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2248706, 2248769, 2248801, 2248833, 2248865, 2248897, 2248929, 2248962, 2249026, 2249090, 2249154, 2240705, 2249217, 2249249, 2249281, 2249313]),
        new Uint32Array([10485857, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 10495394, 6291456, 2098209, 6291456, 6291456, 2097152, 6291456, 10531394]),
        new Uint32Array([0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0]),
        new Uint32Array([14680064, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2173985, 2173953, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889]),
        new Uint32Array([6291456, 2186977, 6291456, 6291456, 6291456, 6291456, 6291456, 10537858, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2209601, 2209633, 2209665, 2209697, 2209729, 2209761, 2209793, 2209825, 2209857, 2209889, 2209921, 2209953, 2209985, 2210017, 2210049, 2210081]),
        new Uint32Array([10501539, 10501635, 10501731, 10501827, 10501923, 10502019, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905]),
        new Uint32Array([2173697, 2173729, 2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889, 2173921, 2173953, 2173985, 2174017, 2174017, 2174049]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 0, 0]),
        new Uint32Array([6291456, 6291456, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2194561, 2194593, 2194625, 2119777, 2119873, 2194657, 2194689, 2194721, 2194753, 2194785, 2194817, 2194849, 2194881, 2194913, 2194945, 2194977]),
        new Uint32Array([2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569]),
        new Uint32Array([2222818, 2222882, 2222946, 2223010, 2223074, 2223138, 2223202, 2223266, 2223330, 2223394, 2223458, 2223522, 2223586, 2223650, 2223714, 2223778]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672]),
        new Uint32Array([0, 2179553, 2179585, 2179617, 2179649, 2144001, 2179681, 2179713, 2179745, 2179777, 2179809, 2156705, 2179841, 2156833, 2179873, 2179905]),
        new Uint32Array([6291456, 23068672, 6291456, 2145602, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 6291456, 0, 0]),
        new Uint32Array([2196513, 2196545, 2196577, 2196609, 2196641, 2196673, 2196705, 2196737, 2196769, 2196801, 2196833, 2196865, 2196897, 2196929, 2196961, 2196993]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2177281, 6291456, 2177313, 6291456, 2177345, 6291456, 2177377, 6291456, 2177409, 6291456, 2177441, 6291456, 2177473, 6291456, 2177505, 6291456]),
        new Uint32Array([2187137, 2221473, 2221505, 2221537, 2221569, 6291456, 6291456, 10610209, 10610241, 10537986, 10537986, 10537986, 10537986, 10609857, 10609857, 10609857]),
        new Uint32Array([2243009, 2243041, 2216033, 2243074, 2243137, 2243169, 2243201, 2219617, 2243233, 2243265, 2243297, 2243329, 2243362, 2243425, 2243457, 2243489]),
        new Uint32Array([10485857, 10485857, 10485857, 10485857, 10485857, 10485857, 10485857, 10485857, 10485857, 10485857, 10485857, 2097152, 4194304, 4194304, 0, 0]),
        new Uint32Array([2143042, 6291456, 2143106, 2143106, 2168833, 6291456, 2168865, 6291456, 6291456, 2168897, 6291456, 2168929, 6291456, 2168961, 6291456, 2143170]),
        new Uint32Array([6291456, 6291456, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2204193, 2204225, 2204257, 2204289, 2204321, 2204353, 2204385, 2204417, 2204449, 2204481, 2204513, 2204545, 2204577, 2204609, 2204641, 2204673]),
        new Uint32Array([2202753, 6291456, 2202785, 6291456, 2202817, 6291456, 2202849, 6291456, 2202881, 6291456, 2202913, 6291456, 2202945, 6291456, 2202977, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193, 2112481, 2112577, 2098177, 2098305, 2108321]),
        new Uint32Array([2147394, 2147458, 2147522, 2147586, 2147650, 2147714, 2147778, 2147842, 2147394, 2147458, 2147522, 2147586, 2147650, 2147714, 2147778, 2147842]),
        new Uint32Array([2253313, 2253346, 2253409, 2253441, 2253473, 2253505, 2253537, 2253569, 2253601, 2253634, 2219393, 2253697, 2253729, 2253761, 2253793, 2253825]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456]),
        new Uint32Array([2162562, 2162626, 2131362, 2162690, 2159938, 2160002, 2162754, 2162818, 2160130, 2162882, 2160194, 2160258, 2160834, 2160898, 2161026, 2161090]),
        new Uint32Array([2175361, 2175393, 2175425, 2175457, 2175489, 2175521, 2175553, 2175585, 2175617, 2175649, 2175681, 2175713, 2175745, 2175777, 2175809, 2175841]),
        new Uint32Array([2253858, 2253921, 2253954, 2254018, 2254082, 2196737, 2254145, 2196865, 2254177, 2254209, 2254241, 2254273, 2197025, 2254306, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2202113, 2204129, 2188705, 2204161]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 0, 0]),
        new Uint32Array([2173985, 2174017, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2233089, 2173697, 2173761, 2173793, 2174113, 2173985, 2173953]),
        new Uint32Array([2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 2100833, 2100737, 2098337, 2101441, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209]),
        new Uint32Array([2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 2105505, 2098241, 0, 2108417, 0, 2111713, 2100897, 2111905]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2175425, 2175489, 2175809, 2175905, 2175937, 2175937, 2176193, 2176417, 2180865, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 2143298, 2143298, 2143298, 2143362, 2143362, 2143362, 2143426, 2143426, 2143426, 2171105, 6291456, 2171137]),
        new Uint32Array([2120162, 2120258, 2151618, 2151682, 2151746, 2151810, 2151874, 2151938, 2152002, 2120035, 2120131, 2120227, 2152066, 2120323, 2152130, 2120419]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2195361, 2142433, 2236065, 2236097, 2236129, 2236161, 2118241, 2117473, 2236193, 2236225, 2236257, 2236289, 0, 0, 0, 0]),
        new Uint32Array([2189281, 6291456, 2189313, 6291456, 2189345, 6291456, 2189377, 6291456, 2189409, 6291456, 2189441, 6291456, 2189473, 6291456, 2189505, 6291456]),
        new Uint32Array([6291456, 6291456, 2145922, 6291456, 6291456, 6291456, 6291456, 2145986, 6291456, 6291456, 6291456, 6291456, 2146050, 6291456, 6291456, 6291456]),
        new Uint32Array([2100833, 2100737, 2098337, 2101441, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 10502113, 10562017, 10610401, 10502177, 10610433, 10538049]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 2186401, 0, 2186433, 0, 2186465, 0, 2186497]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 23068672, 23068672, 23068672]),
        new Uint32Array([0, 0, 2198241, 2198273, 2198305, 2198337, 2198369, 2198401, 0, 0, 2198433, 2198465, 2198497, 0, 0, 0]),
        new Uint32Array([6291456, 0, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 23068672, 6291456, 23068672, 23068672]),
        new Uint32Array([0, 2105921, 2097729, 0, 2097377, 0, 0, 2106017, 2133281, 2097505, 2105889, 0, 2097697, 2135777, 2097633, 2097441]),
        new Uint32Array([2197889, 2197921, 2197953, 2197985, 2198017, 2198049, 2198081, 2198113, 2198145, 2198177, 2198209, 2198241, 2198273, 2198305, 2198337, 2198369]),
        new Uint32Array([2132514, 2132610, 2160386, 2133090, 2133186, 2160450, 2160514, 2133282, 2160578, 2133570, 2106178, 2160642, 2133858, 2160706, 2160770, 2134146]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 23068672, 23068672, 6291456, 23068672, 23068672, 6291456, 23068672, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2184737, 6291456, 2184769, 6291456, 2184801, 6291456, 2184833, 6291456, 2184865, 6291456, 2184897, 6291456, 2184929, 6291456, 2184961, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 0, 6291456]),
        new Uint32Array([6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 2186753, 6291456, 6291456, 6291456, 6291456, 2186785, 2186817, 2186849, 2173569, 2186881, 10496355, 10495395, 10575521]),
        new Uint32Array([0, 0, 2097729, 0, 0, 0, 0, 2106017, 0, 2097505, 0, 2097185, 0, 2135777, 2097633, 2097441]),
        new Uint32Array([2189537, 6291456, 2189569, 6291456, 2189601, 6291456, 2189633, 6291456, 2189665, 6291456, 2189697, 6291456, 2189729, 6291456, 2189761, 6291456]),
        new Uint32Array([2202497, 6291456, 2202529, 6291456, 2202561, 6291456, 2202593, 6291456, 2202625, 6291456, 2202657, 6291456, 2202689, 6291456, 2202721, 6291456]),
        new Uint32Array([2245217, 2218369, 2245249, 2245282, 2245345, 2245377, 2245410, 2245474, 2245537, 2245569, 2245601, 2245633, 2245665, 2245665, 2245697, 2245729]),
        new Uint32Array([6291456, 0, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 0, 0, 0, 0, 0, 0, 23068672, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 23068672, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672]),
        new Uint32Array([0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2097281, 2105921, 2097729, 2106081, 2097377, 2097601, 2162337, 2106017, 2133281, 2097505, 0, 2097185, 2097697, 2135777, 2097633, 2097441]),
        new Uint32Array([2176641, 6291456, 2176673, 6291456, 2176705, 6291456, 2176737, 6291456, 2176769, 6291456, 2176801, 6291456, 2176833, 6291456, 2176865, 6291456]),
        new Uint32Array([2174145, 2174177, 2149057, 2233089, 2173697, 2173761, 2173793, 2174113, 2173985, 2173953, 2174369, 2174369, 0, 0, 2100833, 2100737]),
        new Uint32Array([2116513, 2190817, 2190849, 2190881, 2190913, 2190945, 2116609, 2190977, 2191009, 2191041, 2191073, 2117185, 2191105, 2191137, 2191169, 2191201]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456]),
        new Uint32Array([0, 0, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456]),
        new Uint32Array([2167617, 2167649, 2167681, 2167713, 2167745, 2167777, 2167809, 6291456, 2167841, 2167873, 2167905, 2167937, 2167969, 2168001, 2168033, 4240130]),
        new Uint32Array([2165122, 2163970, 2164034, 2164098, 2164162, 2164226, 2164290, 2164354, 2164418, 2164482, 2164546, 2133122, 2134562, 2132162, 2132834, 2136866]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 2186209, 2186241, 2186273, 2186305, 2186337, 2186369, 0, 0]),
        new Uint32Array([2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 14680064, 14680064, 14680064, 14680064, 14680064]),
        new Uint32Array([0, 0, 23068672, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456]),
        new Uint32Array([0, 10537921, 10610689, 10610273, 10610497, 10610529, 10610305, 10610721, 10489601, 10489697, 10610337, 10575617, 10554529, 2221761, 2197217, 10496577]),
        new Uint32Array([2105473, 2105569, 2105601, 2112289, 0, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441]),
        new Uint32Array([2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481]),
        new Uint32Array([2125346, 2153410, 2153474, 2127394, 2153538, 2153602, 2153666, 2153730, 2105507, 2105476, 2153794, 2153858, 2153922, 2153986, 2154050, 2105794]),
        new Uint32Array([2200449, 2119681, 2200481, 2153313, 2199873, 2199905, 2199937, 2200513, 2200545, 2200577, 2200609, 2119105, 2119201, 2119297, 2119393, 2119489]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2175777, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2222273, 2197217, 2221473, 2221505, 2221089, 2222305, 2200865, 2099681, 2104481, 2222337, 2099905, 2120737, 2222369, 2103713, 2100225, 2098785]),
        new Uint32Array([2201377, 6291456, 2201409, 6291456, 2201441, 6291456, 2201473, 6291456, 2201505, 6291456, 2201537, 6291456, 2201569, 6291456, 6291456, 23068672]),
        new Uint32Array([2174081, 2174113, 2174145, 2174177, 2149057, 2233057, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761, 2143969, 2173793]),
        new Uint32Array([2200897, 6291456, 2200929, 6291456, 2200961, 6291456, 2200993, 6291456, 2201025, 6291456, 2180865, 6291456, 2201057, 6291456, 2201089, 6291456]),
        new Uint32Array([0, 0, 0, 0, 0, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0]),
        new Uint32Array([2161154, 2161410, 2138658, 2161474, 2161538, 2097666, 2097186, 2097474, 2162946, 2132450, 2163010, 2163074, 2136162, 2163138, 2161666, 2161730]),
        new Uint32Array([2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889, 2173921, 2173953]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 23068672, 23068672, 0, 0, 0, 0, 2145410, 2145474, 0, 6291456]),
        new Uint32Array([2244161, 2216065, 2212769, 2244193, 2244225, 2244257, 2244290, 2244353, 2244385, 2244417, 2244449, 2218273, 2244481, 2244514, 2244577, 2244609]),
        new Uint32Array([2125730, 2125699, 2125795, 2125891, 2125987, 2154114, 2154178, 2154242, 2154306, 2154370, 2154434, 2154498, 2126082, 2126178, 2126274, 2126083]),
        new Uint32Array([2237665, 2237697, 2237697, 2237697, 2237730, 2237793, 2237825, 2237857, 2237890, 2237953, 2237985, 2238017, 2238049, 2238081, 2238113, 2238145]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2150146, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 23068672, 23068672, 0, 0, 23068672, 23068672, 23068672, 0, 0]),
        new Uint32Array([2214369, 2238593, 2238625, 2238657, 2238689, 2238721, 2238753, 2238785, 2238817, 2238850, 2238913, 2238945, 2238977, 2235457, 2239009, 2239041]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0]),
        new Uint32Array([2252066, 2252130, 2252193, 2252225, 2252257, 2252290, 2252353, 2252385, 2252417, 2252449, 2252481, 2252513, 2252545, 2252578, 2252641, 2252673]),
        new Uint32Array([2197697, 2114113, 2114209, 2197729, 2197761, 2114305, 2197793, 2114401, 2114497, 2197825, 2114593, 2114689, 2114785, 2114881, 2114977, 2197857]),
        new Uint32Array([2224866, 2224930, 2224994, 2225058, 2225122, 2225186, 2225250, 2225314, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2219490, 2219554, 2219617, 2219649, 2219681, 2219714, 2219778, 2219842, 2219905, 2219937, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456]),
        new Uint32Array([2113345, 2113441, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289]),
        new Uint32Array([2174081, 2174113, 2174145, 2174177, 2149057, 2233089, 2173697, 2173761, 2173793, 2174113, 2173985, 2173953, 2148481, 2173601, 2173633, 2173665]),
        new Uint32Array([2220161, 2220161, 2220193, 2220193, 2220193, 2220193, 2220225, 2220225, 2220225, 2220225, 2220257, 2220257, 2220257, 2220257, 2220289, 2220289]),
        new Uint32Array([2192673, 2192705, 2192737, 2192769, 2192801, 2192833, 2192865, 2118049, 2192897, 2117473, 2117761, 2192929, 2192961, 2192993, 2193025, 2193057]),
        new Uint32Array([2179297, 6291456, 2179329, 6291456, 2179361, 6291456, 2179393, 6291456, 2179425, 6291456, 2179457, 6291456, 2179489, 6291456, 2179521, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2235745, 2235777, 2193633, 2235809, 2235841, 2235873, 2235905, 2235937, 2235969, 2116513, 2116705, 2236001, 2200513, 2199905, 2200545, 2236033]),
        new Uint32Array([2113153, 2108481, 2113345, 2113441, 2232993, 2233025, 0, 0, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761]),
        new Uint32Array([2170593, 6291456, 2170625, 6291456, 2170657, 6291456, 2170689, 2170721, 6291456, 2170753, 6291456, 6291456, 2170785, 6291456, 2170817, 2170849]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2166786, 2166850, 0, 0, 0, 0]),
        new Uint32Array([23068672, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456]),
        new Uint32Array([2100833, 2100737, 2098337, 2101441, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 10575617, 2187041, 10502177, 10489601, 10489697, 0]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2134562, 2132162, 2132834, 2136866, 2136482, 2164610, 2164674, 2164738, 2164802, 2132802, 2132706, 2164866, 2132898, 2164930, 2164994, 2165058]),
        new Uint32Array([6291456, 6291456, 2098337, 2101441, 10531458, 2153473, 6291456, 6291456, 10531522, 2100737, 2108193, 6291456, 2106499, 2106595, 2106691, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2233122, 2233186, 2233250, 2233314, 2233378, 2233442, 2233506, 2233570, 2233634, 2233698, 2233762, 2233826, 2233890, 2233954, 2234018, 2234082]),
        new Uint32Array([23068672, 6291456, 23068672, 23068672, 23068672, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2205217, 2205249, 2205281, 2205313, 2205345, 2205377, 2205409, 2205441, 2205473, 2205505, 2205537, 2205569, 2205601, 2205633, 2205665, 2205697]),
        new Uint32Array([6291456, 0, 6291456, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 0, 0, 23068672, 6291456, 23068672, 23068672]),
        new Uint32Array([2173601, 2173761, 2174081, 2173569, 2174241, 2174113, 2173953, 6291456, 2174305, 6291456, 2174337, 6291456, 2174369, 6291456, 2174401, 6291456]),
        new Uint32Array([6291456, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456]),
        new Uint32Array([2152450, 2152514, 2099653, 2104452, 2099813, 2122243, 2099973, 2152578, 2122339, 2122435, 2122531, 2122627, 2122723, 2104580, 2122819, 2152642]),
        new Uint32Array([2236385, 2236417, 2236449, 2236482, 2236545, 2215425, 2236577, 2236609, 2236641, 2236673, 2215457, 2236705, 2236737, 2236770, 2215489, 2236833]),
        new Uint32Array([2163394, 2159746, 2163458, 2131362, 2163522, 2160130, 2163778, 2132226, 2163842, 2132898, 2163906, 2161410, 2138658, 2097666, 2136162, 2163650]),
        new Uint32Array([2218721, 2246913, 2246946, 2216385, 2247010, 2247074, 2215009, 2247137, 2247169, 2216481, 2247201, 2247233, 2247266, 2247330, 2247330, 0]),
        new Uint32Array([2129730, 2129762, 2129858, 2129731, 2129827, 2156482, 2156482, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 0, 0, 0, 0, 0, 6291456, 0, 0]),
        new Uint32Array([2203969, 2204001, 2181377, 2204033, 2204065, 6291456, 2204097, 6291456, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2169473, 6291456, 2169505, 6291456, 2169537, 6291456, 2169569, 6291456, 2169601, 6291456, 2169633, 6291456, 2169665, 6291456, 2169697, 6291456]),
        new Uint32Array([2141542, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2220801, 2220801, 2220801, 2220801, 2220833, 2220833, 2220865, 2220865, 2220865, 2220865, 2220897, 2220897, 2220897, 2220897, 2139873, 2139873]),
        new Uint32Array([0, 0, 0, 0, 0, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 6291456, 0]),
        new Uint32Array([2214849, 2218433, 2218465, 2218497, 2218529, 2218561, 2214881, 2218593, 2218625, 2218657, 2218689, 2218721, 2218753, 2216545, 2218785, 2218817]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6291456]),
        new Uint32Array([2136482, 2164610, 2164674, 2164738, 2164802, 2132802, 2132706, 2164866, 2132898, 2164930, 2164994, 2165058, 2165122, 2132802, 2132706, 2164866]),
        new Uint32Array([2207649, 2207681, 2207713, 2207745, 2207777, 2207809, 2207841, 2207873, 2207905, 2207937, 2207969, 2208001, 2208033, 2208065, 2208097, 2208129]),
        new Uint32Array([2123683, 2105092, 2152706, 2123779, 2105220, 2152770, 2100453, 2098755, 2123906, 2124002, 2124098, 2124194, 2124290, 2124386, 2124482, 2124578]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 0, 0, 0, 0, 0, 0, 0, 10485857]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([10508163, 10508259, 10508355, 10508451, 2200129, 2200161, 2192737, 2200193, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2203553, 6291456, 2203585, 6291456, 6291456, 6291456, 2203617, 6291456, 2203649, 6291456, 2203681, 6291456, 2203713, 6291456, 2203745, 6291456]),
        new Uint32Array([18884449, 18884065, 23068672, 18884417, 18884034, 18921185, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 18874368]),
        new Uint32Array([2247393, 2247426, 2247489, 2247521, 2247553, 2247586, 2247649, 2247681, 2247713, 2247745, 2247777, 2247810, 2247873, 2247905, 2247937, 2247969]),
        new Uint32Array([6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 23068672]),
        new Uint32Array([2134145, 2097153, 2134241, 0, 2132705, 2130977, 2160065, 2131297, 0, 2133089, 2160577, 2133857, 2235297, 0, 2235329, 0]),
        new Uint32Array([2182593, 6291456, 2182625, 6291456, 2182657, 6291456, 2182689, 6291456, 2182721, 6291456, 2182753, 6291456, 2182785, 6291456, 2182817, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2102402, 2102403, 6291456, 2110050]),
        new Uint32Array([2149890, 2108323, 2149954, 6291456, 2113441, 6291456, 2149057, 6291456, 2113441, 6291456, 2105473, 2167265, 2111137, 2105505, 6291456, 2108353]),
        new Uint32Array([2219105, 2219137, 2195233, 2251554, 2251617, 2251649, 2251681, 2251713, 2251746, 2251810, 2251873, 2251905, 2251937, 2251970, 2252033, 2219169]),
        new Uint32Array([2203009, 6291456, 2203041, 6291456, 2203073, 6291456, 2203105, 6291456, 2203137, 6291456, 2203169, 6291456, 2203201, 6291456, 2203233, 6291456]),
        new Uint32Array([2128195, 2128291, 2128387, 2128483, 2128579, 2128675, 2128771, 2128867, 2128963, 2129059, 2129155, 2129251, 2129347, 2129443, 2129539, 2129635]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2140964, 2141156, 2140966, 2141158, 2141350]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([2225378, 2225442, 2225506, 2225570, 2225634, 2225698, 2225762, 2225826, 2225890, 2225954, 2226018, 2226082, 2226146, 2226210, 2226274, 2226338]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417]),
        new Uint32Array([2108353, 2108417, 0, 2105601, 2108193, 2157121, 2157313, 2157377, 2157441, 2100897, 6291456, 2108419, 2173953, 2173633, 2173633, 2173953]),
        new Uint32Array([2111713, 2173121, 2111905, 2098177, 2173153, 2173185, 2173217, 2113153, 2113345, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 2190753]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2197249, 6291456, 2117377, 2197281, 2197313, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 0, 0, 0, 0, 0, 0, 23068672, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456]),
        new Uint32Array([2098337, 2101441, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 2100833, 2100737, 2098337, 2101441, 2101569, 2101697, 2101825, 2101953]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0]),
        new Uint32Array([0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 23068672, 23068672, 23068672]),
        new Uint32Array([2173281, 6291456, 2173313, 6291456, 2173345, 6291456, 2173377, 6291456, 0, 0, 10532546, 6291456, 6291456, 6291456, 10562017, 2173441]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 0, 0]),
        new Uint32Array([23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2159426, 2159490, 2159554, 2159362, 2159618, 2159682, 2139522, 2136450, 2159746, 2159810, 2159874, 2130978, 2131074, 2131266, 2131362, 2159938]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2203233, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2203265, 6291456, 2203297, 6291456, 2203329, 2203361, 6291456]),
        new Uint32Array([6291456, 6291456, 2148418, 2148482, 2148546, 0, 6291456, 2148610, 2186529, 2186561, 2148417, 2148545, 2148482, 10495778, 2143969, 10495778]),
        new Uint32Array([2134146, 2139426, 2160962, 2134242, 2161218, 2161282, 2161346, 2161410, 2138658, 2134722, 2134434, 2134818, 2097666, 2097346, 2097698, 2105986]),
        new Uint32Array([2198881, 2198913, 2198945, 2198977, 2199009, 2199041, 2199073, 2199105, 2199137, 2199169, 2199201, 2199233, 2199265, 2199297, 2199329, 2199361]),
        new Uint32Array([0, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456]),
        new Uint32Array([10610561, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193]),
        new Uint32Array([2183873, 6291456, 2183905, 6291456, 2183937, 6291456, 2183969, 6291456, 2184001, 6291456, 2184033, 6291456, 2184065, 6291456, 2184097, 6291456]),
        new Uint32Array([2244642, 2244706, 2244769, 2244801, 2218305, 2244833, 2244865, 2244897, 2244929, 2244961, 2244993, 2245026, 2245089, 2245122, 2245185, 0]),
        new Uint32Array([6291456, 6291456, 2116513, 2116609, 2116705, 2116801, 2199873, 2199905, 2199937, 2199969, 2190913, 2200001, 2200033, 2200065, 2200097, 2191009]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 2180673, 2180705, 2180737, 2180769, 2180801, 2180833, 0, 0]),
        new Uint32Array([2098081, 2099521, 2099105, 2120705, 2098369, 2120801, 2103361, 2097985, 2098433, 2121377, 2121473, 2099169, 2099873, 2098401, 2099393, 2152609]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2150402]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 2145666, 2145730, 6291456, 6291456]),
        new Uint32Array([2173921, 2173953, 2173985, 2173761, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2233057, 2148481, 2173601, 2173633, 2173665]),
        new Uint32Array([2187073, 6291456, 6291456, 6291456, 6291456, 2098241, 2098241, 2108353, 2100897, 2111905, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2102404, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2100612, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 10485857]),
        new Uint32Array([2149057, 2233057, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889]),
        new Uint32Array([2217697, 2217729, 2217761, 2217793, 2217825, 2217857, 2217889, 2217921, 2217953, 2215873, 2217985, 2215905, 2218017, 2218049, 2218081, 2218113]),
        new Uint32Array([2211233, 2218849, 2216673, 2218881, 2218913, 2218945, 2218977, 2219009, 2216833, 2219041, 2215137, 2219073, 2216865, 2209505, 2219105, 2216897]),
        new Uint32Array([2240097, 2240129, 2240161, 2240193, 2240225, 2240257, 2240289, 2240321, 2240353, 2240386, 2240449, 2240481, 2240513, 2240545, 2207905, 2240578]),
        new Uint32Array([6291456, 6291456, 2202273, 6291456, 2202305, 6291456, 2202337, 6291456, 2202369, 6291456, 2202401, 6291456, 2202433, 6291456, 2202465, 6291456]),
        new Uint32Array([0, 23068672, 23068672, 18923394, 23068672, 18923458, 18923522, 18884099, 18923586, 18884195, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([2201121, 6291456, 2201153, 6291456, 2201185, 6291456, 2201217, 6291456, 2201249, 6291456, 2201281, 6291456, 2201313, 6291456, 2201345, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456]),
        new Uint32Array([2211041, 2211073, 2211105, 2211137, 2211169, 2211201, 2211233, 2211265, 2211297, 2211329, 2211361, 2211393, 2211425, 2211457, 2211489, 2211521]),
        new Uint32Array([2181825, 6291456, 2181857, 6291456, 2181889, 6291456, 2181921, 6291456, 2181953, 6291456, 2181985, 6291456, 2182017, 6291456, 2182049, 6291456]),
        new Uint32Array([2162337, 2097633, 2097633, 2097633, 2097633, 2132705, 2132705, 2132705, 2132705, 2097153, 2097153, 2097153, 2097153, 2133089, 2133089, 2133089]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 2148545, 6291456, 2173473, 6291456, 2148865, 6291456, 2173505, 6291456, 2173537, 6291456, 2173569, 6291456, 2149121, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 0, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0]),
        new Uint32Array([2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889, 2173921, 2173953, 2173985, 2174017, 2174017, 2174049, 2174081, 2174113]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([2207137, 2207169, 2207201, 2207233, 2207265, 2207297, 2207329, 2207361, 2207393, 2207425, 2207457, 2207489, 2207521, 2207553, 2207585, 2207617]),
        new Uint32Array([6291456, 6291456, 23068672, 23068672, 23068672, 6291456, 6291456, 0, 23068672, 23068672, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2198401, 2198433, 2198465, 2198497, 0, 2198529, 2198561, 2198593, 2198625, 2198657, 2198689, 2198721, 2198753, 2198785, 2198817, 2198849]),
        new Uint32Array([2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193, 2112481, 2112577, 2098177]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 0, 0]),
        new Uint32Array([2216385, 2118721, 2216417, 2216449, 2216481, 2216513, 2216545, 2211233, 2216577, 2216609, 2216641, 2216673, 2216705, 2216737, 2216737, 2216769]),
        new Uint32Array([2216801, 2216833, 2216865, 2216897, 2216929, 2216961, 2216993, 2215169, 2217025, 2217057, 2217089, 2217121, 2217154, 2217217, 0, 0]),
        new Uint32Array([2210593, 2191809, 2210625, 2210657, 2210689, 2210721, 2210753, 2210785, 2210817, 2210849, 2191297, 2210881, 2210913, 2210945, 2210977, 2211009]),
        new Uint32Array([0, 0, 2105825, 0, 0, 2111905, 2105473, 0, 0, 2112289, 2108193, 2112481, 2112577, 0, 2098305, 2108321]),
        new Uint32Array([0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([0, 2097153, 2134241, 0, 2132705, 0, 0, 2131297, 0, 2133089, 0, 2133857, 0, 2220769, 0, 2235361]),
        new Uint32Array([14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 6291456, 6291456, 14680064]),
        new Uint32Array([23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2171873, 6291456, 2171905, 6291456, 2171937, 6291456, 2171969, 6291456, 2172001, 6291456, 2172033, 6291456, 2172065, 6291456, 2172097, 6291456]),
        new Uint32Array([2220929, 2220929, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2133857, 2134145, 2134145, 2134145, 2134145, 2134241, 2134241, 2134241, 2134241, 2105889, 2105889, 2105889, 2105889, 2097185, 2097185, 2097185]),
        new Uint32Array([2173697, 2173761, 2173793, 2174113, 2173985, 2173953, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761, 2143969, 2173793]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10499619, 10499715, 10499811, 10499907]),
        new Uint32Array([0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23068672]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 0, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 23068672, 23068672]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 2144322, 2144386, 2144450, 2144514, 2144578, 2144642, 2144706, 2144770]),
        new Uint32Array([23068672, 23068672, 23068672, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 0, 2098241, 2108353, 2108417, 2105825, 0, 0, 2111905, 2105473, 2105569]),
        new Uint32Array([2236321, 2236353, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2152194, 2121283, 2103684, 2103812, 2097986, 2098533, 2097990, 2098693, 2098595, 2098853, 2099013, 2103940, 2121379, 2121475, 2121571, 2104068]),
        new Uint32Array([2206241, 2206273, 2206305, 2206337, 2206369, 2206401, 2206433, 2206465, 2206497, 2206529, 2206561, 2206593, 2206625, 2206657, 2206689, 2206721]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 16777216, 16777216, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 23068672, 23068672, 10538818, 10538882, 6291456, 6291456, 2150338]),
        new Uint32Array([6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2214369, 2214401, 2214433, 2214465, 2214497, 2214529, 2214561, 2214593, 2194977, 2214625, 2195073, 2214657, 2214689, 2214721, 6291456, 6291456]),
        new Uint32Array([2097152, 2097152, 2097152, 2097152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2182081, 6291456, 2182113, 6291456, 2182145, 6291456, 2182177, 6291456, 2182209, 6291456, 2182241, 6291456, 2182273, 6291456, 2182305, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2146881, 2146945, 2147009, 2147073, 2147137, 2147201, 2147265, 2147329]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 23068672, 23068672]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2122915, 2123011, 2123107, 2104708, 2123203, 2123299, 2123395, 2100133, 2104836, 2100290, 2100293, 2104962, 2104964, 2098052, 2123491, 2123587]),
        new Uint32Array([23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456]),
        new Uint32Array([6291456, 2171169, 6291456, 2171201, 6291456, 2171233, 6291456, 2171265, 6291456, 2171297, 6291456, 2171329, 6291456, 6291456, 2171361, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([0, 0, 2148994, 2149058, 2149122, 0, 6291456, 2149186, 2186945, 2173537, 2148993, 2149121, 2149058, 10531458, 10496066, 0]),
        new Uint32Array([2195009, 2195041, 2195073, 2195105, 2195137, 2195169, 2195201, 2195233, 2195265, 2195297, 2195329, 2195361, 2195393, 2195425, 2195457, 2195489]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 0, 0, 6291456, 6291456]),
        new Uint32Array([2182849, 6291456, 2182881, 6291456, 2182913, 6291456, 2182945, 6291456, 2182977, 6291456, 2183009, 6291456, 2183041, 6291456, 2183073, 6291456]),
        new Uint32Array([2211553, 2210081, 2211585, 2211617, 2211649, 2211681, 2211713, 2211745, 2211777, 2211809, 2209569, 2211841, 2211873, 2211905, 2211937, 2211969]),
        new Uint32Array([2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2166594, 2127298, 2166658, 2142978, 2141827, 2166722]),
        new Uint32Array([2173985, 2173761, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2233057, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 2185761, 2185793, 2185825, 2185857, 2185889, 2185921, 0, 0]),
        new Uint32Array([6291456, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889, 2173921]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 6291456]),
        new Uint32Array([0, 0, 0, 2220961, 2220961, 2220961, 2220961, 2144193, 2144193, 2159201, 2159201, 2159265, 2159265, 2144194, 2220993, 2220993]),
        new Uint32Array([2192641, 2235393, 2235425, 2152257, 2116609, 2235457, 2235489, 2200065, 2235521, 2235553, 2235585, 2212449, 2235617, 2235649, 2235681, 2235713]),
        new Uint32Array([2194049, 2194081, 2194113, 2194145, 2194177, 2194209, 2194241, 2194273, 2194305, 2194337, 2194369, 2194401, 2194433, 2194465, 2194497, 2194529]),
        new Uint32Array([2196673, 2208641, 2208673, 2208705, 2208737, 2208769, 2208801, 2208833, 2208865, 2208897, 2208929, 2208961, 2208993, 2209025, 2209057, 2209089]),
        new Uint32Array([2191681, 2191713, 2191745, 2191777, 2153281, 2191809, 2191841, 2191873, 2191905, 2191937, 2191969, 2192001, 2192033, 2192065, 2192097, 2192129]),
        new Uint32Array([2230946, 2231010, 2231074, 2231138, 2231202, 2231266, 2231330, 2231394, 2231458, 2231522, 2231586, 2231650, 2231714, 2231778, 2231842, 2231906]),
        new Uint32Array([14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2185953, 2185985, 2186017, 2186049, 2186081, 2186113, 2186145, 2186177]),
        new Uint32Array([2139811, 2139907, 2097284, 2105860, 2105988, 2106116, 2106244, 2097444, 2097604, 2097155, 10485778, 10486344, 2106372, 6291456, 0, 0]),
        new Uint32Array([2110051, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2172385, 6291456, 2172417, 6291456, 2172449, 6291456, 2172481, 6291456, 2172513, 6291456, 2172545, 6291456, 2172577, 6291456, 2172609, 6291456]),
        new Uint32Array([0, 0, 23068672, 23068672, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2249345, 2249377, 2249409, 2249441, 2249473, 2249505, 2249537, 2249570, 2210209, 2249633, 2249665, 2249697, 2249729, 2249761, 2249793, 2216769]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2187169, 2187201, 2187233, 2187265, 2187297, 2187329, 2187361, 2187393, 2187425, 2187457, 2187489, 2187521, 2187553, 2187585, 2187617, 2187649]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([0, 0, 0, 6291456, 6291456, 0, 0, 0, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456]),
        new Uint32Array([2182337, 6291456, 2182369, 6291456, 2182401, 6291456, 2182433, 6291456, 2182465, 6291456, 2182497, 6291456, 2182529, 6291456, 2182561, 6291456]),
        new Uint32Array([2138179, 2138275, 2138371, 2138467, 2134243, 2134435, 2138563, 2138659, 2138755, 2138851, 2138947, 2139043, 2138947, 2138755, 2139139, 2139235]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([0, 0, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2250498, 2250562, 2250625, 2250657, 2208321, 2250689, 2250721, 2250753, 2250785, 2250817, 2250849, 2218945, 2250881, 2250913, 2250945, 0]),
        new Uint32Array([2170369, 2105569, 2098305, 2108481, 2173249, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456]),
        new Uint32Array([2100897, 2111905, 2105473, 2105569, 2105601, 0, 2108193, 0, 0, 0, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481]),
        new Uint32Array([2100897, 2100897, 2105569, 2105569, 6291456, 2112289, 2149826, 6291456, 6291456, 2112481, 2112577, 2098177, 2098177, 2098177, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 2169953, 2169985, 6291456, 2170017, 6291456, 2170049, 2170081, 6291456, 2170113, 2170145, 2170177, 6291456, 6291456, 2170209, 2170241]),
        new Uint32Array([6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2220641, 2220641, 2220673, 2220673, 2220673, 2220673, 2220705, 2220705, 2220705, 2220705, 2220737, 2220737, 2220737, 2220737, 2220769, 2220769]),
        new Uint32Array([2127650, 2127746, 2127842, 2127938, 2128034, 2128130, 2128226, 2128322, 2128418, 2127523, 2127619, 2127715, 2127811, 2127907, 2128003, 2128099]),
        new Uint32Array([2143969, 2173793, 2173825, 2153473, 2173857, 2173889, 2173921, 2173953, 2173985, 2173761, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177]),
        new Uint32Array([0, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([2204705, 2204737, 2204769, 2204801, 2204833, 2204865, 2204897, 2204929, 2204961, 2204993, 2205025, 2205057, 2205089, 2205121, 2205153, 2205185]),
        new Uint32Array([2176385, 6291456, 2176417, 6291456, 2176449, 6291456, 2176481, 6291456, 2176513, 6291456, 2176545, 6291456, 2176577, 6291456, 2176609, 6291456]),
        new Uint32Array([2195521, 2195553, 2195585, 2195617, 2195649, 2195681, 2117857, 2195713, 2195745, 2195777, 2195809, 2195841, 2195873, 2195905, 2195937, 2195969]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456]),
        new Uint32Array([2173921, 2173953, 2173985, 2174017, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2233089, 2173697, 2173761, 2173793, 2174113]),
        new Uint32Array([2131586, 2132450, 2135970, 2135778, 2161602, 2136162, 2163650, 2161794, 2135586, 2163714, 2137186, 2131810, 2160290, 2135170, 2097506, 2159554]),
        new Uint32Array([2134145, 2097153, 2134241, 2105953, 2132705, 2130977, 2160065, 2131297, 2162049, 2133089, 2160577, 2133857, 0, 0, 0, 0]),
        new Uint32Array([2116513, 2116609, 2116705, 2116801, 2116897, 2116993, 2117089, 2117185, 2117281, 2117377, 2117473, 2117569, 2117665, 2117761, 2117857, 2117953]),
        new Uint32Array([2100737, 2098337, 2101441, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 2100802, 2101154, 2101282, 2101410, 2101538, 2101666, 2101794]),
        new Uint32Array([2100289, 2098657, 2098049, 2200737, 2123489, 2123681, 2200769, 2098625, 2100321, 2098145, 2100449, 2098017, 2098753, 2098977, 2150241, 2150305]),
        new Uint32Array([6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 2109955, 6291456, 6291456, 0, 0, 0, 0]),
        new Uint32Array([18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 0, 6291456, 0, 0]),
        new Uint32Array([2130979, 2131075, 2131075, 2131171, 2131267, 2131363, 2131459, 2131555, 2131651, 2131651, 2131747, 2131843, 2131939, 2132035, 2132131, 2132227]),
        new Uint32Array([0, 2177793, 6291456, 2177825, 6291456, 2177857, 6291456, 2177889, 6291456, 2177921, 6291456, 2177953, 6291456, 2177985, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]),
        new Uint32Array([6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2113345, 0, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289]),
        new Uint32Array([2136643, 2136739, 2136835, 2136931, 2137027, 2137123, 2137219, 2137315, 2137411, 2137507, 2137603, 2137699, 2137795, 2137891, 2137987, 2138083]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0]),
        new Uint32Array([2174433, 6291456, 2174465, 6291456, 2174497, 6291456, 2174529, 6291456, 2174561, 6291456, 2174593, 6291456, 2174625, 6291456, 2174657, 6291456]),
        new Uint32Array([0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2105473, 2105569, 2105601, 2112289, 2108193, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441]),
        new Uint32Array([10496547, 10496643, 2105505, 2149698, 6291456, 10496739, 10496835, 2170273, 6291456, 2149762, 2105825, 2111713, 2111713, 2111713, 2111713, 2168673]),
        new Uint32Array([6291456, 2143490, 2143490, 2143490, 2171649, 6291456, 2171681, 2171713, 2171745, 6291456, 2171777, 6291456, 2171809, 6291456, 2171841, 6291456]),
        new Uint32Array([2159106, 2159106, 2159170, 2159170, 2159234, 2159234, 2159298, 2159298, 2159298, 2159362, 2159362, 2159362, 2106401, 2106401, 2106401, 2106401]),
        new Uint32Array([2105601, 2112289, 2108193, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137]),
        new Uint32Array([2108417, 2181217, 2181249, 2181281, 2170433, 2170401, 2181313, 2181345, 2181377, 2181409, 2181441, 2181473, 2181505, 2181537, 2170529, 2181569]),
        new Uint32Array([2218433, 2245761, 2245793, 2245825, 2245857, 2245890, 2245953, 2245986, 2209665, 2246050, 2246113, 2246146, 2246210, 2246274, 2246337, 2246369]),
        new Uint32Array([2230754, 2230818, 2230882, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([6291456, 0, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2184129, 6291456, 2184161, 6291456, 2184193, 6291456, 6291456, 6291456, 6291456, 6291456, 2146818, 2183361, 6291456, 6291456, 2142978, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2135170, 2097506, 2130691, 2130787, 2130883, 2163970, 2164034, 2164098, 2164162, 2164226, 2164290, 2164354, 2164418, 2164482, 2164546, 2133122]),
        new Uint32Array([2108515, 2108611, 2100740, 2108707, 2108803, 2108899, 2108995, 2109091, 2109187, 2109283, 2109379, 2109475, 2109571, 2109667, 2109763, 2100738]),
        new Uint32Array([2102788, 2102916, 2103044, 2120515, 2103172, 2120611, 2120707, 2098373, 2103300, 2120803, 2120899, 2120995, 2103428, 2103556, 2121091, 2121187]),
        new Uint32Array([2158082, 2158146, 0, 2158210, 2158274, 0, 2158338, 2158402, 2158466, 2129922, 2158530, 2158594, 2158658, 2158722, 2158786, 2158850]),
        new Uint32Array([10499619, 10499715, 10499811, 10499907, 10500003, 10500099, 10500195, 10500291, 10500387, 10500483, 10500579, 10500675, 10500771, 10500867, 10500963, 10501059]),
        new Uint32Array([2239585, 2239618, 2239681, 2239713, 0, 2191969, 2239745, 2239777, 2192033, 2239809, 2239841, 2239874, 2239937, 2239970, 2240033, 2240065]),
        new Uint32Array([2252705, 2252738, 2252801, 2252833, 2252865, 2252897, 2252930, 2252994, 2253057, 2253089, 2253121, 2253154, 2253217, 2253250, 2219361, 2219361]),
        new Uint32Array([2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 10538050, 10538114, 10538178, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([2226402, 2226466, 2226530, 2226594, 2226658, 2226722, 2226786, 2226850, 2226914, 2226978, 2227042, 2227106, 2227170, 2227234, 2227298, 2227362]),
        new Uint32Array([23068672, 6291456, 6291456, 6291456, 6291456, 2144066, 2144130, 2144194, 2144258, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 6291456, 23068672, 23068672]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2124674, 2124770, 2123875, 2123971, 2124067, 2124163, 2124259, 2124355, 2124451, 2124547, 2124643, 2124739, 2124835, 2124931, 2125027, 2125123]),
        new Uint32Array([2168065, 6291456, 2168097, 6291456, 2168129, 6291456, 2168161, 6291456, 2168193, 6291456, 2168225, 6291456, 2168257, 6291456, 2168289, 6291456]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0]),
        new Uint32Array([23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 2100610, 2100611, 6291456, 2107842, 2107843, 6291456, 6291456, 6291456, 6291456, 10537922, 6291456, 10537986, 6291456]),
        new Uint32Array([2174849, 2174881, 2174913, 2174945, 2174977, 2175009, 2175041, 2175073, 2175105, 2175137, 2175169, 2175201, 2175233, 2175265, 2175297, 2175329]),
        new Uint32Array([2154562, 2154626, 2154690, 2154754, 2141858, 2154818, 2154882, 2127298, 2154946, 2127298, 2155010, 2155074, 2155138, 2155202, 2155266, 2155202]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 0]),
        new Uint32Array([2200641, 2150786, 2150850, 2150914, 2150978, 2151042, 2106562, 2151106, 2150562, 2151170, 2151234, 2151298, 2151362, 2151426, 2151490, 2151554]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456]),
        new Uint32Array([2220289, 2220289, 2220321, 2220321, 2220321, 2220321, 2220353, 2220353, 2220353, 2220353, 2220385, 2220385, 2220385, 2220385, 2220417, 2220417]),
        new Uint32Array([2155330, 2155394, 0, 2155458, 2155522, 2155586, 2105732, 0, 2155650, 2155714, 2155778, 2125314, 2155842, 2155906, 2126274, 2155970]),
        new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 23068672, 23068672, 6291456, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2097729, 2106017, 2106017, 2106017, 2106017, 2131297, 2131297, 2131297, 2131297, 2106081, 2106081, 2162049, 2162049, 2105953, 2105953, 2162337]),
        new Uint32Array([2097185, 2097697, 2097697, 2097697, 2097697, 2135777, 2135777, 2135777, 2135777, 2097377, 2097377, 2097377, 2097377, 2097601, 2097601, 2097217]),
        new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23068672]),
        new Uint32Array([2139331, 2139427, 2139523, 2139043, 2133571, 2132611, 2139619, 2139715, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2174113, 2174145, 2100897, 2098177, 2108289, 2100865, 2173601, 2173633, 2173985, 2174113, 2174145, 6291456, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456]),
        new Uint32Array([23068672, 23068672, 18923778, 23068672, 23068672, 23068672, 23068672, 18923842, 23068672, 23068672, 23068672, 23068672, 18923906, 23068672, 23068672, 23068672]),
        new Uint32Array([2134145, 2097153, 2134241, 0, 2132705, 2130977, 2160065, 2131297, 0, 2133089, 0, 2133857, 0, 0, 0, 0]),
        new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2177537, 6291456, 2177569, 6291456, 2177601, 6291456, 2177633, 6291456, 2177665, 6291456, 2177697, 6291456, 2177729, 6291456, 2177761, 6291456]),
        new Uint32Array([2212481, 2212513, 2212545, 2212577, 2197121, 2212609, 2212641, 2212673, 2212705, 2212737, 2212769, 2212801, 2212833, 2212865, 2212897, 2212929]),
        new Uint32Array([6291456, 6291456, 23068672, 23068672, 23068672, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        new Uint32Array([2098241, 2108353, 2170209, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 6291456, 2108193, 2172417, 2112481, 2098177]),
        new Uint32Array([6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456])
      ];
      var blockIdxes = new Uint16Array([616, 616, 565, 147, 161, 411, 330, 2, 131, 131, 328, 454, 241, 408, 86, 86, 696, 113, 285, 350, 325, 301, 473, 214, 639, 232, 447, 64, 369, 598, 124, 672, 567, 223, 621, 154, 107, 86, 86, 86, 86, 86, 86, 505, 86, 68, 634, 86, 218, 218, 218, 218, 486, 218, 218, 513, 188, 608, 216, 86, 217, 463, 668, 85, 700, 360, 184, 86, 86, 86, 647, 402, 153, 10, 346, 718, 662, 260, 145, 298, 117, 1, 443, 342, 138, 54, 563, 86, 240, 572, 218, 70, 387, 86, 118, 460, 641, 602, 86, 86, 306, 218, 86, 692, 86, 86, 86, 86, 86, 162, 707, 86, 458, 26, 86, 218, 638, 86, 86, 86, 86, 86, 65, 449, 86, 86, 306, 183, 86, 58, 391, 667, 86, 157, 131, 131, 131, 131, 86, 433, 131, 406, 31, 218, 247, 86, 86, 693, 218, 581, 351, 86, 438, 295, 69, 462, 45, 126, 173, 650, 14, 295, 69, 97, 168, 187, 641, 78, 523, 390, 69, 108, 287, 664, 173, 219, 83, 295, 69, 108, 431, 426, 173, 694, 412, 115, 628, 52, 257, 398, 641, 118, 501, 121, 69, 579, 151, 423, 173, 620, 464, 121, 69, 382, 151, 476, 173, 27, 53, 121, 86, 594, 578, 226, 173, 86, 632, 130, 86, 96, 228, 268, 641, 622, 563, 86, 86, 21, 148, 650, 131, 131, 321, 43, 144, 343, 381, 531, 131, 131, 178, 20, 86, 399, 156, 375, 164, 541, 30, 60, 715, 198, 92, 118, 131, 131, 86, 86, 306, 407, 86, 280, 457, 196, 488, 358, 131, 131, 244, 86, 86, 143, 86, 86, 86, 86, 86, 667, 563, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 336, 363, 86, 86, 336, 86, 86, 380, 678, 67, 86, 86, 86, 678, 86, 86, 86, 512, 86, 307, 86, 708, 86, 86, 86, 86, 86, 528, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 563, 307, 86, 86, 86, 86, 86, 104, 450, 337, 86, 720, 86, 32, 450, 397, 86, 86, 86, 587, 218, 558, 708, 708, 293, 708, 86, 86, 86, 86, 86, 694, 205, 86, 8, 86, 86, 86, 86, 549, 86, 667, 697, 697, 679, 86, 458, 460, 86, 86, 650, 86, 708, 543, 86, 86, 86, 245, 86, 86, 86, 140, 218, 127, 708, 708, 458, 197, 131, 131, 131, 131, 500, 86, 86, 483, 251, 86, 306, 510, 515, 86, 722, 86, 86, 86, 65, 201, 86, 86, 483, 580, 470, 86, 86, 86, 368, 131, 131, 131, 694, 114, 110, 555, 86, 86, 123, 721, 163, 142, 713, 418, 86, 317, 675, 209, 218, 218, 218, 371, 545, 592, 629, 490, 603, 199, 46, 320, 525, 680, 310, 279, 388, 111, 42, 252, 593, 607, 235, 617, 410, 377, 50, 548, 135, 356, 17, 520, 189, 116, 392, 600, 349, 332, 482, 699, 690, 535, 119, 106, 451, 71, 152, 667, 131, 218, 218, 265, 671, 637, 492, 504, 533, 683, 269, 269, 658, 86, 86, 86, 86, 86, 86, 86, 86, 86, 491, 619, 86, 86, 6, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 229, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 667, 86, 86, 171, 131, 118, 131, 656, 206, 234, 571, 89, 334, 670, 246, 311, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 534, 86, 86, 86, 86, 86, 86, 82, 86, 86, 86, 86, 86, 430, 86, 86, 86, 86, 86, 86, 86, 86, 86, 599, 86, 324, 86, 470, 69, 640, 264, 131, 626, 101, 174, 86, 86, 667, 233, 105, 73, 374, 394, 221, 204, 84, 28, 326, 86, 86, 471, 86, 86, 86, 109, 573, 86, 171, 200, 200, 200, 200, 218, 218, 86, 86, 86, 86, 460, 131, 131, 131, 86, 506, 86, 86, 86, 86, 86, 220, 404, 34, 614, 47, 442, 305, 25, 612, 338, 601, 648, 7, 344, 255, 131, 131, 51, 86, 312, 507, 563, 86, 86, 86, 86, 588, 86, 86, 86, 86, 86, 530, 511, 86, 458, 3, 435, 384, 556, 522, 230, 527, 86, 118, 86, 86, 717, 86, 137, 273, 79, 181, 484, 23, 93, 112, 655, 249, 417, 703, 370, 87, 98, 313, 684, 585, 155, 465, 596, 481, 695, 18, 416, 428, 61, 701, 706, 282, 643, 495, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 549, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 549, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 307, 86, 86, 86, 171, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 650, 131, 422, 542, 420, 263, 24, 172, 86, 86, 86, 86, 86, 566, 86, 86, 132, 540, 395, 353, 494, 519, 19, 485, 284, 472, 131, 131, 131, 16, 714, 86, 211, 708, 86, 86, 86, 694, 698, 86, 86, 483, 704, 708, 218, 272, 86, 86, 120, 86, 159, 478, 86, 307, 247, 86, 86, 663, 597, 459, 627, 667, 86, 86, 277, 455, 39, 302, 86, 250, 86, 86, 86, 271, 99, 452, 306, 281, 329, 400, 200, 86, 86, 362, 549, 352, 646, 461, 323, 586, 86, 86, 4, 708, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 717, 86, 518, 86, 86, 650, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 125, 554, 480, 300, 613, 72, 333, 288, 561, 544, 604, 48, 719, 91, 169, 176, 590, 224, 76, 191, 29, 559, 560, 231, 537, 166, 477, 538, 256, 437, 131, 131, 469, 167, 40, 0, 685, 266, 441, 705, 239, 642, 475, 568, 640, 610, 299, 673, 517, 318, 385, 22, 202, 180, 179, 359, 424, 215, 90, 66, 521, 653, 467, 682, 453, 409, 479, 88, 131, 661, 35, 303, 15, 262, 666, 630, 712, 131, 131, 618, 659, 175, 218, 195, 347, 193, 227, 261, 150, 165, 709, 546, 294, 569, 710, 270, 413, 376, 524, 55, 242, 38, 419, 529, 170, 657, 3, 304, 122, 379, 278, 131, 651, 86, 67, 576, 458, 458, 131, 131, 86, 86, 86, 86, 86, 86, 86, 118, 309, 86, 86, 547, 86, 86, 86, 86, 667, 650, 664, 131, 131, 86, 86, 56, 131, 131, 131, 131, 131, 131, 131, 131, 86, 307, 86, 86, 86, 664, 238, 650, 86, 86, 717, 86, 118, 86, 86, 315, 86, 59, 86, 86, 574, 549, 131, 131, 340, 57, 436, 86, 86, 86, 86, 86, 86, 458, 708, 499, 691, 62, 86, 650, 86, 86, 694, 86, 86, 86, 319, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 171, 86, 549, 694, 131, 131, 131, 131, 131, 131, 131, 131, 131, 77, 86, 86, 139, 86, 502, 86, 86, 86, 667, 595, 131, 131, 131, 86, 12, 86, 13, 86, 609, 131, 131, 131, 131, 86, 86, 86, 625, 86, 669, 86, 86, 182, 129, 86, 5, 694, 104, 86, 86, 86, 86, 131, 131, 86, 86, 386, 171, 86, 86, 86, 345, 86, 324, 86, 589, 86, 213, 36, 131, 131, 131, 131, 131, 86, 86, 86, 86, 104, 131, 131, 131, 141, 290, 80, 677, 86, 86, 86, 267, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 667, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 515, 86, 86, 33, 136, 669, 86, 711, 515, 86, 86, 550, 640, 86, 104, 708, 515, 86, 159, 372, 717, 86, 86, 444, 515, 86, 86, 663, 37, 86, 563, 460, 86, 390, 624, 702, 131, 131, 131, 131, 389, 59, 708, 86, 86, 341, 208, 708, 635, 295, 69, 108, 431, 508, 100, 190, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 649, 516, 660, 131, 131, 86, 86, 86, 218, 631, 708, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 341, 575, 238, 514, 131, 131, 86, 86, 86, 218, 291, 708, 307, 131, 86, 86, 306, 367, 708, 131, 131, 131, 86, 378, 697, 86, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 615, 253, 86, 86, 86, 292, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 104, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 69, 86, 341, 553, 549, 86, 307, 86, 86, 645, 275, 455, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 708, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 667, 460, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 717, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 667, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 171, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 104, 86, 667, 459, 131, 131, 131, 131, 131, 131, 86, 458, 225, 86, 86, 86, 516, 549, 11, 390, 405, 86, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 460, 44, 218, 197, 711, 515, 131, 131, 131, 131, 664, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 307, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 308, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 640, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 118, 307, 104, 286, 591, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 549, 86, 86, 681, 86, 86, 75, 185, 314, 582, 86, 358, 496, 474, 86, 104, 131, 86, 86, 86, 86, 146, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 171, 86, 640, 131, 131, 131, 131, 131, 131, 131, 131, 246, 503, 689, 339, 674, 81, 258, 415, 439, 128, 562, 366, 414, 246, 503, 689, 583, 222, 557, 316, 636, 665, 186, 355, 95, 670, 246, 503, 689, 339, 674, 557, 258, 415, 439, 186, 355, 95, 670, 246, 503, 689, 446, 644, 536, 652, 331, 532, 335, 440, 274, 421, 297, 570, 74, 425, 364, 425, 606, 552, 403, 509, 134, 365, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 218, 218, 218, 498, 218, 218, 577, 627, 551, 497, 572, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 553, 354, 236, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 296, 455, 131, 131, 456, 243, 103, 86, 41, 459, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 9, 276, 158, 716, 393, 564, 383, 489, 401, 654, 210, 654, 131, 131, 131, 640, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 650, 86, 86, 86, 86, 86, 86, 717, 667, 563, 563, 563, 86, 549, 102, 686, 133, 246, 605, 86, 448, 86, 86, 207, 307, 131, 131, 131, 641, 86, 177, 611, 445, 373, 194, 584, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 308, 307, 171, 86, 86, 86, 86, 86, 86, 86, 717, 86, 86, 86, 86, 86, 460, 131, 131, 650, 86, 86, 86, 694, 708, 86, 86, 694, 86, 458, 131, 131, 131, 131, 131, 131, 667, 694, 289, 650, 667, 131, 131, 86, 640, 131, 131, 664, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 171, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 460, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 458, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 640, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 466, 203, 149, 429, 94, 432, 160, 687, 539, 63, 237, 283, 192, 248, 348, 259, 427, 526, 396, 676, 254, 468, 487, 212, 327, 623, 49, 633, 322, 493, 434, 688, 357, 361, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131]);
      var mappingStr = "\u0635\u0644\u0649 \u0627\u0644\u0644\u0647 \u0639\u0644\u064A\u0647 \u0648\u0633\u0644\u0645\u062C\u0644 \u062C\u0644\u0627\u0644\u0647\u30AD\u30ED\u30E1\u30FC\u30C8\u30EBrad\u2215s2\u30A8\u30B9\u30AF\u30FC\u30C9\u30AD\u30ED\u30B0\u30E9\u30E0\u30AD\u30ED\u30EF\u30C3\u30C8\u30B0\u30E9\u30E0\u30C8\u30F3\u30AF\u30EB\u30BC\u30A4\u30ED\u30B5\u30F3\u30C1\u30FC\u30E0\u30D1\u30FC\u30BB\u30F3\u30C8\u30D4\u30A2\u30B9\u30C8\u30EB\u30D5\u30A1\u30E9\u30C3\u30C9\u30D6\u30C3\u30B7\u30A7\u30EB\u30D8\u30AF\u30BF\u30FC\u30EB\u30DE\u30F3\u30B7\u30E7\u30F3\u30DF\u30EA\u30D0\u30FC\u30EB\u30EC\u30F3\u30C8\u30B2\u30F3\u2032\u2032\u2032\u20321\u204410viii(10)(11)(12)(13)(14)(15)(16)(17)(18)(19)(20)\u222B\u222B\u222B\u222B(\uC624\uC804)(\uC624\uD6C4)\u30A2\u30D1\u30FC\u30C8\u30A2\u30EB\u30D5\u30A1\u30A2\u30F3\u30DA\u30A2\u30A4\u30CB\u30F3\u30B0\u30A8\u30FC\u30AB\u30FC\u30AB\u30E9\u30C3\u30C8\u30AB\u30ED\u30EA\u30FC\u30AD\u30E5\u30EA\u30FC\u30AE\u30EB\u30C0\u30FC\u30AF\u30ED\u30FC\u30CD\u30B5\u30A4\u30AF\u30EB\u30B7\u30EA\u30F3\u30B0\u30D0\u30FC\u30EC\u30EB\u30D5\u30A3\u30FC\u30C8\u30DD\u30A4\u30F3\u30C8\u30DE\u30A4\u30AF\u30ED\u30DF\u30AF\u30ED\u30F3\u30E1\u30AC\u30C8\u30F3\u30EA\u30C3\u30C8\u30EB\u30EB\u30FC\u30D6\u30EB\u682A\u5F0F\u4F1A\u793Ekcalm\u2215s2c\u2215kg\u0627\u0643\u0628\u0631\u0645\u062D\u0645\u062F\u0635\u0644\u0639\u0645\u0631\u0633\u0648\u0644\u0631\u06CC\u0627\u06441\u204441\u204423\u20444 \u0308\u0301\u0FB2\u0F71\u0F80\u0FB3\u0F71\u0F80 \u0308\u0342 \u0313\u0300 \u0313\u0301 \u0313\u0342 \u0314\u0300 \u0314\u0301 \u0314\u0342 \u0308\u0300\u2035\u2035\u2035a/ca/sc/oc/utelfax1\u204471\u204491\u204432\u204431\u204452\u204453\u204454\u204451\u204465\u204461\u204483\u204485\u204487\u20448xii0\u20443\u222E\u222E\u222E(1)(2)(3)(4)(5)(6)(7)(8)(9)(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)(n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)::====(\u1100)(\u1102)(\u1103)(\u1105)(\u1106)(\u1107)(\u1109)(\u110B)(\u110C)(\u110E)(\u110F)(\u1110)(\u1111)(\u1112)(\uAC00)(\uB098)(\uB2E4)(\uB77C)(\uB9C8)(\uBC14)(\uC0AC)(\uC544)(\uC790)(\uCC28)(\uCE74)(\uD0C0)(\uD30C)(\uD558)(\uC8FC)(\u4E00)(\u4E8C)(\u4E09)(\u56DB)(\u4E94)(\u516D)(\u4E03)(\u516B)(\u4E5D)(\u5341)(\u6708)(\u706B)(\u6C34)(\u6728)(\u91D1)(\u571F)(\u65E5)(\u682A)(\u6709)(\u793E)(\u540D)(\u7279)(\u8CA1)(\u795D)(\u52B4)(\u4EE3)(\u547C)(\u5B66)(\u76E3)(\u4F01)(\u8CC7)(\u5354)(\u796D)(\u4F11)(\u81EA)(\u81F3)pte10\u670811\u670812\u6708ergltd\u30A2\u30FC\u30EB\u30A4\u30F3\u30C1\u30A6\u30A9\u30F3\u30AA\u30F3\u30B9\u30AA\u30FC\u30E0\u30AB\u30A4\u30EA\u30AC\u30ED\u30F3\u30AC\u30F3\u30DE\u30AE\u30CB\u30FC\u30B1\u30FC\u30B9\u30B3\u30EB\u30CA\u30B3\u30FC\u30DD\u30BB\u30F3\u30C1\u30C0\u30FC\u30B9\u30CE\u30C3\u30C8\u30CF\u30A4\u30C4\u30D1\u30FC\u30C4\u30D4\u30AF\u30EB\u30D5\u30E9\u30F3\u30DA\u30CB\u30D2\u30D8\u30EB\u30C4\u30DA\u30F3\u30B9\u30DA\u30FC\u30B8\u30D9\u30FC\u30BF\u30DC\u30EB\u30C8\u30DD\u30F3\u30C9\u30DB\u30FC\u30EB\u30DB\u30FC\u30F3\u30DE\u30A4\u30EB\u30DE\u30C3\u30CF\u30DE\u30EB\u30AF\u30E4\u30FC\u30C9\u30E4\u30FC\u30EB\u30E6\u30A2\u30F3\u30EB\u30D4\u30FC10\u70B911\u70B912\u70B913\u70B914\u70B915\u70B916\u70B917\u70B918\u70B919\u70B920\u70B921\u70B922\u70B923\u70B924\u70B9hpabardm2dm3khzmhzghzthzmm2cm2km2mm3cm3km3kpampagpalogmilmolppmv\u2215ma\u2215m10\u65E511\u65E512\u65E513\u65E514\u65E515\u65E516\u65E517\u65E518\u65E519\u65E520\u65E521\u65E522\u65E523\u65E524\u65E525\u65E526\u65E527\u65E528\u65E529\u65E530\u65E531\u65E5galffiffl\u05E9\u05BC\u05C1\u05E9\u05BC\u05C2 \u064C\u0651 \u064D\u0651 \u064E\u0651 \u064F\u0651 \u0650\u0651 \u0651\u0670\u0640\u064E\u0651\u0640\u064F\u0651\u0640\u0650\u0651\u062A\u062C\u0645\u062A\u062D\u062C\u062A\u062D\u0645\u062A\u062E\u0645\u062A\u0645\u062C\u062A\u0645\u062D\u062A\u0645\u062E\u062C\u0645\u062D\u062D\u0645\u064A\u062D\u0645\u0649\u0633\u062D\u062C\u0633\u062C\u062D\u0633\u062C\u0649\u0633\u0645\u062D\u0633\u0645\u062C\u0633\u0645\u0645\u0635\u062D\u062D\u0635\u0645\u0645\u0634\u062D\u0645\u0634\u062C\u064A\u0634\u0645\u062E\u0634\u0645\u0645\u0636\u062D\u0649\u0636\u062E\u0645\u0637\u0645\u062D\u0637\u0645\u0645\u0637\u0645\u064A\u0639\u062C\u0645\u0639\u0645\u0645\u0639\u0645\u0649\u063A\u0645\u0645\u063A\u0645\u064A\u063A\u0645\u0649\u0641\u062E\u0645\u0642\u0645\u062D\u0642\u0645\u0645\u0644\u062D\u0645\u0644\u062D\u064A\u0644\u062D\u0649\u0644\u062C\u062C\u0644\u062E\u0645\u0644\u0645\u062D\u0645\u062D\u062C\u0645\u062D\u064A\u0645\u062C\u062D\u0645\u062C\u0645\u0645\u062E\u0645\u0645\u062C\u062E\u0647\u0645\u062C\u0647\u0645\u0645\u0646\u062D\u0645\u0646\u062D\u0649\u0646\u062C\u0645\u0646\u062C\u0649\u0646\u0645\u064A\u0646\u0645\u0649\u064A\u0645\u0645\u0628\u062E\u064A\u062A\u062C\u064A\u062A\u062C\u0649\u062A\u062E\u064A\u062A\u062E\u0649\u062A\u0645\u064A\u062A\u0645\u0649\u062C\u0645\u064A\u062C\u062D\u0649\u062C\u0645\u0649\u0633\u062E\u0649\u0635\u062D\u064A\u0634\u062D\u064A\u0636\u062D\u064A\u0644\u062C\u064A\u0644\u0645\u064A\u064A\u062D\u064A\u064A\u062C\u064A\u064A\u0645\u064A\u0645\u0645\u064A\u0642\u0645\u064A\u0646\u062D\u064A\u0639\u0645\u064A\u0643\u0645\u064A\u0646\u062C\u062D\u0645\u062E\u064A\u0644\u062C\u0645\u0643\u0645\u0645\u062C\u062D\u064A\u062D\u062C\u064A\u0645\u062C\u064A\u0641\u0645\u064A\u0628\u062D\u064A\u0633\u062E\u064A\u0646\u062C\u064A\u0635\u0644\u06D2\u0642\u0644\u06D2\u{1D158}\u{1D165}\u{1D16E}\u{1D158}\u{1D165}\u{1D16F}\u{1D158}\u{1D165}\u{1D170}\u{1D158}\u{1D165}\u{1D171}\u{1D158}\u{1D165}\u{1D172}\u{1D1B9}\u{1D165}\u{1D16E}\u{1D1BA}\u{1D165}\u{1D16E}\u{1D1B9}\u{1D165}\u{1D16F}\u{1D1BA}\u{1D165}\u{1D16F}\u3014s\u3015ppv\u3014\u672C\u3015\u3014\u4E09\u3015\u3014\u4E8C\u3015\u3014\u5B89\u3015\u3014\u70B9\u3015\u3014\u6253\u3015\u3014\u76D7\u3015\u3014\u52DD\u3015\u3014\u6557\u3015 \u0304 \u0301 \u0327ssi\u0307ijl\xB7\u02BCnd\u017Eljnjdz \u0306 \u0307 \u030A \u0328 \u0303 \u030B \u03B9\u0565\u0582\u0627\u0674\u0648\u0674\u06C7\u0674\u064A\u0674\u0915\u093C\u0916\u093C\u0917\u093C\u091C\u093C\u0921\u093C\u0922\u093C\u092B\u093C\u092F\u093C\u09A1\u09BC\u09A2\u09BC\u09AF\u09BC\u0A32\u0A3C\u0A38\u0A3C\u0A16\u0A3C\u0A17\u0A3C\u0A1C\u0A3C\u0A2B\u0A3C\u0B21\u0B3C\u0B22\u0B3C\u0E4D\u0E32\u0ECD\u0EB2\u0EAB\u0E99\u0EAB\u0EA1\u0F42\u0FB7\u0F4C\u0FB7\u0F51\u0FB7\u0F56\u0FB7\u0F5B\u0FB7\u0F40\u0FB5\u0F71\u0F72\u0F71\u0F74\u0FB2\u0F80\u0FB3\u0F80\u0F92\u0FB7\u0F9C\u0FB7\u0FA1\u0FB7\u0FA6\u0FB7\u0FAB\u0FB7\u0F90\u0FB5a\u02BE\u1F00\u03B9\u1F01\u03B9\u1F02\u03B9\u1F03\u03B9\u1F04\u03B9\u1F05\u03B9\u1F06\u03B9\u1F07\u03B9\u1F20\u03B9\u1F21\u03B9\u1F22\u03B9\u1F23\u03B9\u1F24\u03B9\u1F25\u03B9\u1F26\u03B9\u1F27\u03B9\u1F60\u03B9\u1F61\u03B9\u1F62\u03B9\u1F63\u03B9\u1F64\u03B9\u1F65\u03B9\u1F66\u03B9\u1F67\u03B9\u1F70\u03B9\u03B1\u03B9\u03AC\u03B9\u1FB6\u03B9 \u0342\u1F74\u03B9\u03B7\u03B9\u03AE\u03B9\u1FC6\u03B9\u1F7C\u03B9\u03C9\u03B9\u03CE\u03B9\u1FF6\u03B9 \u0333!! \u0305???!!?rs\xB0c\xB0fnosmtmivix\u2ADD\u0338 \u3099 \u309A\u3088\u308A\u30B3\u30C8333435\uCC38\uACE0\uC8FC\uC758363738394042444546474849503\u67084\u67085\u67086\u67087\u67088\u67089\u6708hgev\u30AE\u30AC\u30C7\u30B7\u30C9\u30EB\u30CA\u30CE\u30D4\u30B3\u30D3\u30EB\u30DA\u30BD\u30DB\u30F3\u30EA\u30E9\u30EC\u30E0daauovpciu\u5E73\u6210\u662D\u548C\u5927\u6B63\u660E\u6CBBna\u03BCakakbmbgbpfnf\u03BCf\u03BCgmg\u03BClmldlklfmnm\u03BCmpsns\u03BCsmsnv\u03BCvkvpwnw\u03BCwmwkwk\u03C9m\u03C9bqcccddbgyhainkkktlnlxphprsrsvwbst\u0574\u0576\u0574\u0565\u0574\u056B\u057E\u0576\u0574\u056D\u05D9\u05B4\u05F2\u05B7\u05E9\u05C1\u05E9\u05C2\u05D0\u05B7\u05D0\u05B8\u05D0\u05BC\u05D1\u05BC\u05D2\u05BC\u05D3\u05BC\u05D4\u05BC\u05D5\u05BC\u05D6\u05BC\u05D8\u05BC\u05D9\u05BC\u05DA\u05BC\u05DB\u05BC\u05DC\u05BC\u05DE\u05BC\u05E0\u05BC\u05E1\u05BC\u05E3\u05BC\u05E4\u05BC\u05E6\u05BC\u05E7\u05BC\u05E8\u05BC\u05EA\u05BC\u05D5\u05B9\u05D1\u05BF\u05DB\u05BF\u05E4\u05BF\u05D0\u05DC\u0626\u0627\u0626\u06D5\u0626\u0648\u0626\u06C7\u0626\u06C6\u0626\u06C8\u0626\u06D0\u0626\u0649\u0626\u062C\u0626\u062D\u0626\u0645\u0626\u064A\u0628\u062C\u0628\u0645\u0628\u0649\u0628\u064A\u062A\u0649\u062A\u064A\u062B\u062C\u062B\u0645\u062B\u0649\u062B\u064A\u062E\u062D\u0636\u062C\u0636\u0645\u0637\u062D\u0638\u0645\u063A\u062C\u0641\u062C\u0641\u062D\u0641\u0649\u0641\u064A\u0642\u062D\u0642\u0649\u0642\u064A\u0643\u0627\u0643\u062C\u0643\u062D\u0643\u062E\u0643\u0644\u0643\u0649\u0643\u064A\u0646\u062E\u0646\u0649\u0646\u064A\u0647\u062C\u0647\u0649\u0647\u064A\u064A\u0649\u0630\u0670\u0631\u0670\u0649\u0670\u0626\u0631\u0626\u0632\u0626\u0646\u0628\u0632\u0628\u0646\u062A\u0631\u062A\u0632\u062A\u0646\u062B\u0631\u062B\u0632\u062B\u0646\u0645\u0627\u0646\u0631\u0646\u0632\u0646\u0646\u064A\u0631\u064A\u0632\u0626\u062E\u0626\u0647\u0628\u0647\u062A\u0647\u0635\u062E\u0646\u0647\u0647\u0670\u062B\u0647\u0633\u0647\u0634\u0647\u0637\u0649\u0637\u064A\u0639\u0649\u0639\u064A\u063A\u0649\u063A\u064A\u0633\u0649\u0633\u064A\u0634\u0649\u0634\u064A\u0635\u0649\u0635\u064A\u0636\u0649\u0636\u064A\u0634\u062E\u0634\u0631\u0633\u0631\u0635\u0631\u0636\u0631\u0627\u064B \u064B\u0640\u064B\u0640\u0651 \u0652\u0640\u0652\u0644\u0622\u0644\u0623\u0644\u0625\u{1D157}\u{1D165}0,1,2,3,4,5,6,7,8,9,wzhvsdwcmcmddj\u307B\u304B\u30B3\u30B3\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0135\u0137\u013A\u013C\u013E\u0142\u0144\u0146\u0148\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\xFF\u017A\u017C\u0253\u0183\u0185\u0254\u0188\u0256\u0257\u018C\u01DD\u0259\u025B\u0192\u0260\u0263\u0269\u0268\u0199\u026F\u0272\u0275\u01A1\u01A3\u01A5\u0280\u01A8\u0283\u01AD\u0288\u01B0\u028A\u028B\u01B4\u01B6\u0292\u01B9\u01BD\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F5\u0195\u01BF\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u019E\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233\u2C65\u023C\u019A\u2C66\u0242\u0180\u0289\u028C\u0247\u0249\u024B\u024D\u024F\u0266\u0279\u027B\u0281\u0295\u0371\u0373\u02B9\u0377;\u03F3\u03AD\u03AF\u03CC\u03CD\u03B2\u03B3\u03B4\u03B5\u03B6\u03B8\u03BA\u03BB\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03CA\u03CB\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF\u03F8\u03FB\u037B\u037C\u037D\u0450\u0451\u0452\u0453\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\u045D\u045E\u045F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561\u0562\u0563\u0564\u0566\u0567\u0568\u0569\u056A\u056C\u056E\u056F\u0570\u0571\u0572\u0573\u0575\u0577\u0578\u0579\u057A\u057B\u057C\u057D\u057F\u0580\u0581\u0583\u0584\u0585\u0586\u0F0B\u2D27\u2D2D\u10DC\u13F0\u13F1\u13F2\u13F3\u13F4\u13F5\uA64B\u0250\u0251\u1D02\u025C\u1D16\u1D17\u1D1D\u1D25\u0252\u0255\u025F\u0261\u0265\u026A\u1D7B\u029D\u026D\u1D85\u029F\u0271\u0270\u0273\u0274\u0278\u0282\u01AB\u1D1C\u0290\u0291\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF\u1F10\u1F11\u1F12\u1F13\u1F14\u1F15\u1F30\u1F31\u1F32\u1F33\u1F34\u1F35\u1F36\u1F37\u1F40\u1F41\u1F42\u1F43\u1F44\u1F45\u1F51\u1F53\u1F55\u1F57\u1FB0\u1FB1\u1F72\u0390\u1FD0\u1FD1\u1F76\u03B0\u1FE0\u1FE1\u1F7A\u1FE5`\u1F78\u2010+\u2212\u2211\u3008\u3009\u2C30\u2C31\u2C32\u2C33\u2C34\u2C35\u2C36\u2C37\u2C38\u2C39\u2C3A\u2C3B\u2C3C\u2C3D\u2C3E\u2C3F\u2C40\u2C41\u2C42\u2C43\u2C44\u2C45\u2C46\u2C47\u2C48\u2C49\u2C4A\u2C4B\u2C4C\u2C4D\u2C4E\u2C4F\u2C50\u2C51\u2C52\u2C53\u2C54\u2C55\u2C56\u2C57\u2C58\u2C59\u2C5A\u2C5B\u2C5C\u2C5D\u2C5E\u2C61\u026B\u1D7D\u027D\u2C68\u2C6A\u2C6C\u2C73\u2C76\u023F\u0240\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CEC\u2CEE\u2CF3\u2D61\u6BCD\u9F9F\u4E28\u4E36\u4E3F\u4E59\u4E85\u4EA0\u4EBA\u513F\u5165\u5182\u5196\u51AB\u51E0\u51F5\u5200\u529B\u52F9\u5315\u531A\u5338\u535C\u5369\u5382\u53B6\u53C8\u53E3\u56D7\u58EB\u5902\u590A\u5915\u5973\u5B50\u5B80\u5BF8\u5C0F\u5C22\u5C38\u5C6E\u5C71\u5DDB\u5DE5\u5DF1\u5DFE\u5E72\u5E7A\u5E7F\u5EF4\u5EFE\u5F0B\u5F13\u5F50\u5F61\u5F73\u5FC3\u6208\u6236\u624B\u652F\u6534\u6587\u6597\u65A4\u65B9\u65E0\u66F0\u6B20\u6B62\u6B79\u6BB3\u6BCB\u6BD4\u6BDB\u6C0F\u6C14\u722A\u7236\u723B\u723F\u7247\u7259\u725B\u72AC\u7384\u7389\u74DC\u74E6\u7518\u751F\u7528\u7530\u758B\u7592\u7676\u767D\u76AE\u76BF\u76EE\u77DB\u77E2\u77F3\u793A\u79B8\u79BE\u7A74\u7ACB\u7AF9\u7C73\u7CF8\u7F36\u7F51\u7F8A\u7FBD\u8001\u800C\u8012\u8033\u807F\u8089\u81E3\u81FC\u820C\u821B\u821F\u826E\u8272\u8278\u864D\u866B\u8840\u884C\u8863\u897E\u898B\u89D2\u8A00\u8C37\u8C46\u8C55\u8C78\u8C9D\u8D64\u8D70\u8DB3\u8EAB\u8ECA\u8F9B\u8FB0\u8FB5\u9091\u9149\u91C6\u91CC\u9577\u9580\u961C\u96B6\u96B9\u96E8\u9751\u975E\u9762\u9769\u97CB\u97ED\u97F3\u9801\u98A8\u98DB\u98DF\u9996\u9999\u99AC\u9AA8\u9AD8\u9ADF\u9B25\u9B2F\u9B32\u9B3C\u9B5A\u9CE5\u9E75\u9E7F\u9EA5\u9EBB\u9EC3\u9ECD\u9ED1\u9EF9\u9EFD\u9F0E\u9F13\u9F20\u9F3B\u9F4A\u9F52\u9F8D\u9F9C\u9FA0.\u3012\u5344\u5345\u1101\u11AA\u11AC\u11AD\u1104\u11B0\u11B1\u11B2\u11B3\u11B4\u11B5\u111A\u1108\u1121\u110A\u110D\u1161\u1162\u1163\u1164\u1165\u1166\u1167\u1168\u1169\u116A\u116B\u116C\u116D\u116E\u116F\u1170\u1171\u1172\u1173\u1174\u1175\u1114\u1115\u11C7\u11C8\u11CC\u11CE\u11D3\u11D7\u11D9\u111C\u11DD\u11DF\u111D\u111E\u1120\u1122\u1123\u1127\u1129\u112B\u112C\u112D\u112E\u112F\u1132\u1136\u1140\u1147\u114C\u11F1\u11F2\u1157\u1158\u1159\u1184\u1185\u1188\u1191\u1192\u1194\u119E\u11A1\u4E0A\u4E2D\u4E0B\u7532\u4E19\u4E01\u5929\u5730\u554F\u5E7C\u7B8F\uC6B0\u79D8\u7537\u9069\u512A\u5370\u6CE8\u9805\u5199\u5DE6\u53F3\u533B\u5B97\u591C\u30C6\u30CC\u30E2\u30E8\u30F0\u30F1\u30F2\uA641\uA643\uA645\uA647\uA649\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA77A\uA77C\u1D79\uA77F\uA781\uA783\uA785\uA787\uA78C\uA791\uA793\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\u026C\u029E\u0287\uAB53\uA7B5\uA7B7\uAB37\uAB52\u13A0\u13A1\u13A2\u13A3\u13A4\u13A5\u13A6\u13A7\u13A8\u13A9\u13AA\u13AB\u13AC\u13AD\u13AE\u13AF\u13B0\u13B1\u13B2\u13B3\u13B4\u13B5\u13B6\u13B7\u13B8\u13B9\u13BA\u13BB\u13BC\u13BD\u13BE\u13BF\u13C0\u13C1\u13C2\u13C3\u13C4\u13C5\u13C6\u13C7\u13C8\u13C9\u13CA\u13CB\u13CC\u13CD\u13CE\u13CF\u13D0\u13D1\u13D2\u13D3\u13D4\u13D5\u13D6\u13D7\u13D8\u13D9\u13DA\u13DB\u13DC\u13DD\u13DE\u13DF\u13E0\u13E1\u13E2\u13E3\u13E4\u13E5\u13E6\u13E7\u13E8\u13E9\u13EA\u13EB\u13EC\u13ED\u13EE\u13EF\u8C48\u66F4\u8CC8\u6ED1\u4E32\u53E5\u5951\u5587\u5948\u61F6\u7669\u7F85\u863F\u87BA\u88F8\u908F\u6A02\u6D1B\u70D9\u73DE\u843D\u916A\u99F1\u4E82\u5375\u6B04\u721B\u862D\u9E1E\u5D50\u6FEB\u85CD\u8964\u62C9\u81D8\u881F\u5ECA\u6717\u6D6A\u72FC\u90CE\u4F86\u51B7\u52DE\u64C4\u6AD3\u7210\u76E7\u8606\u865C\u8DEF\u9732\u9B6F\u9DFA\u788C\u797F\u7DA0\u83C9\u9304\u8AD6\u58DF\u5F04\u7C60\u807E\u7262\u78CA\u8CC2\u96F7\u58D8\u5C62\u6A13\u6DDA\u6F0F\u7D2F\u7E37\u964B\u52D2\u808B\u51DC\u51CC\u7A1C\u7DBE\u83F1\u9675\u8B80\u62CF\u8AFE\u4E39\u5BE7\u6012\u7387\u7570\u5317\u78FB\u4FBF\u5FA9\u4E0D\u6CCC\u6578\u7D22\u53C3\u585E\u7701\u8449\u8AAA\u6BBA\u6C88\u62FE\u82E5\u63A0\u7565\u4EAE\u5169\u51C9\u6881\u7CE7\u826F\u8AD2\u91CF\u52F5\u5442\u5EEC\u65C5\u6FFE\u792A\u95AD\u9A6A\u9E97\u9ECE\u66C6\u6B77\u8F62\u5E74\u6190\u6200\u649A\u6F23\u7149\u7489\u79CA\u7DF4\u806F\u8F26\u84EE\u9023\u934A\u5217\u52A3\u54BD\u70C8\u88C2\u5EC9\u5FF5\u637B\u6BAE\u7C3E\u7375\u4EE4\u56F9\u5DBA\u601C\u73B2\u7469\u7F9A\u8046\u9234\u96F6\u9748\u9818\u4F8B\u79AE\u91B4\u96B8\u60E1\u4E86\u50DA\u5BEE\u5C3F\u6599\u71CE\u7642\u84FC\u907C\u6688\u962E\u5289\u677B\u67F3\u6D41\u6E9C\u7409\u7559\u786B\u7D10\u985E\u622E\u9678\u502B\u5D19\u6DEA\u8F2A\u5F8B\u6144\u6817\u9686\u5229\u540F\u5C65\u6613\u674E\u68A8\u6CE5\u7406\u75E2\u7F79\u88CF\u88E1\u96E2\u533F\u6EBA\u541D\u71D0\u7498\u85FA\u96A3\u9C57\u9E9F\u6797\u6DCB\u81E8\u7B20\u7C92\u72C0\u7099\u8B58\u4EC0\u8336\u523A\u5207\u5EA6\u62D3\u7CD6\u5B85\u6D1E\u66B4\u8F3B\u964D\u5ED3\u5140\u55C0\u585A\u6674\u51DE\u732A\u76CA\u793C\u795E\u7965\u798F\u9756\u7CBE\u8612\u8AF8\u9038\u90FD\u98EF\u98FC\u9928\u9DB4\u90DE\u96B7\u4FAE\u50E7\u514D\u52C9\u52E4\u5351\u559D\u5606\u5668\u5840\u58A8\u5C64\u6094\u6168\u618E\u61F2\u654F\u65E2\u6691\u6885\u6D77\u6E1A\u6F22\u716E\u722B\u7422\u7891\u7949\u7948\u7950\u7956\u798D\u798E\u7A40\u7A81\u7BC0\u7E09\u7E41\u7F72\u8005\u81ED\u8279\u8457\u8910\u8996\u8B01\u8B39\u8CD3\u8D08\u8FB6\u96E3\u97FF\u983B\u6075\u{242EE}\u8218\u4E26\u51B5\u5168\u4F80\u5145\u5180\u52C7\u52FA\u5555\u5599\u55E2\u58B3\u5944\u5954\u5A62\u5B28\u5ED2\u5ED9\u5F69\u5FAD\u60D8\u614E\u6108\u6160\u6234\u63C4\u641C\u6452\u6556\u671B\u6756\u6EDB\u6ECB\u701E\u77A7\u7235\u72AF\u7471\u7506\u753B\u761D\u761F\u76DB\u76F4\u774A\u7740\u78CC\u7AB1\u7C7B\u7D5B\u7F3E\u8352\u83EF\u8779\u8941\u8986\u8ABF\u8ACB\u8AED\u8B8A\u8F38\u9072\u9199\u9276\u967C\u97DB\u980B\u9B12\u{2284A}\u{22844}\u{233D5}\u3B9D\u4018\u4039\u{25249}\u{25CD0}\u{27ED3}\u9F43\u9F8E\u05E2\u05DD\u0671\u067B\u067E\u0680\u067A\u067F\u0679\u06A4\u06A6\u0684\u0683\u0686\u0687\u068D\u068C\u068E\u0688\u0698\u0691\u06A9\u06AF\u06B3\u06B1\u06BA\u06BB\u06C0\u06C1\u06BE\u06D3\u06AD\u06CB\u06C5\u06C9\u3001\u3016\u3017\u2014\u2013_{}\u3010\u3011\u300A\u300B\u300C\u300D\u300E\u300F[]#&*-<>\\$%@\u0621\u0624\u0629\"'^|~\u2985\u2986\u30FB\u30A5\u30E3\xA2\xA3\xAC\xA6\xA5\u20A9\u2502\u2190\u2191\u2192\u2193\u25A0\u25CB\u{10428}\u{10429}\u{1042A}\u{1042B}\u{1042C}\u{1042D}\u{1042E}\u{1042F}\u{10430}\u{10431}\u{10432}\u{10433}\u{10434}\u{10435}\u{10436}\u{10437}\u{10438}\u{10439}\u{1043A}\u{1043B}\u{1043C}\u{1043D}\u{1043E}\u{1043F}\u{10440}\u{10441}\u{10442}\u{10443}\u{10444}\u{10445}\u{10446}\u{10447}\u{10448}\u{10449}\u{1044A}\u{1044B}\u{1044C}\u{1044D}\u{1044E}\u{1044F}\u{104D8}\u{104D9}\u{104DA}\u{104DB}\u{104DC}\u{104DD}\u{104DE}\u{104DF}\u{104E0}\u{104E1}\u{104E2}\u{104E3}\u{104E4}\u{104E5}\u{104E6}\u{104E7}\u{104E8}\u{104E9}\u{104EA}\u{104EB}\u{104EC}\u{104ED}\u{104EE}\u{104EF}\u{104F0}\u{104F1}\u{104F2}\u{104F3}\u{104F4}\u{104F5}\u{104F6}\u{104F7}\u{104F8}\u{104F9}\u{104FA}\u{104FB}\u{10CC0}\u{10CC1}\u{10CC2}\u{10CC3}\u{10CC4}\u{10CC5}\u{10CC6}\u{10CC7}\u{10CC8}\u{10CC9}\u{10CCA}\u{10CCB}\u{10CCC}\u{10CCD}\u{10CCE}\u{10CCF}\u{10CD0}\u{10CD1}\u{10CD2}\u{10CD3}\u{10CD4}\u{10CD5}\u{10CD6}\u{10CD7}\u{10CD8}\u{10CD9}\u{10CDA}\u{10CDB}\u{10CDC}\u{10CDD}\u{10CDE}\u{10CDF}\u{10CE0}\u{10CE1}\u{10CE2}\u{10CE3}\u{10CE4}\u{10CE5}\u{10CE6}\u{10CE7}\u{10CE8}\u{10CE9}\u{10CEA}\u{10CEB}\u{10CEC}\u{10CED}\u{10CEE}\u{10CEF}\u{10CF0}\u{10CF1}\u{10CF2}\u{118C0}\u{118C1}\u{118C2}\u{118C3}\u{118C4}\u{118C5}\u{118C6}\u{118C7}\u{118C8}\u{118C9}\u{118CA}\u{118CB}\u{118CC}\u{118CD}\u{118CE}\u{118CF}\u{118D0}\u{118D1}\u{118D2}\u{118D3}\u{118D4}\u{118D5}\u{118D6}\u{118D7}\u{118D8}\u{118D9}\u{118DA}\u{118DB}\u{118DC}\u{118DD}\u{118DE}\u{118DF}\u0131\u0237\u2207\u2202\u{1E922}\u{1E923}\u{1E924}\u{1E925}\u{1E926}\u{1E927}\u{1E928}\u{1E929}\u{1E92A}\u{1E92B}\u{1E92C}\u{1E92D}\u{1E92E}\u{1E92F}\u{1E930}\u{1E931}\u{1E932}\u{1E933}\u{1E934}\u{1E935}\u{1E936}\u{1E937}\u{1E938}\u{1E939}\u{1E93A}\u{1E93B}\u{1E93C}\u{1E93D}\u{1E93E}\u{1E93F}\u{1E940}\u{1E941}\u{1E942}\u{1E943}\u066E\u06A1\u066F\u5B57\u53CC\u591A\u89E3\u4EA4\u6620\u7121\u524D\u5F8C\u518D\u65B0\u521D\u7D42\u8CA9\u58F0\u5439\u6F14\u6295\u6355\u904A\u6307\u7981\u7A7A\u5408\u6E80\u7533\u5272\u55B6\u914D\u5F97\u53EF\u4E3D\u4E38\u4E41\u{20122}\u4F60\u4FBB\u5002\u507A\u5099\u50CF\u349E\u{2063A}\u5154\u5164\u5177\u{2051C}\u34B9\u5167\u{2054B}\u5197\u51A4\u4ECC\u51AC\u{291DF}\u5203\u34DF\u523B\u5246\u5277\u3515\u5305\u5306\u5349\u535A\u5373\u537D\u537F\u{20A2C}\u7070\u53CA\u53DF\u{20B63}\u53EB\u53F1\u5406\u549E\u5438\u5448\u5468\u54A2\u54F6\u5510\u5553\u5563\u5584\u55AB\u55B3\u55C2\u5716\u5717\u5651\u5674\u58EE\u57CE\u57F4\u580D\u578B\u5832\u5831\u58AC\u{214E4}\u58F2\u58F7\u5906\u5922\u5962\u{216A8}\u{216EA}\u59EC\u5A1B\u5A27\u59D8\u5A66\u36EE\u5B08\u5B3E\u{219C8}\u5BC3\u5BD8\u5BF3\u{21B18}\u5BFF\u5C06\u3781\u5C60\u5CC0\u5C8D\u{21DE4}\u5D43\u{21DE6}\u5D6E\u5D6B\u5D7C\u5DE1\u5DE2\u382F\u5DFD\u5E28\u5E3D\u5E69\u3862\u{22183}\u387C\u5EB0\u5EB3\u5EB6\u{2A392}\u{22331}\u8201\u5F22\u38C7\u{232B8}\u{261DA}\u5F62\u5F6B\u38E3\u5F9A\u5FCD\u5FD7\u5FF9\u6081\u393A\u391C\u{226D4}\u60C7\u6148\u614C\u617A\u61B2\u61A4\u61AF\u61DE\u621B\u625D\u62B1\u62D4\u6350\u{22B0C}\u633D\u62FC\u6368\u6383\u63E4\u{22BF1}\u6422\u63C5\u63A9\u3A2E\u6469\u647E\u649D\u6477\u3A6C\u656C\u{2300A}\u65E3\u66F8\u6649\u3B19\u3B08\u3AE4\u5192\u5195\u6700\u669C\u80AD\u43D9\u6721\u675E\u6753\u{233C3}\u3B49\u67FA\u6785\u6852\u{2346D}\u688E\u681F\u6914\u6942\u69A3\u69EA\u6AA8\u{236A3}\u6ADB\u3C18\u6B21\u{238A7}\u6B54\u3C4E\u6B72\u6B9F\u6BBB\u{23A8D}\u{21D0B}\u{23AFA}\u6C4E\u{23CBC}\u6CBF\u6CCD\u6C67\u6D16\u6D3E\u6D69\u6D78\u6D85\u{23D1E}\u6D34\u6E2F\u6E6E\u3D33\u6EC7\u{23ED1}\u6DF9\u6F6E\u{23F5E}\u{23F8E}\u6FC6\u7039\u701B\u3D96\u704A\u707D\u7077\u70AD\u{20525}\u7145\u{24263}\u719C\u7228\u7250\u{24608}\u7280\u7295\u{24735}\u{24814}\u737A\u738B\u3EAC\u73A5\u3EB8\u7447\u745C\u7485\u74CA\u3F1B\u7524\u{24C36}\u753E\u{24C92}\u{2219F}\u7610\u{24FA1}\u{24FB8}\u{25044}\u3FFC\u4008\u{250F3}\u{250F2}\u{25119}\u{25133}\u771E\u771F\u778B\u4046\u4096\u{2541D}\u784E\u40E3\u{25626}\u{2569A}\u{256C5}\u79EB\u412F\u7A4A\u7A4F\u{2597C}\u{25AA7}\u4202\u{25BAB}\u7BC6\u7BC9\u4227\u{25C80}\u7CD2\u42A0\u7CE8\u7CE3\u7D00\u{25F86}\u7D63\u4301\u7DC7\u7E02\u7E45\u4334\u{26228}\u{26247}\u4359\u{262D9}\u7F7A\u{2633E}\u7F95\u7FFA\u{264DA}\u{26523}\u8060\u{265A8}\u8070\u{2335F}\u43D5\u80B2\u8103\u440B\u813E\u5AB5\u{267A7}\u{267B5}\u{23393}\u{2339C}\u8204\u8F9E\u446B\u8291\u828B\u829D\u52B3\u82B1\u82B3\u82BD\u82E6\u{26B3C}\u831D\u8363\u83AD\u8323\u83BD\u83E7\u8353\u83CA\u83CC\u83DC\u{26C36}\u{26D6B}\u{26CD5}\u452B\u84F1\u84F3\u8516\u{273CA}\u8564\u{26F2C}\u455D\u4561\u{26FB1}\u{270D2}\u456B\u8650\u8667\u8669\u86A9\u8688\u870E\u86E2\u8728\u876B\u8786\u87E1\u8801\u45F9\u8860\u{27667}\u88D7\u88DE\u4635\u88FA\u34BB\u{278AE}\u{27966}\u46BE\u46C7\u8AA0\u{27CA8}\u8CAB\u8CC1\u8D1B\u8D77\u{27F2F}\u{20804}\u8DCB\u8DBC\u8DF0\u{208DE}\u8ED4\u{285D2}\u{285ED}\u9094\u90F1\u9111\u{2872E}\u911B\u9238\u92D7\u92D8\u927C\u93F9\u9415\u{28BFA}\u958B\u4995\u95B7\u{28D77}\u49E6\u96C3\u5DB2\u9723\u{29145}\u{2921A}\u4A6E\u4A76\u97E0\u{2940A}\u4AB2\u{29496}\u9829\u{295B6}\u98E2\u4B33\u9929\u99A7\u99C2\u99FE\u4BCE\u{29B30}\u9C40\u9CFD\u4CCE\u4CED\u9D67\u{2A0CE}\u4CF8\u{2A105}\u{2A20E}\u{2A291}\u4D56\u9EFE\u9F05\u9F0F\u9F16\u{2A600}";
      function mapChar(codePoint) {
        if (codePoint >= 196608) {
          if (codePoint >= 917760 && codePoint <= 917999)
            return 18874368;
          return 0;
        }
        return blocks[blockIdxes[codePoint >> 4]][codePoint & 15];
      }
      return {
        mapStr: mappingStr,
        mapChar
      };
    });
  }
});

// node_modules/idna-uts46-hx/uts46.js
var require_uts46 = __commonJS({
  "node_modules/idna-uts46-hx/uts46.js"(exports, module) {
    init_define_process_env();
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(["punycode", "./idna-map"], function(punycode2, idna_map) {
          return factory(punycode2, idna_map);
        });
      } else if (typeof exports === "object") {
        module.exports = factory((init_punycode_es6(), __toCommonJS(punycode_es6_exports)), require_idna_map());
      } else {
        root.uts46 = factory(root.punycode, root.idna_map);
      }
    })(exports, function(punycode2, idna_map) {
      function mapLabel(label, useStd3ASCII, transitional) {
        var mapped = [];
        var chars = punycode2.ucs2.decode(label);
        for (var i = 0; i < chars.length; i++) {
          var cp = chars[i];
          var ch = punycode2.ucs2.encode([chars[i]]);
          var composite = idna_map.mapChar(cp);
          var flags = composite >> 23;
          var kind = composite >> 21 & 3;
          var index = composite >> 5 & 65535;
          var length = composite & 31;
          var value = idna_map.mapStr.substr(index, length);
          if (kind === 0 || useStd3ASCII && flags & 1) {
            throw new Error("Illegal char " + ch);
          } else if (kind === 1) {
            mapped.push(value);
          } else if (kind === 2) {
            mapped.push(transitional ? value : ch);
          } else if (kind === 3) {
            mapped.push(ch);
          }
        }
        var newLabel = mapped.join("").normalize("NFC");
        return newLabel;
      }
      function process2(domain, transitional, useStd3ASCII) {
        if (useStd3ASCII === void 0)
          useStd3ASCII = false;
        var mappedIDNA = mapLabel(domain, useStd3ASCII, transitional);
        var labels = mappedIDNA.split(".");
        labels = labels.map(function(label) {
          if (label.startsWith("xn--")) {
            label = punycode2.decode(label.substring(4));
            validateLabel(label, useStd3ASCII, false);
          } else {
            validateLabel(label, useStd3ASCII, transitional);
          }
          return label;
        });
        return labels.join(".");
      }
      function validateLabel(label, useStd3ASCII, transitional) {
        if (label[2] === "-" && label[3] === "-")
          throw new Error("Failed to validate " + label);
        if (label.startsWith("-") || label.endsWith("-"))
          throw new Error("Failed to validate " + label);
        if (label.includes("."))
          throw new Error("Failed to validate " + label);
        if (mapLabel(label, useStd3ASCII, transitional) !== label)
          throw new Error("Failed to validate " + label);
        var ch = label.codePointAt(0);
        if (idna_map.mapChar(ch) & 2 << 23)
          throw new Error("Label contains illegal character: " + ch);
      }
      function toAscii(domain, options) {
        if (options === void 0)
          options = {};
        var transitional = "transitional" in options ? options.transitional : true;
        var useStd3ASCII = "useStd3ASCII" in options ? options.useStd3ASCII : false;
        var verifyDnsLength = "verifyDnsLength" in options ? options.verifyDnsLength : false;
        var labels = process2(domain, transitional, useStd3ASCII).split(".");
        var asciiLabels = labels.map(punycode2.toASCII);
        var asciiString = asciiLabels.join(".");
        var i;
        if (verifyDnsLength) {
          if (asciiString.length < 1 || asciiString.length > 253) {
            throw new Error("DNS name has wrong length: " + asciiString);
          }
          for (i = 0; i < asciiLabels.length; i++) {
            var label = asciiLabels[i];
            if (label.length < 1 || label.length > 63)
              throw new Error("DNS label has wrong length: " + label);
          }
        }
        return asciiString;
      }
      function toUnicode2(domain, options) {
        if (options === void 0)
          options = {};
        var useStd3ASCII = "useStd3ASCII" in options ? options.useStd3ASCII : false;
        return process2(domain, false, useStd3ASCII);
      }
      return {
        toUnicode: toUnicode2,
        toAscii
      };
    });
  }
});

// node_modules/eth-ens-namehash/index.js
var require_eth_ens_namehash = __commonJS({
  "node_modules/eth-ens-namehash/index.js"(exports) {
    init_define_process_env();
    var sha3 = require_sha3().keccak_256;
    var uts46 = require_uts46();
    function namehash(inputName) {
      var node = "";
      for (var i = 0; i < 32; i++) {
        node += "00";
      }
      name = normalize(inputName);
      if (name) {
        var labels = name.split(".");
        for (var i = labels.length - 1; i >= 0; i--) {
          var labelSha = sha3(labels[i]);
          node = sha3(new Buffer(node + labelSha, "hex"));
        }
      }
      return "0x" + node;
    }
    function normalize(name2) {
      return name2 ? uts46.toUnicode(name2, { useStd3ASCII: true, transitional: false }) : name2;
    }
    exports.hash = namehash;
    exports.normalize = normalize;
  }
});

// node_modules/web3-eth-ens/lib/resources/ABI/Registry.js
var require_Registry = __commonJS({
  "node_modules/web3-eth-ens/lib/resources/ABI/Registry.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var REGISTRY = [
      {
        "constant": true,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          }
        ],
        "name": "resolver",
        "outputs": [
          {
            "name": "",
            "type": "address"
          }
        ],
        "payable": false,
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          }
        ],
        "name": "owner",
        "outputs": [
          {
            "name": "",
            "type": "address"
          }
        ],
        "payable": false,
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          },
          {
            "name": "label",
            "type": "bytes32"
          },
          {
            "name": "owner",
            "type": "address"
          }
        ],
        "name": "setSubnodeOwner",
        "outputs": [],
        "payable": false,
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          },
          {
            "name": "ttl",
            "type": "uint64"
          }
        ],
        "name": "setTTL",
        "outputs": [],
        "payable": false,
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          }
        ],
        "name": "ttl",
        "outputs": [
          {
            "name": "",
            "type": "uint64"
          }
        ],
        "payable": false,
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          },
          {
            "name": "resolver",
            "type": "address"
          }
        ],
        "name": "setResolver",
        "outputs": [],
        "payable": false,
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          },
          {
            "name": "owner",
            "type": "address"
          }
        ],
        "name": "setOwner",
        "outputs": [],
        "payable": false,
        "type": "function"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "name": "node",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "name": "owner",
            "type": "address"
          }
        ],
        "name": "Transfer",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "name": "node",
            "type": "bytes32"
          },
          {
            "indexed": true,
            "name": "label",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "name": "owner",
            "type": "address"
          }
        ],
        "name": "NewOwner",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "name": "node",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "name": "resolver",
            "type": "address"
          }
        ],
        "name": "NewResolver",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "name": "node",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "name": "ttl",
            "type": "uint64"
          }
        ],
        "name": "NewTTL",
        "type": "event"
      },
      {
        "constant": false,
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "node",
            "type": "bytes32"
          },
          {
            "internalType": "address",
            "name": "owner",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "resolver",
            "type": "address"
          },
          {
            "internalType": "uint64",
            "name": "ttl",
            "type": "uint64"
          }
        ],
        "name": "setRecord",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "internalType": "address",
            "name": "operator",
            "type": "address"
          },
          {
            "internalType": "bool",
            "name": "approved",
            "type": "bool"
          }
        ],
        "name": "setApprovalForAll",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "owner",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "operator",
            "type": "address"
          },
          {
            "indexed": false,
            "internalType": "bool",
            "name": "approved",
            "type": "bool"
          }
        ],
        "name": "ApprovalForAll",
        "type": "event"
      },
      {
        "constant": true,
        "inputs": [
          {
            "internalType": "address",
            "name": "owner",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "operator",
            "type": "address"
          }
        ],
        "name": "isApprovedForAll",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "node",
            "type": "bytes32"
          }
        ],
        "name": "recordExists",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "node",
            "type": "bytes32"
          },
          {
            "internalType": "bytes32",
            "name": "label",
            "type": "bytes32"
          },
          {
            "internalType": "address",
            "name": "owner",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "resolver",
            "type": "address"
          },
          {
            "internalType": "uint64",
            "name": "ttl",
            "type": "uint64"
          }
        ],
        "name": "setSubnodeRecord",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
      }
    ];
    module.exports = REGISTRY;
  }
});

// node_modules/web3-eth-ens/lib/resources/ABI/Resolver.js
var require_Resolver = __commonJS({
  "node_modules/web3-eth-ens/lib/resources/ABI/Resolver.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var RESOLVER = [
      {
        "constant": true,
        "inputs": [
          {
            "name": "interfaceID",
            "type": "bytes4"
          }
        ],
        "name": "supportsInterface",
        "outputs": [
          {
            "name": "",
            "type": "bool"
          }
        ],
        "payable": false,
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          },
          {
            "name": "contentTypes",
            "type": "uint256"
          }
        ],
        "name": "ABI",
        "outputs": [
          {
            "name": "contentType",
            "type": "uint256"
          },
          {
            "name": "data",
            "type": "bytes"
          }
        ],
        "payable": false,
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          },
          {
            "name": "hash",
            "type": "bytes"
          }
        ],
        "name": "setMultihash",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          }
        ],
        "name": "multihash",
        "outputs": [
          {
            "name": "",
            "type": "bytes"
          }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          },
          {
            "name": "x",
            "type": "bytes32"
          },
          {
            "name": "y",
            "type": "bytes32"
          }
        ],
        "name": "setPubkey",
        "outputs": [],
        "payable": false,
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          }
        ],
        "name": "content",
        "outputs": [
          {
            "name": "ret",
            "type": "bytes32"
          }
        ],
        "payable": false,
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          }
        ],
        "name": "addr",
        "outputs": [
          {
            "name": "ret",
            "type": "address"
          }
        ],
        "payable": false,
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          },
          {
            "name": "contentType",
            "type": "uint256"
          },
          {
            "name": "data",
            "type": "bytes"
          }
        ],
        "name": "setABI",
        "outputs": [],
        "payable": false,
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          }
        ],
        "name": "name",
        "outputs": [
          {
            "name": "ret",
            "type": "string"
          }
        ],
        "payable": false,
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          },
          {
            "name": "name",
            "type": "string"
          }
        ],
        "name": "setName",
        "outputs": [],
        "payable": false,
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          },
          {
            "name": "hash",
            "type": "bytes32"
          }
        ],
        "name": "setContent",
        "outputs": [],
        "payable": false,
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          }
        ],
        "name": "pubkey",
        "outputs": [
          {
            "name": "x",
            "type": "bytes32"
          },
          {
            "name": "y",
            "type": "bytes32"
          }
        ],
        "payable": false,
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          },
          {
            "name": "addr",
            "type": "address"
          }
        ],
        "name": "setAddr",
        "outputs": [],
        "payable": false,
        "type": "function"
      },
      {
        "inputs": [
          {
            "name": "ensAddr",
            "type": "address"
          }
        ],
        "payable": false,
        "type": "constructor"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "name": "node",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "name": "a",
            "type": "address"
          }
        ],
        "name": "AddrChanged",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "name": "node",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "name": "hash",
            "type": "bytes32"
          }
        ],
        "name": "ContentChanged",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "name": "node",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "name": "name",
            "type": "string"
          }
        ],
        "name": "NameChanged",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "name": "node",
            "type": "bytes32"
          },
          {
            "indexed": true,
            "name": "contentType",
            "type": "uint256"
          }
        ],
        "name": "ABIChanged",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "name": "node",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "name": "x",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "name": "y",
            "type": "bytes32"
          }
        ],
        "name": "PubkeyChanged",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "name": "node",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "name": "hash",
            "type": "bytes"
          }
        ],
        "name": "ContenthashChanged",
        "type": "event"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          }
        ],
        "name": "contenthash",
        "outputs": [
          {
            "name": "",
            "type": "bytes"
          }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "node",
            "type": "bytes32"
          },
          {
            "name": "hash",
            "type": "bytes"
          }
        ],
        "name": "setContenthash",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
      }
    ];
    module.exports = RESOLVER;
  }
});

// node_modules/web3-eth-ens/lib/contracts/Registry.js
var require_Registry2 = __commonJS({
  "node_modules/web3-eth-ens/lib/contracts/Registry.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Contract = require_lib8();
    var namehash = require_eth_ens_namehash();
    var PromiEvent = require_lib4();
    var formatters = require_lib3().formatters;
    var utils = require_lib();
    var REGISTRY_ABI = require_Registry();
    var RESOLVER_ABI = require_Resolver();
    function Registry(ens) {
      var self2 = this;
      this.ens = ens;
      this.contract = ens.checkNetwork().then(function(address) {
        var contract = new Contract(REGISTRY_ABI, address);
        contract.setProvider(self2.ens.eth.currentProvider);
        return contract;
      });
    }
    Registry.prototype.owner = function(name2, callback) {
      console.warn('Deprecated: Please use the "getOwner" method instead of "owner".');
      return this.getOwner(name2, callback);
    };
    Registry.prototype.getOwner = function(name2, callback) {
      var promiEvent = new PromiEvent(true);
      this.contract.then(function(contract) {
        return contract.methods.owner(namehash.hash(name2)).call();
      }).then(function(receipt) {
        if (typeof callback === "function") {
          callback(receipt, receipt);
          return;
        }
        promiEvent.resolve(receipt);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    Registry.prototype.setOwner = function(name2, address, txConfig, callback) {
      var promiEvent = new PromiEvent(true);
      this.contract.then(function(contract) {
        return contract.methods.setOwner(namehash.hash(name2), formatters.inputAddressFormatter(address)).send(txConfig);
      }).then(function(receipt) {
        if (typeof callback === "function") {
          callback(receipt, receipt);
          return;
        }
        promiEvent.resolve(receipt);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    Registry.prototype.getTTL = function(name2, callback) {
      var promiEvent = new PromiEvent(true);
      this.contract.then(function(contract) {
        return contract.methods.ttl(namehash.hash(name2)).call();
      }).then(function(receipt) {
        if (typeof callback === "function") {
          callback(receipt, receipt);
          return;
        }
        promiEvent.resolve(receipt);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    Registry.prototype.setTTL = function(name2, ttl, txConfig, callback) {
      var promiEvent = new PromiEvent(true);
      this.contract.then(function(contract) {
        return contract.methods.setTTL(namehash.hash(name2), ttl).send(txConfig);
      }).then(function(receipt) {
        if (typeof callback === "function") {
          callback(receipt, receipt);
          return;
        }
        promiEvent.resolve(receipt);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    Registry.prototype.setSubnodeOwner = function(name2, label, address, txConfig, callback) {
      var promiEvent = new PromiEvent(true);
      if (!utils.isHexStrict(label)) {
        label = utils.sha3(label);
      }
      this.contract.then(function(contract) {
        return contract.methods.setSubnodeOwner(namehash.hash(name2), label, formatters.inputAddressFormatter(address)).send(txConfig);
      }).then(function(receipt) {
        if (typeof callback === "function") {
          callback(receipt, receipt);
          return;
        }
        promiEvent.resolve(receipt);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    Registry.prototype.setRecord = function(name2, owner, resolver, ttl, txConfig, callback) {
      var promiEvent = new PromiEvent(true);
      this.contract.then(function(contract) {
        return contract.methods.setRecord(namehash.hash(name2), formatters.inputAddressFormatter(owner), formatters.inputAddressFormatter(resolver), ttl).send(txConfig);
      }).then(function(receipt) {
        if (typeof callback === "function") {
          callback(receipt, receipt);
          return;
        }
        promiEvent.resolve(receipt);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    Registry.prototype.setSubnodeRecord = function(name2, label, owner, resolver, ttl, txConfig, callback) {
      var promiEvent = new PromiEvent(true);
      if (!utils.isHexStrict(label)) {
        label = utils.sha3(label);
      }
      this.contract.then(function(contract) {
        return contract.methods.setSubnodeRecord(namehash.hash(name2), label, formatters.inputAddressFormatter(owner), formatters.inputAddressFormatter(resolver), ttl).send(txConfig);
      }).then(function(receipt) {
        if (typeof callback === "function") {
          callback(receipt, receipt);
          return;
        }
        promiEvent.resolve(receipt);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    Registry.prototype.setApprovalForAll = function(operator, approved, txConfig, callback) {
      var promiEvent = new PromiEvent(true);
      this.contract.then(function(contract) {
        return contract.methods.setApprovalForAll(formatters.inputAddressFormatter(operator), approved).send(txConfig);
      }).then(function(receipt) {
        if (typeof callback === "function") {
          callback(receipt, receipt);
          return;
        }
        promiEvent.resolve(receipt);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    Registry.prototype.isApprovedForAll = function(owner, operator, callback) {
      var promiEvent = new PromiEvent(true);
      this.contract.then(function(contract) {
        return contract.methods.isApprovedForAll(formatters.inputAddressFormatter(owner), formatters.inputAddressFormatter(operator)).call();
      }).then(function(receipt) {
        if (typeof callback === "function") {
          callback(receipt, receipt);
          return;
        }
        promiEvent.resolve(receipt);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    Registry.prototype.recordExists = function(name2, callback) {
      var promiEvent = new PromiEvent(true);
      this.contract.then(function(contract) {
        return contract.methods.recordExists(namehash.hash(name2)).call();
      }).then(function(receipt) {
        if (typeof callback === "function") {
          callback(receipt, receipt);
          return;
        }
        promiEvent.resolve(receipt);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    Registry.prototype.resolver = function(name2, callback) {
      console.warn('Deprecated: Please use the "getResolver" method instead of "resolver".');
      return this.getResolver(name2, callback);
    };
    Registry.prototype.getResolver = function(name2, callback) {
      var self2 = this;
      return this.contract.then(function(contract) {
        return contract.methods.resolver(namehash.hash(name2)).call();
      }).then(function(address) {
        var contract = new Contract(RESOLVER_ABI, address);
        contract.setProvider(self2.ens.eth.currentProvider);
        if (typeof callback === "function") {
          callback(contract, contract);
          return;
        }
        return contract;
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        throw error2;
      });
    };
    Registry.prototype.setResolver = function(name2, address, txConfig, callback) {
      var promiEvent = new PromiEvent(true);
      this.contract.then(function(contract) {
        return contract.methods.setResolver(namehash.hash(name2), formatters.inputAddressFormatter(address)).send(txConfig);
      }).then(function(receipt) {
        if (typeof callback === "function") {
          callback(receipt, receipt);
          return;
        }
        promiEvent.resolve(receipt);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    module.exports = Registry;
  }
});

// node_modules/web3-eth-ens/lib/lib/ResolverMethodHandler.js
var require_ResolverMethodHandler = __commonJS({
  "node_modules/web3-eth-ens/lib/lib/ResolverMethodHandler.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var PromiEvent = require_lib4();
    var namehash = require_eth_ens_namehash();
    var errors2 = require_lib3().errors;
    var interfaceIds = require_config().interfaceIds;
    function ResolverMethodHandler(registry) {
      this.registry = registry;
    }
    ResolverMethodHandler.prototype.method = function(ensName, methodName, methodArguments, outputFormatter, callback) {
      return {
        call: this.call.bind({
          ensName,
          methodName,
          methodArguments,
          callback,
          parent: this,
          outputFormatter
        }),
        send: this.send.bind({
          ensName,
          methodName,
          methodArguments,
          callback,
          parent: this
        })
      };
    };
    ResolverMethodHandler.prototype.call = function(callback) {
      var self2 = this;
      var promiEvent = new PromiEvent();
      var preparedArguments = this.parent.prepareArguments(this.ensName, this.methodArguments);
      var outputFormatter = this.outputFormatter || null;
      this.parent.registry.getResolver(this.ensName).then(async function(resolver) {
        await self2.parent.checkInterfaceSupport(resolver, self2.methodName);
        self2.parent.handleCall(promiEvent, resolver.methods[self2.methodName], preparedArguments, outputFormatter, callback);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    ResolverMethodHandler.prototype.send = function(sendOptions, callback) {
      var self2 = this;
      var promiEvent = new PromiEvent();
      var preparedArguments = this.parent.prepareArguments(this.ensName, this.methodArguments);
      this.parent.registry.getResolver(this.ensName).then(async function(resolver) {
        await self2.parent.checkInterfaceSupport(resolver, self2.methodName);
        self2.parent.handleSend(promiEvent, resolver.methods[self2.methodName], preparedArguments, sendOptions, callback);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent.eventEmitter;
    };
    ResolverMethodHandler.prototype.handleCall = function(promiEvent, method, preparedArguments, outputFormatter, callback) {
      method.apply(this, preparedArguments).call().then(function(result) {
        if (outputFormatter) {
          result = outputFormatter(result);
        }
        if (typeof callback === "function") {
          callback(result, result);
          return;
        }
        promiEvent.resolve(result);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent;
    };
    ResolverMethodHandler.prototype.handleSend = function(promiEvent, method, preparedArguments, sendOptions, callback) {
      method.apply(this, preparedArguments).send(sendOptions).on("sending", function() {
        promiEvent.eventEmitter.emit("sending");
      }).on("sent", function() {
        promiEvent.eventEmitter.emit("sent");
      }).on("transactionHash", function(hash) {
        promiEvent.eventEmitter.emit("transactionHash", hash);
      }).on("confirmation", function(confirmationNumber, receipt) {
        promiEvent.eventEmitter.emit("confirmation", confirmationNumber, receipt);
      }).on("receipt", function(receipt) {
        promiEvent.eventEmitter.emit("receipt", receipt);
        promiEvent.resolve(receipt);
        if (typeof callback === "function") {
          callback(receipt, receipt);
        }
      }).on("error", function(error2) {
        promiEvent.eventEmitter.emit("error", error2);
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        promiEvent.reject(error2);
      });
      return promiEvent;
    };
    ResolverMethodHandler.prototype.prepareArguments = function(name2, methodArguments) {
      var node = namehash.hash(name2);
      if (methodArguments.length > 0) {
        methodArguments.unshift(node);
        return methodArguments;
      }
      return [node];
    };
    ResolverMethodHandler.prototype.checkInterfaceSupport = async function(resolver, methodName) {
      if (!interfaceIds[methodName])
        return;
      var supported = false;
      try {
        supported = await resolver.methods.supportsInterface(interfaceIds[methodName]).call();
      } catch (err) {
        console.warn('Could not verify interface of resolver contract at "' + resolver.options.address + '". ');
      }
      if (!supported) {
        throw errors2.ResolverMethodMissingError(resolver.options.address, methodName);
      }
    };
    module.exports = ResolverMethodHandler;
  }
});

// node_modules/multicodec/src/base-table.json
var require_base_table = __commonJS({
  "node_modules/multicodec/src/base-table.json"(exports, module) {
    module.exports = {
      identity: 0,
      ip4: 4,
      tcp: 6,
      sha1: 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      dccp: 33,
      "murmur3-128": 34,
      "murmur3-32": 35,
      ip6: 41,
      ip6zone: 42,
      path: 47,
      multicodec: 48,
      multihash: 49,
      multiaddr: 50,
      multibase: 51,
      dns: 53,
      dns4: 54,
      dns6: 55,
      dnsaddr: 56,
      protobuf: 80,
      cbor: 81,
      raw: 85,
      "dbl-sha2-256": 86,
      rlp: 96,
      bencode: 99,
      "dag-pb": 112,
      "dag-cbor": 113,
      "libp2p-key": 114,
      "git-raw": 120,
      "torrent-info": 123,
      "torrent-file": 124,
      "leofcoin-block": 129,
      "leofcoin-tx": 130,
      "leofcoin-pr": 131,
      sctp: 132,
      "eth-block": 144,
      "eth-block-list": 145,
      "eth-tx-trie": 146,
      "eth-tx": 147,
      "eth-tx-receipt-trie": 148,
      "eth-tx-receipt": 149,
      "eth-state-trie": 150,
      "eth-account-snapshot": 151,
      "eth-storage-trie": 152,
      "bitcoin-block": 176,
      "bitcoin-tx": 177,
      "zcash-block": 192,
      "zcash-tx": 193,
      "stellar-block": 208,
      "stellar-tx": 209,
      md4: 212,
      md5: 213,
      bmt: 214,
      "decred-block": 224,
      "decred-tx": 225,
      "ipld-ns": 226,
      "ipfs-ns": 227,
      "swarm-ns": 228,
      "ipns-ns": 229,
      zeronet: 230,
      "ed25519-pub": 237,
      "dash-block": 240,
      "dash-tx": 241,
      "swarm-manifest": 250,
      "swarm-feed": 251,
      udp: 273,
      "p2p-webrtc-star": 275,
      "p2p-webrtc-direct": 276,
      "p2p-stardust": 277,
      "p2p-circuit": 290,
      "dag-json": 297,
      udt: 301,
      utp: 302,
      unix: 400,
      p2p: 421,
      ipfs: 421,
      https: 443,
      onion: 444,
      onion3: 445,
      garlic64: 446,
      garlic32: 447,
      tls: 448,
      quic: 460,
      ws: 477,
      wss: 478,
      "p2p-websocket-star": 479,
      http: 480,
      json: 512,
      messagepack: 513,
      x11: 4352,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "holochain-adr-v0": 8417572,
      "holochain-adr-v1": 8483108,
      "holochain-key-v0": 9728292,
      "holochain-key-v1": 9793828,
      "holochain-sig-v0": 10645796,
      "holochain-sig-v1": 10711332
    };
  }
});

// node_modules/multicodec/src/int-table.js
var require_int_table = __commonJS({
  "node_modules/multicodec/src/int-table.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var baseTable = require_base_table();
    var nameTable = /* @__PURE__ */ new Map();
    for (const encodingName in baseTable) {
      const code = baseTable[encodingName];
      nameTable.set(code, encodingName);
    }
    module.exports = Object.freeze(nameTable);
  }
});

// node_modules/multicodec/src/util.js
var require_util2 = __commonJS({
  "node_modules/multicodec/src/util.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var varint = require_varint();
    module.exports = {
      numberToBuffer,
      bufferToNumber,
      varintBufferEncode,
      varintBufferDecode,
      varintEncode
    };
    function bufferToNumber(buf) {
      return parseInt(buf.toString("hex"), 16);
    }
    function numberToBuffer(num) {
      let hexString = num.toString(16);
      if (hexString.length % 2 === 1) {
        hexString = "0" + hexString;
      }
      return Buffer.from(hexString, "hex");
    }
    function varintBufferEncode(input) {
      return Buffer.from(varint.encode(bufferToNumber(input)));
    }
    function varintBufferDecode(input) {
      return numberToBuffer(varint.decode(input));
    }
    function varintEncode(num) {
      return Buffer.from(varint.encode(num));
    }
  }
});

// node_modules/multicodec/src/varint-table.js
var require_varint_table = __commonJS({
  "node_modules/multicodec/src/varint-table.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var baseTable = require_base_table();
    var varintEncode = require_util2().varintEncode;
    var varintTable = {};
    for (const encodingName in baseTable) {
      const code = baseTable[encodingName];
      varintTable[encodingName] = varintEncode(code);
    }
    module.exports = Object.freeze(varintTable);
  }
});

// node_modules/multicodec/src/constants.js
var require_constants = __commonJS({
  "node_modules/multicodec/src/constants.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var table = require_base_table();
    var constants = {};
    for (const [name2, code] of Object.entries(table)) {
      constants[name2.toUpperCase().replace(/-/g, "_")] = code;
    }
    module.exports = Object.freeze(constants);
  }
});

// node_modules/multicodec/src/print.js
var require_print = __commonJS({
  "node_modules/multicodec/src/print.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var table = require_base_table();
    var tableByCode = {};
    for (const [name2, code] of Object.entries(table)) {
      if (tableByCode[code] === void 0)
        tableByCode[code] = name2;
    }
    module.exports = Object.freeze(tableByCode);
  }
});

// node_modules/multicodec/src/index.js
var require_src2 = __commonJS({
  "node_modules/multicodec/src/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var varint = require_varint();
    var intTable = require_int_table();
    var codecNameToCodeVarint = require_varint_table();
    var util = require_util2();
    exports = module.exports;
    exports.addPrefix = (multicodecStrOrCode, data) => {
      let prefix;
      if (Buffer.isBuffer(multicodecStrOrCode)) {
        prefix = util.varintBufferEncode(multicodecStrOrCode);
      } else {
        if (codecNameToCodeVarint[multicodecStrOrCode]) {
          prefix = codecNameToCodeVarint[multicodecStrOrCode];
        } else {
          throw new Error("multicodec not recognized");
        }
      }
      return Buffer.concat([prefix, data]);
    };
    exports.rmPrefix = (data) => {
      varint.decode(data);
      return data.slice(varint.decode.bytes);
    };
    exports.getCodec = (prefixedData) => {
      const code = varint.decode(prefixedData);
      const codecName = intTable.get(code);
      if (codecName === void 0) {
        throw new Error(`Code ${code} not found`);
      }
      return codecName;
    };
    exports.getName = (codec) => {
      return intTable.get(codec);
    };
    exports.getNumber = (name2) => {
      const code = codecNameToCodeVarint[name2];
      if (code === void 0) {
        throw new Error("Codec `" + name2 + "` not found");
      }
      return util.varintBufferDecode(code)[0];
    };
    exports.getCode = (prefixedData) => {
      return varint.decode(prefixedData);
    };
    exports.getCodeVarint = (codecName) => {
      const code = codecNameToCodeVarint[codecName];
      if (code === void 0) {
        throw new Error("Codec `" + codecName + "` not found");
      }
      return code;
    };
    exports.getVarint = (code) => {
      return varint.encode(code);
    };
    var constants = require_constants();
    Object.assign(exports, constants);
    exports.print = require_print();
  }
});

// node_modules/cids/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/cids/node_modules/buffer/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer2.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});

// node_modules/multihashes/node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "node_modules/multihashes/node_modules/buffer/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer2.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});

// node_modules/multihashes/node_modules/multibase/src/base.js
var require_base = __commonJS({
  "node_modules/multihashes/node_modules/multibase/src/base.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Base = class {
      constructor(name2, code, implementation, alphabet) {
        this.name = name2;
        this.code = code;
        this.alphabet = alphabet;
        if (implementation && alphabet) {
          this.engine = implementation(alphabet);
        }
      }
      encode(stringOrBuffer) {
        return this.engine.encode(stringOrBuffer);
      }
      decode(stringOrBuffer) {
        return this.engine.decode(stringOrBuffer);
      }
      isImplemented() {
        return this.engine;
      }
    };
    module.exports = Base;
  }
});

// node_modules/multihashes/node_modules/multibase/src/base16.js
var require_base16 = __commonJS({
  "node_modules/multihashes/node_modules/multibase/src/base16.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { Buffer: Buffer2 } = require_buffer2();
    module.exports = function base16(alphabet) {
      return {
        encode(input) {
          if (typeof input === "string") {
            return Buffer2.from(input).toString("hex");
          }
          return input.toString("hex");
        },
        decode(input) {
          for (const char of input) {
            if (alphabet.indexOf(char) < 0) {
              throw new Error("invalid base16 character");
            }
          }
          return Buffer2.from(input, "hex");
        }
      };
    };
  }
});

// node_modules/multihashes/node_modules/multibase/src/base32.js
var require_base32 = __commonJS({
  "node_modules/multihashes/node_modules/multibase/src/base32.js"(exports, module) {
    "use strict";
    init_define_process_env();
    function decode2(input, alphabet) {
      input = input.replace(new RegExp("=", "g"), "");
      const length = input.length;
      let bits = 0;
      let value = 0;
      let index = 0;
      const output = new Uint8Array(length * 5 / 8 | 0);
      for (let i = 0; i < length; i++) {
        value = value << 5 | alphabet.indexOf(input[i]);
        bits += 5;
        if (bits >= 8) {
          output[index++] = value >>> bits - 8 & 255;
          bits -= 8;
        }
      }
      return output.buffer;
    }
    function encode2(buffer, alphabet) {
      const length = buffer.byteLength;
      const view = new Uint8Array(buffer);
      const padding = alphabet.indexOf("=") === alphabet.length - 1;
      if (padding) {
        alphabet = alphabet.substring(0, alphabet.length - 1);
      }
      let bits = 0;
      let value = 0;
      let output = "";
      for (let i = 0; i < length; i++) {
        value = value << 8 | view[i];
        bits += 8;
        while (bits >= 5) {
          output += alphabet[value >>> bits - 5 & 31];
          bits -= 5;
        }
      }
      if (bits > 0) {
        output += alphabet[value << 5 - bits & 31];
      }
      if (padding) {
        while (output.length % 8 !== 0) {
          output += "=";
        }
      }
      return output;
    }
    module.exports = function base32(alphabet) {
      return {
        encode(input) {
          if (typeof input === "string") {
            return encode2(Uint8Array.from(input), alphabet);
          }
          return encode2(input, alphabet);
        },
        decode(input) {
          for (const char of input) {
            if (alphabet.indexOf(char) < 0) {
              throw new Error("invalid base32 character");
            }
          }
          return decode2(input, alphabet);
        }
      };
    };
  }
});

// node_modules/multihashes/node_modules/multibase/src/base64.js
var require_base64 = __commonJS({
  "node_modules/multihashes/node_modules/multibase/src/base64.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { Buffer: Buffer2 } = require_buffer2();
    module.exports = function base64(alphabet) {
      const padding = alphabet.indexOf("=") > -1;
      const url = alphabet.indexOf("-") > -1 && alphabet.indexOf("_") > -1;
      return {
        encode(input) {
          let output = "";
          if (typeof input === "string") {
            output = Buffer2.from(input).toString("base64");
          } else {
            output = input.toString("base64");
          }
          if (url) {
            output = output.replace(/\+/g, "-").replace(/\//g, "_");
          }
          const pad = output.indexOf("=");
          if (pad > 0 && !padding) {
            output = output.substring(0, pad);
          }
          return output;
        },
        decode(input) {
          for (const char of input) {
            if (alphabet.indexOf(char) < 0) {
              throw new Error("invalid base64 character");
            }
          }
          return Buffer2.from(input, "base64");
        }
      };
    };
  }
});

// node_modules/multihashes/node_modules/multibase/src/constants.js
var require_constants2 = __commonJS({
  "node_modules/multihashes/node_modules/multibase/src/constants.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Base = require_base();
    var baseX = require_src();
    var base16 = require_base16();
    var base32 = require_base32();
    var base64 = require_base64();
    var constants = [
      ["base1", "1", "", "1"],
      ["base2", "0", baseX, "01"],
      ["base8", "7", baseX, "01234567"],
      ["base10", "9", baseX, "0123456789"],
      ["base16", "f", base16, "0123456789abcdef"],
      ["base32", "b", base32, "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32pad", "c", base32, "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32hex", "v", base32, "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexpad", "t", base32, "0123456789abcdefghijklmnopqrstuv="],
      ["base32z", "h", base32, "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base64", "m", base64, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", base64, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", base64, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", base64, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names = constants.reduce((prev, tupple) => {
      prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
      return prev;
    }, {});
    var codes = constants.reduce((prev, tupple) => {
      prev[tupple[1]] = names[tupple[0]];
      return prev;
    }, {});
    module.exports = {
      names,
      codes
    };
  }
});

// node_modules/multihashes/node_modules/multibase/src/index.js
var require_src3 = __commonJS({
  "node_modules/multihashes/node_modules/multibase/src/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { Buffer: Buffer2 } = require_buffer2();
    var constants = require_constants2();
    exports = module.exports = multibase;
    exports.encode = encode2;
    exports.decode = decode2;
    exports.isEncoded = isEncoded;
    exports.names = Object.freeze(Object.keys(constants.names));
    exports.codes = Object.freeze(Object.keys(constants.codes));
    function multibase(nameOrCode, buf) {
      if (!buf) {
        throw new Error("requires an encoded buffer");
      }
      const base2 = getBase(nameOrCode);
      const codeBuf = Buffer2.from(base2.code);
      const name2 = base2.name;
      validEncode(name2, buf);
      return Buffer2.concat([codeBuf, buf]);
    }
    function encode2(nameOrCode, buf) {
      const base2 = getBase(nameOrCode);
      const name2 = base2.name;
      return multibase(name2, Buffer2.from(base2.encode(buf)));
    }
    function decode2(bufOrString) {
      if (Buffer2.isBuffer(bufOrString)) {
        bufOrString = bufOrString.toString();
      }
      const code = bufOrString.substring(0, 1);
      bufOrString = bufOrString.substring(1, bufOrString.length);
      if (typeof bufOrString === "string") {
        bufOrString = Buffer2.from(bufOrString);
      }
      const base2 = getBase(code);
      return Buffer2.from(base2.decode(bufOrString.toString()));
    }
    function isEncoded(bufOrString) {
      if (Buffer2.isBuffer(bufOrString)) {
        bufOrString = bufOrString.toString();
      }
      if (Object.prototype.toString.call(bufOrString) !== "[object String]") {
        return false;
      }
      const code = bufOrString.substring(0, 1);
      try {
        const base2 = getBase(code);
        return base2.name;
      } catch (err) {
        return false;
      }
    }
    function validEncode(name2, buf) {
      const base2 = getBase(name2);
      base2.decode(buf.toString());
    }
    function getBase(nameOrCode) {
      let base2;
      if (constants.names[nameOrCode]) {
        base2 = constants.names[nameOrCode];
      } else if (constants.codes[nameOrCode]) {
        base2 = constants.codes[nameOrCode];
      } else {
        throw new Error("Unsupported encoding");
      }
      if (!base2.isImplemented()) {
        throw new Error("Base " + nameOrCode + " is not implemented yet");
      }
      return base2;
    }
  }
});

// node_modules/multihashes/src/constants.js
var require_constants3 = __commonJS({
  "node_modules/multihashes/src/constants.js"(exports) {
    "use strict";
    init_define_process_env();
    exports.names = Object.freeze({
      "identity": 0,
      "sha1": 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "dbl-sha2-256": 86,
      "sha3-224": 23,
      "sha3-256": 22,
      "sha3-384": 21,
      "sha3-512": 20,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "murmur3-128": 34,
      "murmur3-32": 35,
      "md4": 212,
      "md5": 213,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "Skein256-8": 45825,
      "Skein256-16": 45826,
      "Skein256-24": 45827,
      "Skein256-32": 45828,
      "Skein256-40": 45829,
      "Skein256-48": 45830,
      "Skein256-56": 45831,
      "Skein256-64": 45832,
      "Skein256-72": 45833,
      "Skein256-80": 45834,
      "Skein256-88": 45835,
      "Skein256-96": 45836,
      "Skein256-104": 45837,
      "Skein256-112": 45838,
      "Skein256-120": 45839,
      "Skein256-128": 45840,
      "Skein256-136": 45841,
      "Skein256-144": 45842,
      "Skein256-152": 45843,
      "Skein256-160": 45844,
      "Skein256-168": 45845,
      "Skein256-176": 45846,
      "Skein256-184": 45847,
      "Skein256-192": 45848,
      "Skein256-200": 45849,
      "Skein256-208": 45850,
      "Skein256-216": 45851,
      "Skein256-224": 45852,
      "Skein256-232": 45853,
      "Skein256-240": 45854,
      "Skein256-248": 45855,
      "Skein256-256": 45856,
      "Skein512-8": 45857,
      "Skein512-16": 45858,
      "Skein512-24": 45859,
      "Skein512-32": 45860,
      "Skein512-40": 45861,
      "Skein512-48": 45862,
      "Skein512-56": 45863,
      "Skein512-64": 45864,
      "Skein512-72": 45865,
      "Skein512-80": 45866,
      "Skein512-88": 45867,
      "Skein512-96": 45868,
      "Skein512-104": 45869,
      "Skein512-112": 45870,
      "Skein512-120": 45871,
      "Skein512-128": 45872,
      "Skein512-136": 45873,
      "Skein512-144": 45874,
      "Skein512-152": 45875,
      "Skein512-160": 45876,
      "Skein512-168": 45877,
      "Skein512-176": 45878,
      "Skein512-184": 45879,
      "Skein512-192": 45880,
      "Skein512-200": 45881,
      "Skein512-208": 45882,
      "Skein512-216": 45883,
      "Skein512-224": 45884,
      "Skein512-232": 45885,
      "Skein512-240": 45886,
      "Skein512-248": 45887,
      "Skein512-256": 45888,
      "Skein512-264": 45889,
      "Skein512-272": 45890,
      "Skein512-280": 45891,
      "Skein512-288": 45892,
      "Skein512-296": 45893,
      "Skein512-304": 45894,
      "Skein512-312": 45895,
      "Skein512-320": 45896,
      "Skein512-328": 45897,
      "Skein512-336": 45898,
      "Skein512-344": 45899,
      "Skein512-352": 45900,
      "Skein512-360": 45901,
      "Skein512-368": 45902,
      "Skein512-376": 45903,
      "Skein512-384": 45904,
      "Skein512-392": 45905,
      "Skein512-400": 45906,
      "Skein512-408": 45907,
      "Skein512-416": 45908,
      "Skein512-424": 45909,
      "Skein512-432": 45910,
      "Skein512-440": 45911,
      "Skein512-448": 45912,
      "Skein512-456": 45913,
      "Skein512-464": 45914,
      "Skein512-472": 45915,
      "Skein512-480": 45916,
      "Skein512-488": 45917,
      "Skein512-496": 45918,
      "Skein512-504": 45919,
      "Skein512-512": 45920,
      "Skein1024-8": 45921,
      "Skein1024-16": 45922,
      "Skein1024-24": 45923,
      "Skein1024-32": 45924,
      "Skein1024-40": 45925,
      "Skein1024-48": 45926,
      "Skein1024-56": 45927,
      "Skein1024-64": 45928,
      "Skein1024-72": 45929,
      "Skein1024-80": 45930,
      "Skein1024-88": 45931,
      "Skein1024-96": 45932,
      "Skein1024-104": 45933,
      "Skein1024-112": 45934,
      "Skein1024-120": 45935,
      "Skein1024-128": 45936,
      "Skein1024-136": 45937,
      "Skein1024-144": 45938,
      "Skein1024-152": 45939,
      "Skein1024-160": 45940,
      "Skein1024-168": 45941,
      "Skein1024-176": 45942,
      "Skein1024-184": 45943,
      "Skein1024-192": 45944,
      "Skein1024-200": 45945,
      "Skein1024-208": 45946,
      "Skein1024-216": 45947,
      "Skein1024-224": 45948,
      "Skein1024-232": 45949,
      "Skein1024-240": 45950,
      "Skein1024-248": 45951,
      "Skein1024-256": 45952,
      "Skein1024-264": 45953,
      "Skein1024-272": 45954,
      "Skein1024-280": 45955,
      "Skein1024-288": 45956,
      "Skein1024-296": 45957,
      "Skein1024-304": 45958,
      "Skein1024-312": 45959,
      "Skein1024-320": 45960,
      "Skein1024-328": 45961,
      "Skein1024-336": 45962,
      "Skein1024-344": 45963,
      "Skein1024-352": 45964,
      "Skein1024-360": 45965,
      "Skein1024-368": 45966,
      "Skein1024-376": 45967,
      "Skein1024-384": 45968,
      "Skein1024-392": 45969,
      "Skein1024-400": 45970,
      "Skein1024-408": 45971,
      "Skein1024-416": 45972,
      "Skein1024-424": 45973,
      "Skein1024-432": 45974,
      "Skein1024-440": 45975,
      "Skein1024-448": 45976,
      "Skein1024-456": 45977,
      "Skein1024-464": 45978,
      "Skein1024-472": 45979,
      "Skein1024-480": 45980,
      "Skein1024-488": 45981,
      "Skein1024-496": 45982,
      "Skein1024-504": 45983,
      "Skein1024-512": 45984,
      "Skein1024-520": 45985,
      "Skein1024-528": 45986,
      "Skein1024-536": 45987,
      "Skein1024-544": 45988,
      "Skein1024-552": 45989,
      "Skein1024-560": 45990,
      "Skein1024-568": 45991,
      "Skein1024-576": 45992,
      "Skein1024-584": 45993,
      "Skein1024-592": 45994,
      "Skein1024-600": 45995,
      "Skein1024-608": 45996,
      "Skein1024-616": 45997,
      "Skein1024-624": 45998,
      "Skein1024-632": 45999,
      "Skein1024-640": 46e3,
      "Skein1024-648": 46001,
      "Skein1024-656": 46002,
      "Skein1024-664": 46003,
      "Skein1024-672": 46004,
      "Skein1024-680": 46005,
      "Skein1024-688": 46006,
      "Skein1024-696": 46007,
      "Skein1024-704": 46008,
      "Skein1024-712": 46009,
      "Skein1024-720": 46010,
      "Skein1024-728": 46011,
      "Skein1024-736": 46012,
      "Skein1024-744": 46013,
      "Skein1024-752": 46014,
      "Skein1024-760": 46015,
      "Skein1024-768": 46016,
      "Skein1024-776": 46017,
      "Skein1024-784": 46018,
      "Skein1024-792": 46019,
      "Skein1024-800": 46020,
      "Skein1024-808": 46021,
      "Skein1024-816": 46022,
      "Skein1024-824": 46023,
      "Skein1024-832": 46024,
      "Skein1024-840": 46025,
      "Skein1024-848": 46026,
      "Skein1024-856": 46027,
      "Skein1024-864": 46028,
      "Skein1024-872": 46029,
      "Skein1024-880": 46030,
      "Skein1024-888": 46031,
      "Skein1024-896": 46032,
      "Skein1024-904": 46033,
      "Skein1024-912": 46034,
      "Skein1024-920": 46035,
      "Skein1024-928": 46036,
      "Skein1024-936": 46037,
      "Skein1024-944": 46038,
      "Skein1024-952": 46039,
      "Skein1024-960": 46040,
      "Skein1024-968": 46041,
      "Skein1024-976": 46042,
      "Skein1024-984": 46043,
      "Skein1024-992": 46044,
      "Skein1024-1000": 46045,
      "Skein1024-1008": 46046,
      "Skein1024-1016": 46047,
      "Skein1024-1024": 46048
    });
    exports.codes = Object.freeze({
      0: "identity",
      17: "sha1",
      18: "sha2-256",
      19: "sha2-512",
      86: "dbl-sha2-256",
      23: "sha3-224",
      22: "sha3-256",
      21: "sha3-384",
      20: "sha3-512",
      24: "shake-128",
      25: "shake-256",
      26: "keccak-224",
      27: "keccak-256",
      28: "keccak-384",
      29: "keccak-512",
      34: "murmur3-128",
      35: "murmur3-32",
      212: "md4",
      213: "md5",
      45569: "blake2b-8",
      45570: "blake2b-16",
      45571: "blake2b-24",
      45572: "blake2b-32",
      45573: "blake2b-40",
      45574: "blake2b-48",
      45575: "blake2b-56",
      45576: "blake2b-64",
      45577: "blake2b-72",
      45578: "blake2b-80",
      45579: "blake2b-88",
      45580: "blake2b-96",
      45581: "blake2b-104",
      45582: "blake2b-112",
      45583: "blake2b-120",
      45584: "blake2b-128",
      45585: "blake2b-136",
      45586: "blake2b-144",
      45587: "blake2b-152",
      45588: "blake2b-160",
      45589: "blake2b-168",
      45590: "blake2b-176",
      45591: "blake2b-184",
      45592: "blake2b-192",
      45593: "blake2b-200",
      45594: "blake2b-208",
      45595: "blake2b-216",
      45596: "blake2b-224",
      45597: "blake2b-232",
      45598: "blake2b-240",
      45599: "blake2b-248",
      45600: "blake2b-256",
      45601: "blake2b-264",
      45602: "blake2b-272",
      45603: "blake2b-280",
      45604: "blake2b-288",
      45605: "blake2b-296",
      45606: "blake2b-304",
      45607: "blake2b-312",
      45608: "blake2b-320",
      45609: "blake2b-328",
      45610: "blake2b-336",
      45611: "blake2b-344",
      45612: "blake2b-352",
      45613: "blake2b-360",
      45614: "blake2b-368",
      45615: "blake2b-376",
      45616: "blake2b-384",
      45617: "blake2b-392",
      45618: "blake2b-400",
      45619: "blake2b-408",
      45620: "blake2b-416",
      45621: "blake2b-424",
      45622: "blake2b-432",
      45623: "blake2b-440",
      45624: "blake2b-448",
      45625: "blake2b-456",
      45626: "blake2b-464",
      45627: "blake2b-472",
      45628: "blake2b-480",
      45629: "blake2b-488",
      45630: "blake2b-496",
      45631: "blake2b-504",
      45632: "blake2b-512",
      45633: "blake2s-8",
      45634: "blake2s-16",
      45635: "blake2s-24",
      45636: "blake2s-32",
      45637: "blake2s-40",
      45638: "blake2s-48",
      45639: "blake2s-56",
      45640: "blake2s-64",
      45641: "blake2s-72",
      45642: "blake2s-80",
      45643: "blake2s-88",
      45644: "blake2s-96",
      45645: "blake2s-104",
      45646: "blake2s-112",
      45647: "blake2s-120",
      45648: "blake2s-128",
      45649: "blake2s-136",
      45650: "blake2s-144",
      45651: "blake2s-152",
      45652: "blake2s-160",
      45653: "blake2s-168",
      45654: "blake2s-176",
      45655: "blake2s-184",
      45656: "blake2s-192",
      45657: "blake2s-200",
      45658: "blake2s-208",
      45659: "blake2s-216",
      45660: "blake2s-224",
      45661: "blake2s-232",
      45662: "blake2s-240",
      45663: "blake2s-248",
      45664: "blake2s-256",
      45825: "Skein256-8",
      45826: "Skein256-16",
      45827: "Skein256-24",
      45828: "Skein256-32",
      45829: "Skein256-40",
      45830: "Skein256-48",
      45831: "Skein256-56",
      45832: "Skein256-64",
      45833: "Skein256-72",
      45834: "Skein256-80",
      45835: "Skein256-88",
      45836: "Skein256-96",
      45837: "Skein256-104",
      45838: "Skein256-112",
      45839: "Skein256-120",
      45840: "Skein256-128",
      45841: "Skein256-136",
      45842: "Skein256-144",
      45843: "Skein256-152",
      45844: "Skein256-160",
      45845: "Skein256-168",
      45846: "Skein256-176",
      45847: "Skein256-184",
      45848: "Skein256-192",
      45849: "Skein256-200",
      45850: "Skein256-208",
      45851: "Skein256-216",
      45852: "Skein256-224",
      45853: "Skein256-232",
      45854: "Skein256-240",
      45855: "Skein256-248",
      45856: "Skein256-256",
      45857: "Skein512-8",
      45858: "Skein512-16",
      45859: "Skein512-24",
      45860: "Skein512-32",
      45861: "Skein512-40",
      45862: "Skein512-48",
      45863: "Skein512-56",
      45864: "Skein512-64",
      45865: "Skein512-72",
      45866: "Skein512-80",
      45867: "Skein512-88",
      45868: "Skein512-96",
      45869: "Skein512-104",
      45870: "Skein512-112",
      45871: "Skein512-120",
      45872: "Skein512-128",
      45873: "Skein512-136",
      45874: "Skein512-144",
      45875: "Skein512-152",
      45876: "Skein512-160",
      45877: "Skein512-168",
      45878: "Skein512-176",
      45879: "Skein512-184",
      45880: "Skein512-192",
      45881: "Skein512-200",
      45882: "Skein512-208",
      45883: "Skein512-216",
      45884: "Skein512-224",
      45885: "Skein512-232",
      45886: "Skein512-240",
      45887: "Skein512-248",
      45888: "Skein512-256",
      45889: "Skein512-264",
      45890: "Skein512-272",
      45891: "Skein512-280",
      45892: "Skein512-288",
      45893: "Skein512-296",
      45894: "Skein512-304",
      45895: "Skein512-312",
      45896: "Skein512-320",
      45897: "Skein512-328",
      45898: "Skein512-336",
      45899: "Skein512-344",
      45900: "Skein512-352",
      45901: "Skein512-360",
      45902: "Skein512-368",
      45903: "Skein512-376",
      45904: "Skein512-384",
      45905: "Skein512-392",
      45906: "Skein512-400",
      45907: "Skein512-408",
      45908: "Skein512-416",
      45909: "Skein512-424",
      45910: "Skein512-432",
      45911: "Skein512-440",
      45912: "Skein512-448",
      45913: "Skein512-456",
      45914: "Skein512-464",
      45915: "Skein512-472",
      45916: "Skein512-480",
      45917: "Skein512-488",
      45918: "Skein512-496",
      45919: "Skein512-504",
      45920: "Skein512-512",
      45921: "Skein1024-8",
      45922: "Skein1024-16",
      45923: "Skein1024-24",
      45924: "Skein1024-32",
      45925: "Skein1024-40",
      45926: "Skein1024-48",
      45927: "Skein1024-56",
      45928: "Skein1024-64",
      45929: "Skein1024-72",
      45930: "Skein1024-80",
      45931: "Skein1024-88",
      45932: "Skein1024-96",
      45933: "Skein1024-104",
      45934: "Skein1024-112",
      45935: "Skein1024-120",
      45936: "Skein1024-128",
      45937: "Skein1024-136",
      45938: "Skein1024-144",
      45939: "Skein1024-152",
      45940: "Skein1024-160",
      45941: "Skein1024-168",
      45942: "Skein1024-176",
      45943: "Skein1024-184",
      45944: "Skein1024-192",
      45945: "Skein1024-200",
      45946: "Skein1024-208",
      45947: "Skein1024-216",
      45948: "Skein1024-224",
      45949: "Skein1024-232",
      45950: "Skein1024-240",
      45951: "Skein1024-248",
      45952: "Skein1024-256",
      45953: "Skein1024-264",
      45954: "Skein1024-272",
      45955: "Skein1024-280",
      45956: "Skein1024-288",
      45957: "Skein1024-296",
      45958: "Skein1024-304",
      45959: "Skein1024-312",
      45960: "Skein1024-320",
      45961: "Skein1024-328",
      45962: "Skein1024-336",
      45963: "Skein1024-344",
      45964: "Skein1024-352",
      45965: "Skein1024-360",
      45966: "Skein1024-368",
      45967: "Skein1024-376",
      45968: "Skein1024-384",
      45969: "Skein1024-392",
      45970: "Skein1024-400",
      45971: "Skein1024-408",
      45972: "Skein1024-416",
      45973: "Skein1024-424",
      45974: "Skein1024-432",
      45975: "Skein1024-440",
      45976: "Skein1024-448",
      45977: "Skein1024-456",
      45978: "Skein1024-464",
      45979: "Skein1024-472",
      45980: "Skein1024-480",
      45981: "Skein1024-488",
      45982: "Skein1024-496",
      45983: "Skein1024-504",
      45984: "Skein1024-512",
      45985: "Skein1024-520",
      45986: "Skein1024-528",
      45987: "Skein1024-536",
      45988: "Skein1024-544",
      45989: "Skein1024-552",
      45990: "Skein1024-560",
      45991: "Skein1024-568",
      45992: "Skein1024-576",
      45993: "Skein1024-584",
      45994: "Skein1024-592",
      45995: "Skein1024-600",
      45996: "Skein1024-608",
      45997: "Skein1024-616",
      45998: "Skein1024-624",
      45999: "Skein1024-632",
      46e3: "Skein1024-640",
      46001: "Skein1024-648",
      46002: "Skein1024-656",
      46003: "Skein1024-664",
      46004: "Skein1024-672",
      46005: "Skein1024-680",
      46006: "Skein1024-688",
      46007: "Skein1024-696",
      46008: "Skein1024-704",
      46009: "Skein1024-712",
      46010: "Skein1024-720",
      46011: "Skein1024-728",
      46012: "Skein1024-736",
      46013: "Skein1024-744",
      46014: "Skein1024-752",
      46015: "Skein1024-760",
      46016: "Skein1024-768",
      46017: "Skein1024-776",
      46018: "Skein1024-784",
      46019: "Skein1024-792",
      46020: "Skein1024-800",
      46021: "Skein1024-808",
      46022: "Skein1024-816",
      46023: "Skein1024-824",
      46024: "Skein1024-832",
      46025: "Skein1024-840",
      46026: "Skein1024-848",
      46027: "Skein1024-856",
      46028: "Skein1024-864",
      46029: "Skein1024-872",
      46030: "Skein1024-880",
      46031: "Skein1024-888",
      46032: "Skein1024-896",
      46033: "Skein1024-904",
      46034: "Skein1024-912",
      46035: "Skein1024-920",
      46036: "Skein1024-928",
      46037: "Skein1024-936",
      46038: "Skein1024-944",
      46039: "Skein1024-952",
      46040: "Skein1024-960",
      46041: "Skein1024-968",
      46042: "Skein1024-976",
      46043: "Skein1024-984",
      46044: "Skein1024-992",
      46045: "Skein1024-1000",
      46046: "Skein1024-1008",
      46047: "Skein1024-1016",
      46048: "Skein1024-1024"
    });
    exports.defaultLengths = Object.freeze({
      17: 20,
      18: 32,
      19: 64,
      86: 32,
      23: 28,
      22: 32,
      21: 48,
      20: 64,
      24: 32,
      25: 64,
      26: 28,
      27: 32,
      28: 48,
      29: 64,
      34: 32,
      45569: 1,
      45570: 2,
      45571: 3,
      45572: 4,
      45573: 5,
      45574: 6,
      45575: 7,
      45576: 8,
      45577: 9,
      45578: 10,
      45579: 11,
      45580: 12,
      45581: 13,
      45582: 14,
      45583: 15,
      45584: 16,
      45585: 17,
      45586: 18,
      45587: 19,
      45588: 20,
      45589: 21,
      45590: 22,
      45591: 23,
      45592: 24,
      45593: 25,
      45594: 26,
      45595: 27,
      45596: 28,
      45597: 29,
      45598: 30,
      45599: 31,
      45600: 32,
      45601: 33,
      45602: 34,
      45603: 35,
      45604: 36,
      45605: 37,
      45606: 38,
      45607: 39,
      45608: 40,
      45609: 41,
      45610: 42,
      45611: 43,
      45612: 44,
      45613: 45,
      45614: 46,
      45615: 47,
      45616: 48,
      45617: 49,
      45618: 50,
      45619: 51,
      45620: 52,
      45621: 53,
      45622: 54,
      45623: 55,
      45624: 56,
      45625: 57,
      45626: 58,
      45627: 59,
      45628: 60,
      45629: 61,
      45630: 62,
      45631: 63,
      45632: 64,
      45633: 1,
      45634: 2,
      45635: 3,
      45636: 4,
      45637: 5,
      45638: 6,
      45639: 7,
      45640: 8,
      45641: 9,
      45642: 10,
      45643: 11,
      45644: 12,
      45645: 13,
      45646: 14,
      45647: 15,
      45648: 16,
      45649: 17,
      45650: 18,
      45651: 19,
      45652: 20,
      45653: 21,
      45654: 22,
      45655: 23,
      45656: 24,
      45657: 25,
      45658: 26,
      45659: 27,
      45660: 28,
      45661: 29,
      45662: 30,
      45663: 31,
      45664: 32,
      45825: 1,
      45826: 2,
      45827: 3,
      45828: 4,
      45829: 5,
      45830: 6,
      45831: 7,
      45832: 8,
      45833: 9,
      45834: 10,
      45835: 11,
      45836: 12,
      45837: 13,
      45838: 14,
      45839: 15,
      45840: 16,
      45841: 17,
      45842: 18,
      45843: 19,
      45844: 20,
      45845: 21,
      45846: 22,
      45847: 23,
      45848: 24,
      45849: 25,
      45850: 26,
      45851: 27,
      45852: 28,
      45853: 29,
      45854: 30,
      45855: 31,
      45856: 32,
      45857: 1,
      45858: 2,
      45859: 3,
      45860: 4,
      45861: 5,
      45862: 6,
      45863: 7,
      45864: 8,
      45865: 9,
      45866: 10,
      45867: 11,
      45868: 12,
      45869: 13,
      45870: 14,
      45871: 15,
      45872: 16,
      45873: 17,
      45874: 18,
      45875: 19,
      45876: 20,
      45877: 21,
      45878: 22,
      45879: 23,
      45880: 24,
      45881: 25,
      45882: 26,
      45883: 27,
      45884: 28,
      45885: 29,
      45886: 30,
      45887: 31,
      45888: 32,
      45889: 33,
      45890: 34,
      45891: 35,
      45892: 36,
      45893: 37,
      45894: 38,
      45895: 39,
      45896: 40,
      45897: 41,
      45898: 42,
      45899: 43,
      45900: 44,
      45901: 45,
      45902: 46,
      45903: 47,
      45904: 48,
      45905: 49,
      45906: 50,
      45907: 51,
      45908: 52,
      45909: 53,
      45910: 54,
      45911: 55,
      45912: 56,
      45913: 57,
      45914: 58,
      45915: 59,
      45916: 60,
      45917: 61,
      45918: 62,
      45919: 63,
      45920: 64,
      45921: 1,
      45922: 2,
      45923: 3,
      45924: 4,
      45925: 5,
      45926: 6,
      45927: 7,
      45928: 8,
      45929: 9,
      45930: 10,
      45931: 11,
      45932: 12,
      45933: 13,
      45934: 14,
      45935: 15,
      45936: 16,
      45937: 17,
      45938: 18,
      45939: 19,
      45940: 20,
      45941: 21,
      45942: 22,
      45943: 23,
      45944: 24,
      45945: 25,
      45946: 26,
      45947: 27,
      45948: 28,
      45949: 29,
      45950: 30,
      45951: 31,
      45952: 32,
      45953: 33,
      45954: 34,
      45955: 35,
      45956: 36,
      45957: 37,
      45958: 38,
      45959: 39,
      45960: 40,
      45961: 41,
      45962: 42,
      45963: 43,
      45964: 44,
      45965: 45,
      45966: 46,
      45967: 47,
      45968: 48,
      45969: 49,
      45970: 50,
      45971: 51,
      45972: 52,
      45973: 53,
      45974: 54,
      45975: 55,
      45976: 56,
      45977: 57,
      45978: 58,
      45979: 59,
      45980: 60,
      45981: 61,
      45982: 62,
      45983: 63,
      45984: 64,
      45985: 65,
      45986: 66,
      45987: 67,
      45988: 68,
      45989: 69,
      45990: 70,
      45991: 71,
      45992: 72,
      45993: 73,
      45994: 74,
      45995: 75,
      45996: 76,
      45997: 77,
      45998: 78,
      45999: 79,
      46e3: 80,
      46001: 81,
      46002: 82,
      46003: 83,
      46004: 84,
      46005: 85,
      46006: 86,
      46007: 87,
      46008: 88,
      46009: 89,
      46010: 90,
      46011: 91,
      46012: 92,
      46013: 93,
      46014: 94,
      46015: 95,
      46016: 96,
      46017: 97,
      46018: 98,
      46019: 99,
      46020: 100,
      46021: 101,
      46022: 102,
      46023: 103,
      46024: 104,
      46025: 105,
      46026: 106,
      46027: 107,
      46028: 108,
      46029: 109,
      46030: 110,
      46031: 111,
      46032: 112,
      46033: 113,
      46034: 114,
      46035: 115,
      46036: 116,
      46037: 117,
      46038: 118,
      46039: 119,
      46040: 120,
      46041: 121,
      46042: 122,
      46043: 123,
      46044: 124,
      46045: 125,
      46046: 126,
      46047: 127,
      46048: 128
    });
  }
});

// node_modules/multihashes/src/index.js
var require_src4 = __commonJS({
  "node_modules/multihashes/src/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var { Buffer: Buffer2 } = require_buffer2();
    var multibase = require_src3();
    var varint = require_varint();
    var cs = require_constants3();
    exports.names = cs.names;
    exports.codes = cs.codes;
    exports.defaultLengths = cs.defaultLengths;
    exports.toHexString = function toHexString(hash) {
      if (!Buffer2.isBuffer(hash)) {
        throw new Error("must be passed a buffer");
      }
      return hash.toString("hex");
    };
    exports.fromHexString = function fromHexString(hash) {
      return Buffer2.from(hash, "hex");
    };
    exports.toB58String = function toB58String(hash) {
      if (!Buffer2.isBuffer(hash)) {
        throw new Error("must be passed a buffer");
      }
      return multibase.encode("base58btc", hash).toString().slice(1);
    };
    exports.fromB58String = function fromB58String(hash) {
      let encoded = hash;
      if (Buffer2.isBuffer(hash)) {
        encoded = hash.toString();
      }
      return multibase.decode("z" + encoded);
    };
    exports.decode = function decode2(buf) {
      if (!Buffer2.isBuffer(buf)) {
        throw new Error("multihash must be a Buffer");
      }
      if (buf.length < 2) {
        throw new Error("multihash too short. must be > 2 bytes.");
      }
      const code = varint.decode(buf);
      if (!exports.isValidCode(code)) {
        throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);
      }
      buf = buf.slice(varint.decode.bytes);
      const len = varint.decode(buf);
      if (len < 0) {
        throw new Error(`multihash invalid length: ${len}`);
      }
      buf = buf.slice(varint.decode.bytes);
      if (buf.length !== len) {
        throw new Error(`multihash length inconsistent: 0x${buf.toString("hex")}`);
      }
      return {
        code,
        name: cs.codes[code],
        length: len,
        digest: buf
      };
    };
    exports.encode = function encode2(digest, code, length) {
      if (!digest || code === void 0) {
        throw new Error("multihash encode requires at least two args: digest, code");
      }
      const hashfn = exports.coerceCode(code);
      if (!Buffer2.isBuffer(digest)) {
        throw new Error("digest should be a Buffer");
      }
      if (length == null) {
        length = digest.length;
      }
      if (length && digest.length !== length) {
        throw new Error("digest length should be equal to specified length.");
      }
      return Buffer2.concat([
        Buffer2.from(varint.encode(hashfn)),
        Buffer2.from(varint.encode(length)),
        digest
      ]);
    };
    exports.coerceCode = function coerceCode(name2) {
      let code = name2;
      if (typeof name2 === "string") {
        if (cs.names[name2] === void 0) {
          throw new Error(`Unrecognized hash function named: ${name2}`);
        }
        code = cs.names[name2];
      }
      if (typeof code !== "number") {
        throw new Error(`Hash function code should be a number. Got: ${code}`);
      }
      if (cs.codes[code] === void 0 && !exports.isAppCode(code)) {
        throw new Error(`Unrecognized function code: ${code}`);
      }
      return code;
    };
    exports.isAppCode = function appCode(code) {
      return code > 0 && code < 16;
    };
    exports.isValidCode = function validCode(code) {
      if (exports.isAppCode(code)) {
        return true;
      }
      if (cs.codes[code]) {
        return true;
      }
      return false;
    };
    function validate(multihash) {
      exports.decode(multihash);
    }
    exports.validate = validate;
    exports.prefix = function prefix(multihash) {
      validate(multihash);
      return multihash.slice(0, 2);
    };
  }
});

// node_modules/multibase/node_modules/buffer/index.js
var require_buffer3 = __commonJS({
  "node_modules/multibase/node_modules/buffer/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer2.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});

// node_modules/multibase/src/base.js
var require_base2 = __commonJS({
  "node_modules/multibase/src/base.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Base = class {
      constructor(name2, code, implementation, alphabet) {
        this.name = name2;
        this.code = code;
        this.alphabet = alphabet;
        if (implementation && alphabet) {
          this.engine = implementation(alphabet);
        }
      }
      encode(stringOrBuffer) {
        return this.engine.encode(stringOrBuffer);
      }
      decode(stringOrBuffer) {
        return this.engine.decode(stringOrBuffer);
      }
      isImplemented() {
        return this.engine;
      }
    };
    module.exports = Base;
  }
});

// node_modules/multibase/src/base16.js
var require_base162 = __commonJS({
  "node_modules/multibase/src/base16.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { Buffer: Buffer2 } = require_buffer3();
    module.exports = function base16(alphabet) {
      return {
        encode(input) {
          if (typeof input === "string") {
            return Buffer2.from(input).toString("hex");
          }
          return input.toString("hex");
        },
        decode(input) {
          for (const char of input) {
            if (alphabet.indexOf(char) < 0) {
              throw new Error("invalid base16 character");
            }
          }
          return Buffer2.from(input, "hex");
        }
      };
    };
  }
});

// node_modules/multibase/src/base32.js
var require_base322 = __commonJS({
  "node_modules/multibase/src/base32.js"(exports, module) {
    "use strict";
    init_define_process_env();
    function decode2(input, alphabet) {
      input = input.replace(new RegExp("=", "g"), "");
      const length = input.length;
      let bits = 0;
      let value = 0;
      let index = 0;
      const output = new Uint8Array(length * 5 / 8 | 0);
      for (let i = 0; i < length; i++) {
        value = value << 5 | alphabet.indexOf(input[i]);
        bits += 5;
        if (bits >= 8) {
          output[index++] = value >>> bits - 8 & 255;
          bits -= 8;
        }
      }
      return output.buffer;
    }
    function encode2(buffer, alphabet) {
      const length = buffer.byteLength;
      const view = new Uint8Array(buffer);
      const padding = alphabet.indexOf("=") === alphabet.length - 1;
      if (padding) {
        alphabet = alphabet.substring(0, alphabet.length - 1);
      }
      let bits = 0;
      let value = 0;
      let output = "";
      for (let i = 0; i < length; i++) {
        value = value << 8 | view[i];
        bits += 8;
        while (bits >= 5) {
          output += alphabet[value >>> bits - 5 & 31];
          bits -= 5;
        }
      }
      if (bits > 0) {
        output += alphabet[value << 5 - bits & 31];
      }
      if (padding) {
        while (output.length % 8 !== 0) {
          output += "=";
        }
      }
      return output;
    }
    module.exports = function base32(alphabet) {
      return {
        encode(input) {
          if (typeof input === "string") {
            return encode2(Uint8Array.from(input), alphabet);
          }
          return encode2(input, alphabet);
        },
        decode(input) {
          for (const char of input) {
            if (alphabet.indexOf(char) < 0) {
              throw new Error("invalid base32 character");
            }
          }
          return decode2(input, alphabet);
        }
      };
    };
  }
});

// node_modules/multibase/src/base64.js
var require_base642 = __commonJS({
  "node_modules/multibase/src/base64.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { Buffer: Buffer2 } = require_buffer3();
    module.exports = function base64(alphabet) {
      const padding = alphabet.indexOf("=") > -1;
      const url = alphabet.indexOf("-") > -1 && alphabet.indexOf("_") > -1;
      return {
        encode(input) {
          let output = "";
          if (typeof input === "string") {
            output = Buffer2.from(input).toString("base64");
          } else {
            output = input.toString("base64");
          }
          if (url) {
            output = output.replace(/\+/g, "-").replace(/\//g, "_");
          }
          const pad = output.indexOf("=");
          if (pad > 0 && !padding) {
            output = output.substring(0, pad);
          }
          return output;
        },
        decode(input) {
          for (const char of input) {
            if (alphabet.indexOf(char) < 0) {
              throw new Error("invalid base64 character");
            }
          }
          return Buffer2.from(input, "base64");
        }
      };
    };
  }
});

// node_modules/multibase/src/constants.js
var require_constants4 = __commonJS({
  "node_modules/multibase/src/constants.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Base = require_base2();
    var baseX = require_src();
    var base16 = require_base162();
    var base32 = require_base322();
    var base64 = require_base642();
    var constants = [
      ["base1", "1", "", "1"],
      ["base2", "0", baseX, "01"],
      ["base8", "7", baseX, "01234567"],
      ["base10", "9", baseX, "0123456789"],
      ["base16", "f", base16, "0123456789abcdef"],
      ["base32", "b", base32, "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32pad", "c", base32, "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32hex", "v", base32, "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexpad", "t", base32, "0123456789abcdefghijklmnopqrstuv="],
      ["base32z", "h", base32, "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base64", "m", base64, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", base64, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", base64, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", base64, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names = constants.reduce((prev, tupple) => {
      prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
      return prev;
    }, {});
    var codes = constants.reduce((prev, tupple) => {
      prev[tupple[1]] = names[tupple[0]];
      return prev;
    }, {});
    module.exports = {
      names,
      codes
    };
  }
});

// node_modules/multibase/src/index.js
var require_src5 = __commonJS({
  "node_modules/multibase/src/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { Buffer: Buffer2 } = require_buffer3();
    var constants = require_constants4();
    exports = module.exports = multibase;
    exports.encode = encode2;
    exports.decode = decode2;
    exports.isEncoded = isEncoded;
    exports.names = Object.freeze(Object.keys(constants.names));
    exports.codes = Object.freeze(Object.keys(constants.codes));
    var errNotSupported = new Error("Unsupported encoding");
    function multibase(nameOrCode, buf) {
      if (!buf) {
        throw new Error("requires an encoded buffer");
      }
      const base2 = getBase(nameOrCode);
      const codeBuf = Buffer2.from(base2.code);
      const name2 = base2.name;
      validEncode(name2, buf);
      return Buffer2.concat([codeBuf, buf]);
    }
    function encode2(nameOrCode, buf) {
      const base2 = getBase(nameOrCode);
      const name2 = base2.name;
      return multibase(name2, Buffer2.from(base2.encode(buf)));
    }
    function decode2(bufOrString) {
      if (Buffer2.isBuffer(bufOrString)) {
        bufOrString = bufOrString.toString();
      }
      const code = bufOrString.substring(0, 1);
      bufOrString = bufOrString.substring(1, bufOrString.length);
      if (typeof bufOrString === "string") {
        bufOrString = Buffer2.from(bufOrString);
      }
      const base2 = getBase(code);
      return Buffer2.from(base2.decode(bufOrString.toString()));
    }
    function isEncoded(bufOrString) {
      if (Buffer2.isBuffer(bufOrString)) {
        bufOrString = bufOrString.toString();
      }
      if (Object.prototype.toString.call(bufOrString) !== "[object String]") {
        return false;
      }
      const code = bufOrString.substring(0, 1);
      try {
        const base2 = getBase(code);
        return base2.name;
      } catch (err) {
        return false;
      }
    }
    function validEncode(name2, buf) {
      const base2 = getBase(name2);
      base2.decode(buf.toString());
    }
    function getBase(nameOrCode) {
      let base2;
      if (constants.names[nameOrCode]) {
        base2 = constants.names[nameOrCode];
      } else if (constants.codes[nameOrCode]) {
        base2 = constants.codes[nameOrCode];
      } else {
        throw errNotSupported;
      }
      if (!base2.isImplemented()) {
        throw new Error("Base " + nameOrCode + " is not implemented yet");
      }
      return base2;
    }
  }
});

// node_modules/cids/node_modules/multicodec/src/base-table.json
var require_base_table2 = __commonJS({
  "node_modules/cids/node_modules/multicodec/src/base-table.json"(exports, module) {
    module.exports = {
      identity: 0,
      ip4: 4,
      tcp: 6,
      sha1: 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      blake3: 30,
      dccp: 33,
      "murmur3-128": 34,
      "murmur3-32": 35,
      ip6: 41,
      ip6zone: 42,
      path: 47,
      multicodec: 48,
      multihash: 49,
      multiaddr: 50,
      multibase: 51,
      dns: 53,
      dns4: 54,
      dns6: 55,
      dnsaddr: 56,
      protobuf: 80,
      cbor: 81,
      raw: 85,
      "dbl-sha2-256": 86,
      rlp: 96,
      bencode: 99,
      "dag-pb": 112,
      "dag-cbor": 113,
      "libp2p-key": 114,
      "git-raw": 120,
      "torrent-info": 123,
      "torrent-file": 124,
      "leofcoin-block": 129,
      "leofcoin-tx": 130,
      "leofcoin-pr": 131,
      sctp: 132,
      "dag-jose": 133,
      "dag-cose": 134,
      "eth-block": 144,
      "eth-block-list": 145,
      "eth-tx-trie": 146,
      "eth-tx": 147,
      "eth-tx-receipt-trie": 148,
      "eth-tx-receipt": 149,
      "eth-state-trie": 150,
      "eth-account-snapshot": 151,
      "eth-storage-trie": 152,
      "bitcoin-block": 176,
      "bitcoin-tx": 177,
      "bitcoin-witness-commitment": 178,
      "zcash-block": 192,
      "zcash-tx": 193,
      "stellar-block": 208,
      "stellar-tx": 209,
      md4: 212,
      md5: 213,
      bmt: 214,
      "decred-block": 224,
      "decred-tx": 225,
      "ipld-ns": 226,
      "ipfs-ns": 227,
      "swarm-ns": 228,
      "ipns-ns": 229,
      zeronet: 230,
      "secp256k1-pub": 231,
      "bls12_381-g1-pub": 234,
      "bls12_381-g2-pub": 235,
      "x25519-pub": 236,
      "ed25519-pub": 237,
      "dash-block": 240,
      "dash-tx": 241,
      "swarm-manifest": 250,
      "swarm-feed": 251,
      udp: 273,
      "p2p-webrtc-star": 275,
      "p2p-webrtc-direct": 276,
      "p2p-stardust": 277,
      "p2p-circuit": 290,
      "dag-json": 297,
      udt: 301,
      utp: 302,
      unix: 400,
      p2p: 421,
      ipfs: 421,
      https: 443,
      onion: 444,
      onion3: 445,
      garlic64: 446,
      garlic32: 447,
      tls: 448,
      quic: 460,
      ws: 477,
      wss: 478,
      "p2p-websocket-star": 479,
      http: 480,
      json: 512,
      messagepack: 513,
      "libp2p-peer-record": 769,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      x11: 4352,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082,
      "zeroxcert-imprint-256": 52753,
      "fil-commitment-unsealed": 61697,
      "fil-commitment-sealed": 61698,
      "holochain-adr-v0": 8417572,
      "holochain-adr-v1": 8483108,
      "holochain-key-v0": 9728292,
      "holochain-key-v1": 9793828,
      "holochain-sig-v0": 10645796,
      "holochain-sig-v1": 10711332
    };
  }
});

// node_modules/cids/node_modules/multicodec/src/int-table.js
var require_int_table2 = __commonJS({
  "node_modules/cids/node_modules/multicodec/src/int-table.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var baseTable = require_base_table2();
    var nameTable = /* @__PURE__ */ new Map();
    for (const encodingName in baseTable) {
      const code = baseTable[encodingName];
      nameTable.set(code, encodingName);
    }
    module.exports = Object.freeze(nameTable);
  }
});

// node_modules/cids/node_modules/multicodec/src/util.js
var require_util3 = __commonJS({
  "node_modules/cids/node_modules/multicodec/src/util.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var varint = require_varint();
    var { Buffer: Buffer2 } = require_buffer();
    module.exports = {
      numberToBuffer,
      bufferToNumber,
      varintBufferEncode,
      varintBufferDecode,
      varintEncode
    };
    function bufferToNumber(buf) {
      return parseInt(buf.toString("hex"), 16);
    }
    function numberToBuffer(num) {
      let hexString = num.toString(16);
      if (hexString.length % 2 === 1) {
        hexString = "0" + hexString;
      }
      return Buffer2.from(hexString, "hex");
    }
    function varintBufferEncode(input) {
      return Buffer2.from(varint.encode(bufferToNumber(input)));
    }
    function varintBufferDecode(input) {
      return numberToBuffer(varint.decode(input));
    }
    function varintEncode(num) {
      return Buffer2.from(varint.encode(num));
    }
  }
});

// node_modules/cids/node_modules/multicodec/src/varint-table.js
var require_varint_table2 = __commonJS({
  "node_modules/cids/node_modules/multicodec/src/varint-table.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var baseTable = require_base_table2();
    var varintEncode = require_util3().varintEncode;
    var varintTable = {};
    for (const encodingName in baseTable) {
      const code = baseTable[encodingName];
      varintTable[encodingName] = varintEncode(code);
    }
    module.exports = Object.freeze(varintTable);
  }
});

// node_modules/cids/node_modules/multicodec/src/constants.js
var require_constants5 = __commonJS({
  "node_modules/cids/node_modules/multicodec/src/constants.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var table = require_base_table2();
    var constants = {};
    for (const [name2, code] of Object.entries(table)) {
      constants[name2.toUpperCase().replace(/-/g, "_")] = code;
    }
    module.exports = Object.freeze(constants);
  }
});

// node_modules/cids/node_modules/multicodec/src/print.js
var require_print2 = __commonJS({
  "node_modules/cids/node_modules/multicodec/src/print.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var table = require_base_table2();
    var tableByCode = {};
    for (const [name2, code] of Object.entries(table)) {
      if (tableByCode[code] === void 0)
        tableByCode[code] = name2;
    }
    module.exports = Object.freeze(tableByCode);
  }
});

// node_modules/cids/node_modules/multicodec/src/index.js
var require_src6 = __commonJS({
  "node_modules/cids/node_modules/multicodec/src/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { Buffer: Buffer2 } = require_buffer();
    var varint = require_varint();
    var intTable = require_int_table2();
    var codecNameToCodeVarint = require_varint_table2();
    var util = require_util3();
    exports = module.exports;
    exports.addPrefix = (multicodecStrOrCode, data) => {
      let prefix;
      if (Buffer2.isBuffer(multicodecStrOrCode)) {
        prefix = util.varintBufferEncode(multicodecStrOrCode);
      } else {
        if (codecNameToCodeVarint[multicodecStrOrCode]) {
          prefix = codecNameToCodeVarint[multicodecStrOrCode];
        } else {
          throw new Error("multicodec not recognized");
        }
      }
      return Buffer2.concat([prefix, data]);
    };
    exports.rmPrefix = (data) => {
      varint.decode(data);
      return data.slice(varint.decode.bytes);
    };
    exports.getCodec = (prefixedData) => {
      const code = varint.decode(prefixedData);
      const codecName = intTable.get(code);
      if (codecName === void 0) {
        throw new Error(`Code ${code} not found`);
      }
      return codecName;
    };
    exports.getName = (codec) => {
      return intTable.get(codec);
    };
    exports.getNumber = (name2) => {
      const code = codecNameToCodeVarint[name2];
      if (code === void 0) {
        throw new Error("Codec `" + name2 + "` not found");
      }
      return util.varintBufferDecode(code)[0];
    };
    exports.getCode = (prefixedData) => {
      return varint.decode(prefixedData);
    };
    exports.getCodeVarint = (codecName) => {
      const code = codecNameToCodeVarint[codecName];
      if (code === void 0) {
        throw new Error("Codec `" + codecName + "` not found");
      }
      return code;
    };
    exports.getVarint = (code) => {
      return varint.encode(code);
    };
    var constants = require_constants5();
    Object.assign(exports, constants);
    exports.print = require_print2();
  }
});

// node_modules/cids/src/cid-util.js
var require_cid_util = __commonJS({
  "node_modules/cids/src/cid-util.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var mh = require_src4();
    var { Buffer: Buffer2 } = require_buffer();
    var CIDUtil = {
      checkCIDComponents: function(other) {
        if (other == null) {
          return "null values are not valid CIDs";
        }
        if (!(other.version === 0 || other.version === 1)) {
          return "Invalid version, must be a number equal to 1 or 0";
        }
        if (typeof other.codec !== "string") {
          return "codec must be string";
        }
        if (other.version === 0) {
          if (other.codec !== "dag-pb") {
            return "codec must be 'dag-pb' for CIDv0";
          }
          if (other.multibaseName !== "base58btc") {
            return "multibaseName must be 'base58btc' for CIDv0";
          }
        }
        if (!Buffer2.isBuffer(other.multihash)) {
          return "multihash must be a Buffer";
        }
        try {
          mh.validate(other.multihash);
        } catch (err) {
          let errorMsg = err.message;
          if (!errorMsg) {
            errorMsg = "Multihash validation failed";
          }
          return errorMsg;
        }
      }
    };
    module.exports = CIDUtil;
  }
});

// node_modules/class-is/index.js
var require_class_is = __commonJS({
  "node_modules/class-is/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    function withIs(Class, { className, symbolName }) {
      const symbol = Symbol.for(symbolName);
      const ClassIsWrapper = {
        [className]: class extends Class {
          constructor(...args) {
            super(...args);
            Object.defineProperty(this, symbol, { value: true });
          }
          get [Symbol.toStringTag]() {
            return className;
          }
        }
      }[className];
      ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);
      return ClassIsWrapper;
    }
    function withIsProto(Class, { className, symbolName, withoutNew }) {
      const symbol = Symbol.for(symbolName);
      const ClassIsWrapper = {
        [className]: function(...args) {
          if (withoutNew && !(this instanceof ClassIsWrapper)) {
            return new ClassIsWrapper(...args);
          }
          const _this = Class.call(this, ...args) || this;
          if (_this && !_this[symbol]) {
            Object.defineProperty(_this, symbol, { value: true });
          }
          return _this;
        }
      }[className];
      ClassIsWrapper.prototype = Object.create(Class.prototype);
      ClassIsWrapper.prototype.constructor = ClassIsWrapper;
      Object.defineProperty(ClassIsWrapper.prototype, Symbol.toStringTag, {
        get() {
          return className;
        }
      });
      ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);
      return ClassIsWrapper;
    }
    module.exports = withIs;
    module.exports.proto = withIsProto;
  }
});

// node_modules/cids/src/index.js
var require_src7 = __commonJS({
  "node_modules/cids/src/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { Buffer: Buffer2 } = require_buffer();
    var mh = require_src4();
    var multibase = require_src5();
    var multicodec = require_src6();
    var codecs = require_base_table2();
    var CIDUtil = require_cid_util();
    var withIs = require_class_is();
    var CID = class {
      constructor(version, codec, multihash, multibaseName) {
        if (_CID.isCID(version)) {
          const cid = version;
          this.version = cid.version;
          this.codec = cid.codec;
          this.multihash = Buffer2.from(cid.multihash);
          this.multibaseName = cid.multibaseName || (cid.version === 0 ? "base58btc" : "base32");
          return;
        }
        if (typeof version === "string") {
          const baseName = multibase.isEncoded(version);
          if (baseName) {
            const cid = multibase.decode(version);
            this.version = parseInt(cid.slice(0, 1).toString("hex"), 16);
            this.codec = multicodec.getCodec(cid.slice(1));
            this.multihash = multicodec.rmPrefix(cid.slice(1));
            this.multibaseName = baseName;
          } else {
            this.version = 0;
            this.codec = "dag-pb";
            this.multihash = mh.fromB58String(version);
            this.multibaseName = "base58btc";
          }
          CID.validateCID(this);
          Object.defineProperty(this, "string", { value: version });
          return;
        }
        if (Buffer2.isBuffer(version)) {
          const firstByte = version.slice(0, 1);
          const v = parseInt(firstByte.toString("hex"), 16);
          if (v === 1) {
            const cid = version;
            this.version = v;
            this.codec = multicodec.getCodec(cid.slice(1));
            this.multihash = multicodec.rmPrefix(cid.slice(1));
            this.multibaseName = "base32";
          } else {
            this.version = 0;
            this.codec = "dag-pb";
            this.multihash = version;
            this.multibaseName = "base58btc";
          }
          CID.validateCID(this);
          return;
        }
        this.version = version;
        this.codec = codec;
        this.multihash = multihash;
        this.multibaseName = multibaseName || (version === 0 ? "base58btc" : "base32");
        CID.validateCID(this);
      }
      get buffer() {
        let buffer = this._buffer;
        if (!buffer) {
          if (this.version === 0) {
            buffer = this.multihash;
          } else if (this.version === 1) {
            buffer = Buffer2.concat([
              Buffer2.from("01", "hex"),
              multicodec.getCodeVarint(this.codec),
              this.multihash
            ]);
          } else {
            throw new Error("unsupported version");
          }
          Object.defineProperty(this, "_buffer", { value: buffer });
        }
        return buffer;
      }
      get prefix() {
        return Buffer2.concat([
          Buffer2.from(`0${this.version}`, "hex"),
          multicodec.getCodeVarint(this.codec),
          mh.prefix(this.multihash)
        ]);
      }
      toV0() {
        if (this.codec !== "dag-pb") {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        const { name: name2, length } = mh.decode(this.multihash);
        if (name2 !== "sha2-256") {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        if (length !== 32) {
          throw new Error("Cannot convert non 32 byte multihash CID to CIDv0");
        }
        return new _CID(0, this.codec, this.multihash);
      }
      toV1() {
        return new _CID(1, this.codec, this.multihash);
      }
      toBaseEncodedString(base2 = this.multibaseName) {
        if (this.string && base2 === this.multibaseName) {
          return this.string;
        }
        let str = null;
        if (this.version === 0) {
          if (base2 !== "base58btc") {
            throw new Error("not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()");
          }
          str = mh.toB58String(this.multihash);
        } else if (this.version === 1) {
          str = multibase.encode(base2, this.buffer).toString();
        } else {
          throw new Error("unsupported version");
        }
        if (base2 === this.multibaseName) {
          Object.defineProperty(this, "string", { value: str });
        }
        return str;
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      toString(base2) {
        return this.toBaseEncodedString(base2);
      }
      toJSON() {
        return {
          codec: this.codec,
          version: this.version,
          hash: this.multihash
        };
      }
      equals(other) {
        return this.codec === other.codec && this.version === other.version && this.multihash.equals(other.multihash);
      }
      static validateCID(other) {
        const errorMsg = CIDUtil.checkCIDComponents(other);
        if (errorMsg) {
          throw new Error(errorMsg);
        }
      }
    };
    var _CID = withIs(CID, {
      className: "CID",
      symbolName: "@ipld/js-cid/CID"
    });
    _CID.codecs = codecs;
    module.exports = _CID;
  }
});

// node_modules/content-hash/src/profiles.js
var require_profiles = __commonJS({
  "node_modules/content-hash/src/profiles.js"(exports) {
    init_define_process_env();
    var CID = require_src7();
    var multiH = require_src4();
    var hexStringToBuffer = (hex) => {
      let prefix = hex.slice(0, 2);
      let value = hex.slice(2);
      let res = "";
      if (prefix === "0x")
        res = value;
      else
        res = hex;
      return multiH.fromHexString(res);
    };
    var encodes = {
      swarm: (value) => {
        const multihash = multiH.encode(hexStringToBuffer(value), "keccak-256");
        return new CID(1, "swarm-manifest", multihash).buffer;
      },
      ipfs: (value) => {
        const multihash = multiH.fromB58String(value);
        return new CID(1, "dag-pb", multihash).buffer;
      },
      utf8: (value) => {
        return Buffer.from(value, "utf8");
      }
    };
    var decodes = {
      hexMultiHash: (value) => {
        const cid = new CID(value);
        return multiH.decode(cid.multihash).digest.toString("hex");
      },
      b58MultiHash: (value) => {
        const cid = new CID(value);
        return multiH.toB58String(cid.multihash);
      },
      utf8: (value) => {
        return value.toString("utf8");
      }
    };
    var profiles = {
      "swarm-ns": {
        encode: encodes.swarm,
        decode: decodes.hexMultiHash
      },
      "ipfs-ns": {
        encode: encodes.ipfs,
        decode: decodes.b58MultiHash
      },
      "ipns-ns": {
        encode: encodes.ipfs,
        decode: decodes.b58MultiHash
      },
      "default": {
        encode: encodes.utf8,
        decode: decodes.utf8
      }
    };
    exports.hexStringToBuffer = hexStringToBuffer;
    exports.profiles = profiles;
  }
});

// node_modules/content-hash/src/helpers.js
var require_helpers4 = __commonJS({
  "node_modules/content-hash/src/helpers.js"(exports) {
    init_define_process_env();
    var CID = require_src7();
    var cidV0ToV1Base32 = (ipfsHash) => {
      let cid = new CID(ipfsHash);
      if (cid.version === 0) {
        cid = cid.toV1();
      }
      return cid.toString("base32");
    };
    exports.cidV0ToV1Base32 = cidV0ToV1Base32;
  }
});

// node_modules/content-hash/src/index.js
var require_src8 = __commonJS({
  "node_modules/content-hash/src/index.js"(exports, module) {
    init_define_process_env();
    var multiC = require_src2();
    var { hexStringToBuffer, profiles } = require_profiles();
    var { cidV0ToV1Base32 } = require_helpers4();
    module.exports = {
      helpers: {
        cidV0ToV1Base32
      },
      decode: function(contentHash) {
        const buffer = hexStringToBuffer(contentHash);
        const codec = multiC.getCodec(buffer);
        const value = multiC.rmPrefix(buffer);
        let profile = profiles[codec];
        if (!profile)
          profile = profiles["default"];
        return profile.decode(value);
      },
      fromIpfs: function(ipfsHash) {
        return this.encode("ipfs-ns", ipfsHash);
      },
      fromSwarm: function(swarmHash) {
        return this.encode("swarm-ns", swarmHash);
      },
      encode: function(codec, value) {
        let profile = profiles[codec];
        if (!profile)
          profile = profiles["default"];
        const encodedValue = profile.encode(value);
        return multiC.addPrefix(codec, encodedValue).toString("hex");
      },
      getCodec: function(hash) {
        let buffer = hexStringToBuffer(hash);
        return multiC.getCodec(buffer);
      }
    };
  }
});

// node_modules/web3-eth-ens/lib/lib/contentHash.js
var require_contentHash = __commonJS({
  "node_modules/web3-eth-ens/lib/lib/contentHash.js"(exports, module) {
    init_define_process_env();
    var contentHash = require_src8();
    function decode2(encoded) {
      var decoded = null;
      var protocolType = null;
      var error2 = null;
      if (encoded && encoded.error) {
        return {
          protocolType: null,
          decoded: encoded.error
        };
      }
      if (encoded) {
        try {
          decoded = contentHash.decode(encoded);
          var codec = contentHash.getCodec(encoded);
          if (codec === "ipfs-ns") {
            protocolType = "ipfs";
          } else if (codec === "swarm-ns") {
            protocolType = "bzz";
          } else if (codec === "onion") {
            protocolType = "onion";
          } else if (codec === "onion3") {
            protocolType = "onion3";
          } else {
            decoded = encoded;
          }
        } catch (e) {
          error2 = e.message;
        }
      }
      return {
        protocolType,
        decoded,
        error: error2
      };
    }
    function encode2(text) {
      var content, contentType;
      var encoded = false;
      if (!!text) {
        var matched = text.match(/^(ipfs|bzz|onion|onion3):\/\/(.*)/) || text.match(/\/(ipfs)\/(.*)/);
        if (matched) {
          contentType = matched[1];
          content = matched[2];
        }
        try {
          if (contentType === "ipfs") {
            if (content.length >= 4) {
              encoded = "0x" + contentHash.fromIpfs(content);
            }
          } else if (contentType === "bzz") {
            if (content.length >= 4) {
              encoded = "0x" + contentHash.fromSwarm(content);
            }
          } else if (contentType === "onion") {
            if (content.length === 16) {
              encoded = "0x" + contentHash.encode("onion", content);
            }
          } else if (contentType === "onion3") {
            if (content.length === 56) {
              encoded = "0x" + contentHash.encode("onion3", content);
            }
          } else {
            throw new Error("Could not encode content hash: unsupported content type");
          }
        } catch (err) {
          throw err;
        }
      }
      return encoded;
    }
    module.exports = {
      decode: decode2,
      encode: encode2
    };
  }
});

// node_modules/web3-eth-ens/lib/ENS.js
var require_ENS = __commonJS({
  "node_modules/web3-eth-ens/lib/ENS.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var config = require_config();
    var formatters = require_lib3().formatters;
    var utils = require_lib();
    var Registry = require_Registry2();
    var ResolverMethodHandler = require_ResolverMethodHandler();
    var contenthash = require_contentHash();
    function ENS(eth) {
      this.eth = eth;
      var registryAddress = null;
      this._detectedAddress = null;
      this._lastSyncCheck = null;
      Object.defineProperty(this, "registry", {
        get: function() {
          return new Registry(this);
        },
        enumerable: true
      });
      Object.defineProperty(this, "resolverMethodHandler", {
        get: function() {
          return new ResolverMethodHandler(this.registry);
        },
        enumerable: true
      });
      Object.defineProperty(this, "registryAddress", {
        get: function() {
          return registryAddress;
        },
        set: function(value) {
          if (value === null) {
            registryAddress = value;
            return;
          }
          registryAddress = formatters.inputAddressFormatter(value);
        },
        enumerable: true
      });
    }
    ENS.prototype.supportsInterface = function(name2, interfaceId, callback) {
      return this.getResolver(name2).then(function(resolver) {
        if (!utils.isHexStrict(interfaceId)) {
          interfaceId = utils.sha3(interfaceId).slice(0, 10);
        }
        return resolver.methods.supportsInterface(interfaceId).call(callback);
      }).catch(function(error2) {
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        throw error2;
      });
    };
    ENS.prototype.resolver = function(name2, callback) {
      return this.registry.resolver(name2, callback);
    };
    ENS.prototype.getResolver = function(name2, callback) {
      return this.registry.getResolver(name2, callback);
    };
    ENS.prototype.setResolver = function(name2, address, txConfig, callback) {
      return this.registry.setResolver(name2, address, txConfig, callback);
    };
    ENS.prototype.setRecord = function(name2, owner, resolver, ttl, txConfig, callback) {
      return this.registry.setRecord(name2, owner, resolver, ttl, txConfig, callback);
    };
    ENS.prototype.setSubnodeRecord = function(name2, label, owner, resolver, ttl, txConfig, callback) {
      return this.registry.setSubnodeRecord(name2, label, owner, resolver, ttl, txConfig, callback);
    };
    ENS.prototype.setApprovalForAll = function(operator, approved, txConfig, callback) {
      return this.registry.setApprovalForAll(operator, approved, txConfig, callback);
    };
    ENS.prototype.isApprovedForAll = function(owner, operator, callback) {
      return this.registry.isApprovedForAll(owner, operator, callback);
    };
    ENS.prototype.recordExists = function(name2, callback) {
      return this.registry.recordExists(name2, callback);
    };
    ENS.prototype.setSubnodeOwner = function(name2, label, address, txConfig, callback) {
      return this.registry.setSubnodeOwner(name2, label, address, txConfig, callback);
    };
    ENS.prototype.getTTL = function(name2, callback) {
      return this.registry.getTTL(name2, callback);
    };
    ENS.prototype.setTTL = function(name2, ttl, txConfig, callback) {
      return this.registry.setTTL(name2, ttl, txConfig, callback);
    };
    ENS.prototype.getOwner = function(name2, callback) {
      return this.registry.getOwner(name2, callback);
    };
    ENS.prototype.setOwner = function(name2, address, txConfig, callback) {
      return this.registry.setOwner(name2, address, txConfig, callback);
    };
    ENS.prototype.getAddress = function(name2, callback) {
      return this.resolverMethodHandler.method(name2, "addr", []).call(callback);
    };
    ENS.prototype.setAddress = function(name2, address, txConfig, callback) {
      return this.resolverMethodHandler.method(name2, "setAddr", [address]).send(txConfig, callback);
    };
    ENS.prototype.getPubkey = function(name2, callback) {
      return this.resolverMethodHandler.method(name2, "pubkey", [], null, callback).call(callback);
    };
    ENS.prototype.setPubkey = function(name2, x, y, txConfig, callback) {
      return this.resolverMethodHandler.method(name2, "setPubkey", [x, y]).send(txConfig, callback);
    };
    ENS.prototype.getContent = function(name2, callback) {
      return this.resolverMethodHandler.method(name2, "content", []).call(callback);
    };
    ENS.prototype.setContent = function(name2, hash, txConfig, callback) {
      return this.resolverMethodHandler.method(name2, "setContent", [hash]).send(txConfig, callback);
    };
    ENS.prototype.getContenthash = function(name2, callback) {
      return this.resolverMethodHandler.method(name2, "contenthash", [], contenthash.decode).call(callback);
    };
    ENS.prototype.setContenthash = function(name2, hash, txConfig, callback) {
      var encoded;
      try {
        encoded = contenthash.encode(hash);
      } catch (err) {
        var error2 = new Error("Could not encode " + hash + ". See docs for supported hash protocols.");
        if (typeof callback === "function") {
          callback(error2, null);
          return;
        }
        throw error2;
      }
      return this.resolverMethodHandler.method(name2, "setContenthash", [encoded]).send(txConfig, callback);
    };
    ENS.prototype.getMultihash = function(name2, callback) {
      return this.resolverMethodHandler.method(name2, "multihash", []).call(callback);
    };
    ENS.prototype.setMultihash = function(name2, hash, txConfig, callback) {
      return this.resolverMethodHandler.method(name2, "multihash", [hash]).send(txConfig, callback);
    };
    ENS.prototype.checkNetwork = async function() {
      var now = new Date() / 1e3;
      if (!this._lastSyncCheck || now - this._lastSyncCheck > 3600) {
        var block = await this.eth.getBlock("latest");
        var headAge = now - block.timestamp;
        if (headAge > 3600) {
          throw new Error("Network not synced; last block was " + headAge + " seconds ago");
        }
        this._lastSyncCheck = now;
      }
      if (this.registryAddress) {
        return this.registryAddress;
      }
      if (!this._detectedAddress) {
        var networkType = await this.eth.net.getNetworkType();
        var addr = config.addresses[networkType];
        if (typeof addr === "undefined") {
          throw new Error("ENS is not supported on network " + networkType);
        }
        this._detectedAddress = addr;
        return this._detectedAddress;
      }
      return this._detectedAddress;
    };
    module.exports = ENS;
  }
});

// node_modules/web3-eth-ens/lib/index.js
var require_lib25 = __commonJS({
  "node_modules/web3-eth-ens/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var ENS = require_ENS();
    module.exports = ENS;
  }
});

// node_modules/web3-eth-personal/node_modules/web3-core-requestmanager/lib/jsonrpc.js
var require_jsonrpc4 = __commonJS({
  "node_modules/web3-eth-personal/node_modules/web3-core-requestmanager/lib/jsonrpc.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = {
      messageId: 0
    };
    Jsonrpc.toPayload = function(method, params) {
      if (!method) {
        throw new Error('JSONRPC method should be specified for params: "' + JSON.stringify(params) + '"!');
      }
      Jsonrpc.messageId++;
      return {
        jsonrpc: "2.0",
        id: Jsonrpc.messageId,
        method,
        params: params || []
      };
    };
    Jsonrpc.isValidResponse = function(response) {
      return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);
      function validateSingleMessage(message) {
        return !!message && !message.error && message.jsonrpc === "2.0" && (typeof message.id === "number" || typeof message.id === "string") && message.result !== void 0;
      }
    };
    Jsonrpc.toBatchPayload = function(messages) {
      return messages.map(function(message) {
        return Jsonrpc.toPayload(message.method, message.params);
      });
    };
    module.exports = Jsonrpc;
  }
});

// node_modules/web3-eth-personal/node_modules/web3-core-requestmanager/lib/batch.js
var require_batch4 = __commonJS({
  "node_modules/web3-eth-personal/node_modules/web3-core-requestmanager/lib/batch.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = require_jsonrpc4();
    var errors2 = require_lib3().errors;
    var Batch = function(requestManager) {
      this.requestManager = requestManager;
      this.requests = [];
    };
    Batch.prototype.add = function(request) {
      this.requests.push(request);
    };
    Batch.prototype.execute = function() {
      var requests = this.requests;
      var sortResponses = this._sortResponses.bind(this);
      this.requestManager.sendBatch(requests, function(err, results) {
        results = sortResponses(results);
        requests.map(function(request, index) {
          return results[index] || {};
        }).forEach(function(result, index) {
          if (requests[index].callback) {
            if (result && result.error) {
              return requests[index].callback(errors2.ErrorResponse(result));
            }
            if (!Jsonrpc.isValidResponse(result)) {
              return requests[index].callback(errors2.InvalidResponse(result));
            }
            try {
              requests[index].callback(null, requests[index].format ? requests[index].format(result.result) : result.result);
            } catch (err2) {
              requests[index].callback(err2);
            }
          }
        });
      });
    };
    Batch.prototype._sortResponses = function(responses) {
      return (responses || []).sort((a, b) => a.id - b.id);
    };
    module.exports = Batch;
  }
});

// node_modules/web3-eth-personal/node_modules/web3-core-requestmanager/lib/givenProvider.js
var require_givenProvider4 = __commonJS({
  "node_modules/web3-eth-personal/node_modules/web3-core-requestmanager/lib/givenProvider.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var givenProvider = null;
    var global2 = typeof globalThis === "object" ? globalThis : void 0;
    if (!global2) {
      try {
        global2 = Function("return this")();
      } catch (e) {
        global2 = self;
      }
    }
    if (typeof global2.ethereum !== "undefined") {
      givenProvider = global2.ethereum;
    } else if (typeof global2.web3 !== "undefined" && global2.web3.currentProvider) {
      if (global2.web3.currentProvider.sendAsync) {
        global2.web3.currentProvider.send = global2.web3.currentProvider.sendAsync;
        delete global2.web3.currentProvider.sendAsync;
      }
      if (!global2.web3.currentProvider.on && global2.web3.currentProvider.connection && global2.web3.currentProvider.connection.constructor.name === "ipcProviderWrapper") {
        global2.web3.currentProvider.on = function(type, callback) {
          if (typeof callback !== "function")
            throw new Error("The second parameter callback must be a function.");
          switch (type) {
            case "data":
              this.connection.on("data", function(data) {
                var result = "";
                data = data.toString();
                try {
                  result = JSON.parse(data);
                } catch (e) {
                  return callback(new Error("Couldn't parse response data" + data));
                }
                if (!result.id && result.method.indexOf("_subscription") !== -1) {
                  callback(null, result);
                }
              });
              break;
            default:
              this.connection.on(type, callback);
              break;
          }
        };
      }
      givenProvider = global2.web3.currentProvider;
    }
    module.exports = givenProvider;
  }
});

// node_modules/web3-eth-personal/node_modules/web3-providers-ws/lib/helpers.js
var require_helpers5 = __commonJS({
  "node_modules/web3-eth-personal/node_modules/web3-providers-ws/lib/helpers.js"(exports, module) {
    init_define_process_env();
    var isNode = Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
    var isRN = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var _btoa = null;
    var helpers = null;
    if (isNode || isRN) {
      _btoa = function(str) {
        return Buffer.from(str).toString("base64");
      };
      url = require_url();
      if (url.URL) {
        newURL = url.URL;
        helpers = function(url2) {
          return new newURL(url2);
        };
      } else {
        helpers = require_url().parse;
      }
    } else {
      _btoa = btoa.bind(typeof globalThis === "object" ? globalThis : self);
      helpers = function(url2) {
        return new URL(url2);
      };
    }
    var url;
    var newURL;
    module.exports = {
      parseURL: helpers,
      btoa: _btoa
    };
  }
});

// node_modules/web3-eth-personal/node_modules/web3-providers-ws/lib/index.js
var require_lib26 = __commonJS({
  "node_modules/web3-eth-personal/node_modules/web3-providers-ws/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var EventEmitter = require_eventemitter3();
    var helpers = require_helpers5();
    var errors2 = require_lib3().errors;
    var Ws = require_browser().w3cwebsocket;
    var WebsocketProvider = function WebsocketProvider2(url, options) {
      EventEmitter.call(this);
      options = options || {};
      this.url = url;
      this._customTimeout = options.timeout || 1e3 * 15;
      this.headers = options.headers || {};
      this.protocol = options.protocol || void 0;
      this.reconnectOptions = Object.assign({
        auto: false,
        delay: 5e3,
        maxAttempts: false,
        onTimeout: false
      }, options.reconnect);
      this.clientConfig = options.clientConfig || void 0;
      this.requestOptions = options.requestOptions || void 0;
      this.DATA = "data";
      this.CLOSE = "close";
      this.ERROR = "error";
      this.CONNECT = "connect";
      this.RECONNECT = "reconnect";
      this.connection = null;
      this.requestQueue = /* @__PURE__ */ new Map();
      this.responseQueue = /* @__PURE__ */ new Map();
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      var parsedURL = helpers.parseURL(url);
      if (parsedURL.username && parsedURL.password) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.username + ":" + parsedURL.password);
      }
      if (parsedURL.auth) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.auth);
      }
      Object.defineProperty(this, "connected", {
        get: function() {
          return this.connection && this.connection.readyState === this.connection.OPEN;
        },
        enumerable: true
      });
      this.connect();
    };
    WebsocketProvider.prototype = Object.create(EventEmitter.prototype);
    WebsocketProvider.prototype.constructor = WebsocketProvider;
    WebsocketProvider.prototype.connect = function() {
      this.connection = new Ws(this.url, this.protocol, void 0, this.headers, this.requestOptions, this.clientConfig);
      this._addSocketListeners();
    };
    WebsocketProvider.prototype._onMessage = function(e) {
      var _this = this;
      this._parseResponse(typeof e.data === "string" ? e.data : "").forEach(function(result) {
        if (result.method && result.method.indexOf("_subscription") !== -1) {
          _this.emit(_this.DATA, result);
          return;
        }
        var id = result.id;
        if (Array.isArray(result)) {
          id = result[0].id;
        }
        if (_this.responseQueue.has(id)) {
          if (_this.responseQueue.get(id).callback !== void 0) {
            _this.responseQueue.get(id).callback(false, result);
          }
          _this.responseQueue.delete(id);
        }
      });
    };
    WebsocketProvider.prototype._onConnect = function() {
      this.emit(this.CONNECT);
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        var _this = this;
        this.requestQueue.forEach(function(request, key) {
          _this.send(request.payload, request.callback);
          _this.requestQueue.delete(key);
        });
      }
    };
    WebsocketProvider.prototype._onClose = function(event) {
      var _this = this;
      if (this.reconnectOptions.auto && (![1e3, 1001].includes(event.code) || event.wasClean === false)) {
        this.reconnect();
        return;
      }
      this.emit(this.CLOSE, event);
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors2.ConnectionNotOpenError(event));
          _this.requestQueue.delete(key);
        });
      }
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors2.InvalidConnection("on WS", event));
          _this.responseQueue.delete(key);
        });
      }
      this._removeSocketListeners();
      this.removeAllListeners();
    };
    WebsocketProvider.prototype._addSocketListeners = function() {
      this.connection.addEventListener("message", this._onMessage.bind(this));
      this.connection.addEventListener("open", this._onConnect.bind(this));
      this.connection.addEventListener("close", this._onClose.bind(this));
    };
    WebsocketProvider.prototype._removeSocketListeners = function() {
      this.connection.removeEventListener("message", this._onMessage);
      this.connection.removeEventListener("open", this._onConnect);
      this.connection.removeEventListener("close", this._onClose);
    };
    WebsocketProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {
              _this.reconnect();
              return;
            }
            _this.emit(_this.ERROR, errors2.ConnectionTimeout(_this._customTimeout));
            if (_this.requestQueue.size > 0) {
              _this.requestQueue.forEach(function(request, key) {
                request.callback(errors2.ConnectionTimeout(_this._customTimeout));
                _this.requestQueue.delete(key);
              });
            }
          }, _this._customTimeout);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    WebsocketProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var id = payload.id;
      var request = { payload, callback };
      if (Array.isArray(payload)) {
        id = payload[0].id;
      }
      if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {
        this.requestQueue.set(id, request);
        return;
      }
      if (this.connection.readyState !== this.connection.OPEN) {
        this.requestQueue.delete(id);
        this.emit(this.ERROR, errors2.ConnectionNotOpenError());
        request.callback(errors2.ConnectionNotOpenError());
        return;
      }
      this.responseQueue.set(id, request);
      this.requestQueue.delete(id);
      try {
        this.connection.send(JSON.stringify(request.payload));
      } catch (error2) {
        request.callback(error2);
        _this.responseQueue.delete(id);
      }
    };
    WebsocketProvider.prototype.reset = function() {
      this.responseQueue.clear();
      this.requestQueue.clear();
      this.removeAllListeners();
      this._removeSocketListeners();
      this._addSocketListeners();
    };
    WebsocketProvider.prototype.disconnect = function(code, reason) {
      this._removeSocketListeners();
      this.connection.close(code || 1e3, reason);
    };
    WebsocketProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    WebsocketProvider.prototype.reconnect = function() {
      var _this = this;
      this.reconnecting = true;
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors2.PendingRequestsOnReconnectingError());
          _this.responseQueue.delete(key);
        });
      }
      if (!this.reconnectOptions.maxAttempts || this.reconnectAttempts < this.reconnectOptions.maxAttempts) {
        setTimeout(function() {
          _this.reconnectAttempts++;
          _this._removeSocketListeners();
          _this.emit(_this.RECONNECT, _this.reconnectAttempts);
          _this.connect();
        }, this.reconnectOptions.delay);
        return;
      }
      this.emit(this.ERROR, errors2.MaxAttemptsReachedOnReconnectingError());
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors2.MaxAttemptsReachedOnReconnectingError());
          _this.requestQueue.delete(key);
        });
      }
    };
    module.exports = WebsocketProvider;
  }
});

// node_modules/web3-eth-personal/node_modules/web3-providers-http/lib/index.js
var require_lib27 = __commonJS({
  "node_modules/web3-eth-personal/node_modules/web3-providers-http/lib/index.js"(exports, module) {
    init_define_process_env();
    var errors2 = require_lib3().errors;
    var XHR2 = require_dist2().XMLHttpRequest;
    var http = (init_http(), __toCommonJS(http_exports));
    var https = (init_https(), __toCommonJS(https_exports));
    var HttpProvider = function HttpProvider2(host, options) {
      options = options || {};
      this.withCredentials = options.withCredentials || false;
      this.timeout = options.timeout || 0;
      this.headers = options.headers;
      this.agent = options.agent;
      this.connected = false;
      const keepAlive = options.keepAlive !== false;
      this.host = host || "http://localhost:8545";
      if (!this.agent) {
        if (this.host.substring(0, 5) === "https") {
          this.httpsAgent = new https.Agent({ keepAlive });
        } else {
          this.httpAgent = new http.Agent({ keepAlive });
        }
      }
    };
    HttpProvider.prototype._prepareRequest = function() {
      var request;
      if (typeof XMLHttpRequest !== "undefined") {
        request = new XMLHttpRequest();
      } else {
        request = new XHR2();
        var agents = { httpsAgent: this.httpsAgent, httpAgent: this.httpAgent, baseUrl: this.baseUrl };
        if (this.agent) {
          agents.httpsAgent = this.agent.https;
          agents.httpAgent = this.agent.http;
          agents.baseUrl = this.agent.baseUrl;
        }
        request.nodejsSet(agents);
      }
      request.open("POST", this.host, true);
      request.setRequestHeader("Content-Type", "application/json");
      request.timeout = this.timeout;
      request.withCredentials = this.withCredentials;
      if (this.headers) {
        this.headers.forEach(function(header) {
          request.setRequestHeader(header.name, header.value);
        });
      }
      return request;
    };
    HttpProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var request = this._prepareRequest();
      request.onreadystatechange = function() {
        if (request.readyState === 4 && request.timeout !== 1) {
          var result = request.responseText;
          var error2 = null;
          try {
            result = JSON.parse(result);
          } catch (e) {
            error2 = errors2.InvalidResponse(request.responseText);
          }
          _this.connected = true;
          callback(error2, result);
        }
      };
      request.ontimeout = function() {
        _this.connected = false;
        callback(errors2.ConnectionTimeout(this.timeout));
      };
      try {
        request.send(JSON.stringify(payload));
      } catch (error2) {
        this.connected = false;
        callback(errors2.InvalidConnection(this.host));
      }
    };
    HttpProvider.prototype.disconnect = function() {
    };
    HttpProvider.prototype.supportsSubscriptions = function() {
      return false;
    };
    module.exports = HttpProvider;
  }
});

// node_modules/web3-eth-personal/node_modules/web3-providers-ipc/lib/index.js
var require_lib28 = __commonJS({
  "node_modules/web3-eth-personal/node_modules/web3-providers-ipc/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var errors2 = require_lib3().errors;
    var oboe = require_oboe_browser();
    var IpcProvider = function IpcProvider2(path, net) {
      var _this = this;
      this.responseCallbacks = {};
      this.notificationCallbacks = [];
      this.path = path;
      this.connected = false;
      this.connection = net.connect({ path: this.path });
      this.addDefaultEvents();
      var callback = function(result) {
        var id = null;
        if (Array.isArray(result)) {
          result.forEach(function(load) {
            if (_this.responseCallbacks[load.id])
              id = load.id;
          });
        } else {
          id = result.id;
        }
        if (!id && result.method.indexOf("_subscription") !== -1) {
          _this.notificationCallbacks.forEach(function(callback2) {
            if (typeof callback2 === "function")
              callback2(result);
          });
        } else if (_this.responseCallbacks[id]) {
          _this.responseCallbacks[id](null, result);
          delete _this.responseCallbacks[id];
        }
      };
      if (net.constructor.name === "Socket") {
        oboe(this.connection).done(callback);
      } else {
        this.connection.on("data", function(data) {
          _this._parseResponse(data.toString()).forEach(callback);
        });
      }
    };
    IpcProvider.prototype.addDefaultEvents = function() {
      var _this = this;
      this.connection.on("connect", function() {
        _this.connected = true;
      });
      this.connection.on("close", function() {
        _this.connected = false;
      });
      this.connection.on("error", function() {
        _this._timeout();
      });
      this.connection.on("end", function() {
        _this._timeout();
      });
      this.connection.on("timeout", function() {
        _this._timeout();
      });
    };
    IpcProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            _this._timeout();
            throw errors2.InvalidResponse(data2);
          }, 1e3 * 15);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    IpcProvider.prototype._addResponseCallback = function(payload, callback) {
      var id = payload.id || payload[0].id;
      var method = payload.method || payload[0].method;
      this.responseCallbacks[id] = callback;
      this.responseCallbacks[id].method = method;
    };
    IpcProvider.prototype._timeout = function() {
      for (var key in this.responseCallbacks) {
        if (this.responseCallbacks.hasOwnProperty(key)) {
          this.responseCallbacks[key](errors2.InvalidConnection("on IPC"));
          delete this.responseCallbacks[key];
        }
      }
    };
    IpcProvider.prototype.reconnect = function() {
      this.connection.connect({ path: this.path });
    };
    IpcProvider.prototype.send = function(payload, callback) {
      if (!this.connection.writable)
        this.connection.connect({ path: this.path });
      this.connection.write(JSON.stringify(payload));
      this._addResponseCallback(payload, callback);
    };
    IpcProvider.prototype.on = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      switch (type) {
        case "data":
          this.notificationCallbacks.push(callback);
          break;
        default:
          this.connection.on(type, callback);
          break;
      }
    };
    IpcProvider.prototype.once = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      this.connection.once(type, callback);
    };
    IpcProvider.prototype.removeListener = function(type, callback) {
      var _this = this;
      switch (type) {
        case "data":
          this.notificationCallbacks.forEach(function(cb, index) {
            if (cb === callback)
              _this.notificationCallbacks.splice(index, 1);
          });
          break;
        default:
          this.connection.removeListener(type, callback);
          break;
      }
    };
    IpcProvider.prototype.removeAllListeners = function(type) {
      switch (type) {
        case "data":
          this.notificationCallbacks = [];
          break;
        default:
          this.connection.removeAllListeners(type);
          break;
      }
    };
    IpcProvider.prototype.reset = function() {
      this._timeout();
      this.notificationCallbacks = [];
      this.connection.removeAllListeners("error");
      this.connection.removeAllListeners("end");
      this.connection.removeAllListeners("timeout");
      this.addDefaultEvents();
    };
    IpcProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    module.exports = IpcProvider;
  }
});

// node_modules/web3-eth-personal/node_modules/web3-core-requestmanager/lib/index.js
var require_lib29 = __commonJS({
  "node_modules/web3-eth-personal/node_modules/web3-core-requestmanager/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { callbackify } = require_util();
    var errors2 = require_lib3().errors;
    var Jsonrpc = require_jsonrpc4();
    var BatchManager = require_batch4();
    var givenProvider = require_givenProvider4();
    var RequestManager = function RequestManager2(provider, net) {
      this.provider = null;
      this.providers = RequestManager2.providers;
      this.setProvider(provider, net);
      this.subscriptions = /* @__PURE__ */ new Map();
    };
    RequestManager.givenProvider = givenProvider;
    RequestManager.providers = {
      WebsocketProvider: require_lib26(),
      HttpProvider: require_lib27(),
      IpcProvider: require_lib28()
    };
    RequestManager.prototype.setProvider = function(provider, net) {
      var _this = this;
      if (provider && typeof provider === "string" && this.providers) {
        if (/^http(s)?:\/\//i.test(provider)) {
          provider = new this.providers.HttpProvider(provider);
        } else if (/^ws(s)?:\/\//i.test(provider)) {
          provider = new this.providers.WebsocketProvider(provider);
        } else if (provider && typeof net === "object" && typeof net.connect === "function") {
          provider = new this.providers.IpcProvider(provider, net);
        } else if (provider) {
          throw new Error(`Can't autodetect provider for "` + provider + '"');
        }
      }
      if (this.provider && this.provider.connected)
        this.clearSubscriptions();
      this.provider = provider || null;
      if (this.provider && this.provider.on) {
        if (typeof provider.request === "function") {
          this.provider.on("message", function(payload) {
            if (payload && payload.type === "eth_subscription" && payload.data) {
              const data = payload.data;
              if (data.subscription && _this.subscriptions.has(data.subscription)) {
                _this.subscriptions.get(data.subscription).callback(null, data.result);
              }
            }
          });
        } else {
          this.provider.on("data", function data(result, deprecatedResult) {
            result = result || deprecatedResult;
            if (result.method && result.params && result.params.subscription && _this.subscriptions.has(result.params.subscription)) {
              _this.subscriptions.get(result.params.subscription).callback(null, result.params.result);
            }
          });
        }
        this.provider.on("connect", function connect() {
          _this.subscriptions.forEach(function(subscription) {
            subscription.subscription.resubscribe();
          });
        });
        this.provider.on("error", function error2(error2) {
          _this.subscriptions.forEach(function(subscription) {
            subscription.callback(error2);
          });
        });
        const disconnect = function disconnect2(event) {
          if (!_this._isCleanCloseEvent(event) || _this._isIpcCloseError(event)) {
            _this.subscriptions.forEach(function(subscription) {
              subscription.callback(errors2.ConnectionCloseError(event));
              _this.subscriptions.delete(subscription.subscription.id);
            });
            if (_this.provider && _this.provider.emit) {
              _this.provider.emit("error", errors2.ConnectionCloseError(event));
            }
          }
          if (_this.provider && _this.provider.emit) {
            _this.provider.emit("end", event);
          }
        };
        this.provider.on("disconnect", disconnect);
      }
    };
    RequestManager.prototype.send = function(data, callback) {
      callback = callback || function() {
      };
      if (!this.provider) {
        return callback(errors2.InvalidProvider());
      }
      const { method, params } = data;
      const jsonrpcPayload = Jsonrpc.toPayload(method, params);
      const jsonrpcResultCallback = this._jsonrpcResultCallback(callback, jsonrpcPayload);
      if (this.provider.request) {
        const callbackRequest = callbackify(this.provider.request.bind(this.provider));
        const requestArgs = { method, params };
        callbackRequest(requestArgs, callback);
      } else if (this.provider.sendAsync) {
        this.provider.sendAsync(jsonrpcPayload, jsonrpcResultCallback);
      } else if (this.provider.send) {
        this.provider.send(jsonrpcPayload, jsonrpcResultCallback);
      } else {
        throw new Error("Provider does not have a request or send method to use.");
      }
    };
    RequestManager.prototype.sendBatch = function(data, callback) {
      if (!this.provider) {
        return callback(errors2.InvalidProvider());
      }
      var payload = Jsonrpc.toBatchPayload(data);
      this.provider[this.provider.sendAsync ? "sendAsync" : "send"](payload, function(err, results) {
        if (err) {
          return callback(err);
        }
        if (!Array.isArray(results)) {
          return callback(errors2.InvalidResponse(results));
        }
        callback(null, results);
      });
    };
    RequestManager.prototype.addSubscription = function(subscription, callback) {
      if (this.provider.on) {
        this.subscriptions.set(subscription.id, {
          callback,
          subscription
        });
      } else {
        throw new Error("The provider doesn't support subscriptions: " + this.provider.constructor.name);
      }
    };
    RequestManager.prototype.removeSubscription = function(id, callback) {
      if (this.subscriptions.has(id)) {
        var type = this.subscriptions.get(id).subscription.options.type;
        this.subscriptions.delete(id);
        this.send({
          method: type + "_unsubscribe",
          params: [id]
        }, callback);
        return;
      }
      if (typeof callback === "function") {
        callback(null);
      }
    };
    RequestManager.prototype.clearSubscriptions = function(keepIsSyncing) {
      try {
        var _this = this;
        if (this.subscriptions.size > 0) {
          this.subscriptions.forEach(function(value, id) {
            if (!keepIsSyncing || value.name !== "syncing")
              _this.removeSubscription(id);
          });
        }
        if (this.provider.reset)
          this.provider.reset();
        return true;
      } catch (e) {
        throw new Error(`Error while clearing subscriptions: ${e}`);
      }
    };
    RequestManager.prototype._isCleanCloseEvent = function(event) {
      return typeof event === "object" && ([1e3].includes(event.code) || event.wasClean === true);
    };
    RequestManager.prototype._isIpcCloseError = function(event) {
      return typeof event === "boolean" && event;
    };
    RequestManager.prototype._jsonrpcResultCallback = function(callback, payload) {
      return function(err, result) {
        if (result && result.id && payload.id !== result.id) {
          return callback(new Error(`Wrong response id ${result.id} (expected: ${payload.id}) in ${JSON.stringify(payload)}`));
        }
        if (err) {
          return callback(err);
        }
        if (result && result.error) {
          return callback(errors2.ErrorResponse(result));
        }
        if (!Jsonrpc.isValidResponse(result)) {
          return callback(errors2.InvalidResponse(result));
        }
        callback(null, result.result);
      };
    };
    module.exports = {
      Manager: RequestManager,
      BatchManager
    };
  }
});

// node_modules/web3-eth-personal/node_modules/web3-core/lib/extend.js
var require_extend4 = __commonJS({
  "node_modules/web3-eth-personal/node_modules/web3-core/lib/extend.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var formatters = require_lib3().formatters;
    var Method = require_lib6();
    var utils = require_lib();
    var extend = function(pckg) {
      var ex = function(extension) {
        var extendedObject;
        if (extension.property) {
          if (!pckg[extension.property]) {
            pckg[extension.property] = {};
          }
          extendedObject = pckg[extension.property];
        } else {
          extendedObject = pckg;
        }
        if (extension.methods) {
          extension.methods.forEach(function(method) {
            if (!(method instanceof Method)) {
              method = new Method(method);
            }
            method.attachToObject(extendedObject);
            method.setRequestManager(pckg._requestManager);
          });
        }
        return pckg;
      };
      ex.formatters = formatters;
      ex.utils = utils;
      ex.Method = Method;
      return ex;
    };
    module.exports = extend;
  }
});

// node_modules/web3-eth-personal/node_modules/web3-core/lib/index.js
var require_lib30 = __commonJS({
  "node_modules/web3-eth-personal/node_modules/web3-core/lib/index.js"(exports, module) {
    init_define_process_env();
    var requestManager = require_lib29();
    var extend = require_extend4();
    var packageInit = (pkg, args) => {
      args = Array.prototype.slice.call(args);
      if (!pkg) {
        throw new Error('You need to instantiate using the "new" keyword.');
      }
      Object.defineProperty(pkg, "currentProvider", {
        get: () => {
          return pkg._provider;
        },
        set: (value) => {
          return pkg.setProvider(value);
        },
        enumerable: true,
        configurable: true
      });
      if (args[0] && args[0]._requestManager) {
        pkg._requestManager = args[0]._requestManager;
      } else {
        pkg._requestManager = new requestManager.Manager(args[0], args[1]);
      }
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
      pkg._provider = pkg._requestManager.provider;
      if (!pkg.setProvider) {
        pkg.setProvider = (provider, net) => {
          pkg._requestManager.setProvider(provider, net);
          pkg._provider = pkg._requestManager.provider;
          return true;
        };
      }
      pkg.setRequestManager = (manager) => {
        pkg._requestManager = manager;
        pkg._provider = manager.provider;
      };
      pkg.BatchRequest = requestManager.BatchManager.bind(null, pkg._requestManager);
      pkg.extend = extend(pkg);
    };
    var addProviders = (pkg) => {
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
    };
    module.exports = {
      packageInit,
      addProviders
    };
  }
});

// node_modules/web3-eth-personal/lib/index.js
var require_lib31 = __commonJS({
  "node_modules/web3-eth-personal/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var core = require_lib30();
    var Method = require_lib6();
    var utils = require_lib();
    var Net = require_lib24();
    var formatters = require_lib3().formatters;
    var Personal = function Personal2() {
      var _this = this;
      core.packageInit(this, arguments);
      this.net = new Net(this);
      var defaultAccount = null;
      var defaultBlock = "latest";
      Object.defineProperty(this, "defaultAccount", {
        get: function() {
          return defaultAccount;
        },
        set: function(val) {
          if (val) {
            defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val));
          }
          methods.forEach(function(method) {
            method.defaultAccount = defaultAccount;
          });
          return val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "defaultBlock", {
        get: function() {
          return defaultBlock;
        },
        set: function(val) {
          defaultBlock = val;
          methods.forEach(function(method) {
            method.defaultBlock = defaultBlock;
          });
          return val;
        },
        enumerable: true
      });
      var methods = [
        new Method({
          name: "getAccounts",
          call: "personal_listAccounts",
          params: 0,
          outputFormatter: utils.toChecksumAddress
        }),
        new Method({
          name: "newAccount",
          call: "personal_newAccount",
          params: 1,
          inputFormatter: [null],
          outputFormatter: utils.toChecksumAddress
        }),
        new Method({
          name: "unlockAccount",
          call: "personal_unlockAccount",
          params: 3,
          inputFormatter: [formatters.inputAddressFormatter, null, null]
        }),
        new Method({
          name: "lockAccount",
          call: "personal_lockAccount",
          params: 1,
          inputFormatter: [formatters.inputAddressFormatter]
        }),
        new Method({
          name: "importRawKey",
          call: "personal_importRawKey",
          params: 2
        }),
        new Method({
          name: "sendTransaction",
          call: "personal_sendTransaction",
          params: 2,
          inputFormatter: [formatters.inputTransactionFormatter, null]
        }),
        new Method({
          name: "signTransaction",
          call: "personal_signTransaction",
          params: 2,
          inputFormatter: [formatters.inputTransactionFormatter, null]
        }),
        new Method({
          name: "sign",
          call: "personal_sign",
          params: 3,
          inputFormatter: [formatters.inputSignFormatter, formatters.inputAddressFormatter, null]
        }),
        new Method({
          name: "ecRecover",
          call: "personal_ecRecover",
          params: 2,
          inputFormatter: [formatters.inputSignFormatter, null]
        })
      ];
      methods.forEach(function(method) {
        method.attachToObject(_this);
        method.setRequestManager(_this._requestManager);
        method.defaultBlock = _this.defaultBlock;
        method.defaultAccount = _this.defaultAccount;
      });
    };
    core.addProviders(Personal);
    module.exports = Personal;
  }
});

// node_modules/web3-eth-accounts/node_modules/web3-core-requestmanager/lib/jsonrpc.js
var require_jsonrpc5 = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/web3-core-requestmanager/lib/jsonrpc.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = {
      messageId: 0
    };
    Jsonrpc.toPayload = function(method, params) {
      if (!method) {
        throw new Error('JSONRPC method should be specified for params: "' + JSON.stringify(params) + '"!');
      }
      Jsonrpc.messageId++;
      return {
        jsonrpc: "2.0",
        id: Jsonrpc.messageId,
        method,
        params: params || []
      };
    };
    Jsonrpc.isValidResponse = function(response) {
      return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);
      function validateSingleMessage(message) {
        return !!message && !message.error && message.jsonrpc === "2.0" && (typeof message.id === "number" || typeof message.id === "string") && message.result !== void 0;
      }
    };
    Jsonrpc.toBatchPayload = function(messages) {
      return messages.map(function(message) {
        return Jsonrpc.toPayload(message.method, message.params);
      });
    };
    module.exports = Jsonrpc;
  }
});

// node_modules/web3-eth-accounts/node_modules/web3-core-requestmanager/lib/batch.js
var require_batch5 = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/web3-core-requestmanager/lib/batch.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = require_jsonrpc5();
    var errors2 = require_lib3().errors;
    var Batch = function(requestManager) {
      this.requestManager = requestManager;
      this.requests = [];
    };
    Batch.prototype.add = function(request) {
      this.requests.push(request);
    };
    Batch.prototype.execute = function() {
      var requests = this.requests;
      var sortResponses = this._sortResponses.bind(this);
      this.requestManager.sendBatch(requests, function(err, results) {
        results = sortResponses(results);
        requests.map(function(request, index) {
          return results[index] || {};
        }).forEach(function(result, index) {
          if (requests[index].callback) {
            if (result && result.error) {
              return requests[index].callback(errors2.ErrorResponse(result));
            }
            if (!Jsonrpc.isValidResponse(result)) {
              return requests[index].callback(errors2.InvalidResponse(result));
            }
            try {
              requests[index].callback(null, requests[index].format ? requests[index].format(result.result) : result.result);
            } catch (err2) {
              requests[index].callback(err2);
            }
          }
        });
      });
    };
    Batch.prototype._sortResponses = function(responses) {
      return (responses || []).sort((a, b) => a.id - b.id);
    };
    module.exports = Batch;
  }
});

// node_modules/web3-eth-accounts/node_modules/web3-core-requestmanager/lib/givenProvider.js
var require_givenProvider5 = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/web3-core-requestmanager/lib/givenProvider.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var givenProvider = null;
    var global2 = typeof globalThis === "object" ? globalThis : void 0;
    if (!global2) {
      try {
        global2 = Function("return this")();
      } catch (e) {
        global2 = self;
      }
    }
    if (typeof global2.ethereum !== "undefined") {
      givenProvider = global2.ethereum;
    } else if (typeof global2.web3 !== "undefined" && global2.web3.currentProvider) {
      if (global2.web3.currentProvider.sendAsync) {
        global2.web3.currentProvider.send = global2.web3.currentProvider.sendAsync;
        delete global2.web3.currentProvider.sendAsync;
      }
      if (!global2.web3.currentProvider.on && global2.web3.currentProvider.connection && global2.web3.currentProvider.connection.constructor.name === "ipcProviderWrapper") {
        global2.web3.currentProvider.on = function(type, callback) {
          if (typeof callback !== "function")
            throw new Error("The second parameter callback must be a function.");
          switch (type) {
            case "data":
              this.connection.on("data", function(data) {
                var result = "";
                data = data.toString();
                try {
                  result = JSON.parse(data);
                } catch (e) {
                  return callback(new Error("Couldn't parse response data" + data));
                }
                if (!result.id && result.method.indexOf("_subscription") !== -1) {
                  callback(null, result);
                }
              });
              break;
            default:
              this.connection.on(type, callback);
              break;
          }
        };
      }
      givenProvider = global2.web3.currentProvider;
    }
    module.exports = givenProvider;
  }
});

// node_modules/web3-eth-accounts/node_modules/web3-providers-ws/lib/helpers.js
var require_helpers6 = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/web3-providers-ws/lib/helpers.js"(exports, module) {
    init_define_process_env();
    var isNode = Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
    var isRN = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var _btoa = null;
    var helpers = null;
    if (isNode || isRN) {
      _btoa = function(str) {
        return Buffer.from(str).toString("base64");
      };
      url = require_url();
      if (url.URL) {
        newURL = url.URL;
        helpers = function(url2) {
          return new newURL(url2);
        };
      } else {
        helpers = require_url().parse;
      }
    } else {
      _btoa = btoa.bind(typeof globalThis === "object" ? globalThis : self);
      helpers = function(url2) {
        return new URL(url2);
      };
    }
    var url;
    var newURL;
    module.exports = {
      parseURL: helpers,
      btoa: _btoa
    };
  }
});

// node_modules/web3-eth-accounts/node_modules/web3-providers-ws/lib/index.js
var require_lib32 = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/web3-providers-ws/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var EventEmitter = require_eventemitter3();
    var helpers = require_helpers6();
    var errors2 = require_lib3().errors;
    var Ws = require_browser().w3cwebsocket;
    var WebsocketProvider = function WebsocketProvider2(url, options) {
      EventEmitter.call(this);
      options = options || {};
      this.url = url;
      this._customTimeout = options.timeout || 1e3 * 15;
      this.headers = options.headers || {};
      this.protocol = options.protocol || void 0;
      this.reconnectOptions = Object.assign({
        auto: false,
        delay: 5e3,
        maxAttempts: false,
        onTimeout: false
      }, options.reconnect);
      this.clientConfig = options.clientConfig || void 0;
      this.requestOptions = options.requestOptions || void 0;
      this.DATA = "data";
      this.CLOSE = "close";
      this.ERROR = "error";
      this.CONNECT = "connect";
      this.RECONNECT = "reconnect";
      this.connection = null;
      this.requestQueue = /* @__PURE__ */ new Map();
      this.responseQueue = /* @__PURE__ */ new Map();
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      var parsedURL = helpers.parseURL(url);
      if (parsedURL.username && parsedURL.password) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.username + ":" + parsedURL.password);
      }
      if (parsedURL.auth) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.auth);
      }
      Object.defineProperty(this, "connected", {
        get: function() {
          return this.connection && this.connection.readyState === this.connection.OPEN;
        },
        enumerable: true
      });
      this.connect();
    };
    WebsocketProvider.prototype = Object.create(EventEmitter.prototype);
    WebsocketProvider.prototype.constructor = WebsocketProvider;
    WebsocketProvider.prototype.connect = function() {
      this.connection = new Ws(this.url, this.protocol, void 0, this.headers, this.requestOptions, this.clientConfig);
      this._addSocketListeners();
    };
    WebsocketProvider.prototype._onMessage = function(e) {
      var _this = this;
      this._parseResponse(typeof e.data === "string" ? e.data : "").forEach(function(result) {
        if (result.method && result.method.indexOf("_subscription") !== -1) {
          _this.emit(_this.DATA, result);
          return;
        }
        var id = result.id;
        if (Array.isArray(result)) {
          id = result[0].id;
        }
        if (_this.responseQueue.has(id)) {
          if (_this.responseQueue.get(id).callback !== void 0) {
            _this.responseQueue.get(id).callback(false, result);
          }
          _this.responseQueue.delete(id);
        }
      });
    };
    WebsocketProvider.prototype._onConnect = function() {
      this.emit(this.CONNECT);
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        var _this = this;
        this.requestQueue.forEach(function(request, key) {
          _this.send(request.payload, request.callback);
          _this.requestQueue.delete(key);
        });
      }
    };
    WebsocketProvider.prototype._onClose = function(event) {
      var _this = this;
      if (this.reconnectOptions.auto && (![1e3, 1001].includes(event.code) || event.wasClean === false)) {
        this.reconnect();
        return;
      }
      this.emit(this.CLOSE, event);
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors2.ConnectionNotOpenError(event));
          _this.requestQueue.delete(key);
        });
      }
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors2.InvalidConnection("on WS", event));
          _this.responseQueue.delete(key);
        });
      }
      this._removeSocketListeners();
      this.removeAllListeners();
    };
    WebsocketProvider.prototype._addSocketListeners = function() {
      this.connection.addEventListener("message", this._onMessage.bind(this));
      this.connection.addEventListener("open", this._onConnect.bind(this));
      this.connection.addEventListener("close", this._onClose.bind(this));
    };
    WebsocketProvider.prototype._removeSocketListeners = function() {
      this.connection.removeEventListener("message", this._onMessage);
      this.connection.removeEventListener("open", this._onConnect);
      this.connection.removeEventListener("close", this._onClose);
    };
    WebsocketProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {
              _this.reconnect();
              return;
            }
            _this.emit(_this.ERROR, errors2.ConnectionTimeout(_this._customTimeout));
            if (_this.requestQueue.size > 0) {
              _this.requestQueue.forEach(function(request, key) {
                request.callback(errors2.ConnectionTimeout(_this._customTimeout));
                _this.requestQueue.delete(key);
              });
            }
          }, _this._customTimeout);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    WebsocketProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var id = payload.id;
      var request = { payload, callback };
      if (Array.isArray(payload)) {
        id = payload[0].id;
      }
      if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {
        this.requestQueue.set(id, request);
        return;
      }
      if (this.connection.readyState !== this.connection.OPEN) {
        this.requestQueue.delete(id);
        this.emit(this.ERROR, errors2.ConnectionNotOpenError());
        request.callback(errors2.ConnectionNotOpenError());
        return;
      }
      this.responseQueue.set(id, request);
      this.requestQueue.delete(id);
      try {
        this.connection.send(JSON.stringify(request.payload));
      } catch (error2) {
        request.callback(error2);
        _this.responseQueue.delete(id);
      }
    };
    WebsocketProvider.prototype.reset = function() {
      this.responseQueue.clear();
      this.requestQueue.clear();
      this.removeAllListeners();
      this._removeSocketListeners();
      this._addSocketListeners();
    };
    WebsocketProvider.prototype.disconnect = function(code, reason) {
      this._removeSocketListeners();
      this.connection.close(code || 1e3, reason);
    };
    WebsocketProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    WebsocketProvider.prototype.reconnect = function() {
      var _this = this;
      this.reconnecting = true;
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors2.PendingRequestsOnReconnectingError());
          _this.responseQueue.delete(key);
        });
      }
      if (!this.reconnectOptions.maxAttempts || this.reconnectAttempts < this.reconnectOptions.maxAttempts) {
        setTimeout(function() {
          _this.reconnectAttempts++;
          _this._removeSocketListeners();
          _this.emit(_this.RECONNECT, _this.reconnectAttempts);
          _this.connect();
        }, this.reconnectOptions.delay);
        return;
      }
      this.emit(this.ERROR, errors2.MaxAttemptsReachedOnReconnectingError());
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors2.MaxAttemptsReachedOnReconnectingError());
          _this.requestQueue.delete(key);
        });
      }
    };
    module.exports = WebsocketProvider;
  }
});

// node_modules/web3-eth-accounts/node_modules/web3-providers-http/lib/index.js
var require_lib33 = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/web3-providers-http/lib/index.js"(exports, module) {
    init_define_process_env();
    var errors2 = require_lib3().errors;
    var XHR2 = require_dist2().XMLHttpRequest;
    var http = (init_http(), __toCommonJS(http_exports));
    var https = (init_https(), __toCommonJS(https_exports));
    var HttpProvider = function HttpProvider2(host, options) {
      options = options || {};
      this.withCredentials = options.withCredentials || false;
      this.timeout = options.timeout || 0;
      this.headers = options.headers;
      this.agent = options.agent;
      this.connected = false;
      const keepAlive = options.keepAlive !== false;
      this.host = host || "http://localhost:8545";
      if (!this.agent) {
        if (this.host.substring(0, 5) === "https") {
          this.httpsAgent = new https.Agent({ keepAlive });
        } else {
          this.httpAgent = new http.Agent({ keepAlive });
        }
      }
    };
    HttpProvider.prototype._prepareRequest = function() {
      var request;
      if (typeof XMLHttpRequest !== "undefined") {
        request = new XMLHttpRequest();
      } else {
        request = new XHR2();
        var agents = { httpsAgent: this.httpsAgent, httpAgent: this.httpAgent, baseUrl: this.baseUrl };
        if (this.agent) {
          agents.httpsAgent = this.agent.https;
          agents.httpAgent = this.agent.http;
          agents.baseUrl = this.agent.baseUrl;
        }
        request.nodejsSet(agents);
      }
      request.open("POST", this.host, true);
      request.setRequestHeader("Content-Type", "application/json");
      request.timeout = this.timeout;
      request.withCredentials = this.withCredentials;
      if (this.headers) {
        this.headers.forEach(function(header) {
          request.setRequestHeader(header.name, header.value);
        });
      }
      return request;
    };
    HttpProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var request = this._prepareRequest();
      request.onreadystatechange = function() {
        if (request.readyState === 4 && request.timeout !== 1) {
          var result = request.responseText;
          var error2 = null;
          try {
            result = JSON.parse(result);
          } catch (e) {
            error2 = errors2.InvalidResponse(request.responseText);
          }
          _this.connected = true;
          callback(error2, result);
        }
      };
      request.ontimeout = function() {
        _this.connected = false;
        callback(errors2.ConnectionTimeout(this.timeout));
      };
      try {
        request.send(JSON.stringify(payload));
      } catch (error2) {
        this.connected = false;
        callback(errors2.InvalidConnection(this.host));
      }
    };
    HttpProvider.prototype.disconnect = function() {
    };
    HttpProvider.prototype.supportsSubscriptions = function() {
      return false;
    };
    module.exports = HttpProvider;
  }
});

// node_modules/web3-eth-accounts/node_modules/web3-providers-ipc/lib/index.js
var require_lib34 = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/web3-providers-ipc/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var errors2 = require_lib3().errors;
    var oboe = require_oboe_browser();
    var IpcProvider = function IpcProvider2(path, net) {
      var _this = this;
      this.responseCallbacks = {};
      this.notificationCallbacks = [];
      this.path = path;
      this.connected = false;
      this.connection = net.connect({ path: this.path });
      this.addDefaultEvents();
      var callback = function(result) {
        var id = null;
        if (Array.isArray(result)) {
          result.forEach(function(load) {
            if (_this.responseCallbacks[load.id])
              id = load.id;
          });
        } else {
          id = result.id;
        }
        if (!id && result.method.indexOf("_subscription") !== -1) {
          _this.notificationCallbacks.forEach(function(callback2) {
            if (typeof callback2 === "function")
              callback2(result);
          });
        } else if (_this.responseCallbacks[id]) {
          _this.responseCallbacks[id](null, result);
          delete _this.responseCallbacks[id];
        }
      };
      if (net.constructor.name === "Socket") {
        oboe(this.connection).done(callback);
      } else {
        this.connection.on("data", function(data) {
          _this._parseResponse(data.toString()).forEach(callback);
        });
      }
    };
    IpcProvider.prototype.addDefaultEvents = function() {
      var _this = this;
      this.connection.on("connect", function() {
        _this.connected = true;
      });
      this.connection.on("close", function() {
        _this.connected = false;
      });
      this.connection.on("error", function() {
        _this._timeout();
      });
      this.connection.on("end", function() {
        _this._timeout();
      });
      this.connection.on("timeout", function() {
        _this._timeout();
      });
    };
    IpcProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            _this._timeout();
            throw errors2.InvalidResponse(data2);
          }, 1e3 * 15);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    IpcProvider.prototype._addResponseCallback = function(payload, callback) {
      var id = payload.id || payload[0].id;
      var method = payload.method || payload[0].method;
      this.responseCallbacks[id] = callback;
      this.responseCallbacks[id].method = method;
    };
    IpcProvider.prototype._timeout = function() {
      for (var key in this.responseCallbacks) {
        if (this.responseCallbacks.hasOwnProperty(key)) {
          this.responseCallbacks[key](errors2.InvalidConnection("on IPC"));
          delete this.responseCallbacks[key];
        }
      }
    };
    IpcProvider.prototype.reconnect = function() {
      this.connection.connect({ path: this.path });
    };
    IpcProvider.prototype.send = function(payload, callback) {
      if (!this.connection.writable)
        this.connection.connect({ path: this.path });
      this.connection.write(JSON.stringify(payload));
      this._addResponseCallback(payload, callback);
    };
    IpcProvider.prototype.on = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      switch (type) {
        case "data":
          this.notificationCallbacks.push(callback);
          break;
        default:
          this.connection.on(type, callback);
          break;
      }
    };
    IpcProvider.prototype.once = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      this.connection.once(type, callback);
    };
    IpcProvider.prototype.removeListener = function(type, callback) {
      var _this = this;
      switch (type) {
        case "data":
          this.notificationCallbacks.forEach(function(cb, index) {
            if (cb === callback)
              _this.notificationCallbacks.splice(index, 1);
          });
          break;
        default:
          this.connection.removeListener(type, callback);
          break;
      }
    };
    IpcProvider.prototype.removeAllListeners = function(type) {
      switch (type) {
        case "data":
          this.notificationCallbacks = [];
          break;
        default:
          this.connection.removeAllListeners(type);
          break;
      }
    };
    IpcProvider.prototype.reset = function() {
      this._timeout();
      this.notificationCallbacks = [];
      this.connection.removeAllListeners("error");
      this.connection.removeAllListeners("end");
      this.connection.removeAllListeners("timeout");
      this.addDefaultEvents();
    };
    IpcProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    module.exports = IpcProvider;
  }
});

// node_modules/web3-eth-accounts/node_modules/web3-core-requestmanager/lib/index.js
var require_lib35 = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/web3-core-requestmanager/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { callbackify } = require_util();
    var errors2 = require_lib3().errors;
    var Jsonrpc = require_jsonrpc5();
    var BatchManager = require_batch5();
    var givenProvider = require_givenProvider5();
    var RequestManager = function RequestManager2(provider, net) {
      this.provider = null;
      this.providers = RequestManager2.providers;
      this.setProvider(provider, net);
      this.subscriptions = /* @__PURE__ */ new Map();
    };
    RequestManager.givenProvider = givenProvider;
    RequestManager.providers = {
      WebsocketProvider: require_lib32(),
      HttpProvider: require_lib33(),
      IpcProvider: require_lib34()
    };
    RequestManager.prototype.setProvider = function(provider, net) {
      var _this = this;
      if (provider && typeof provider === "string" && this.providers) {
        if (/^http(s)?:\/\//i.test(provider)) {
          provider = new this.providers.HttpProvider(provider);
        } else if (/^ws(s)?:\/\//i.test(provider)) {
          provider = new this.providers.WebsocketProvider(provider);
        } else if (provider && typeof net === "object" && typeof net.connect === "function") {
          provider = new this.providers.IpcProvider(provider, net);
        } else if (provider) {
          throw new Error(`Can't autodetect provider for "` + provider + '"');
        }
      }
      if (this.provider && this.provider.connected)
        this.clearSubscriptions();
      this.provider = provider || null;
      if (this.provider && this.provider.on) {
        if (typeof provider.request === "function") {
          this.provider.on("message", function(payload) {
            if (payload && payload.type === "eth_subscription" && payload.data) {
              const data = payload.data;
              if (data.subscription && _this.subscriptions.has(data.subscription)) {
                _this.subscriptions.get(data.subscription).callback(null, data.result);
              }
            }
          });
        } else {
          this.provider.on("data", function data(result, deprecatedResult) {
            result = result || deprecatedResult;
            if (result.method && result.params && result.params.subscription && _this.subscriptions.has(result.params.subscription)) {
              _this.subscriptions.get(result.params.subscription).callback(null, result.params.result);
            }
          });
        }
        this.provider.on("connect", function connect() {
          _this.subscriptions.forEach(function(subscription) {
            subscription.subscription.resubscribe();
          });
        });
        this.provider.on("error", function error2(error2) {
          _this.subscriptions.forEach(function(subscription) {
            subscription.callback(error2);
          });
        });
        const disconnect = function disconnect2(event) {
          if (!_this._isCleanCloseEvent(event) || _this._isIpcCloseError(event)) {
            _this.subscriptions.forEach(function(subscription) {
              subscription.callback(errors2.ConnectionCloseError(event));
              _this.subscriptions.delete(subscription.subscription.id);
            });
            if (_this.provider && _this.provider.emit) {
              _this.provider.emit("error", errors2.ConnectionCloseError(event));
            }
          }
          if (_this.provider && _this.provider.emit) {
            _this.provider.emit("end", event);
          }
        };
        this.provider.on("disconnect", disconnect);
      }
    };
    RequestManager.prototype.send = function(data, callback) {
      callback = callback || function() {
      };
      if (!this.provider) {
        return callback(errors2.InvalidProvider());
      }
      const { method, params } = data;
      const jsonrpcPayload = Jsonrpc.toPayload(method, params);
      const jsonrpcResultCallback = this._jsonrpcResultCallback(callback, jsonrpcPayload);
      if (this.provider.request) {
        const callbackRequest = callbackify(this.provider.request.bind(this.provider));
        const requestArgs = { method, params };
        callbackRequest(requestArgs, callback);
      } else if (this.provider.sendAsync) {
        this.provider.sendAsync(jsonrpcPayload, jsonrpcResultCallback);
      } else if (this.provider.send) {
        this.provider.send(jsonrpcPayload, jsonrpcResultCallback);
      } else {
        throw new Error("Provider does not have a request or send method to use.");
      }
    };
    RequestManager.prototype.sendBatch = function(data, callback) {
      if (!this.provider) {
        return callback(errors2.InvalidProvider());
      }
      var payload = Jsonrpc.toBatchPayload(data);
      this.provider[this.provider.sendAsync ? "sendAsync" : "send"](payload, function(err, results) {
        if (err) {
          return callback(err);
        }
        if (!Array.isArray(results)) {
          return callback(errors2.InvalidResponse(results));
        }
        callback(null, results);
      });
    };
    RequestManager.prototype.addSubscription = function(subscription, callback) {
      if (this.provider.on) {
        this.subscriptions.set(subscription.id, {
          callback,
          subscription
        });
      } else {
        throw new Error("The provider doesn't support subscriptions: " + this.provider.constructor.name);
      }
    };
    RequestManager.prototype.removeSubscription = function(id, callback) {
      if (this.subscriptions.has(id)) {
        var type = this.subscriptions.get(id).subscription.options.type;
        this.subscriptions.delete(id);
        this.send({
          method: type + "_unsubscribe",
          params: [id]
        }, callback);
        return;
      }
      if (typeof callback === "function") {
        callback(null);
      }
    };
    RequestManager.prototype.clearSubscriptions = function(keepIsSyncing) {
      try {
        var _this = this;
        if (this.subscriptions.size > 0) {
          this.subscriptions.forEach(function(value, id) {
            if (!keepIsSyncing || value.name !== "syncing")
              _this.removeSubscription(id);
          });
        }
        if (this.provider.reset)
          this.provider.reset();
        return true;
      } catch (e) {
        throw new Error(`Error while clearing subscriptions: ${e}`);
      }
    };
    RequestManager.prototype._isCleanCloseEvent = function(event) {
      return typeof event === "object" && ([1e3].includes(event.code) || event.wasClean === true);
    };
    RequestManager.prototype._isIpcCloseError = function(event) {
      return typeof event === "boolean" && event;
    };
    RequestManager.prototype._jsonrpcResultCallback = function(callback, payload) {
      return function(err, result) {
        if (result && result.id && payload.id !== result.id) {
          return callback(new Error(`Wrong response id ${result.id} (expected: ${payload.id}) in ${JSON.stringify(payload)}`));
        }
        if (err) {
          return callback(err);
        }
        if (result && result.error) {
          return callback(errors2.ErrorResponse(result));
        }
        if (!Jsonrpc.isValidResponse(result)) {
          return callback(errors2.InvalidResponse(result));
        }
        callback(null, result.result);
      };
    };
    module.exports = {
      Manager: RequestManager,
      BatchManager
    };
  }
});

// node_modules/web3-eth-accounts/node_modules/web3-core/lib/extend.js
var require_extend5 = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/web3-core/lib/extend.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var formatters = require_lib3().formatters;
    var Method = require_lib6();
    var utils = require_lib();
    var extend = function(pckg) {
      var ex = function(extension) {
        var extendedObject;
        if (extension.property) {
          if (!pckg[extension.property]) {
            pckg[extension.property] = {};
          }
          extendedObject = pckg[extension.property];
        } else {
          extendedObject = pckg;
        }
        if (extension.methods) {
          extension.methods.forEach(function(method) {
            if (!(method instanceof Method)) {
              method = new Method(method);
            }
            method.attachToObject(extendedObject);
            method.setRequestManager(pckg._requestManager);
          });
        }
        return pckg;
      };
      ex.formatters = formatters;
      ex.utils = utils;
      ex.Method = Method;
      return ex;
    };
    module.exports = extend;
  }
});

// node_modules/web3-eth-accounts/node_modules/web3-core/lib/index.js
var require_lib36 = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/web3-core/lib/index.js"(exports, module) {
    init_define_process_env();
    var requestManager = require_lib35();
    var extend = require_extend5();
    var packageInit = (pkg, args) => {
      args = Array.prototype.slice.call(args);
      if (!pkg) {
        throw new Error('You need to instantiate using the "new" keyword.');
      }
      Object.defineProperty(pkg, "currentProvider", {
        get: () => {
          return pkg._provider;
        },
        set: (value) => {
          return pkg.setProvider(value);
        },
        enumerable: true,
        configurable: true
      });
      if (args[0] && args[0]._requestManager) {
        pkg._requestManager = args[0]._requestManager;
      } else {
        pkg._requestManager = new requestManager.Manager(args[0], args[1]);
      }
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
      pkg._provider = pkg._requestManager.provider;
      if (!pkg.setProvider) {
        pkg.setProvider = (provider, net) => {
          pkg._requestManager.setProvider(provider, net);
          pkg._provider = pkg._requestManager.provider;
          return true;
        };
      }
      pkg.setRequestManager = (manager) => {
        pkg._requestManager = manager;
        pkg._provider = manager.provider;
      };
      pkg.BatchRequest = requestManager.BatchManager.bind(null, pkg._requestManager);
      pkg.extend = extend(pkg);
    };
    var addProviders = (pkg) => {
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
    };
    module.exports = {
      packageInit,
      addProviders
    };
  }
});

// node_modules/eth-lib/lib/array.js
var require_array = __commonJS({
  "node_modules/eth-lib/lib/array.js"(exports, module) {
    init_define_process_env();
    var generate = (num, fn) => {
      let a = [];
      for (var i = 0; i < num; ++i)
        a.push(fn(i));
      return a;
    };
    var replicate = (num, val) => generate(num, () => val);
    var concat = (a, b) => a.concat(b);
    var flatten = (a) => {
      let r = [];
      for (let j = 0, J = a.length; j < J; ++j)
        for (let i = 0, I = a[j].length; i < I; ++i)
          r.push(a[j][i]);
      return r;
    };
    var chunksOf = (n, a) => {
      let b = [];
      for (let i = 0, l = a.length; i < l; i += n)
        b.push(a.slice(i, i + n));
      return b;
    };
    module.exports = {
      generate,
      replicate,
      concat,
      flatten,
      chunksOf
    };
  }
});

// node_modules/eth-lib/lib/bytes.js
var require_bytes = __commonJS({
  "node_modules/eth-lib/lib/bytes.js"(exports, module) {
    init_define_process_env();
    var A = require_array();
    var at = (bytes, index) => parseInt(bytes.slice(index * 2 + 2, index * 2 + 4), 16);
    var random = (bytes) => {
      let rnd;
      if (typeof window !== "undefined" && window.crypto && window.crypto.getRandomValues)
        rnd = window.crypto.getRandomValues(new Uint8Array(bytes));
      else if (typeof __require !== "undefined")
        rnd = (init_crypto(), __toCommonJS(crypto_exports)).randomBytes(bytes);
      else
        throw "Safe random numbers not available.";
      let hex = "0x";
      for (let i = 0; i < bytes; ++i)
        hex += ("00" + rnd[i].toString(16)).slice(-2);
      return hex;
    };
    var length = (a) => (a.length - 2) / 2;
    var flatten = (a) => "0x" + a.reduce((r, s) => r + s.slice(2), "");
    var slice = (i, j, bs) => "0x" + bs.slice(i * 2 + 2, j * 2 + 2);
    var reverse = (hex) => {
      let rev = "0x";
      for (let i = 0, l = length(hex); i < l; ++i) {
        rev += hex.slice((l - i) * 2, (l - i + 1) * 2);
      }
      return rev;
    };
    var pad = (l, hex) => hex.length === l * 2 + 2 ? hex : pad(l, "0x0" + hex.slice(2));
    var padRight = (l, hex) => hex.length === l * 2 + 2 ? hex : padRight(l, hex + "0");
    var toArray = (hex) => {
      let arr = [];
      for (let i = 2, l = hex.length; i < l; i += 2)
        arr.push(parseInt(hex.slice(i, i + 2), 16));
      return arr;
    };
    var fromArray = (arr) => {
      let hex = "0x";
      for (let i = 0, l = arr.length; i < l; ++i) {
        let b = arr[i];
        hex += (b < 16 ? "0" : "") + b.toString(16);
      }
      return hex;
    };
    var toUint8Array = (hex) => new Uint8Array(toArray(hex));
    var fromUint8Array = (arr) => fromArray([].slice.call(arr, 0));
    var fromNumber = (num) => {
      let hex = num.toString(16);
      return hex.length % 2 === 0 ? "0x" + hex : "0x0" + hex;
    };
    var toNumber = (hex) => parseInt(hex.slice(2), 16);
    var concat = (a, b) => a.concat(b.slice(2));
    var fromNat = (bn) => bn === "0x0" ? "0x" : bn.length % 2 === 0 ? bn : "0x0" + bn.slice(2);
    var toNat = (bn) => bn[2] === "0" ? "0x" + bn.slice(3) : bn;
    var fromAscii = (ascii) => {
      let hex = "0x";
      for (let i = 0; i < ascii.length; ++i)
        hex += ("00" + ascii.charCodeAt(i).toString(16)).slice(-2);
      return hex;
    };
    var toAscii = (hex) => {
      let ascii = "";
      for (let i = 2; i < hex.length; i += 2)
        ascii += String.fromCharCode(parseInt(hex.slice(i, i + 2), 16));
      return ascii;
    };
    var fromString = (s) => {
      const makeByte = (uint8) => {
        const b = uint8.toString(16);
        return b.length < 2 ? "0" + b : b;
      };
      let bytes = "0x";
      for (let ci = 0; ci != s.length; ci++) {
        let c = s.charCodeAt(ci);
        if (c < 128) {
          bytes += makeByte(c);
          continue;
        }
        if (c < 2048) {
          bytes += makeByte(c >> 6 | 192);
        } else {
          if (c > 55295 && c < 56320) {
            if (++ci == s.length)
              return null;
            let c2 = s.charCodeAt(ci);
            if (c2 < 56320 || c2 > 57343)
              return null;
            c = 65536 + ((c & 1023) << 10) + (c2 & 1023);
            bytes += makeByte(c >> 18 | 240);
            bytes += makeByte(c >> 12 & 63 | 128);
          } else {
            bytes += makeByte(c >> 12 | 224);
          }
          bytes += makeByte(c >> 6 & 63 | 128);
        }
        bytes += makeByte(c & 63 | 128);
      }
      return bytes;
    };
    var toString = (bytes) => {
      let s = "";
      let i = 0;
      let l = length(bytes);
      while (i < l) {
        let c = at(bytes, i++);
        if (c > 127) {
          if (c > 191 && c < 224) {
            if (i >= l)
              return null;
            c = (c & 31) << 6 | at(bytes, i) & 63;
          } else if (c > 223 && c < 240) {
            if (i + 1 >= l)
              return null;
            c = (c & 15) << 12 | (at(bytes, i) & 63) << 6 | at(bytes, ++i) & 63;
          } else if (c > 239 && c < 248) {
            if (i + 2 >= l)
              return null;
            c = (c & 7) << 18 | (at(bytes, i) & 63) << 12 | (at(bytes, ++i) & 63) << 6 | at(bytes, ++i) & 63;
          } else
            return null;
          ++i;
        }
        if (c <= 65535)
          s += String.fromCharCode(c);
        else if (c <= 1114111) {
          c -= 65536;
          s += String.fromCharCode(c >> 10 | 55296);
          s += String.fromCharCode(c & 1023 | 56320);
        } else
          return null;
      }
      return s;
    };
    module.exports = {
      random,
      length,
      concat,
      flatten,
      slice,
      reverse,
      pad,
      padRight,
      fromAscii,
      toAscii,
      fromString,
      toString,
      fromNumber,
      toNumber,
      fromNat,
      toNat,
      fromArray,
      toArray,
      fromUint8Array,
      toUint8Array
    };
  }
});

// node_modules/eth-lib/lib/nat.js
var require_nat = __commonJS({
  "node_modules/eth-lib/lib/nat.js"(exports, module) {
    init_define_process_env();
    var BN = require_bn();
    var Bytes = require_bytes();
    var fromBN = (bn) => "0x" + bn.toString("hex");
    var toBN = (str) => new BN(str.slice(2), 16);
    var fromString = (str) => {
      const bn = "0x" + (str.slice(0, 2) === "0x" ? new BN(str.slice(2), 16) : new BN(str, 10)).toString("hex");
      return bn === "0x0" ? "0x" : bn;
    };
    var toEther = (wei) => toNumber(div(wei, fromString("10000000000"))) / 1e8;
    var fromEther = (eth) => mul(fromNumber(Math.floor(eth * 1e8)), fromString("10000000000"));
    var toString = (a) => toBN(a).toString(10);
    var fromNumber = (a) => typeof a === "string" ? /^0x/.test(a) ? a : "0x" + a : "0x" + new BN(a).toString("hex");
    var toNumber = (a) => toBN(a).toNumber();
    var toUint256 = (a) => Bytes.pad(32, a);
    var bin = (method) => (a, b) => fromBN(toBN(a)[method](toBN(b)));
    var add = bin("add");
    var mul = bin("mul");
    var div = bin("div");
    var sub = bin("sub");
    module.exports = {
      toString,
      fromString,
      toNumber,
      fromNumber,
      toEther,
      fromEther,
      toUint256,
      add,
      mul,
      div,
      sub
    };
  }
});

// node_modules/eth-lib/lib/rlp.js
var require_rlp = __commonJS({
  "node_modules/eth-lib/lib/rlp.js"(exports, module) {
    init_define_process_env();
    var encode2 = (tree) => {
      const padEven = (str) => str.length % 2 === 0 ? str : "0" + str;
      const uint = (num) => padEven(num.toString(16));
      const length = (len, add) => len < 56 ? uint(add + len) : uint(add + uint(len).length / 2 + 55) + uint(len);
      const dataTree = (tree2) => {
        if (typeof tree2 === "string") {
          const hex = tree2.slice(2);
          const pre = hex.length != 2 || hex >= "80" ? length(hex.length / 2, 128) : "";
          return pre + hex;
        } else {
          const hex = tree2.map(dataTree).join("");
          const pre = length(hex.length / 2, 192);
          return pre + hex;
        }
      };
      return "0x" + dataTree(tree);
    };
    var decode2 = (hex) => {
      let i = 2;
      const parseTree = () => {
        if (i >= hex.length)
          throw "";
        const head = hex.slice(i, i + 2);
        return head < "80" ? (i += 2, "0x" + head) : head < "c0" ? parseHex() : parseList();
      };
      const parseLength = () => {
        const len = parseInt(hex.slice(i, i += 2), 16) % 64;
        return len < 56 ? len : parseInt(hex.slice(i, i += (len - 55) * 2), 16);
      };
      const parseHex = () => {
        const len = parseLength();
        return "0x" + hex.slice(i, i += len * 2);
      };
      const parseList = () => {
        const lim = parseLength() * 2 + i;
        let list = [];
        while (i < lim)
          list.push(parseTree());
        return list;
      };
      try {
        return parseTree();
      } catch (e) {
        return [];
      }
    };
    module.exports = { encode: encode2, decode: decode2 };
  }
});

// node_modules/eth-lib/lib/hash.js
var require_hash = __commonJS({
  "node_modules/eth-lib/lib/hash.js"(exports, module) {
    init_define_process_env();
    var HEX_CHARS = "0123456789abcdef".split("");
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var SHIFT = [0, 8, 16, 24];
    var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    var Keccak = (bits) => ({
      blocks: [],
      reset: true,
      block: 0,
      start: 0,
      blockCount: 1600 - (bits << 1) >> 5,
      outputBlocks: bits >> 5,
      s: ((s) => [].concat(s, s, s, s, s))([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    });
    var update = (state, message) => {
      var length = message.length, blocks = state.blocks, byteCount = state.blockCount << 2, blockCount = state.blockCount, outputBlocks = state.outputBlocks, s = state.s, index = 0, i, code;
      while (index < length) {
        if (state.reset) {
          state.reset = false;
          blocks[0] = state.block;
          for (i = 1; i < blockCount + 1; ++i) {
            blocks[i] = 0;
          }
        }
        if (typeof message !== "string") {
          for (i = state.start; index < length && i < byteCount; ++index) {
            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
          }
        } else {
          for (i = state.start; index < length && i < byteCount; ++index) {
            code = message.charCodeAt(index);
            if (code < 128) {
              blocks[i >> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 2048) {
              blocks[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            } else if (code < 55296 || code >= 57344) {
              blocks[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            } else {
              code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
              blocks[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            }
          }
        }
        state.lastByteIndex = i;
        if (i >= byteCount) {
          state.start = i - byteCount;
          state.block = blocks[blockCount];
          for (i = 0; i < blockCount; ++i) {
            s[i] ^= blocks[i];
          }
          f(s);
          state.reset = true;
        } else {
          state.start = i;
        }
      }
      i = state.lastByteIndex;
      blocks[i >> 2] |= KECCAK_PADDING[i & 3];
      if (state.lastByteIndex === byteCount) {
        blocks[0] = blocks[blockCount];
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
      }
      f(s);
      var hex = "", i = 0, j = 0, block;
      while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
          block = s[i];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
        }
        if (j % blockCount === 0) {
          f(s);
          i = 0;
        }
      }
      return "0x" + hex;
    };
    var f = (s) => {
      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
        h = c8 ^ (c2 << 1 | c3 >>> 31);
        l = c9 ^ (c3 << 1 | c2 >>> 31);
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ (c4 << 1 | c5 >>> 31);
        l = c1 ^ (c5 << 1 | c4 >>> 31);
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ (c6 << 1 | c7 >>> 31);
        l = c3 ^ (c7 << 1 | c6 >>> 31);
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ (c8 << 1 | c9 >>> 31);
        l = c5 ^ (c9 << 1 | c8 >>> 31);
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ (c0 << 1 | c1 >>> 31);
        l = c7 ^ (c1 << 1 | c0 >>> 31);
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;
        b0 = s[0];
        b1 = s[1];
        b32 = s[11] << 4 | s[10] >>> 28;
        b33 = s[10] << 4 | s[11] >>> 28;
        b14 = s[20] << 3 | s[21] >>> 29;
        b15 = s[21] << 3 | s[20] >>> 29;
        b46 = s[31] << 9 | s[30] >>> 23;
        b47 = s[30] << 9 | s[31] >>> 23;
        b28 = s[40] << 18 | s[41] >>> 14;
        b29 = s[41] << 18 | s[40] >>> 14;
        b20 = s[2] << 1 | s[3] >>> 31;
        b21 = s[3] << 1 | s[2] >>> 31;
        b2 = s[13] << 12 | s[12] >>> 20;
        b3 = s[12] << 12 | s[13] >>> 20;
        b34 = s[22] << 10 | s[23] >>> 22;
        b35 = s[23] << 10 | s[22] >>> 22;
        b16 = s[33] << 13 | s[32] >>> 19;
        b17 = s[32] << 13 | s[33] >>> 19;
        b48 = s[42] << 2 | s[43] >>> 30;
        b49 = s[43] << 2 | s[42] >>> 30;
        b40 = s[5] << 30 | s[4] >>> 2;
        b41 = s[4] << 30 | s[5] >>> 2;
        b22 = s[14] << 6 | s[15] >>> 26;
        b23 = s[15] << 6 | s[14] >>> 26;
        b4 = s[25] << 11 | s[24] >>> 21;
        b5 = s[24] << 11 | s[25] >>> 21;
        b36 = s[34] << 15 | s[35] >>> 17;
        b37 = s[35] << 15 | s[34] >>> 17;
        b18 = s[45] << 29 | s[44] >>> 3;
        b19 = s[44] << 29 | s[45] >>> 3;
        b10 = s[6] << 28 | s[7] >>> 4;
        b11 = s[7] << 28 | s[6] >>> 4;
        b42 = s[17] << 23 | s[16] >>> 9;
        b43 = s[16] << 23 | s[17] >>> 9;
        b24 = s[26] << 25 | s[27] >>> 7;
        b25 = s[27] << 25 | s[26] >>> 7;
        b6 = s[36] << 21 | s[37] >>> 11;
        b7 = s[37] << 21 | s[36] >>> 11;
        b38 = s[47] << 24 | s[46] >>> 8;
        b39 = s[46] << 24 | s[47] >>> 8;
        b30 = s[8] << 27 | s[9] >>> 5;
        b31 = s[9] << 27 | s[8] >>> 5;
        b12 = s[18] << 20 | s[19] >>> 12;
        b13 = s[19] << 20 | s[18] >>> 12;
        b44 = s[29] << 7 | s[28] >>> 25;
        b45 = s[28] << 7 | s[29] >>> 25;
        b26 = s[38] << 8 | s[39] >>> 24;
        b27 = s[39] << 8 | s[38] >>> 24;
        b8 = s[48] << 14 | s[49] >>> 18;
        b9 = s[49] << 14 | s[48] >>> 18;
        s[0] = b0 ^ ~b2 & b4;
        s[1] = b1 ^ ~b3 & b5;
        s[10] = b10 ^ ~b12 & b14;
        s[11] = b11 ^ ~b13 & b15;
        s[20] = b20 ^ ~b22 & b24;
        s[21] = b21 ^ ~b23 & b25;
        s[30] = b30 ^ ~b32 & b34;
        s[31] = b31 ^ ~b33 & b35;
        s[40] = b40 ^ ~b42 & b44;
        s[41] = b41 ^ ~b43 & b45;
        s[2] = b2 ^ ~b4 & b6;
        s[3] = b3 ^ ~b5 & b7;
        s[12] = b12 ^ ~b14 & b16;
        s[13] = b13 ^ ~b15 & b17;
        s[22] = b22 ^ ~b24 & b26;
        s[23] = b23 ^ ~b25 & b27;
        s[32] = b32 ^ ~b34 & b36;
        s[33] = b33 ^ ~b35 & b37;
        s[42] = b42 ^ ~b44 & b46;
        s[43] = b43 ^ ~b45 & b47;
        s[4] = b4 ^ ~b6 & b8;
        s[5] = b5 ^ ~b7 & b9;
        s[14] = b14 ^ ~b16 & b18;
        s[15] = b15 ^ ~b17 & b19;
        s[24] = b24 ^ ~b26 & b28;
        s[25] = b25 ^ ~b27 & b29;
        s[34] = b34 ^ ~b36 & b38;
        s[35] = b35 ^ ~b37 & b39;
        s[44] = b44 ^ ~b46 & b48;
        s[45] = b45 ^ ~b47 & b49;
        s[6] = b6 ^ ~b8 & b0;
        s[7] = b7 ^ ~b9 & b1;
        s[16] = b16 ^ ~b18 & b10;
        s[17] = b17 ^ ~b19 & b11;
        s[26] = b26 ^ ~b28 & b20;
        s[27] = b27 ^ ~b29 & b21;
        s[36] = b36 ^ ~b38 & b30;
        s[37] = b37 ^ ~b39 & b31;
        s[46] = b46 ^ ~b48 & b40;
        s[47] = b47 ^ ~b49 & b41;
        s[8] = b8 ^ ~b0 & b2;
        s[9] = b9 ^ ~b1 & b3;
        s[18] = b18 ^ ~b10 & b12;
        s[19] = b19 ^ ~b11 & b13;
        s[28] = b28 ^ ~b20 & b22;
        s[29] = b29 ^ ~b21 & b23;
        s[38] = b38 ^ ~b30 & b32;
        s[39] = b39 ^ ~b31 & b33;
        s[48] = b48 ^ ~b40 & b42;
        s[49] = b49 ^ ~b41 & b43;
        s[0] ^= RC[n];
        s[1] ^= RC[n + 1];
      }
    };
    var keccak = (bits) => (str) => {
      var msg;
      if (str.slice(0, 2) === "0x") {
        msg = [];
        for (var i = 2, l = str.length; i < l; i += 2)
          msg.push(parseInt(str.slice(i, i + 2), 16));
      } else {
        msg = str;
      }
      return update(Keccak(bits, bits), msg);
    };
    module.exports = {
      keccak256: keccak(256),
      keccak512: keccak(512),
      keccak256s: keccak(256),
      keccak512s: keccak(512)
    };
  }
});

// node_modules/eth-lib/lib/account.js
var require_account = __commonJS({
  "node_modules/eth-lib/lib/account.js"(exports, module) {
    init_define_process_env();
    var Bytes = require_bytes();
    var Nat = require_nat();
    var elliptic = require_elliptic();
    var rlp = require_rlp();
    var secp256k1 = new elliptic.ec("secp256k1");
    var { keccak256, keccak256s } = require_hash();
    var create = (entropy) => {
      const innerHex = keccak256(Bytes.concat(Bytes.random(32), entropy || Bytes.random(32)));
      const middleHex = Bytes.concat(Bytes.concat(Bytes.random(32), innerHex), Bytes.random(32));
      const outerHex = keccak256(middleHex);
      return fromPrivate(outerHex);
    };
    var toChecksum = (address) => {
      const addressHash = keccak256s(address.slice(2));
      let checksumAddress = "0x";
      for (let i = 0; i < 40; i++)
        checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];
      return checksumAddress;
    };
    var fromPrivate = (privateKey) => {
      const buffer = new Buffer(privateKey.slice(2), "hex");
      const ecKey = secp256k1.keyFromPrivate(buffer);
      const publicKey = "0x" + ecKey.getPublic(false, "hex").slice(2);
      const publicHash = keccak256(publicKey);
      const address = toChecksum("0x" + publicHash.slice(-40));
      return {
        address,
        privateKey
      };
    };
    var encodeSignature = ([v, r, s]) => Bytes.flatten([r, s, v]);
    var decodeSignature = (hex) => [Bytes.slice(64, Bytes.length(hex), hex), Bytes.slice(0, 32, hex), Bytes.slice(32, 64, hex)];
    var makeSigner = (addToV) => (hash, privateKey) => {
      const signature = secp256k1.keyFromPrivate(new Buffer(privateKey.slice(2), "hex")).sign(new Buffer(hash.slice(2), "hex"), { canonical: true });
      return encodeSignature([Nat.fromString(Bytes.fromNumber(addToV + signature.recoveryParam)), Bytes.pad(32, Bytes.fromNat("0x" + signature.r.toString(16))), Bytes.pad(32, Bytes.fromNat("0x" + signature.s.toString(16)))]);
    };
    var sign = makeSigner(27);
    var recover = (hash, signature) => {
      const vals = decodeSignature(signature);
      const vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };
      const ecPublicKey = secp256k1.recoverPubKey(new Buffer(hash.slice(2), "hex"), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2);
      const publicKey = "0x" + ecPublicKey.encode("hex", false).slice(2);
      const publicHash = keccak256(publicKey);
      const address = toChecksum("0x" + publicHash.slice(-40));
      return address;
    };
    module.exports = {
      create,
      toChecksum,
      fromPrivate,
      sign,
      makeSigner,
      recover,
      encodeSignature,
      decodeSignature
    };
  }
});

// node_modules/web3-eth-accounts/node_modules/uuid/lib/rng-browser.js
var require_rng_browser = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/uuid/lib/rng-browser.js"(exports, module) {
    init_define_process_env();
    var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (getRandomValues) {
      rnds8 = new Uint8Array(16);
      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      rnds = new Array(16);
      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 3) === 0)
            r = Math.random() * 4294967296;
          rnds[i] = r >>> ((i & 3) << 3) & 255;
        }
        return rnds;
      };
    }
    var rnds8;
    var rnds;
  }
});

// node_modules/web3-eth-accounts/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/uuid/lib/bytesToUuid.js"(exports, module) {
    init_define_process_env();
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module.exports = bytesToUuid;
  }
});

// node_modules/web3-eth-accounts/node_modules/uuid/v1.js
var require_v1 = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/uuid/v1.js"(exports, module) {
    init_define_process_env();
    var rng = require_rng_browser();
    var bytesToUuid = require_bytesToUuid();
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = rng();
        if (node == null) {
          node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : bytesToUuid(b);
    }
    module.exports = v1;
  }
});

// node_modules/web3-eth-accounts/node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/uuid/v4.js"(exports, module) {
    init_define_process_env();
    var rng = require_rng_browser();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module.exports = v4;
  }
});

// node_modules/web3-eth-accounts/node_modules/uuid/index.js
var require_uuid = __commonJS({
  "node_modules/web3-eth-accounts/node_modules/uuid/index.js"(exports, module) {
    init_define_process_env();
    var v1 = require_v1();
    var v4 = require_v4();
    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    module.exports = uuid;
  }
});

// node_modules/web3-eth-accounts/lib/index.js
var require_lib37 = __commonJS({
  "node_modules/web3-eth-accounts/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var core = require_lib36();
    var Method = require_lib6();
    var Account = require_account();
    var cryp = typeof global === "undefined" ? require_crypto_browserify() : (init_crypto(), __toCommonJS(crypto_exports));
    var scrypt = require_scrypt();
    var uuid = require_uuid();
    var utils = require_lib();
    var helpers = require_lib3();
    var { TransactionFactory } = require_dist4();
    var Common = require_dist3().default;
    var HardForks = require_dist3().Hardfork;
    var ethereumjsUtil = require_dist();
    var isNot = function(value) {
      return typeof value === "undefined" || value === null;
    };
    var isExist = function(value) {
      return typeof value !== "undefined" && value !== null;
    };
    var Accounts = function Accounts2() {
      var _this = this;
      core.packageInit(this, arguments);
      delete this.BatchRequest;
      delete this.extend;
      var _ethereumCall = [
        new Method({
          name: "getNetworkId",
          call: "net_version",
          params: 0,
          outputFormatter: parseInt
        }),
        new Method({
          name: "getChainId",
          call: "eth_chainId",
          params: 0,
          outputFormatter: utils.hexToNumber
        }),
        new Method({
          name: "getGasPrice",
          call: "eth_gasPrice",
          params: 0
        }),
        new Method({
          name: "getTransactionCount",
          call: "eth_getTransactionCount",
          params: 2,
          inputFormatter: [function(address) {
            if (utils.isAddress(address)) {
              return address;
            } else {
              throw new Error("Address " + address + ' is not a valid address to get the "transactionCount".');
            }
          }, function() {
            return "latest";
          }]
        }),
        new Method({
          name: "getBlockByNumber",
          call: "eth_getBlockByNumber",
          params: 2,
          inputFormatter: [function(blockNumber) {
            return blockNumber ? utils.toHex(blockNumber) : "latest";
          }, function() {
            return false;
          }]
        })
      ];
      this._ethereumCall = {};
      _ethereumCall.forEach((method) => {
        method.attachToObject(_this._ethereumCall);
        method.setRequestManager(_this._requestManager);
      });
      this.wallet = new Wallet(this);
    };
    Accounts.prototype._addAccountFunctions = function(account) {
      var _this = this;
      account.signTransaction = function signTransaction(tx, callback) {
        return _this.signTransaction(tx, account.privateKey, callback);
      };
      account.sign = function sign(data) {
        return _this.sign(data, account.privateKey);
      };
      account.encrypt = function encrypt(password, options) {
        return _this.encrypt(account.privateKey, password, options);
      };
      return account;
    };
    Accounts.prototype.create = function create(entropy) {
      return this._addAccountFunctions(Account.create(entropy || utils.randomHex(32)));
    };
    Accounts.prototype.privateKeyToAccount = function privateKeyToAccount(privateKey, ignoreLength) {
      if (!privateKey.startsWith("0x")) {
        privateKey = "0x" + privateKey;
      }
      if (!ignoreLength && privateKey.length !== 66) {
        throw new Error("Private key must be 32 bytes long");
      }
      return this._addAccountFunctions(Account.fromPrivate(privateKey));
    };
    Accounts.prototype.signTransaction = function signTransaction(tx, privateKey, callback) {
      var _this = this, error2 = false, transactionOptions = {}, hasTxSigningOptions = !!(tx && (tx.chain && tx.hardfork || tx.common));
      callback = callback || function() {
      };
      if (!tx) {
        error2 = new Error("No transaction object given!");
        callback(error2);
        return Promise.reject(error2);
      }
      if (isExist(tx.common) && isNot(tx.common.customChain)) {
        error2 = new Error("If tx.common is provided it must have tx.common.customChain");
        callback(error2);
        return Promise.reject(error2);
      }
      if (isExist(tx.common) && isNot(tx.common.customChain.chainId)) {
        error2 = new Error("If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId");
        callback(error2);
        return Promise.reject(error2);
      }
      if (isExist(tx.common) && isExist(tx.common.customChain.chainId) && isExist(tx.chainId) && tx.chainId !== tx.common.customChain.chainId) {
        error2 = new Error("Chain Id doesnt match in tx.chainId tx.common.customChain.chainId");
        callback(error2);
        return Promise.reject(error2);
      }
      function signed(tx2) {
        const error3 = _validateTransactionForSigning(tx2);
        if (error3) {
          callback(error3);
          return Promise.reject(error3);
        }
        try {
          var transaction = helpers.formatters.inputCallFormatter(Object.assign({}, tx2));
          transaction.data = transaction.data || "0x";
          transaction.value = transaction.value || "0x";
          transaction.gasLimit = transaction.gasLimit || transaction.gas;
          if (transaction.type === "0x1" && transaction.accessList === void 0)
            transaction.accessList = [];
          if (!hasTxSigningOptions) {
            transactionOptions.common = Common.forCustomChain("mainnet", {
              name: "custom-network",
              networkId: transaction.networkId,
              chainId: transaction.chainId
            }, transaction.hardfork || HardForks.London);
            delete transaction.networkId;
          } else {
            if (transaction.common) {
              transactionOptions.common = Common.forCustomChain(transaction.common.baseChain || "mainnet", {
                name: transaction.common.customChain.name || "custom-network",
                networkId: transaction.common.customChain.networkId,
                chainId: transaction.common.customChain.chainId
              }, transaction.common.hardfork || HardForks.London);
              delete transaction.common;
            }
            if (transaction.chain) {
              transactionOptions.chain = transaction.chain;
              delete transaction.chain;
            }
            if (transaction.hardfork) {
              transactionOptions.hardfork = transaction.hardfork;
              delete transaction.hardfork;
            }
          }
          if (privateKey.startsWith("0x")) {
            privateKey = privateKey.substring(2);
          }
          var ethTx = TransactionFactory.fromTxData(transaction, transactionOptions);
          var signedTx = ethTx.sign(Buffer.from(privateKey, "hex"));
          var validationErrors = signedTx.validate(true);
          if (validationErrors.length > 0) {
            let errorString = "Signer Error: ";
            for (const validationError of validationErrors) {
              errorString += `${errorString} ${validationError}.`;
            }
            throw new Error(errorString);
          }
          var rlpEncoded = signedTx.serialize().toString("hex");
          var rawTransaction = "0x" + rlpEncoded;
          var transactionHash = utils.keccak256(rawTransaction);
          var result = {
            messageHash: "0x" + Buffer.from(signedTx.getMessageToSign(true)).toString("hex"),
            v: "0x" + signedTx.v.toString("hex"),
            r: "0x" + signedTx.r.toString("hex"),
            s: "0x" + signedTx.s.toString("hex"),
            rawTransaction,
            transactionHash
          };
          callback(null, result);
          return result;
        } catch (e) {
          callback(e);
          return Promise.reject(e);
        }
      }
      tx.type = _handleTxType(tx);
      if (tx.nonce !== void 0 && tx.chainId !== void 0 && (tx.gasPrice !== void 0 || tx.maxFeePerGas !== void 0 && tx.maxPriorityFeePerGas !== void 0) && hasTxSigningOptions) {
        return Promise.resolve(signed(tx));
      }
      return Promise.all([
        isNot(tx.common) || isNot(tx.common.customChain.chainId) ? isNot(tx.chainId) ? _this._ethereumCall.getChainId() : tx.chainId : void 0,
        isNot(tx.nonce) ? _this._ethereumCall.getTransactionCount(_this.privateKeyToAccount(privateKey).address) : tx.nonce,
        isNot(hasTxSigningOptions) ? _this._ethereumCall.getNetworkId() : 1,
        _handleTxPricing(_this, tx)
      ]).then(function(args) {
        const [txchainId, txnonce, txnetworkId, txgasInfo] = args;
        if (isNot(txchainId) && isNot(tx.common) && isNot(tx.common.customChain.chainId) || isNot(txnonce) || isNot(txnetworkId) || isNot(txgasInfo)) {
          throw new Error(`One of the values "chainId", "networkId", "gasPrice", or "nonce" couldn't be fetched: ` + JSON.stringify(args));
        }
        return signed(__spreadValues(__spreadProps(__spreadValues(__spreadValues({}, tx), isNot(tx.common) || isNot(tx.common.customChain.chainId) ? { chainId: txchainId } : {}), {
          nonce: txnonce,
          networkId: txnetworkId
        }), txgasInfo));
      });
    };
    function _validateTransactionForSigning(tx) {
      if (tx.common && (tx.chain && tx.hardfork)) {
        return new Error("Please provide the @ethereumjs/common object or the chain and hardfork property but not all together.");
      }
      if (tx.chain && !tx.hardfork || tx.hardfork && !tx.chain) {
        return new Error('When specifying chain and hardfork, both values must be defined. Received "chain": ' + tx.chain + ', "hardfork": ' + tx.hardfork);
      }
      if (!tx.gas && !tx.gasLimit && (!tx.maxPriorityFeePerGas && !tx.maxFeePerGas)) {
        return new Error('"gas" is missing');
      }
      if (tx.gas && tx.gasPrice) {
        if (tx.gas < 0 || tx.gasPrice < 0) {
          return new Error("Gas or gasPrice is lower than 0");
        }
      } else {
        if (tx.maxPriorityFeePerGas < 0 || tx.maxFeePerGas < 0) {
          return new Error("maxPriorityFeePerGas or maxFeePerGas is lower than 0");
        }
      }
      if (tx.nonce < 0 || tx.chainId < 0) {
        return new Error("Nonce or chainId is lower than 0");
      }
      return;
    }
    function _handleTxType(tx) {
      const hasEip1559 = tx.maxFeePerGas !== void 0 || tx.maxPriorityFeePerGas !== void 0;
      let txType;
      if (tx.type !== void 0) {
        txType = utils.toHex(tx.type);
      } else if (tx.type === void 0 && hasEip1559) {
        txType = "0x2";
      }
      if (tx.gasPrice !== void 0 && (txType === "0x2" || hasEip1559))
        throw Error("eip-1559 transactions don't support gasPrice");
      if ((txType === "0x1" || txType === "0x0") && hasEip1559)
        throw Error("pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas");
      if (hasEip1559 || (tx.common && tx.common.hardfork && tx.common.hardfork.toLowerCase() === HardForks.London || tx.hardfork && tx.hardfork.toLowerCase() === HardForks.London)) {
        txType = "0x2";
      } else if (tx.accessList || (tx.common && tx.common.hardfork && tx.common.hardfork.toLowerCase() === HardForks.Berlin || tx.hardfork && tx.hardfork.toLowerCase() === HardForks.Berlin)) {
        txType = "0x1";
      }
      return txType;
    }
    function _handleTxPricing(_this, tx) {
      return new Promise((resolve, reject) => {
        try {
          if ((tx.type === void 0 || tx.type < "0x2") && tx.gasPrice !== void 0) {
            resolve({ gasPrice: tx.gasPrice });
          } else {
            Promise.all([
              _this._ethereumCall.getBlockByNumber(),
              _this._ethereumCall.getGasPrice()
            ]).then((responses) => {
              const [block, gasPrice] = responses;
              if (tx.type === "0x2" && block && block.baseFeePerGas) {
                let maxPriorityFeePerGas, maxFeePerGas;
                if (tx.gasPrice) {
                  maxPriorityFeePerGas = tx.gasPrice;
                  maxFeePerGas = tx.gasPrice;
                  delete tx.gasPrice;
                } else {
                  maxPriorityFeePerGas = tx.maxPriorityFeePerGas || "0x9502F900";
                  maxFeePerGas = tx.maxFeePerGas || utils.toHex(utils.toBN(block.baseFeePerGas).mul(utils.toBN(2)).add(utils.toBN(maxPriorityFeePerGas)));
                }
                resolve({ maxFeePerGas, maxPriorityFeePerGas });
              } else {
                if (tx.maxPriorityFeePerGas || tx.maxFeePerGas)
                  throw Error("Network doesn't support eip-1559");
                resolve({ gasPrice });
              }
            });
          }
        } catch (error2) {
          reject(error2);
        }
      });
    }
    Accounts.prototype.recoverTransaction = function recoverTransaction(rawTx, txOptions = {}) {
      const data = Buffer.from(rawTx.slice(2), "hex");
      const tx = TransactionFactory.fromSerializedData(data);
      return utils.toChecksumAddress(tx.getSenderAddress().toString("hex"));
    };
    Accounts.prototype.hashMessage = function hashMessage(data) {
      var messageHex = utils.isHexStrict(data) ? data : utils.utf8ToHex(data);
      var messageBytes = utils.hexToBytes(messageHex);
      var messageBuffer = Buffer.from(messageBytes);
      var preamble = "Ethereum Signed Message:\n" + messageBytes.length;
      var preambleBuffer = Buffer.from(preamble);
      var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);
      return ethereumjsUtil.bufferToHex(ethereumjsUtil.keccak256(ethMessage));
    };
    Accounts.prototype.sign = function sign(data, privateKey) {
      if (!privateKey.startsWith("0x")) {
        privateKey = "0x" + privateKey;
      }
      if (privateKey.length !== 66) {
        throw new Error("Private key must be 32 bytes long");
      }
      var hash = this.hashMessage(data);
      var signature = Account.sign(hash, privateKey);
      var vrs = Account.decodeSignature(signature);
      return {
        message: data,
        messageHash: hash,
        v: vrs[0],
        r: vrs[1],
        s: vrs[2],
        signature
      };
    };
    Accounts.prototype.recover = function recover(message, signature, preFixed) {
      var args = [].slice.apply(arguments);
      if (!!message && typeof message === "object") {
        return this.recover(message.messageHash, Account.encodeSignature([message.v, message.r, message.s]), true);
      }
      if (!preFixed) {
        message = this.hashMessage(message);
      }
      if (args.length >= 4) {
        preFixed = args.slice(-1)[0];
        preFixed = typeof preFixed === "boolean" ? !!preFixed : false;
        return this.recover(message, Account.encodeSignature(args.slice(1, 4)), preFixed);
      }
      return Account.recover(message, signature);
    };
    Accounts.prototype.decrypt = function(v3Keystore, password, nonStrict) {
      if (!(typeof password === "string")) {
        throw new Error("No password given.");
      }
      var json = !!v3Keystore && typeof v3Keystore === "object" ? v3Keystore : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore);
      if (json.version !== 3) {
        throw new Error("Not a valid V3 wallet");
      }
      var derivedKey;
      var kdfparams;
      if (json.crypto.kdf === "scrypt") {
        kdfparams = json.crypto.kdfparams;
        derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, "hex"), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);
      } else if (json.crypto.kdf === "pbkdf2") {
        kdfparams = json.crypto.kdfparams;
        if (kdfparams.prf !== "hmac-sha256") {
          throw new Error("Unsupported parameters to PBKDF2");
        }
        derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, "hex"), kdfparams.c, kdfparams.dklen, "sha256");
      } else {
        throw new Error("Unsupported key derivation scheme");
      }
      var ciphertext = Buffer.from(json.crypto.ciphertext, "hex");
      var mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace("0x", "");
      if (mac !== json.crypto.mac) {
        throw new Error("Key derivation failed - possibly wrong password");
      }
      var decipher = cryp.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, "hex"));
      var seed = "0x" + Buffer.from([...decipher.update(ciphertext), ...decipher.final()]).toString("hex");
      return this.privateKeyToAccount(seed, true);
    };
    Accounts.prototype.encrypt = function(privateKey, password, options) {
      var account = this.privateKeyToAccount(privateKey, true);
      options = options || {};
      var salt = options.salt || cryp.randomBytes(32);
      var iv = options.iv || cryp.randomBytes(16);
      var derivedKey;
      var kdf = options.kdf || "scrypt";
      var kdfparams = {
        dklen: options.dklen || 32,
        salt: salt.toString("hex")
      };
      if (kdf === "pbkdf2") {
        kdfparams.c = options.c || 262144;
        kdfparams.prf = "hmac-sha256";
        derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, "hex"), kdfparams.c, kdfparams.dklen, "sha256");
      } else if (kdf === "scrypt") {
        kdfparams.n = options.n || 8192;
        kdfparams.r = options.r || 8;
        kdfparams.p = options.p || 1;
        derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, "hex"), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);
      } else {
        throw new Error("Unsupported kdf");
      }
      var cipher = cryp.createCipheriv(options.cipher || "aes-128-ctr", derivedKey.slice(0, 16), iv);
      if (!cipher) {
        throw new Error("Unsupported cipher");
      }
      var ciphertext = Buffer.from([
        ...cipher.update(Buffer.from(account.privateKey.replace("0x", ""), "hex")),
        ...cipher.final()
      ]);
      var mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace("0x", "");
      return {
        version: 3,
        id: uuid.v4({ random: options.uuid || cryp.randomBytes(16) }),
        address: account.address.toLowerCase().replace("0x", ""),
        crypto: {
          ciphertext: ciphertext.toString("hex"),
          cipherparams: {
            iv: iv.toString("hex")
          },
          cipher: options.cipher || "aes-128-ctr",
          kdf,
          kdfparams,
          mac: mac.toString("hex")
        }
      };
    };
    function Wallet(accounts) {
      this._accounts = accounts;
      this.length = 0;
      this.defaultKeyName = "web3js_wallet";
    }
    Wallet.prototype._findSafeIndex = function(pointer) {
      pointer = pointer || 0;
      if (this.hasOwnProperty(pointer)) {
        return this._findSafeIndex(pointer + 1);
      } else {
        return pointer;
      }
    };
    Wallet.prototype._currentIndexes = function() {
      var keys = Object.keys(this);
      var indexes = keys.map(function(key) {
        return parseInt(key);
      }).filter(function(n) {
        return n < 9e20;
      });
      return indexes;
    };
    Wallet.prototype.create = function(numberOfAccounts, entropy) {
      for (var i = 0; i < numberOfAccounts; ++i) {
        this.add(this._accounts.create(entropy).privateKey);
      }
      return this;
    };
    Wallet.prototype.add = function(account) {
      if (typeof account === "string") {
        account = this._accounts.privateKeyToAccount(account);
      }
      if (!this[account.address]) {
        account = this._accounts.privateKeyToAccount(account.privateKey);
        account.index = this._findSafeIndex();
        this[account.index] = account;
        this[account.address] = account;
        this[account.address.toLowerCase()] = account;
        this.length++;
        return account;
      } else {
        return this[account.address];
      }
    };
    Wallet.prototype.remove = function(addressOrIndex) {
      var account = this[addressOrIndex];
      if (account && account.address) {
        this[account.address].privateKey = null;
        delete this[account.address];
        this[account.address.toLowerCase()].privateKey = null;
        delete this[account.address.toLowerCase()];
        this[account.index].privateKey = null;
        delete this[account.index];
        this.length--;
        return true;
      } else {
        return false;
      }
    };
    Wallet.prototype.clear = function() {
      var _this = this;
      var indexes = this._currentIndexes();
      indexes.forEach(function(index) {
        _this.remove(index);
      });
      return this;
    };
    Wallet.prototype.encrypt = function(password, options) {
      var _this = this;
      var indexes = this._currentIndexes();
      var accounts = indexes.map(function(index) {
        return _this[index].encrypt(password, options);
      });
      return accounts;
    };
    Wallet.prototype.decrypt = function(encryptedWallet, password) {
      var _this = this;
      encryptedWallet.forEach(function(keystore) {
        var account = _this._accounts.decrypt(keystore, password);
        if (account) {
          _this.add(account);
        } else {
          throw new Error("Couldn't decrypt accounts. Password wrong?");
        }
      });
      return this;
    };
    Wallet.prototype.save = function(password, keyName) {
      localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)));
      return true;
    };
    Wallet.prototype.load = function(password, keyName) {
      var keystore = localStorage.getItem(keyName || this.defaultKeyName);
      if (keystore) {
        try {
          keystore = JSON.parse(keystore);
        } catch (e) {
        }
      }
      return this.decrypt(keystore || [], password);
    };
    if (!storageAvailable("localStorage")) {
      delete Wallet.prototype.save;
      delete Wallet.prototype.load;
    }
    function storageAvailable(type) {
      var storage;
      try {
        storage = self[type];
        var x = "__storage_test__";
        storage.setItem(x, x);
        storage.removeItem(x);
        return true;
      } catch (e) {
        return e && (e.code === 22 || e.code === 1014 || e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") && (storage && storage.length !== 0);
      }
    }
    module.exports = Accounts;
  }
});

// node_modules/web3-eth/lib/getNetworkType.js
var require_getNetworkType = __commonJS({
  "node_modules/web3-eth/lib/getNetworkType.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var getNetworkType = function(callback) {
      var _this = this, id;
      return this.net.getId().then(function(givenId) {
        id = givenId;
        return _this.getBlock(0);
      }).then(function(genesis) {
        var returnValue = "private";
        if (genesis.hash === "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3" && id === 1) {
          returnValue = "main";
        }
        if (genesis.hash === "0x41941023680923e0fe4d74a34bdac8141f2540e3ae90623718e47d66d1ca4a2d" && id === 3) {
          returnValue = "ropsten";
        }
        if (genesis.hash === "0x6341fd3daf94b748c72ced5a5b26028f2474f5f00d824504e4fa37a75767e177" && id === 4) {
          returnValue = "rinkeby";
        }
        if (genesis.hash === "0xbf7e331f7f7c1dd2e05159666b3bf8bc7a8a3a9eb1d518969eab529dd9b88c1a" && id === 5) {
          returnValue = "goerli";
        }
        if (genesis.hash === "0xa3c565fc15c7478862d50ccd6561e3c06b24cc509bf388941c25ea985ce32cb9" && id === 42) {
          returnValue = "kovan";
        }
        if (typeof callback === "function") {
          callback(null, returnValue);
        }
        return returnValue;
      }).catch(function(err) {
        if (typeof callback === "function") {
          callback(err);
        } else {
          throw err;
        }
      });
    };
    module.exports = getNetworkType;
  }
});

// node_modules/web3-eth/lib/index.js
var require_lib38 = __commonJS({
  "node_modules/web3-eth/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var core = require_lib18();
    var helpers = require_lib3();
    var Subscriptions = require_lib5().subscriptions;
    var Method = require_lib6();
    var utils = require_lib();
    var Net = require_lib24();
    var ENS = require_lib25();
    var Personal = require_lib31();
    var BaseContract = require_lib8();
    var Iban = require_lib2();
    var Accounts = require_lib37();
    var abi = require_lib7();
    var getNetworkType = require_getNetworkType();
    var formatter = helpers.formatters;
    var blockCall = function(args) {
      return typeof args[0] === "string" && args[0].indexOf("0x") === 0 ? "eth_getBlockByHash" : "eth_getBlockByNumber";
    };
    var transactionFromBlockCall = function(args) {
      return typeof args[0] === "string" && args[0].indexOf("0x") === 0 ? "eth_getTransactionByBlockHashAndIndex" : "eth_getTransactionByBlockNumberAndIndex";
    };
    var uncleCall = function(args) {
      return typeof args[0] === "string" && args[0].indexOf("0x") === 0 ? "eth_getUncleByBlockHashAndIndex" : "eth_getUncleByBlockNumberAndIndex";
    };
    var getBlockTransactionCountCall = function(args) {
      return typeof args[0] === "string" && args[0].indexOf("0x") === 0 ? "eth_getBlockTransactionCountByHash" : "eth_getBlockTransactionCountByNumber";
    };
    var uncleCountCall = function(args) {
      return typeof args[0] === "string" && args[0].indexOf("0x") === 0 ? "eth_getUncleCountByBlockHash" : "eth_getUncleCountByBlockNumber";
    };
    var Eth = function Eth2() {
      var _this = this;
      core.packageInit(this, arguments);
      var setRequestManager = this.setRequestManager;
      this.setRequestManager = function(manager) {
        setRequestManager(manager);
        _this.net.setRequestManager(manager);
        _this.personal.setRequestManager(manager);
        _this.accounts.setRequestManager(manager);
        _this.Contract._requestManager = _this._requestManager;
        _this.Contract.currentProvider = _this._provider;
        return true;
      };
      var setProvider = this.setProvider;
      this.setProvider = function() {
        setProvider.apply(_this, arguments);
        _this.setRequestManager(_this._requestManager);
        _this.ens._detectedAddress = null;
        _this.ens._lastSyncCheck = null;
      };
      var handleRevert = false;
      var defaultAccount = null;
      var defaultBlock = "latest";
      var transactionBlockTimeout = 50;
      var transactionConfirmationBlocks = 24;
      var transactionPollingTimeout = 750;
      var transactionPollingInterval = 1e3;
      var blockHeaderTimeout = 10;
      var maxListenersWarningThreshold = 100;
      var defaultChain, defaultHardfork, defaultCommon;
      Object.defineProperty(this, "handleRevert", {
        get: function() {
          return handleRevert;
        },
        set: function(val) {
          handleRevert = val;
          _this.Contract.handleRevert = handleRevert;
          methods.forEach(function(method) {
            method.handleRevert = handleRevert;
          });
        },
        enumerable: true
      });
      Object.defineProperty(this, "defaultCommon", {
        get: function() {
          return defaultCommon;
        },
        set: function(val) {
          defaultCommon = val;
          _this.Contract.defaultCommon = defaultCommon;
          methods.forEach(function(method) {
            method.defaultCommon = defaultCommon;
          });
        },
        enumerable: true
      });
      Object.defineProperty(this, "defaultHardfork", {
        get: function() {
          return defaultHardfork;
        },
        set: function(val) {
          defaultHardfork = val;
          _this.Contract.defaultHardfork = defaultHardfork;
          methods.forEach(function(method) {
            method.defaultHardfork = defaultHardfork;
          });
        },
        enumerable: true
      });
      Object.defineProperty(this, "defaultChain", {
        get: function() {
          return defaultChain;
        },
        set: function(val) {
          defaultChain = val;
          _this.Contract.defaultChain = defaultChain;
          methods.forEach(function(method) {
            method.defaultChain = defaultChain;
          });
        },
        enumerable: true
      });
      Object.defineProperty(this, "transactionPollingTimeout", {
        get: function() {
          return transactionPollingTimeout;
        },
        set: function(val) {
          transactionPollingTimeout = val;
          _this.Contract.transactionPollingTimeout = transactionPollingTimeout;
          methods.forEach(function(method) {
            method.transactionPollingTimeout = transactionPollingTimeout;
          });
        },
        enumerable: true
      });
      Object.defineProperty(this, "transactionPollingInterval", {
        get: function() {
          return transactionPollingInterval;
        },
        set: function(val) {
          transactionPollingInterval = val;
          _this.Contract.transactionPollingInterval = transactionPollingInterval;
          methods.forEach(function(method) {
            method.transactionPollingInterval = transactionPollingInterval;
          });
        },
        enumerable: true
      });
      Object.defineProperty(this, "transactionConfirmationBlocks", {
        get: function() {
          return transactionConfirmationBlocks;
        },
        set: function(val) {
          transactionConfirmationBlocks = val;
          _this.Contract.transactionConfirmationBlocks = transactionConfirmationBlocks;
          methods.forEach(function(method) {
            method.transactionConfirmationBlocks = transactionConfirmationBlocks;
          });
        },
        enumerable: true
      });
      Object.defineProperty(this, "transactionBlockTimeout", {
        get: function() {
          return transactionBlockTimeout;
        },
        set: function(val) {
          transactionBlockTimeout = val;
          _this.Contract.transactionBlockTimeout = transactionBlockTimeout;
          methods.forEach(function(method) {
            method.transactionBlockTimeout = transactionBlockTimeout;
          });
        },
        enumerable: true
      });
      Object.defineProperty(this, "blockHeaderTimeout", {
        get: function() {
          return blockHeaderTimeout;
        },
        set: function(val) {
          blockHeaderTimeout = val;
          _this.Contract.blockHeaderTimeout = blockHeaderTimeout;
          methods.forEach(function(method) {
            method.blockHeaderTimeout = blockHeaderTimeout;
          });
        },
        enumerable: true
      });
      Object.defineProperty(this, "defaultAccount", {
        get: function() {
          return defaultAccount;
        },
        set: function(val) {
          if (val) {
            defaultAccount = utils.toChecksumAddress(formatter.inputAddressFormatter(val));
          }
          _this.Contract.defaultAccount = defaultAccount;
          _this.personal.defaultAccount = defaultAccount;
          methods.forEach(function(method) {
            method.defaultAccount = defaultAccount;
          });
          return val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "defaultBlock", {
        get: function() {
          return defaultBlock;
        },
        set: function(val) {
          defaultBlock = val;
          _this.Contract.defaultBlock = defaultBlock;
          _this.personal.defaultBlock = defaultBlock;
          methods.forEach(function(method) {
            method.defaultBlock = defaultBlock;
          });
          return val;
        },
        enumerable: true
      });
      Object.defineProperty(this, "maxListenersWarningThreshold", {
        get: function() {
          return maxListenersWarningThreshold;
        },
        set: function(val) {
          if (_this.currentProvider && _this.currentProvider.setMaxListeners) {
            maxListenersWarningThreshold = val;
            _this.currentProvider.setMaxListeners(val);
          }
        },
        enumerable: true
      });
      this.clearSubscriptions = _this._requestManager.clearSubscriptions.bind(_this._requestManager);
      this.removeSubscriptionById = _this._requestManager.removeSubscription.bind(_this._requestManager);
      this.net = new Net(this);
      this.net.getNetworkType = getNetworkType.bind(this);
      this.accounts = new Accounts(this);
      this.personal = new Personal(this);
      this.personal.defaultAccount = this.defaultAccount;
      this.maxListenersWarningThreshold = maxListenersWarningThreshold;
      var self2 = this;
      var Contract = function Contract2() {
        BaseContract.apply(this, arguments);
        var _this2 = this;
        var setProvider2 = self2.setProvider;
        self2.setProvider = function() {
          setProvider2.apply(self2, arguments);
          core.packageInit(_this2, [self2]);
        };
      };
      Contract.setProvider = function() {
        BaseContract.setProvider.apply(this, arguments);
      };
      Contract.prototype = Object.create(BaseContract.prototype);
      Contract.prototype.constructor = Contract;
      this.Contract = Contract;
      this.Contract.defaultAccount = this.defaultAccount;
      this.Contract.defaultBlock = this.defaultBlock;
      this.Contract.transactionBlockTimeout = this.transactionBlockTimeout;
      this.Contract.transactionConfirmationBlocks = this.transactionConfirmationBlocks;
      this.Contract.transactionPollingTimeout = this.transactionPollingTimeout;
      this.Contract.transactionPollingInterval = this.transactionPollingInterval;
      this.Contract.blockHeaderTimeout = this.blockHeaderTimeout;
      this.Contract.handleRevert = this.handleRevert;
      this.Contract._requestManager = this._requestManager;
      this.Contract._ethAccounts = this.accounts;
      this.Contract.currentProvider = this._requestManager.provider;
      this.Iban = Iban;
      this.abi = abi;
      this.ens = new ENS(this);
      var methods = [
        new Method({
          name: "getNodeInfo",
          call: "web3_clientVersion"
        }),
        new Method({
          name: "getProtocolVersion",
          call: "eth_protocolVersion",
          params: 0
        }),
        new Method({
          name: "getCoinbase",
          call: "eth_coinbase",
          params: 0
        }),
        new Method({
          name: "isMining",
          call: "eth_mining",
          params: 0
        }),
        new Method({
          name: "getHashrate",
          call: "eth_hashrate",
          params: 0,
          outputFormatter: utils.hexToNumber
        }),
        new Method({
          name: "isSyncing",
          call: "eth_syncing",
          params: 0,
          outputFormatter: formatter.outputSyncingFormatter
        }),
        new Method({
          name: "getGasPrice",
          call: "eth_gasPrice",
          params: 0,
          outputFormatter: formatter.outputBigNumberFormatter
        }),
        new Method({
          name: "getFeeHistory",
          call: "eth_feeHistory",
          params: 3,
          inputFormatter: [utils.numberToHex, formatter.inputBlockNumberFormatter, null]
        }),
        new Method({
          name: "getAccounts",
          call: "eth_accounts",
          params: 0,
          outputFormatter: utils.toChecksumAddress
        }),
        new Method({
          name: "getBlockNumber",
          call: "eth_blockNumber",
          params: 0,
          outputFormatter: utils.hexToNumber
        }),
        new Method({
          name: "getBalance",
          call: "eth_getBalance",
          params: 2,
          inputFormatter: [formatter.inputAddressFormatter, formatter.inputDefaultBlockNumberFormatter],
          outputFormatter: formatter.outputBigNumberFormatter
        }),
        new Method({
          name: "getStorageAt",
          call: "eth_getStorageAt",
          params: 3,
          inputFormatter: [formatter.inputAddressFormatter, utils.numberToHex, formatter.inputDefaultBlockNumberFormatter]
        }),
        new Method({
          name: "getCode",
          call: "eth_getCode",
          params: 2,
          inputFormatter: [formatter.inputAddressFormatter, formatter.inputDefaultBlockNumberFormatter]
        }),
        new Method({
          name: "getBlock",
          call: blockCall,
          params: 2,
          inputFormatter: [formatter.inputBlockNumberFormatter, function(val) {
            return !!val;
          }],
          outputFormatter: formatter.outputBlockFormatter
        }),
        new Method({
          name: "getUncle",
          call: uncleCall,
          params: 2,
          inputFormatter: [formatter.inputBlockNumberFormatter, utils.numberToHex],
          outputFormatter: formatter.outputBlockFormatter
        }),
        new Method({
          name: "getBlockTransactionCount",
          call: getBlockTransactionCountCall,
          params: 1,
          inputFormatter: [formatter.inputBlockNumberFormatter],
          outputFormatter: utils.hexToNumber
        }),
        new Method({
          name: "getBlockUncleCount",
          call: uncleCountCall,
          params: 1,
          inputFormatter: [formatter.inputBlockNumberFormatter],
          outputFormatter: utils.hexToNumber
        }),
        new Method({
          name: "getTransaction",
          call: "eth_getTransactionByHash",
          params: 1,
          inputFormatter: [null],
          outputFormatter: formatter.outputTransactionFormatter
        }),
        new Method({
          name: "getTransactionFromBlock",
          call: transactionFromBlockCall,
          params: 2,
          inputFormatter: [formatter.inputBlockNumberFormatter, utils.numberToHex],
          outputFormatter: formatter.outputTransactionFormatter
        }),
        new Method({
          name: "getTransactionReceipt",
          call: "eth_getTransactionReceipt",
          params: 1,
          inputFormatter: [null],
          outputFormatter: formatter.outputTransactionReceiptFormatter
        }),
        new Method({
          name: "getTransactionCount",
          call: "eth_getTransactionCount",
          params: 2,
          inputFormatter: [formatter.inputAddressFormatter, formatter.inputDefaultBlockNumberFormatter],
          outputFormatter: utils.hexToNumber
        }),
        new Method({
          name: "sendSignedTransaction",
          call: "eth_sendRawTransaction",
          params: 1,
          inputFormatter: [null],
          abiCoder: abi
        }),
        new Method({
          name: "signTransaction",
          call: "eth_signTransaction",
          params: 1,
          inputFormatter: [formatter.inputTransactionFormatter]
        }),
        new Method({
          name: "sendTransaction",
          call: "eth_sendTransaction",
          params: 1,
          inputFormatter: [formatter.inputTransactionFormatter],
          abiCoder: abi
        }),
        new Method({
          name: "sign",
          call: "eth_sign",
          params: 2,
          inputFormatter: [formatter.inputSignFormatter, formatter.inputAddressFormatter],
          transformPayload: function(payload) {
            payload.params.reverse();
            return payload;
          }
        }),
        new Method({
          name: "call",
          call: "eth_call",
          params: 2,
          inputFormatter: [formatter.inputCallFormatter, formatter.inputDefaultBlockNumberFormatter],
          abiCoder: abi
        }),
        new Method({
          name: "estimateGas",
          call: "eth_estimateGas",
          params: 1,
          inputFormatter: [formatter.inputCallFormatter],
          outputFormatter: utils.hexToNumber
        }),
        new Method({
          name: "submitWork",
          call: "eth_submitWork",
          params: 3
        }),
        new Method({
          name: "getWork",
          call: "eth_getWork",
          params: 0
        }),
        new Method({
          name: "getPastLogs",
          call: "eth_getLogs",
          params: 1,
          inputFormatter: [formatter.inputLogFormatter],
          outputFormatter: formatter.outputLogFormatter
        }),
        new Method({
          name: "getChainId",
          call: "eth_chainId",
          params: 0,
          outputFormatter: utils.hexToNumber
        }),
        new Method({
          name: "requestAccounts",
          call: "eth_requestAccounts",
          params: 0,
          outputFormatter: utils.toChecksumAddress
        }),
        new Method({
          name: "getProof",
          call: "eth_getProof",
          params: 3,
          inputFormatter: [formatter.inputAddressFormatter, formatter.inputStorageKeysFormatter, formatter.inputDefaultBlockNumberFormatter],
          outputFormatter: formatter.outputProofFormatter
        }),
        new Method({
          name: "getPendingTransactions",
          call: "eth_pendingTransactions",
          params: 0,
          outputFormatter: formatter.outputTransactionFormatter
        }),
        new Method({
          name: "createAccessList",
          call: "eth_createAccessList",
          params: 2,
          inputFormatter: [formatter.inputTransactionFormatter, formatter.inputDefaultBlockNumberFormatter]
        }),
        new Subscriptions({
          name: "subscribe",
          type: "eth",
          subscriptions: {
            "newBlockHeaders": {
              subscriptionName: "newHeads",
              params: 0,
              outputFormatter: formatter.outputBlockFormatter
            },
            "pendingTransactions": {
              subscriptionName: "newPendingTransactions",
              params: 0
            },
            "logs": {
              params: 1,
              inputFormatter: [formatter.inputLogFormatter],
              outputFormatter: formatter.outputLogFormatter,
              subscriptionHandler: function(output) {
                if (output.removed) {
                  this.emit("changed", output);
                } else {
                  this.emit("data", output);
                }
                if (typeof this.callback === "function") {
                  this.callback(null, output, this);
                }
              }
            },
            "syncing": {
              params: 0,
              outputFormatter: formatter.outputSyncingFormatter,
              subscriptionHandler: function(output) {
                var _this2 = this;
                if (this._isSyncing !== true) {
                  this._isSyncing = true;
                  this.emit("changed", _this2._isSyncing);
                  if (typeof this.callback === "function") {
                    this.callback(null, _this2._isSyncing, this);
                  }
                  setTimeout(function() {
                    _this2.emit("data", output);
                    if (typeof _this2.callback === "function") {
                      _this2.callback(null, output, _this2);
                    }
                  }, 0);
                } else {
                  this.emit("data", output);
                  if (typeof _this2.callback === "function") {
                    this.callback(null, output, this);
                  }
                  clearTimeout(this._isSyncingTimeout);
                  this._isSyncingTimeout = setTimeout(function() {
                    if (output.currentBlock > output.highestBlock - 200) {
                      _this2._isSyncing = false;
                      _this2.emit("changed", _this2._isSyncing);
                      if (typeof _this2.callback === "function") {
                        _this2.callback(null, _this2._isSyncing, _this2);
                      }
                    }
                  }, 500);
                }
              }
            }
          }
        })
      ];
      methods.forEach(function(method) {
        method.attachToObject(_this);
        method.setRequestManager(_this._requestManager, _this.accounts);
        method.defaultBlock = _this.defaultBlock;
        method.defaultAccount = _this.defaultAccount;
        method.transactionBlockTimeout = _this.transactionBlockTimeout;
        method.transactionConfirmationBlocks = _this.transactionConfirmationBlocks;
        method.transactionPollingTimeout = _this.transactionPollingTimeout;
        method.transactionPollingInterval = _this.transactionPollingInterval;
        method.handleRevert = _this.handleRevert;
      });
    };
    core.addProviders(Eth);
    module.exports = Eth;
  }
});

// node_modules/web3-shh/node_modules/web3-core-requestmanager/lib/jsonrpc.js
var require_jsonrpc6 = __commonJS({
  "node_modules/web3-shh/node_modules/web3-core-requestmanager/lib/jsonrpc.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = {
      messageId: 0
    };
    Jsonrpc.toPayload = function(method, params) {
      if (!method) {
        throw new Error('JSONRPC method should be specified for params: "' + JSON.stringify(params) + '"!');
      }
      Jsonrpc.messageId++;
      return {
        jsonrpc: "2.0",
        id: Jsonrpc.messageId,
        method,
        params: params || []
      };
    };
    Jsonrpc.isValidResponse = function(response) {
      return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);
      function validateSingleMessage(message) {
        return !!message && !message.error && message.jsonrpc === "2.0" && (typeof message.id === "number" || typeof message.id === "string") && message.result !== void 0;
      }
    };
    Jsonrpc.toBatchPayload = function(messages) {
      return messages.map(function(message) {
        return Jsonrpc.toPayload(message.method, message.params);
      });
    };
    module.exports = Jsonrpc;
  }
});

// node_modules/web3-shh/node_modules/web3-core-requestmanager/lib/batch.js
var require_batch6 = __commonJS({
  "node_modules/web3-shh/node_modules/web3-core-requestmanager/lib/batch.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var Jsonrpc = require_jsonrpc6();
    var errors2 = require_lib3().errors;
    var Batch = function(requestManager) {
      this.requestManager = requestManager;
      this.requests = [];
    };
    Batch.prototype.add = function(request) {
      this.requests.push(request);
    };
    Batch.prototype.execute = function() {
      var requests = this.requests;
      var sortResponses = this._sortResponses.bind(this);
      this.requestManager.sendBatch(requests, function(err, results) {
        results = sortResponses(results);
        requests.map(function(request, index) {
          return results[index] || {};
        }).forEach(function(result, index) {
          if (requests[index].callback) {
            if (result && result.error) {
              return requests[index].callback(errors2.ErrorResponse(result));
            }
            if (!Jsonrpc.isValidResponse(result)) {
              return requests[index].callback(errors2.InvalidResponse(result));
            }
            try {
              requests[index].callback(null, requests[index].format ? requests[index].format(result.result) : result.result);
            } catch (err2) {
              requests[index].callback(err2);
            }
          }
        });
      });
    };
    Batch.prototype._sortResponses = function(responses) {
      return (responses || []).sort((a, b) => a.id - b.id);
    };
    module.exports = Batch;
  }
});

// node_modules/web3-shh/node_modules/web3-core-requestmanager/lib/givenProvider.js
var require_givenProvider6 = __commonJS({
  "node_modules/web3-shh/node_modules/web3-core-requestmanager/lib/givenProvider.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var givenProvider = null;
    var global2 = typeof globalThis === "object" ? globalThis : void 0;
    if (!global2) {
      try {
        global2 = Function("return this")();
      } catch (e) {
        global2 = self;
      }
    }
    if (typeof global2.ethereum !== "undefined") {
      givenProvider = global2.ethereum;
    } else if (typeof global2.web3 !== "undefined" && global2.web3.currentProvider) {
      if (global2.web3.currentProvider.sendAsync) {
        global2.web3.currentProvider.send = global2.web3.currentProvider.sendAsync;
        delete global2.web3.currentProvider.sendAsync;
      }
      if (!global2.web3.currentProvider.on && global2.web3.currentProvider.connection && global2.web3.currentProvider.connection.constructor.name === "ipcProviderWrapper") {
        global2.web3.currentProvider.on = function(type, callback) {
          if (typeof callback !== "function")
            throw new Error("The second parameter callback must be a function.");
          switch (type) {
            case "data":
              this.connection.on("data", function(data) {
                var result = "";
                data = data.toString();
                try {
                  result = JSON.parse(data);
                } catch (e) {
                  return callback(new Error("Couldn't parse response data" + data));
                }
                if (!result.id && result.method.indexOf("_subscription") !== -1) {
                  callback(null, result);
                }
              });
              break;
            default:
              this.connection.on(type, callback);
              break;
          }
        };
      }
      givenProvider = global2.web3.currentProvider;
    }
    module.exports = givenProvider;
  }
});

// node_modules/web3-shh/node_modules/web3-providers-ws/lib/helpers.js
var require_helpers7 = __commonJS({
  "node_modules/web3-shh/node_modules/web3-providers-ws/lib/helpers.js"(exports, module) {
    init_define_process_env();
    var isNode = Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
    var isRN = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var _btoa = null;
    var helpers = null;
    if (isNode || isRN) {
      _btoa = function(str) {
        return Buffer.from(str).toString("base64");
      };
      url = require_url();
      if (url.URL) {
        newURL = url.URL;
        helpers = function(url2) {
          return new newURL(url2);
        };
      } else {
        helpers = require_url().parse;
      }
    } else {
      _btoa = btoa.bind(typeof globalThis === "object" ? globalThis : self);
      helpers = function(url2) {
        return new URL(url2);
      };
    }
    var url;
    var newURL;
    module.exports = {
      parseURL: helpers,
      btoa: _btoa
    };
  }
});

// node_modules/web3-shh/node_modules/web3-providers-ws/lib/index.js
var require_lib39 = __commonJS({
  "node_modules/web3-shh/node_modules/web3-providers-ws/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var EventEmitter = require_eventemitter3();
    var helpers = require_helpers7();
    var errors2 = require_lib3().errors;
    var Ws = require_browser().w3cwebsocket;
    var WebsocketProvider = function WebsocketProvider2(url, options) {
      EventEmitter.call(this);
      options = options || {};
      this.url = url;
      this._customTimeout = options.timeout || 1e3 * 15;
      this.headers = options.headers || {};
      this.protocol = options.protocol || void 0;
      this.reconnectOptions = Object.assign({
        auto: false,
        delay: 5e3,
        maxAttempts: false,
        onTimeout: false
      }, options.reconnect);
      this.clientConfig = options.clientConfig || void 0;
      this.requestOptions = options.requestOptions || void 0;
      this.DATA = "data";
      this.CLOSE = "close";
      this.ERROR = "error";
      this.CONNECT = "connect";
      this.RECONNECT = "reconnect";
      this.connection = null;
      this.requestQueue = /* @__PURE__ */ new Map();
      this.responseQueue = /* @__PURE__ */ new Map();
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      var parsedURL = helpers.parseURL(url);
      if (parsedURL.username && parsedURL.password) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.username + ":" + parsedURL.password);
      }
      if (parsedURL.auth) {
        this.headers.authorization = "Basic " + helpers.btoa(parsedURL.auth);
      }
      Object.defineProperty(this, "connected", {
        get: function() {
          return this.connection && this.connection.readyState === this.connection.OPEN;
        },
        enumerable: true
      });
      this.connect();
    };
    WebsocketProvider.prototype = Object.create(EventEmitter.prototype);
    WebsocketProvider.prototype.constructor = WebsocketProvider;
    WebsocketProvider.prototype.connect = function() {
      this.connection = new Ws(this.url, this.protocol, void 0, this.headers, this.requestOptions, this.clientConfig);
      this._addSocketListeners();
    };
    WebsocketProvider.prototype._onMessage = function(e) {
      var _this = this;
      this._parseResponse(typeof e.data === "string" ? e.data : "").forEach(function(result) {
        if (result.method && result.method.indexOf("_subscription") !== -1) {
          _this.emit(_this.DATA, result);
          return;
        }
        var id = result.id;
        if (Array.isArray(result)) {
          id = result[0].id;
        }
        if (_this.responseQueue.has(id)) {
          if (_this.responseQueue.get(id).callback !== void 0) {
            _this.responseQueue.get(id).callback(false, result);
          }
          _this.responseQueue.delete(id);
        }
      });
    };
    WebsocketProvider.prototype._onConnect = function() {
      this.emit(this.CONNECT);
      this.reconnectAttempts = 0;
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        var _this = this;
        this.requestQueue.forEach(function(request, key) {
          _this.send(request.payload, request.callback);
          _this.requestQueue.delete(key);
        });
      }
    };
    WebsocketProvider.prototype._onClose = function(event) {
      var _this = this;
      if (this.reconnectOptions.auto && (![1e3, 1001].includes(event.code) || event.wasClean === false)) {
        this.reconnect();
        return;
      }
      this.emit(this.CLOSE, event);
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors2.ConnectionNotOpenError(event));
          _this.requestQueue.delete(key);
        });
      }
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors2.InvalidConnection("on WS", event));
          _this.responseQueue.delete(key);
        });
      }
      this._removeSocketListeners();
      this.removeAllListeners();
    };
    WebsocketProvider.prototype._addSocketListeners = function() {
      this.connection.addEventListener("message", this._onMessage.bind(this));
      this.connection.addEventListener("open", this._onConnect.bind(this));
      this.connection.addEventListener("close", this._onClose.bind(this));
    };
    WebsocketProvider.prototype._removeSocketListeners = function() {
      this.connection.removeEventListener("message", this._onMessage);
      this.connection.removeEventListener("open", this._onConnect);
      this.connection.removeEventListener("close", this._onClose);
    };
    WebsocketProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {
              _this.reconnect();
              return;
            }
            _this.emit(_this.ERROR, errors2.ConnectionTimeout(_this._customTimeout));
            if (_this.requestQueue.size > 0) {
              _this.requestQueue.forEach(function(request, key) {
                request.callback(errors2.ConnectionTimeout(_this._customTimeout));
                _this.requestQueue.delete(key);
              });
            }
          }, _this._customTimeout);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    WebsocketProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var id = payload.id;
      var request = { payload, callback };
      if (Array.isArray(payload)) {
        id = payload[0].id;
      }
      if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {
        this.requestQueue.set(id, request);
        return;
      }
      if (this.connection.readyState !== this.connection.OPEN) {
        this.requestQueue.delete(id);
        this.emit(this.ERROR, errors2.ConnectionNotOpenError());
        request.callback(errors2.ConnectionNotOpenError());
        return;
      }
      this.responseQueue.set(id, request);
      this.requestQueue.delete(id);
      try {
        this.connection.send(JSON.stringify(request.payload));
      } catch (error2) {
        request.callback(error2);
        _this.responseQueue.delete(id);
      }
    };
    WebsocketProvider.prototype.reset = function() {
      this.responseQueue.clear();
      this.requestQueue.clear();
      this.removeAllListeners();
      this._removeSocketListeners();
      this._addSocketListeners();
    };
    WebsocketProvider.prototype.disconnect = function(code, reason) {
      this._removeSocketListeners();
      this.connection.close(code || 1e3, reason);
    };
    WebsocketProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    WebsocketProvider.prototype.reconnect = function() {
      var _this = this;
      this.reconnecting = true;
      if (this.responseQueue.size > 0) {
        this.responseQueue.forEach(function(request, key) {
          request.callback(errors2.PendingRequestsOnReconnectingError());
          _this.responseQueue.delete(key);
        });
      }
      if (!this.reconnectOptions.maxAttempts || this.reconnectAttempts < this.reconnectOptions.maxAttempts) {
        setTimeout(function() {
          _this.reconnectAttempts++;
          _this._removeSocketListeners();
          _this.emit(_this.RECONNECT, _this.reconnectAttempts);
          _this.connect();
        }, this.reconnectOptions.delay);
        return;
      }
      this.emit(this.ERROR, errors2.MaxAttemptsReachedOnReconnectingError());
      this.reconnecting = false;
      if (this.requestQueue.size > 0) {
        this.requestQueue.forEach(function(request, key) {
          request.callback(errors2.MaxAttemptsReachedOnReconnectingError());
          _this.requestQueue.delete(key);
        });
      }
    };
    module.exports = WebsocketProvider;
  }
});

// node_modules/web3-shh/node_modules/web3-providers-http/lib/index.js
var require_lib40 = __commonJS({
  "node_modules/web3-shh/node_modules/web3-providers-http/lib/index.js"(exports, module) {
    init_define_process_env();
    var errors2 = require_lib3().errors;
    var XHR2 = require_dist2().XMLHttpRequest;
    var http = (init_http(), __toCommonJS(http_exports));
    var https = (init_https(), __toCommonJS(https_exports));
    var HttpProvider = function HttpProvider2(host, options) {
      options = options || {};
      this.withCredentials = options.withCredentials || false;
      this.timeout = options.timeout || 0;
      this.headers = options.headers;
      this.agent = options.agent;
      this.connected = false;
      const keepAlive = options.keepAlive !== false;
      this.host = host || "http://localhost:8545";
      if (!this.agent) {
        if (this.host.substring(0, 5) === "https") {
          this.httpsAgent = new https.Agent({ keepAlive });
        } else {
          this.httpAgent = new http.Agent({ keepAlive });
        }
      }
    };
    HttpProvider.prototype._prepareRequest = function() {
      var request;
      if (typeof XMLHttpRequest !== "undefined") {
        request = new XMLHttpRequest();
      } else {
        request = new XHR2();
        var agents = { httpsAgent: this.httpsAgent, httpAgent: this.httpAgent, baseUrl: this.baseUrl };
        if (this.agent) {
          agents.httpsAgent = this.agent.https;
          agents.httpAgent = this.agent.http;
          agents.baseUrl = this.agent.baseUrl;
        }
        request.nodejsSet(agents);
      }
      request.open("POST", this.host, true);
      request.setRequestHeader("Content-Type", "application/json");
      request.timeout = this.timeout;
      request.withCredentials = this.withCredentials;
      if (this.headers) {
        this.headers.forEach(function(header) {
          request.setRequestHeader(header.name, header.value);
        });
      }
      return request;
    };
    HttpProvider.prototype.send = function(payload, callback) {
      var _this = this;
      var request = this._prepareRequest();
      request.onreadystatechange = function() {
        if (request.readyState === 4 && request.timeout !== 1) {
          var result = request.responseText;
          var error2 = null;
          try {
            result = JSON.parse(result);
          } catch (e) {
            error2 = errors2.InvalidResponse(request.responseText);
          }
          _this.connected = true;
          callback(error2, result);
        }
      };
      request.ontimeout = function() {
        _this.connected = false;
        callback(errors2.ConnectionTimeout(this.timeout));
      };
      try {
        request.send(JSON.stringify(payload));
      } catch (error2) {
        this.connected = false;
        callback(errors2.InvalidConnection(this.host));
      }
    };
    HttpProvider.prototype.disconnect = function() {
    };
    HttpProvider.prototype.supportsSubscriptions = function() {
      return false;
    };
    module.exports = HttpProvider;
  }
});

// node_modules/web3-shh/node_modules/web3-providers-ipc/lib/index.js
var require_lib41 = __commonJS({
  "node_modules/web3-shh/node_modules/web3-providers-ipc/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var errors2 = require_lib3().errors;
    var oboe = require_oboe_browser();
    var IpcProvider = function IpcProvider2(path, net) {
      var _this = this;
      this.responseCallbacks = {};
      this.notificationCallbacks = [];
      this.path = path;
      this.connected = false;
      this.connection = net.connect({ path: this.path });
      this.addDefaultEvents();
      var callback = function(result) {
        var id = null;
        if (Array.isArray(result)) {
          result.forEach(function(load) {
            if (_this.responseCallbacks[load.id])
              id = load.id;
          });
        } else {
          id = result.id;
        }
        if (!id && result.method.indexOf("_subscription") !== -1) {
          _this.notificationCallbacks.forEach(function(callback2) {
            if (typeof callback2 === "function")
              callback2(result);
          });
        } else if (_this.responseCallbacks[id]) {
          _this.responseCallbacks[id](null, result);
          delete _this.responseCallbacks[id];
        }
      };
      if (net.constructor.name === "Socket") {
        oboe(this.connection).done(callback);
      } else {
        this.connection.on("data", function(data) {
          _this._parseResponse(data.toString()).forEach(callback);
        });
      }
    };
    IpcProvider.prototype.addDefaultEvents = function() {
      var _this = this;
      this.connection.on("connect", function() {
        _this.connected = true;
      });
      this.connection.on("close", function() {
        _this.connected = false;
      });
      this.connection.on("error", function() {
        _this._timeout();
      });
      this.connection.on("end", function() {
        _this._timeout();
      });
      this.connection.on("timeout", function() {
        _this._timeout();
      });
    };
    IpcProvider.prototype._parseResponse = function(data) {
      var _this = this, returnValues = [];
      var dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
      dechunkedData.forEach(function(data2) {
        if (_this.lastChunk)
          data2 = _this.lastChunk + data2;
        var result = null;
        try {
          result = JSON.parse(data2);
        } catch (e) {
          _this.lastChunk = data2;
          clearTimeout(_this.lastChunkTimeout);
          _this.lastChunkTimeout = setTimeout(function() {
            _this._timeout();
            throw errors2.InvalidResponse(data2);
          }, 1e3 * 15);
          return;
        }
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;
        if (result)
          returnValues.push(result);
      });
      return returnValues;
    };
    IpcProvider.prototype._addResponseCallback = function(payload, callback) {
      var id = payload.id || payload[0].id;
      var method = payload.method || payload[0].method;
      this.responseCallbacks[id] = callback;
      this.responseCallbacks[id].method = method;
    };
    IpcProvider.prototype._timeout = function() {
      for (var key in this.responseCallbacks) {
        if (this.responseCallbacks.hasOwnProperty(key)) {
          this.responseCallbacks[key](errors2.InvalidConnection("on IPC"));
          delete this.responseCallbacks[key];
        }
      }
    };
    IpcProvider.prototype.reconnect = function() {
      this.connection.connect({ path: this.path });
    };
    IpcProvider.prototype.send = function(payload, callback) {
      if (!this.connection.writable)
        this.connection.connect({ path: this.path });
      this.connection.write(JSON.stringify(payload));
      this._addResponseCallback(payload, callback);
    };
    IpcProvider.prototype.on = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      switch (type) {
        case "data":
          this.notificationCallbacks.push(callback);
          break;
        default:
          this.connection.on(type, callback);
          break;
      }
    };
    IpcProvider.prototype.once = function(type, callback) {
      if (typeof callback !== "function")
        throw new Error("The second parameter callback must be a function.");
      this.connection.once(type, callback);
    };
    IpcProvider.prototype.removeListener = function(type, callback) {
      var _this = this;
      switch (type) {
        case "data":
          this.notificationCallbacks.forEach(function(cb, index) {
            if (cb === callback)
              _this.notificationCallbacks.splice(index, 1);
          });
          break;
        default:
          this.connection.removeListener(type, callback);
          break;
      }
    };
    IpcProvider.prototype.removeAllListeners = function(type) {
      switch (type) {
        case "data":
          this.notificationCallbacks = [];
          break;
        default:
          this.connection.removeAllListeners(type);
          break;
      }
    };
    IpcProvider.prototype.reset = function() {
      this._timeout();
      this.notificationCallbacks = [];
      this.connection.removeAllListeners("error");
      this.connection.removeAllListeners("end");
      this.connection.removeAllListeners("timeout");
      this.addDefaultEvents();
    };
    IpcProvider.prototype.supportsSubscriptions = function() {
      return true;
    };
    module.exports = IpcProvider;
  }
});

// node_modules/web3-shh/node_modules/web3-core-requestmanager/lib/index.js
var require_lib42 = __commonJS({
  "node_modules/web3-shh/node_modules/web3-core-requestmanager/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var { callbackify } = require_util();
    var errors2 = require_lib3().errors;
    var Jsonrpc = require_jsonrpc6();
    var BatchManager = require_batch6();
    var givenProvider = require_givenProvider6();
    var RequestManager = function RequestManager2(provider, net) {
      this.provider = null;
      this.providers = RequestManager2.providers;
      this.setProvider(provider, net);
      this.subscriptions = /* @__PURE__ */ new Map();
    };
    RequestManager.givenProvider = givenProvider;
    RequestManager.providers = {
      WebsocketProvider: require_lib39(),
      HttpProvider: require_lib40(),
      IpcProvider: require_lib41()
    };
    RequestManager.prototype.setProvider = function(provider, net) {
      var _this = this;
      if (provider && typeof provider === "string" && this.providers) {
        if (/^http(s)?:\/\//i.test(provider)) {
          provider = new this.providers.HttpProvider(provider);
        } else if (/^ws(s)?:\/\//i.test(provider)) {
          provider = new this.providers.WebsocketProvider(provider);
        } else if (provider && typeof net === "object" && typeof net.connect === "function") {
          provider = new this.providers.IpcProvider(provider, net);
        } else if (provider) {
          throw new Error(`Can't autodetect provider for "` + provider + '"');
        }
      }
      if (this.provider && this.provider.connected)
        this.clearSubscriptions();
      this.provider = provider || null;
      if (this.provider && this.provider.on) {
        if (typeof provider.request === "function") {
          this.provider.on("message", function(payload) {
            if (payload && payload.type === "eth_subscription" && payload.data) {
              const data = payload.data;
              if (data.subscription && _this.subscriptions.has(data.subscription)) {
                _this.subscriptions.get(data.subscription).callback(null, data.result);
              }
            }
          });
        } else {
          this.provider.on("data", function data(result, deprecatedResult) {
            result = result || deprecatedResult;
            if (result.method && result.params && result.params.subscription && _this.subscriptions.has(result.params.subscription)) {
              _this.subscriptions.get(result.params.subscription).callback(null, result.params.result);
            }
          });
        }
        this.provider.on("connect", function connect() {
          _this.subscriptions.forEach(function(subscription) {
            subscription.subscription.resubscribe();
          });
        });
        this.provider.on("error", function error2(error2) {
          _this.subscriptions.forEach(function(subscription) {
            subscription.callback(error2);
          });
        });
        const disconnect = function disconnect2(event) {
          if (!_this._isCleanCloseEvent(event) || _this._isIpcCloseError(event)) {
            _this.subscriptions.forEach(function(subscription) {
              subscription.callback(errors2.ConnectionCloseError(event));
              _this.subscriptions.delete(subscription.subscription.id);
            });
            if (_this.provider && _this.provider.emit) {
              _this.provider.emit("error", errors2.ConnectionCloseError(event));
            }
          }
          if (_this.provider && _this.provider.emit) {
            _this.provider.emit("end", event);
          }
        };
        this.provider.on("disconnect", disconnect);
      }
    };
    RequestManager.prototype.send = function(data, callback) {
      callback = callback || function() {
      };
      if (!this.provider) {
        return callback(errors2.InvalidProvider());
      }
      const { method, params } = data;
      const jsonrpcPayload = Jsonrpc.toPayload(method, params);
      const jsonrpcResultCallback = this._jsonrpcResultCallback(callback, jsonrpcPayload);
      if (this.provider.request) {
        const callbackRequest = callbackify(this.provider.request.bind(this.provider));
        const requestArgs = { method, params };
        callbackRequest(requestArgs, callback);
      } else if (this.provider.sendAsync) {
        this.provider.sendAsync(jsonrpcPayload, jsonrpcResultCallback);
      } else if (this.provider.send) {
        this.provider.send(jsonrpcPayload, jsonrpcResultCallback);
      } else {
        throw new Error("Provider does not have a request or send method to use.");
      }
    };
    RequestManager.prototype.sendBatch = function(data, callback) {
      if (!this.provider) {
        return callback(errors2.InvalidProvider());
      }
      var payload = Jsonrpc.toBatchPayload(data);
      this.provider[this.provider.sendAsync ? "sendAsync" : "send"](payload, function(err, results) {
        if (err) {
          return callback(err);
        }
        if (!Array.isArray(results)) {
          return callback(errors2.InvalidResponse(results));
        }
        callback(null, results);
      });
    };
    RequestManager.prototype.addSubscription = function(subscription, callback) {
      if (this.provider.on) {
        this.subscriptions.set(subscription.id, {
          callback,
          subscription
        });
      } else {
        throw new Error("The provider doesn't support subscriptions: " + this.provider.constructor.name);
      }
    };
    RequestManager.prototype.removeSubscription = function(id, callback) {
      if (this.subscriptions.has(id)) {
        var type = this.subscriptions.get(id).subscription.options.type;
        this.subscriptions.delete(id);
        this.send({
          method: type + "_unsubscribe",
          params: [id]
        }, callback);
        return;
      }
      if (typeof callback === "function") {
        callback(null);
      }
    };
    RequestManager.prototype.clearSubscriptions = function(keepIsSyncing) {
      try {
        var _this = this;
        if (this.subscriptions.size > 0) {
          this.subscriptions.forEach(function(value, id) {
            if (!keepIsSyncing || value.name !== "syncing")
              _this.removeSubscription(id);
          });
        }
        if (this.provider.reset)
          this.provider.reset();
        return true;
      } catch (e) {
        throw new Error(`Error while clearing subscriptions: ${e}`);
      }
    };
    RequestManager.prototype._isCleanCloseEvent = function(event) {
      return typeof event === "object" && ([1e3].includes(event.code) || event.wasClean === true);
    };
    RequestManager.prototype._isIpcCloseError = function(event) {
      return typeof event === "boolean" && event;
    };
    RequestManager.prototype._jsonrpcResultCallback = function(callback, payload) {
      return function(err, result) {
        if (result && result.id && payload.id !== result.id) {
          return callback(new Error(`Wrong response id ${result.id} (expected: ${payload.id}) in ${JSON.stringify(payload)}`));
        }
        if (err) {
          return callback(err);
        }
        if (result && result.error) {
          return callback(errors2.ErrorResponse(result));
        }
        if (!Jsonrpc.isValidResponse(result)) {
          return callback(errors2.InvalidResponse(result));
        }
        callback(null, result.result);
      };
    };
    module.exports = {
      Manager: RequestManager,
      BatchManager
    };
  }
});

// node_modules/web3-shh/node_modules/web3-core/lib/extend.js
var require_extend6 = __commonJS({
  "node_modules/web3-shh/node_modules/web3-core/lib/extend.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var formatters = require_lib3().formatters;
    var Method = require_lib6();
    var utils = require_lib();
    var extend = function(pckg) {
      var ex = function(extension) {
        var extendedObject;
        if (extension.property) {
          if (!pckg[extension.property]) {
            pckg[extension.property] = {};
          }
          extendedObject = pckg[extension.property];
        } else {
          extendedObject = pckg;
        }
        if (extension.methods) {
          extension.methods.forEach(function(method) {
            if (!(method instanceof Method)) {
              method = new Method(method);
            }
            method.attachToObject(extendedObject);
            method.setRequestManager(pckg._requestManager);
          });
        }
        return pckg;
      };
      ex.formatters = formatters;
      ex.utils = utils;
      ex.Method = Method;
      return ex;
    };
    module.exports = extend;
  }
});

// node_modules/web3-shh/node_modules/web3-core/lib/index.js
var require_lib43 = __commonJS({
  "node_modules/web3-shh/node_modules/web3-core/lib/index.js"(exports, module) {
    init_define_process_env();
    var requestManager = require_lib42();
    var extend = require_extend6();
    var packageInit = (pkg, args) => {
      args = Array.prototype.slice.call(args);
      if (!pkg) {
        throw new Error('You need to instantiate using the "new" keyword.');
      }
      Object.defineProperty(pkg, "currentProvider", {
        get: () => {
          return pkg._provider;
        },
        set: (value) => {
          return pkg.setProvider(value);
        },
        enumerable: true,
        configurable: true
      });
      if (args[0] && args[0]._requestManager) {
        pkg._requestManager = args[0]._requestManager;
      } else {
        pkg._requestManager = new requestManager.Manager(args[0], args[1]);
      }
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
      pkg._provider = pkg._requestManager.provider;
      if (!pkg.setProvider) {
        pkg.setProvider = (provider, net) => {
          pkg._requestManager.setProvider(provider, net);
          pkg._provider = pkg._requestManager.provider;
          return true;
        };
      }
      pkg.setRequestManager = (manager) => {
        pkg._requestManager = manager;
        pkg._provider = manager.provider;
      };
      pkg.BatchRequest = requestManager.BatchManager.bind(null, pkg._requestManager);
      pkg.extend = extend(pkg);
    };
    var addProviders = (pkg) => {
      pkg.givenProvider = requestManager.Manager.givenProvider;
      pkg.providers = requestManager.Manager.providers;
    };
    module.exports = {
      packageInit,
      addProviders
    };
  }
});

// node_modules/web3-shh/lib/index.js
var require_lib44 = __commonJS({
  "node_modules/web3-shh/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var core = require_lib43();
    var Subscriptions = require_lib5().subscriptions;
    var Method = require_lib6();
    var Net = require_lib24();
    var Shh = function Shh2() {
      var _this = this;
      core.packageInit(this, arguments);
      var setRequestManager = this.setRequestManager;
      this.setRequestManager = function(manager) {
        setRequestManager(manager);
        _this.net.setRequestManager(manager);
        return true;
      };
      var setProvider = this.setProvider;
      this.setProvider = function() {
        setProvider.apply(_this, arguments);
        _this.setRequestManager(_this._requestManager);
      };
      this.net = new Net(this);
      [
        new Subscriptions({
          name: "subscribe",
          type: "shh",
          subscriptions: {
            "messages": {
              params: 1
            }
          }
        }),
        new Method({
          name: "getVersion",
          call: "shh_version",
          params: 0
        }),
        new Method({
          name: "getInfo",
          call: "shh_info",
          params: 0
        }),
        new Method({
          name: "setMaxMessageSize",
          call: "shh_setMaxMessageSize",
          params: 1
        }),
        new Method({
          name: "setMinPoW",
          call: "shh_setMinPoW",
          params: 1
        }),
        new Method({
          name: "markTrustedPeer",
          call: "shh_markTrustedPeer",
          params: 1
        }),
        new Method({
          name: "newKeyPair",
          call: "shh_newKeyPair",
          params: 0
        }),
        new Method({
          name: "addPrivateKey",
          call: "shh_addPrivateKey",
          params: 1
        }),
        new Method({
          name: "deleteKeyPair",
          call: "shh_deleteKeyPair",
          params: 1
        }),
        new Method({
          name: "hasKeyPair",
          call: "shh_hasKeyPair",
          params: 1
        }),
        new Method({
          name: "getPublicKey",
          call: "shh_getPublicKey",
          params: 1
        }),
        new Method({
          name: "getPrivateKey",
          call: "shh_getPrivateKey",
          params: 1
        }),
        new Method({
          name: "newSymKey",
          call: "shh_newSymKey",
          params: 0
        }),
        new Method({
          name: "addSymKey",
          call: "shh_addSymKey",
          params: 1
        }),
        new Method({
          name: "generateSymKeyFromPassword",
          call: "shh_generateSymKeyFromPassword",
          params: 1
        }),
        new Method({
          name: "hasSymKey",
          call: "shh_hasSymKey",
          params: 1
        }),
        new Method({
          name: "getSymKey",
          call: "shh_getSymKey",
          params: 1
        }),
        new Method({
          name: "deleteSymKey",
          call: "shh_deleteSymKey",
          params: 1
        }),
        new Method({
          name: "newMessageFilter",
          call: "shh_newMessageFilter",
          params: 1
        }),
        new Method({
          name: "getFilterMessages",
          call: "shh_getFilterMessages",
          params: 1
        }),
        new Method({
          name: "deleteMessageFilter",
          call: "shh_deleteMessageFilter",
          params: 1
        }),
        new Method({
          name: "post",
          call: "shh_post",
          params: 1,
          inputFormatter: [null]
        }),
        new Method({
          name: "unsubscribe",
          call: "shh_unsubscribe",
          params: 1
        })
      ].forEach(function(method) {
        method.attachToObject(_this);
        method.setRequestManager(_this._requestManager);
      });
    };
    Shh.prototype.clearSubscriptions = function() {
      this._requestManager.clearSubscriptions();
    };
    core.addProviders(Shh);
    module.exports = Shh;
  }
});

// node_modules/xhr-request/node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/xhr-request/node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    module.exports = function(str) {
      return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    };
  }
});

// node_modules/xhr-request/node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/xhr-request/node_modules/query-string/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var strictUriEncode = require_strict_uri_encode();
    var objectAssign = require_object_assign();
    var decodeComponent = require_decode_uri_component();
    function encoderForArrayFormat(opts) {
      switch (opts.arrayFormat) {
        case "index":
          return function(key, value, index) {
            return value === null ? [
              encode2(key, opts),
              "[",
              index,
              "]"
            ].join("") : [
              encode2(key, opts),
              "[",
              encode2(index, opts),
              "]=",
              encode2(value, opts)
            ].join("");
          };
        case "bracket":
          return function(key, value) {
            return value === null ? encode2(key, opts) : [
              encode2(key, opts),
              "[]=",
              encode2(value, opts)
            ].join("");
          };
        default:
          return function(key, value) {
            return value === null ? encode2(key, opts) : [
              encode2(key, opts),
              "=",
              encode2(value, opts)
            ].join("");
          };
      }
    }
    function parserForArrayFormat(opts) {
      var result;
      switch (opts.arrayFormat) {
        case "index":
          return function(key, value, accumulator) {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return function(key, value, accumulator) {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            } else if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        default:
          return function(key, value, accumulator) {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function encode2(value, opts) {
      if (opts.encode) {
        return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      } else if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort(function(a, b) {
          return Number(a) - Number(b);
        }).map(function(key) {
          return input[key];
        });
      }
      return input;
    }
    function extract(str) {
      var queryStart = str.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return str.slice(queryStart + 1);
    }
    function parse(str, opts) {
      opts = objectAssign({ arrayFormat: "none" }, opts);
      var formatter = parserForArrayFormat(opts);
      var ret = /* @__PURE__ */ Object.create(null);
      if (typeof str !== "string") {
        return ret;
      }
      str = str.trim().replace(/^[?#&]/, "");
      if (!str) {
        return ret;
      }
      str.split("&").forEach(function(param) {
        var parts = param.replace(/\+/g, " ").split("=");
        var key = parts.shift();
        var val = parts.length > 0 ? parts.join("=") : void 0;
        val = val === void 0 ? null : decodeComponent(val);
        formatter(decodeComponent(key), val, ret);
      });
      return Object.keys(ret).sort().reduce(function(result, key) {
        var val = ret[key];
        if (Boolean(val) && typeof val === "object" && !Array.isArray(val)) {
          result[key] = keysSorter(val);
        } else {
          result[key] = val;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse;
    exports.stringify = function(obj, opts) {
      var defaults = {
        encode: true,
        strict: true,
        arrayFormat: "none"
      };
      opts = objectAssign(defaults, opts);
      if (opts.sort === false) {
        opts.sort = function() {
        };
      }
      var formatter = encoderForArrayFormat(opts);
      return obj ? Object.keys(obj).sort(opts.sort).map(function(key) {
        var val = obj[key];
        if (val === void 0) {
          return "";
        }
        if (val === null) {
          return encode2(key, opts);
        }
        if (Array.isArray(val)) {
          var result = [];
          val.slice().forEach(function(val2) {
            if (val2 === void 0) {
              return;
            }
            result.push(formatter(key, val2, result.length));
          });
          return result.join("&");
        }
        return encode2(key, opts) + "=" + encode2(val, opts);
      }).filter(function(x) {
        return x.length > 0;
      }).join("&") : "";
    };
    exports.parseUrl = function(str, opts) {
      return {
        url: str.split("?")[0] || "",
        query: parse(extract(str), opts)
      };
    };
  }
});

// node_modules/url-set-query/index.js
var require_url_set_query = __commonJS({
  "node_modules/url-set-query/index.js"(exports, module) {
    init_define_process_env();
    module.exports = urlSetQuery;
    function urlSetQuery(url, query) {
      if (query) {
        query = query.trim().replace(/^(\?|#|&)/, "");
        query = query ? "?" + query : query;
        var parts = url.split(/[\?\#]/);
        var start = parts[0];
        if (query && /\:\/\/[^\/]*$/.test(start)) {
          start = start + "/";
        }
        var match = url.match(/(\#.*)$/);
        url = start + query;
        if (match) {
          url = url + match[0];
        }
      }
      return url;
    }
  }
});

// node_modules/xhr-request/lib/ensure-header.js
var require_ensure_header = __commonJS({
  "node_modules/xhr-request/lib/ensure-header.js"(exports, module) {
    init_define_process_env();
    module.exports = ensureHeader;
    function ensureHeader(headers, key, value) {
      var lower = key.toLowerCase();
      if (!headers[key] && !headers[lower]) {
        headers[key] = value;
      }
    }
  }
});

// node_modules/global/window.js
var require_window = __commonJS({
  "node_modules/global/window.js"(exports, module) {
    init_define_process_env();
    var win;
    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof global !== "undefined") {
      win = global;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }
    module.exports = win;
  }
});

// node_modules/is-function/index.js
var require_is_function = __commonJS({
  "node_modules/is-function/index.js"(exports, module) {
    init_define_process_env();
    module.exports = isFunction;
    var toString = Object.prototype.toString;
    function isFunction(fn) {
      if (!fn) {
        return false;
      }
      var string = toString.call(fn);
      return string === "[object Function]" || typeof fn === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
    }
  }
});

// node_modules/parse-headers/parse-headers.js
var require_parse_headers = __commonJS({
  "node_modules/parse-headers/parse-headers.js"(exports, module) {
    init_define_process_env();
    var trim = function(string) {
      return string.replace(/^\s+|\s+$/g, "");
    };
    var isArray = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
    module.exports = function(headers) {
      if (!headers)
        return {};
      var result = {};
      var headersArr = trim(headers).split("\n");
      for (var i = 0; i < headersArr.length; i++) {
        var row = headersArr[i];
        var index = row.indexOf(":"), key = trim(row.slice(0, index)).toLowerCase(), value = trim(row.slice(index + 1));
        if (typeof result[key] === "undefined") {
          result[key] = value;
        } else if (isArray(result[key])) {
          result[key].push(value);
        } else {
          result[key] = [result[key], value];
        }
      }
      return result;
    };
  }
});

// node_modules/xhr/index.js
var require_xhr = __commonJS({
  "node_modules/xhr/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var window2 = require_window();
    var isFunction = require_is_function();
    var parseHeaders = require_parse_headers();
    var xtend = require_immutable();
    module.exports = createXHR;
    module.exports.default = createXHR;
    createXHR.XMLHttpRequest = window2.XMLHttpRequest || noop;
    createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window2.XDomainRequest;
    forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
      createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback);
        options.method = method.toUpperCase();
        return _createXHR(options);
      };
    });
    function forEachArray(array, iterator) {
      for (var i = 0; i < array.length; i++) {
        iterator(array[i]);
      }
    }
    function isEmpty(obj) {
      for (var i in obj) {
        if (obj.hasOwnProperty(i))
          return false;
      }
      return true;
    }
    function initParams(uri, options, callback) {
      var params = uri;
      if (isFunction(options)) {
        callback = options;
        if (typeof uri === "string") {
          params = { uri };
        }
      } else {
        params = xtend(options, { uri });
      }
      params.callback = callback;
      return params;
    }
    function createXHR(uri, options, callback) {
      options = initParams(uri, options, callback);
      return _createXHR(options);
    }
    function _createXHR(options) {
      if (typeof options.callback === "undefined") {
        throw new Error("callback argument missing");
      }
      var called = false;
      var callback = function cbOnce(err, response, body2) {
        if (!called) {
          called = true;
          options.callback(err, response, body2);
        }
      };
      function readystatechange() {
        if (xhr.readyState === 4) {
          setTimeout(loadFunc, 0);
        }
      }
      function getBody() {
        var body2 = void 0;
        if (xhr.response) {
          body2 = xhr.response;
        } else {
          body2 = xhr.responseText || getXml(xhr);
        }
        if (isJson) {
          try {
            body2 = JSON.parse(body2);
          } catch (e) {
          }
        }
        return body2;
      }
      function errorFunc(evt) {
        clearTimeout(timeoutTimer);
        if (!(evt instanceof Error)) {
          evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
        }
        evt.statusCode = 0;
        return callback(evt, failureResponse);
      }
      function loadFunc() {
        if (aborted)
          return;
        var status;
        clearTimeout(timeoutTimer);
        if (options.useXDR && xhr.status === void 0) {
          status = 200;
        } else {
          status = xhr.status === 1223 ? 204 : xhr.status;
        }
        var response = failureResponse;
        var err = null;
        if (status !== 0) {
          response = {
            body: getBody(),
            statusCode: status,
            method,
            headers: {},
            url: uri,
            rawRequest: xhr
          };
          if (xhr.getAllResponseHeaders) {
            response.headers = parseHeaders(xhr.getAllResponseHeaders());
          }
        } else {
          err = new Error("Internal XMLHttpRequest Error");
        }
        return callback(err, response, response.body);
      }
      var xhr = options.xhr || null;
      if (!xhr) {
        if (options.cors || options.useXDR) {
          xhr = new createXHR.XDomainRequest();
        } else {
          xhr = new createXHR.XMLHttpRequest();
        }
      }
      var key;
      var aborted;
      var uri = xhr.url = options.uri || options.url;
      var method = xhr.method = options.method || "GET";
      var body = options.body || options.data;
      var headers = xhr.headers = options.headers || {};
      var sync = !!options.sync;
      var isJson = false;
      var timeoutTimer;
      var failureResponse = {
        body: void 0,
        headers: {},
        statusCode: 0,
        method,
        url: uri,
        rawRequest: xhr
      };
      if ("json" in options && options.json !== false) {
        isJson = true;
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
        if (method !== "GET" && method !== "HEAD") {
          headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
          body = JSON.stringify(options.json === true ? body : options.json);
        }
      }
      xhr.onreadystatechange = readystatechange;
      xhr.onload = loadFunc;
      xhr.onerror = errorFunc;
      xhr.onprogress = function() {
      };
      xhr.onabort = function() {
        aborted = true;
      };
      xhr.ontimeout = errorFunc;
      xhr.open(method, uri, !sync, options.username, options.password);
      if (!sync) {
        xhr.withCredentials = !!options.withCredentials;
      }
      if (!sync && options.timeout > 0) {
        timeoutTimer = setTimeout(function() {
          if (aborted)
            return;
          aborted = true;
          xhr.abort("timeout");
          var e = new Error("XMLHttpRequest timeout");
          e.code = "ETIMEDOUT";
          errorFunc(e);
        }, options.timeout);
      }
      if (xhr.setRequestHeader) {
        for (key in headers) {
          if (headers.hasOwnProperty(key)) {
            xhr.setRequestHeader(key, headers[key]);
          }
        }
      } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object");
      }
      if ("responseType" in options) {
        xhr.responseType = options.responseType;
      }
      if ("beforeSend" in options && typeof options.beforeSend === "function") {
        options.beforeSend(xhr);
      }
      xhr.send(body || null);
      return xhr;
    }
    function getXml(xhr) {
      try {
        if (xhr.responseType === "document") {
          return xhr.responseXML;
        }
        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
        if (xhr.responseType === "" && !firefoxBugTakenEffect) {
          return xhr.responseXML;
        }
      } catch (e) {
      }
      return null;
    }
    function noop() {
    }
  }
});

// node_modules/xhr-request/lib/normalize-response.js
var require_normalize_response = __commonJS({
  "node_modules/xhr-request/lib/normalize-response.js"(exports, module) {
    init_define_process_env();
    module.exports = getResponse;
    function getResponse(opt, resp) {
      if (!resp)
        return null;
      return {
        statusCode: resp.statusCode,
        headers: resp.headers,
        method: opt.method,
        url: opt.url,
        rawRequest: resp.rawRequest ? resp.rawRequest : resp
      };
    }
  }
});

// node_modules/xhr-request/lib/request-browser.js
var require_request_browser = __commonJS({
  "node_modules/xhr-request/lib/request-browser.js"(exports, module) {
    init_define_process_env();
    var xhr = require_xhr();
    var normalize = require_normalize_response();
    var noop = function() {
    };
    module.exports = xhrRequest;
    function xhrRequest(opt, cb) {
      delete opt.uri;
      var useJson = false;
      if (opt.responseType === "json") {
        opt.responseType = "text";
        useJson = true;
      }
      var req = xhr(opt, function xhrRequestResult(err, resp, body) {
        if (useJson && !err) {
          try {
            var text = resp.rawRequest.responseText;
            body = JSON.parse(text);
          } catch (e) {
            err = e;
          }
        }
        resp = normalize(opt, resp);
        if (err)
          cb(err, null, resp);
        else
          cb(err, body, resp);
        cb = noop;
      });
      var onabort = req.onabort;
      req.onabort = function() {
        var ret = onabort.apply(req, Array.prototype.slice.call(arguments));
        cb(new Error("XHR Aborted"));
        cb = noop;
        return ret;
      };
      return req;
    }
  }
});

// node_modules/xhr-request/index.js
var require_xhr_request = __commonJS({
  "node_modules/xhr-request/index.js"(exports, module) {
    init_define_process_env();
    var queryString = require_query_string();
    var setQuery = require_url_set_query();
    var assign = require_object_assign();
    var ensureHeader = require_ensure_header();
    var request = require_request_browser();
    var mimeTypeJson = "application/json";
    var noop = function() {
    };
    module.exports = xhrRequest;
    function xhrRequest(url, opt, cb) {
      if (!url || typeof url !== "string") {
        throw new TypeError("must specify a URL");
      }
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (cb && typeof cb !== "function") {
        throw new TypeError("expected cb to be undefined or a function");
      }
      cb = cb || noop;
      opt = opt || {};
      var defaultResponse = opt.json ? "json" : "text";
      opt = assign({ responseType: defaultResponse }, opt);
      var headers = opt.headers || {};
      var method = (opt.method || "GET").toUpperCase();
      var query = opt.query;
      if (query) {
        if (typeof query !== "string") {
          query = queryString.stringify(query);
        }
        url = setQuery(url, query);
      }
      if (opt.responseType === "json") {
        ensureHeader(headers, "Accept", mimeTypeJson);
      }
      if (opt.json && method !== "GET" && method !== "HEAD") {
        ensureHeader(headers, "Content-Type", mimeTypeJson);
        opt.body = JSON.stringify(opt.body);
      }
      opt.method = method;
      opt.url = url;
      opt.headers = headers;
      delete opt.query;
      delete opt.json;
      return request(opt, cb);
    }
  }
});

// node_modules/swarm-js/node_modules/eth-lib/lib/array.js
var require_array2 = __commonJS({
  "node_modules/swarm-js/node_modules/eth-lib/lib/array.js"(exports, module) {
    init_define_process_env();
    var generate = function generate2(num, fn) {
      var a = [];
      for (var i = 0; i < num; ++i) {
        a.push(fn(i));
      }
      return a;
    };
    var replicate = function replicate2(num, val) {
      return generate(num, function() {
        return val;
      });
    };
    var concat = function concat2(a, b) {
      return a.concat(b);
    };
    var flatten = function flatten2(a) {
      var r = [];
      for (var j = 0, J = a.length; j < J; ++j) {
        for (var i = 0, I = a[j].length; i < I; ++i) {
          r.push(a[j][i]);
        }
      }
      return r;
    };
    var chunksOf = function chunksOf2(n, a) {
      var b = [];
      for (var i = 0, l = a.length; i < l; i += n) {
        b.push(a.slice(i, i + n));
      }
      return b;
    };
    module.exports = {
      generate,
      replicate,
      concat,
      flatten,
      chunksOf
    };
  }
});

// node_modules/swarm-js/node_modules/eth-lib/lib/bytes.js
var require_bytes2 = __commonJS({
  "node_modules/swarm-js/node_modules/eth-lib/lib/bytes.js"(exports, module) {
    init_define_process_env();
    var A = require_array2();
    var at = function at2(bytes, index) {
      return parseInt(bytes.slice(index * 2 + 2, index * 2 + 4), 16);
    };
    var random = function random2(bytes) {
      var rnd = void 0;
      if (typeof window !== "undefined" && window.crypto && window.crypto.getRandomValues)
        rnd = window.crypto.getRandomValues(new Uint8Array(bytes));
      else if (typeof __require !== "undefined")
        rnd = (init_crypto(), __toCommonJS(crypto_exports)).randomBytes(bytes);
      else
        throw "Safe random numbers not available.";
      var hex = "0x";
      for (var i = 0; i < bytes; ++i) {
        hex += ("00" + rnd[i].toString(16)).slice(-2);
      }
      return hex;
    };
    var length = function length2(a) {
      return (a.length - 2) / 2;
    };
    var flatten = function flatten2(a) {
      return "0x" + a.reduce(function(r, s) {
        return r + s.slice(2);
      }, "");
    };
    var slice = function slice2(i, j, bs) {
      return "0x" + bs.slice(i * 2 + 2, j * 2 + 2);
    };
    var reverse = function reverse2(hex) {
      var rev = "0x";
      for (var i = 0, l = length(hex); i < l; ++i) {
        rev += hex.slice((l - i) * 2, (l - i + 1) * 2);
      }
      return rev;
    };
    var pad = function pad2(l, hex) {
      return hex.length === l * 2 + 2 ? hex : pad2(l, "0x0" + hex.slice(2));
    };
    var padRight = function padRight2(l, hex) {
      return hex.length === l * 2 + 2 ? hex : padRight2(l, hex + "0");
    };
    var toArray = function toArray2(hex) {
      var arr = [];
      for (var i = 2, l = hex.length; i < l; i += 2) {
        arr.push(parseInt(hex.slice(i, i + 2), 16));
      }
      return arr;
    };
    var fromArray = function fromArray2(arr) {
      var hex = "0x";
      for (var i = 0, l = arr.length; i < l; ++i) {
        var b = arr[i];
        hex += (b < 16 ? "0" : "") + b.toString(16);
      }
      return hex;
    };
    var toUint8Array = function toUint8Array2(hex) {
      return new Uint8Array(toArray(hex));
    };
    var fromUint8Array = function fromUint8Array2(arr) {
      return fromArray([].slice.call(arr, 0));
    };
    var fromNumber = function fromNumber2(num) {
      var hex = num.toString(16);
      return hex.length % 2 === 0 ? "0x" + hex : "0x0" + hex;
    };
    var toNumber = function toNumber2(hex) {
      return parseInt(hex.slice(2), 16);
    };
    var concat = function concat2(a, b) {
      return a.concat(b.slice(2));
    };
    var fromNat = function fromNat2(bn) {
      return bn === "0x0" ? "0x" : bn.length % 2 === 0 ? bn : "0x0" + bn.slice(2);
    };
    var toNat = function toNat2(bn) {
      return bn[2] === "0" ? "0x" + bn.slice(3) : bn;
    };
    var fromAscii = function fromAscii2(ascii) {
      var hex = "0x";
      for (var i = 0; i < ascii.length; ++i) {
        hex += ("00" + ascii.charCodeAt(i).toString(16)).slice(-2);
      }
      return hex;
    };
    var toAscii = function toAscii2(hex) {
      var ascii = "";
      for (var i = 2; i < hex.length; i += 2) {
        ascii += String.fromCharCode(parseInt(hex.slice(i, i + 2), 16));
      }
      return ascii;
    };
    var fromString = function fromString2(s) {
      var makeByte = function makeByte2(uint8) {
        var b = uint8.toString(16);
        return b.length < 2 ? "0" + b : b;
      };
      var bytes = "0x";
      for (var ci = 0; ci != s.length; ci++) {
        var c = s.charCodeAt(ci);
        if (c < 128) {
          bytes += makeByte(c);
          continue;
        }
        if (c < 2048) {
          bytes += makeByte(c >> 6 | 192);
        } else {
          if (c > 55295 && c < 56320) {
            if (++ci == s.length)
              return null;
            var c2 = s.charCodeAt(ci);
            if (c2 < 56320 || c2 > 57343)
              return null;
            c = 65536 + ((c & 1023) << 10) + (c2 & 1023);
            bytes += makeByte(c >> 18 | 240);
            bytes += makeByte(c >> 12 & 63 | 128);
          } else {
            bytes += makeByte(c >> 12 | 224);
          }
          bytes += makeByte(c >> 6 & 63 | 128);
        }
        bytes += makeByte(c & 63 | 128);
      }
      return bytes;
    };
    var toString = function toString2(bytes) {
      var s = "";
      var i = 0;
      var l = length(bytes);
      while (i < l) {
        var c = at(bytes, i++);
        if (c > 127) {
          if (c > 191 && c < 224) {
            if (i >= l)
              return null;
            c = (c & 31) << 6 | at(bytes, i) & 63;
          } else if (c > 223 && c < 240) {
            if (i + 1 >= l)
              return null;
            c = (c & 15) << 12 | (at(bytes, i) & 63) << 6 | at(bytes, ++i) & 63;
          } else if (c > 239 && c < 248) {
            if (i + 2 >= l)
              return null;
            c = (c & 7) << 18 | (at(bytes, i) & 63) << 12 | (at(bytes, ++i) & 63) << 6 | at(bytes, ++i) & 63;
          } else
            return null;
          ++i;
        }
        if (c <= 65535)
          s += String.fromCharCode(c);
        else if (c <= 1114111) {
          c -= 65536;
          s += String.fromCharCode(c >> 10 | 55296);
          s += String.fromCharCode(c & 1023 | 56320);
        } else
          return null;
      }
      return s;
    };
    module.exports = {
      random,
      length,
      concat,
      flatten,
      slice,
      reverse,
      pad,
      padRight,
      fromAscii,
      toAscii,
      fromString,
      toString,
      fromNumber,
      toNumber,
      fromNat,
      toNat,
      fromArray,
      toArray,
      fromUint8Array,
      toUint8Array
    };
  }
});

// node_modules/swarm-js/node_modules/eth-lib/lib/hash.js
var require_hash2 = __commonJS({
  "node_modules/swarm-js/node_modules/eth-lib/lib/hash.js"(exports, module) {
    init_define_process_env();
    var HEX_CHARS = "0123456789abcdef".split("");
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var SHIFT = [0, 8, 16, 24];
    var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    var Keccak = function Keccak2(bits) {
      return {
        blocks: [],
        reset: true,
        block: 0,
        start: 0,
        blockCount: 1600 - (bits << 1) >> 5,
        outputBlocks: bits >> 5,
        s: function(s) {
          return [].concat(s, s, s, s, s);
        }([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
      };
    };
    var update = function update2(state, message) {
      var length = message.length, blocks = state.blocks, byteCount = state.blockCount << 2, blockCount = state.blockCount, outputBlocks = state.outputBlocks, s = state.s, index = 0, i, code;
      while (index < length) {
        if (state.reset) {
          state.reset = false;
          blocks[0] = state.block;
          for (i = 1; i < blockCount + 1; ++i) {
            blocks[i] = 0;
          }
        }
        if (typeof message !== "string") {
          for (i = state.start; index < length && i < byteCount; ++index) {
            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
          }
        } else {
          for (i = state.start; index < length && i < byteCount; ++index) {
            code = message.charCodeAt(index);
            if (code < 128) {
              blocks[i >> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 2048) {
              blocks[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            } else if (code < 55296 || code >= 57344) {
              blocks[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            } else {
              code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
              blocks[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            }
          }
        }
        state.lastByteIndex = i;
        if (i >= byteCount) {
          state.start = i - byteCount;
          state.block = blocks[blockCount];
          for (i = 0; i < blockCount; ++i) {
            s[i] ^= blocks[i];
          }
          f(s);
          state.reset = true;
        } else {
          state.start = i;
        }
      }
      i = state.lastByteIndex;
      blocks[i >> 2] |= KECCAK_PADDING[i & 3];
      if (state.lastByteIndex === byteCount) {
        blocks[0] = blocks[blockCount];
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
      }
      f(s);
      var hex = "", i = 0, j = 0, block;
      while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
          block = s[i];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
        }
        if (j % blockCount === 0) {
          f(s);
          i = 0;
        }
      }
      return "0x" + hex;
    };
    var f = function f2(s) {
      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
        h = c8 ^ (c2 << 1 | c3 >>> 31);
        l = c9 ^ (c3 << 1 | c2 >>> 31);
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ (c4 << 1 | c5 >>> 31);
        l = c1 ^ (c5 << 1 | c4 >>> 31);
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ (c6 << 1 | c7 >>> 31);
        l = c3 ^ (c7 << 1 | c6 >>> 31);
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ (c8 << 1 | c9 >>> 31);
        l = c5 ^ (c9 << 1 | c8 >>> 31);
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ (c0 << 1 | c1 >>> 31);
        l = c7 ^ (c1 << 1 | c0 >>> 31);
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;
        b0 = s[0];
        b1 = s[1];
        b32 = s[11] << 4 | s[10] >>> 28;
        b33 = s[10] << 4 | s[11] >>> 28;
        b14 = s[20] << 3 | s[21] >>> 29;
        b15 = s[21] << 3 | s[20] >>> 29;
        b46 = s[31] << 9 | s[30] >>> 23;
        b47 = s[30] << 9 | s[31] >>> 23;
        b28 = s[40] << 18 | s[41] >>> 14;
        b29 = s[41] << 18 | s[40] >>> 14;
        b20 = s[2] << 1 | s[3] >>> 31;
        b21 = s[3] << 1 | s[2] >>> 31;
        b2 = s[13] << 12 | s[12] >>> 20;
        b3 = s[12] << 12 | s[13] >>> 20;
        b34 = s[22] << 10 | s[23] >>> 22;
        b35 = s[23] << 10 | s[22] >>> 22;
        b16 = s[33] << 13 | s[32] >>> 19;
        b17 = s[32] << 13 | s[33] >>> 19;
        b48 = s[42] << 2 | s[43] >>> 30;
        b49 = s[43] << 2 | s[42] >>> 30;
        b40 = s[5] << 30 | s[4] >>> 2;
        b41 = s[4] << 30 | s[5] >>> 2;
        b22 = s[14] << 6 | s[15] >>> 26;
        b23 = s[15] << 6 | s[14] >>> 26;
        b4 = s[25] << 11 | s[24] >>> 21;
        b5 = s[24] << 11 | s[25] >>> 21;
        b36 = s[34] << 15 | s[35] >>> 17;
        b37 = s[35] << 15 | s[34] >>> 17;
        b18 = s[45] << 29 | s[44] >>> 3;
        b19 = s[44] << 29 | s[45] >>> 3;
        b10 = s[6] << 28 | s[7] >>> 4;
        b11 = s[7] << 28 | s[6] >>> 4;
        b42 = s[17] << 23 | s[16] >>> 9;
        b43 = s[16] << 23 | s[17] >>> 9;
        b24 = s[26] << 25 | s[27] >>> 7;
        b25 = s[27] << 25 | s[26] >>> 7;
        b6 = s[36] << 21 | s[37] >>> 11;
        b7 = s[37] << 21 | s[36] >>> 11;
        b38 = s[47] << 24 | s[46] >>> 8;
        b39 = s[46] << 24 | s[47] >>> 8;
        b30 = s[8] << 27 | s[9] >>> 5;
        b31 = s[9] << 27 | s[8] >>> 5;
        b12 = s[18] << 20 | s[19] >>> 12;
        b13 = s[19] << 20 | s[18] >>> 12;
        b44 = s[29] << 7 | s[28] >>> 25;
        b45 = s[28] << 7 | s[29] >>> 25;
        b26 = s[38] << 8 | s[39] >>> 24;
        b27 = s[39] << 8 | s[38] >>> 24;
        b8 = s[48] << 14 | s[49] >>> 18;
        b9 = s[49] << 14 | s[48] >>> 18;
        s[0] = b0 ^ ~b2 & b4;
        s[1] = b1 ^ ~b3 & b5;
        s[10] = b10 ^ ~b12 & b14;
        s[11] = b11 ^ ~b13 & b15;
        s[20] = b20 ^ ~b22 & b24;
        s[21] = b21 ^ ~b23 & b25;
        s[30] = b30 ^ ~b32 & b34;
        s[31] = b31 ^ ~b33 & b35;
        s[40] = b40 ^ ~b42 & b44;
        s[41] = b41 ^ ~b43 & b45;
        s[2] = b2 ^ ~b4 & b6;
        s[3] = b3 ^ ~b5 & b7;
        s[12] = b12 ^ ~b14 & b16;
        s[13] = b13 ^ ~b15 & b17;
        s[22] = b22 ^ ~b24 & b26;
        s[23] = b23 ^ ~b25 & b27;
        s[32] = b32 ^ ~b34 & b36;
        s[33] = b33 ^ ~b35 & b37;
        s[42] = b42 ^ ~b44 & b46;
        s[43] = b43 ^ ~b45 & b47;
        s[4] = b4 ^ ~b6 & b8;
        s[5] = b5 ^ ~b7 & b9;
        s[14] = b14 ^ ~b16 & b18;
        s[15] = b15 ^ ~b17 & b19;
        s[24] = b24 ^ ~b26 & b28;
        s[25] = b25 ^ ~b27 & b29;
        s[34] = b34 ^ ~b36 & b38;
        s[35] = b35 ^ ~b37 & b39;
        s[44] = b44 ^ ~b46 & b48;
        s[45] = b45 ^ ~b47 & b49;
        s[6] = b6 ^ ~b8 & b0;
        s[7] = b7 ^ ~b9 & b1;
        s[16] = b16 ^ ~b18 & b10;
        s[17] = b17 ^ ~b19 & b11;
        s[26] = b26 ^ ~b28 & b20;
        s[27] = b27 ^ ~b29 & b21;
        s[36] = b36 ^ ~b38 & b30;
        s[37] = b37 ^ ~b39 & b31;
        s[46] = b46 ^ ~b48 & b40;
        s[47] = b47 ^ ~b49 & b41;
        s[8] = b8 ^ ~b0 & b2;
        s[9] = b9 ^ ~b1 & b3;
        s[18] = b18 ^ ~b10 & b12;
        s[19] = b19 ^ ~b11 & b13;
        s[28] = b28 ^ ~b20 & b22;
        s[29] = b29 ^ ~b21 & b23;
        s[38] = b38 ^ ~b30 & b32;
        s[39] = b39 ^ ~b31 & b33;
        s[48] = b48 ^ ~b40 & b42;
        s[49] = b49 ^ ~b41 & b43;
        s[0] ^= RC[n];
        s[1] ^= RC[n + 1];
      }
    };
    var keccak = function keccak2(bits) {
      return function(str) {
        var msg;
        if (str.slice(0, 2) === "0x") {
          msg = [];
          for (var i = 2, l = str.length; i < l; i += 2) {
            msg.push(parseInt(str.slice(i, i + 2), 16));
          }
        } else {
          msg = str;
        }
        return update(Keccak(bits, bits), msg);
      };
    };
    module.exports = {
      keccak256: keccak(256),
      keccak512: keccak(512),
      keccak256s: keccak(256),
      keccak512s: keccak(512)
    };
  }
});

// node_modules/swarm-js/lib/swarm-hash.js
var require_swarm_hash = __commonJS({
  "node_modules/swarm-js/lib/swarm-hash.js"(exports, module) {
    init_define_process_env();
    var keccak = require_hash2().keccak256;
    var Bytes = require_bytes2();
    var swarmHashBlock = function swarmHashBlock2(length, data) {
      var lengthEncoded = Bytes.reverse(Bytes.pad(6, Bytes.fromNumber(length)));
      var bytes = Bytes.flatten([lengthEncoded, "0x0000", data]);
      return keccak(bytes).slice(2);
    };
    var swarmHash = function swarmHash2(data) {
      if (typeof data === "string" && data.slice(0, 2) !== "0x") {
        data = Bytes.fromString(data);
      } else if (typeof data !== "string" && data.length !== void 0) {
        data = Bytes.fromUint8Array(data);
      }
      var length = Bytes.length(data);
      if (length <= 4096) {
        return swarmHashBlock(length, data);
      }
      var maxSize = 4096;
      while (maxSize * (4096 / 32) < length) {
        maxSize *= 4096 / 32;
      }
      var innerNodes = [];
      for (var i = 0; i < length; i += maxSize) {
        var size = maxSize < length - i ? maxSize : length - i;
        innerNodes.push(swarmHash2(Bytes.slice(data, i, i + size)));
      }
      return swarmHashBlock(length, Bytes.flatten(innerNodes));
    };
    module.exports = swarmHash;
  }
});

// node_modules/swarm-js/lib/pick.js
var require_pick = __commonJS({
  "node_modules/swarm-js/lib/pick.js"(exports, module) {
    init_define_process_env();
    var picker = function picker2(type) {
      return function() {
        return new Promise(function(resolve, reject) {
          var fileLoader = function fileLoader2(e) {
            var directory = {};
            var totalFiles = e.target.files.length;
            var loadedFiles = 0;
            [].map.call(e.target.files, function(file) {
              var reader = new FileReader();
              reader.onload = function(e2) {
                var data = new Uint8Array(e2.target.result);
                if (type === "directory") {
                  var path = file.webkitRelativePath;
                  directory[path.slice(path.indexOf("/") + 1)] = {
                    type: "text/plain",
                    data
                  };
                  if (++loadedFiles === totalFiles)
                    resolve(directory);
                } else if (type === "file") {
                  var _path = file.webkitRelativePath;
                  resolve({
                    "type": mimetype.lookup(_path),
                    "data": data
                  });
                } else {
                  resolve(data);
                }
              };
              reader.readAsArrayBuffer(file);
            });
          };
          var fileInput;
          if (type === "directory") {
            fileInput = document.createElement("input");
            fileInput.addEventListener("change", fileLoader);
            fileInput.type = "file";
            fileInput.webkitdirectory = true;
            fileInput.mozdirectory = true;
            fileInput.msdirectory = true;
            fileInput.odirectory = true;
            fileInput.directory = true;
          } else {
            fileInput = document.createElement("input");
            fileInput.addEventListener("change", fileLoader);
            fileInput.type = "file";
          }
          ;
          var mouseEvent = document.createEvent("MouseEvents");
          mouseEvent.initEvent("click", true, false);
          fileInput.dispatchEvent(mouseEvent);
        });
      };
    };
    module.exports = {
      data: picker("data"),
      file: picker("file"),
      directory: picker("directory")
    };
  }
});

// node_modules/swarm-js/lib/swarm.js
var require_swarm = __commonJS({
  "node_modules/swarm-js/lib/swarm.js"(exports, module) {
    init_define_process_env();
    module.exports = function(_ref) {
      var fs = _ref.fs, files = _ref.files, os = _ref.os, path = _ref.path, child_process = _ref.child_process, mimetype2 = _ref.mimetype, defaultArchives = _ref.defaultArchives, request = _ref.request, downloadUrl = _ref.downloadUrl, bytes = _ref.bytes, hash = _ref.hash, pick = _ref.pick;
      var impureInsert = function impureInsert2(key) {
        return function(val) {
          return function(map2) {
            return map2[key] = val, map2;
          };
        };
      };
      var toMap = function toMap2(keys) {
        return function(vals) {
          var map2 = {};
          for (var i = 0, l = keys.length; i < l; ++i) {
            map2[keys[i]] = vals[i];
          }
          return map2;
        };
      };
      var merge = function merge2(a) {
        return function(b) {
          var map2 = {};
          for (var key in a) {
            map2[key] = a[key];
          }
          for (var _key in b) {
            map2[_key] = b[_key];
          }
          return map2;
        };
      };
      var equals = function equals2(a) {
        return function(b) {
          if (a.length !== b.length) {
            return false;
          } else {
            for (var i = 0, l = a.length; i < l; ++i) {
              if (a[i] !== b[i])
                return false;
            }
          }
          return true;
        };
      };
      var rawUrl = function rawUrl2(swarmUrl) {
        return function(hash2) {
          return "".concat(swarmUrl, "/bzz-raw:/").concat(hash2);
        };
      };
      var downloadData = function downloadData2(swarmUrl) {
        return function(hash2) {
          return new Promise(function(resolve, reject) {
            request(rawUrl(swarmUrl)(hash2), {
              responseType: "arraybuffer"
            }, function(err, arrayBuffer, response) {
              if (err) {
                return reject(err);
              }
              if (response.statusCode >= 400) {
                return reject(new Error("Error ".concat(response.statusCode, ".")));
              }
              return resolve(new Uint8Array(arrayBuffer));
            });
          });
        };
      };
      var downloadEntries = function downloadEntries2(swarmUrl) {
        return function(hash2) {
          var search = function search2(hash3) {
            return function(path2) {
              return function(routes) {
                var format = function format2(entry) {
                  return {
                    type: entry.contentType,
                    hash: entry.hash
                  };
                };
                var downloadEntry = function downloadEntry2(entry) {
                  if (entry.path === void 0) {
                    return Promise.resolve();
                  } else {
                    return entry.contentType === "application/bzz-manifest+json" ? search2(entry.hash)(path2 + entry.path)(routes) : Promise.resolve(impureInsert(path2 + entry.path)(format(entry))(routes));
                  }
                };
                return downloadData(swarmUrl)(hash3).then(function(text) {
                  return JSON.parse(toString(text)).entries;
                }).then(function(entries) {
                  return Promise.all(entries.map(downloadEntry));
                }).then(function() {
                  return routes;
                });
              };
            };
          };
          return search(hash2)("")({});
        };
      };
      var downloadRoutes = function downloadRoutes2(swarmUrl) {
        return function(hash2) {
          return downloadEntries(swarmUrl)(hash2).then(function(entries) {
            return toMap(Object.keys(entries))(Object.keys(entries).map(function(route) {
              return entries[route].hash;
            }));
          });
        };
      };
      var downloadDirectory = function downloadDirectory2(swarmUrl) {
        return function(hash2) {
          return downloadEntries(swarmUrl)(hash2).then(function(entries) {
            var paths = Object.keys(entries);
            var hashs = paths.map(function(path2) {
              return entries[path2].hash;
            });
            var types = paths.map(function(path2) {
              return entries[path2].type;
            });
            var datas = hashs.map(downloadData(swarmUrl));
            var files2 = function files3(datas2) {
              return datas2.map(function(data, i) {
                return {
                  type: types[i],
                  data
                };
              });
            };
            return Promise.all(datas).then(function(datas2) {
              return toMap(paths)(files2(datas2));
            });
          });
        };
      };
      var downloadDataToDisk = function downloadDataToDisk2(swarmUrl) {
        return function(hash2) {
          return function(filePath) {
            return files.download(rawUrl(swarmUrl)(hash2))(filePath);
          };
        };
      };
      var downloadDirectoryToDisk = function downloadDirectoryToDisk2(swarmUrl) {
        return function(hash2) {
          return function(dirPath) {
            return downloadRoutes(swarmUrl)(hash2).then(function(routingTable) {
              var downloads = [];
              for (var route in routingTable) {
                if (route.length > 0) {
                  var filePath = path.join(dirPath, route);
                  downloads.push(downloadDataToDisk(swarmUrl)(routingTable[route])(filePath));
                }
                ;
              }
              ;
              return Promise.all(downloads).then(function() {
                return dirPath;
              });
            });
          };
        };
      };
      var uploadData = function uploadData2(swarmUrl) {
        return function(data) {
          return new Promise(function(resolve, reject) {
            var params = {
              body: typeof data === "string" ? fromString(data) : data,
              method: "POST"
            };
            request("".concat(swarmUrl, "/bzz-raw:/"), params, function(err, data2) {
              if (err) {
                return reject(err);
              }
              return resolve(data2);
            });
          });
        };
      };
      var uploadToManifest = function uploadToManifest2(swarmUrl) {
        return function(hash2) {
          return function(route) {
            return function(file) {
              var attempt = function attempt2(n) {
                var slashRoute = route[0] === "/" ? route : "/" + route;
                var url = "".concat(swarmUrl, "/bzz:/").concat(hash2).concat(slashRoute);
                var opt = {
                  method: "PUT",
                  headers: {
                    "Content-Type": file.type
                  },
                  body: file.data
                };
                return new Promise(function(resolve, reject) {
                  request(url, opt, function(err, data) {
                    if (err) {
                      return reject(err);
                    }
                    if (data.indexOf("error") !== -1) {
                      return reject(data);
                    }
                    return resolve(data);
                  });
                })["catch"](function(e) {
                  return n > 0 && attempt2(n - 1);
                });
              };
              return attempt(3);
            };
          };
        };
      };
      var uploadFile = function uploadFile2(swarmUrl) {
        return function(file) {
          return uploadDirectory(swarmUrl)({
            "": file
          });
        };
      };
      var uploadFileFromDisk = function uploadFileFromDisk2(swarmUrl) {
        return function(filePath) {
          return fs.readFile(filePath).then(function(data) {
            return uploadFile(swarmUrl)({
              type: mimetype2.lookup(filePath),
              data
            });
          });
        };
      };
      var uploadDirectory = function uploadDirectory2(swarmUrl) {
        return function(directory) {
          return uploadData(swarmUrl)("{}").then(function(hash2) {
            var uploadRoute = function uploadRoute2(route) {
              return function(hash3) {
                return uploadToManifest(swarmUrl)(hash3)(route)(directory[route]);
              };
            };
            var uploadToHash = function uploadToHash2(hash3, route) {
              return hash3.then(uploadRoute(route));
            };
            return Object.keys(directory).reduce(uploadToHash, Promise.resolve(hash2));
          });
        };
      };
      var uploadDataFromDisk = function uploadDataFromDisk2(swarmUrl) {
        return function(filePath) {
          return fs.readFile(filePath).then(uploadData(swarmUrl));
        };
      };
      var uploadDirectoryFromDisk = function uploadDirectoryFromDisk2(swarmUrl) {
        return function(defaultPath) {
          return function(dirPath) {
            return files.directoryTree(dirPath).then(function(fullPaths) {
              return Promise.all(fullPaths.map(function(path2) {
                return fs.readFile(path2);
              })).then(function(datas) {
                var paths = fullPaths.map(function(path2) {
                  return path2.slice(dirPath.length);
                });
                var types = fullPaths.map(function(path2) {
                  return mimetype2.lookup(path2) || "text/plain";
                });
                return toMap(paths)(datas.map(function(data, i) {
                  return {
                    type: types[i],
                    data
                  };
                }));
              });
            }).then(function(directory) {
              return merge(defaultPath ? {
                "": directory[defaultPath]
              } : {})(directory);
            }).then(uploadDirectory(swarmUrl));
          };
        };
      };
      var _upload = function upload(swarmUrl) {
        return function(arg) {
          if (arg.pick === "data") {
            return pick.data().then(uploadData(swarmUrl));
          } else if (arg.pick === "file") {
            return pick.file().then(uploadFile(swarmUrl));
          } else if (arg.pick === "directory") {
            return pick.directory().then(uploadDirectory(swarmUrl));
          } else if (arg.path) {
            switch (arg.kind) {
              case "data":
                return uploadDataFromDisk(swarmUrl)(arg.path);
              case "file":
                return uploadFileFromDisk(swarmUrl)(arg.path);
              case "directory":
                return uploadDirectoryFromDisk(swarmUrl)(arg.defaultFile)(arg.path);
            }
            ;
          } else if (arg.length || typeof arg === "string") {
            return uploadData(swarmUrl)(arg);
          } else if (arg instanceof Object) {
            return uploadDirectory(swarmUrl)(arg);
          }
          return Promise.reject(new Error("Bad arguments"));
        };
      };
      var _download = function download(swarmUrl) {
        return function(hash2) {
          return function(path2) {
            return isDirectory(swarmUrl)(hash2).then(function(isDir) {
              if (isDir) {
                return path2 ? downloadDirectoryToDisk(swarmUrl)(hash2)(path2) : downloadDirectory(swarmUrl)(hash2);
              } else {
                return path2 ? downloadDataToDisk(swarmUrl)(hash2)(path2) : downloadData(swarmUrl)(hash2);
              }
            });
          };
        };
      };
      var downloadBinary = function downloadBinary2(path2, archives) {
        var system = os.platform().replace("win32", "windows") + "-" + (os.arch() === "x64" ? "amd64" : "386");
        var archive = (archives || defaultArchives)[system];
        var archiveUrl = downloadUrl + archive.archive + ".tar.gz";
        var archiveMD5 = archive.archiveMD5;
        var binaryMD5 = archive.binaryMD5;
        return files.safeDownloadArchived(archiveUrl)(archiveMD5)(binaryMD5)(path2);
      };
      var startProcess = function startProcess2(swarmSetup) {
        return new Promise(function(resolve, reject) {
          var spawn = child_process.spawn;
          var hasString = function hasString2(str) {
            return function(buffer) {
              return ("" + buffer).indexOf(str) !== -1;
            };
          };
          var account = swarmSetup.account, password = swarmSetup.password, dataDir = swarmSetup.dataDir, ensApi = swarmSetup.ensApi, privateKey = swarmSetup.privateKey;
          var STARTUP_TIMEOUT_SECS = 3;
          var WAITING_PASSWORD = 0;
          var STARTING = 1;
          var LISTENING = 2;
          var PASSWORD_PROMPT_HOOK = "Passphrase";
          var LISTENING_HOOK = "Swarm http proxy started";
          var state = WAITING_PASSWORD;
          var swarmProcess = spawn(swarmSetup.binPath, ["--bzzaccount", account || privateKey, "--datadir", dataDir, "--ens-api", ensApi]);
          var handleProcessOutput = function handleProcessOutput2(data) {
            if (state === WAITING_PASSWORD && hasString(PASSWORD_PROMPT_HOOK)(data)) {
              setTimeout(function() {
                state = STARTING;
                swarmProcess.stdin.write(password + "\n");
              }, 500);
            } else if (hasString(LISTENING_HOOK)(data)) {
              state = LISTENING;
              clearTimeout(timeout);
              resolve(swarmProcess);
            }
          };
          swarmProcess.stdout.on("data", handleProcessOutput);
          swarmProcess.stderr.on("data", handleProcessOutput);
          var restart = function restart2() {
            return startProcess2(swarmSetup).then(resolve)["catch"](reject);
          };
          var error2 = function error3() {
            return reject(new Error("Couldn't start swarm process."));
          };
          var timeout = setTimeout(error2, 2e4);
        });
      };
      var stopProcess = function stopProcess2(process2) {
        return new Promise(function(resolve, reject) {
          process2.stderr.removeAllListeners("data");
          process2.stdout.removeAllListeners("data");
          process2.stdin.removeAllListeners("error");
          process2.removeAllListeners("error");
          process2.removeAllListeners("exit");
          process2.kill("SIGINT");
          var killTimeout = setTimeout(function() {
            return process2.kill("SIGKILL");
          }, 8e3);
          process2.once("close", function() {
            clearTimeout(killTimeout);
            resolve();
          });
        });
      };
      var local = function local2(swarmSetup) {
        return function(useAPI) {
          return _isAvailable("http://localhost:8500").then(function(isAvailable) {
            return isAvailable ? useAPI(at("http://localhost:8500")).then(function() {
            }) : downloadBinary(swarmSetup.binPath, swarmSetup.archives).onData(function(data) {
              return (swarmSetup.onProgress || function() {
              })(data.length);
            }).then(function() {
              return startProcess(swarmSetup);
            }).then(function(process2) {
              return useAPI(at("http://localhost:8500")).then(function() {
                return process2;
              });
            }).then(stopProcess);
          });
        };
      };
      var _isAvailable = function isAvailable(swarmUrl) {
        var testFile = "test";
        var testHash = "c9a99c7d326dcc6316f32fe2625b311f6dc49a175e6877681ded93137d3569e7";
        return uploadData(swarmUrl)(testFile).then(function(hash2) {
          return hash2 === testHash;
        })["catch"](function() {
          return false;
        });
      };
      var isDirectory = function isDirectory2(swarmUrl) {
        return function(hash2) {
          return downloadData(swarmUrl)(hash2).then(function(data) {
            try {
              return !!JSON.parse(toString(data)).entries;
            } catch (e) {
              return false;
            }
          });
        };
      };
      var uncurry = function uncurry2(f) {
        return function(a, b, c, d, e) {
          var p;
          if (typeof a !== "undefined")
            p = f(a);
          if (typeof b !== "undefined")
            p = f(b);
          if (typeof c !== "undefined")
            p = f(c);
          if (typeof d !== "undefined")
            p = f(d);
          if (typeof e !== "undefined")
            p = f(e);
          return p;
        };
      };
      var test = function test2() {
        return Promise.resolve(true);
      };
      var toString = function toString2(uint8Array) {
        return bytes.toString(bytes.fromUint8Array(uint8Array));
      };
      var fromString = function fromString2(string) {
        return bytes.toUint8Array(bytes.fromString(string));
      };
      var at = function at2(swarmUrl) {
        return {
          download: function download(hash2, path2) {
            return _download(swarmUrl)(hash2)(path2);
          },
          downloadData: uncurry(downloadData(swarmUrl)),
          downloadDataToDisk: uncurry(downloadDataToDisk(swarmUrl)),
          downloadDirectory: uncurry(downloadDirectory(swarmUrl)),
          downloadDirectoryToDisk: uncurry(downloadDirectoryToDisk(swarmUrl)),
          downloadEntries: uncurry(downloadEntries(swarmUrl)),
          downloadRoutes: uncurry(downloadRoutes(swarmUrl)),
          isAvailable: function isAvailable() {
            return _isAvailable(swarmUrl);
          },
          upload: function upload(arg) {
            return _upload(swarmUrl)(arg);
          },
          uploadData: uncurry(uploadData(swarmUrl)),
          uploadFile: uncurry(uploadFile(swarmUrl)),
          uploadFileFromDisk: uncurry(uploadFile(swarmUrl)),
          uploadDataFromDisk: uncurry(uploadDataFromDisk(swarmUrl)),
          uploadDirectory: uncurry(uploadDirectory(swarmUrl)),
          uploadDirectoryFromDisk: uncurry(uploadDirectoryFromDisk(swarmUrl)),
          uploadToManifest: uncurry(uploadToManifest(swarmUrl)),
          pick,
          hash,
          fromString,
          toString
        };
      };
      return {
        at,
        local,
        download: _download,
        downloadBinary,
        downloadData,
        downloadDataToDisk,
        downloadDirectory,
        downloadDirectoryToDisk,
        downloadEntries,
        downloadRoutes,
        isAvailable: _isAvailable,
        startProcess,
        stopProcess,
        upload: _upload,
        uploadData,
        uploadDataFromDisk,
        uploadFile,
        uploadFileFromDisk,
        uploadDirectory,
        uploadDirectoryFromDisk,
        uploadToManifest,
        pick,
        hash,
        fromString,
        toString
      };
    };
  }
});

// node_modules/swarm-js/lib/api-browser.js
var require_api_browser = __commonJS({
  "node_modules/swarm-js/lib/api-browser.js"(exports, module) {
    init_define_process_env();
    var unavailable = function unavailable2() {
      throw "This swarm.js function isn't available on the browser.";
    };
    var fs = {
      readFile: unavailable
    };
    var files = {
      download: unavailable,
      safeDownloadArchived: unavailable,
      directoryTree: unavailable
    };
    var os = {
      platform: unavailable,
      arch: unavailable
    };
    var path = {
      join: unavailable,
      slice: unavailable
    };
    var child_process = {
      spawn: unavailable
    };
    var mimetype2 = {
      lookup: unavailable
    };
    var defaultArchives = {};
    var downloadUrl = null;
    var request = require_xhr_request();
    var bytes = require_bytes2();
    var hash = require_swarm_hash();
    var pick = require_pick();
    var swarm = require_swarm();
    module.exports = swarm({
      fs,
      files,
      os,
      path,
      child_process,
      defaultArchives,
      mimetype: mimetype2,
      request,
      downloadUrl,
      bytes,
      hash,
      pick
    });
  }
});

// node_modules/web3-bzz/lib/index.js
var require_lib45 = __commonJS({
  "node_modules/web3-bzz/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var swarm = require_api_browser();
    var Bzz = function Bzz2(provider) {
      this.givenProvider = Bzz2.givenProvider;
      if (provider && provider._requestManager) {
        provider = provider.currentProvider;
      }
      if (typeof document !== "undefined") {
        this.pick = swarm.pick;
      }
      this.setProvider(provider);
    };
    Bzz.givenProvider = null;
    if (typeof ethereum !== "undefined" && ethereum.bzz) {
      Bzz.givenProvider = ethereum.bzz;
    }
    Bzz.prototype.setProvider = function(provider) {
      if (!!provider && typeof provider === "object" && typeof provider.bzz === "string") {
        provider = provider.bzz;
      }
      if (typeof provider === "string") {
        this.currentProvider = provider;
      } else {
        this.currentProvider = null;
        var noProviderError = new Error("No provider set, please set one using bzz.setProvider().");
        this.download = this.upload = this.isAvailable = function() {
          throw noProviderError;
        };
        return false;
      }
      this.download = swarm.at(provider).download;
      this.upload = swarm.at(provider).upload;
      this.isAvailable = swarm.at(provider).isAvailable;
      return true;
    };
    module.exports = Bzz;
  }
});

// node_modules/web3/lib/index.js
var require_lib46 = __commonJS({
  "node_modules/web3/lib/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var version = require_package().version;
    var core = require_lib13();
    var Eth = require_lib38();
    var Net = require_lib24();
    var Personal = require_lib31();
    var Shh = require_lib44();
    var Bzz = require_lib45();
    var utils = require_lib();
    var Web3 = function Web32() {
      var _this = this;
      core.packageInit(this, arguments);
      this.version = version;
      this.utils = utils;
      this.eth = new Eth(this);
      this.shh = new Shh(this);
      this.bzz = new Bzz(this);
      var setProvider = this.setProvider;
      this.setProvider = function(provider, net) {
        setProvider.apply(_this, arguments);
        _this.eth.setRequestManager(_this._requestManager);
        _this.shh.setRequestManager(_this._requestManager);
        _this.bzz.setProvider(provider);
        return true;
      };
    };
    Web3.version = version;
    Web3.utils = utils;
    Web3.modules = {
      Eth,
      Net,
      Personal,
      Shh,
      Bzz
    };
    core.addProviders(Web3);
    module.exports = Web3;
  }
});

// dep:web3
init_define_process_env();
var web3_default = require_lib46();
export {
  web3_default as default
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.5.7
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2016
 * @license MIT
 */
//# sourceMappingURL=web3.js.map
