import {
  require_events
} from "./chunk-K2K3O27I.js";
import {
  __commonJS,
  __toESM,
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// node_modules/u2f-api/lib/google-u2f-api.js
var require_google_u2f_api = __commonJS({
  "node_modules/u2f-api/lib/google-u2f-api.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var u2f = u2f || {};
    module.exports = u2f;
    u2f.EXTENSION_ID = "kmendfapggjehodndflmmgagdbamhnfd";
    u2f.MessageTypes = {
      "U2F_REGISTER_REQUEST": "u2f_register_request",
      "U2F_SIGN_REQUEST": "u2f_sign_request",
      "U2F_REGISTER_RESPONSE": "u2f_register_response",
      "U2F_SIGN_RESPONSE": "u2f_sign_response"
    };
    u2f.ErrorCodes = {
      "OK": 0,
      "OTHER_ERROR": 1,
      "BAD_REQUEST": 2,
      "CONFIGURATION_UNSUPPORTED": 3,
      "DEVICE_INELIGIBLE": 4,
      "TIMEOUT": 5
    };
    u2f.Request;
    u2f.Response;
    u2f.Error;
    u2f.SignRequest;
    u2f.SignResponse;
    u2f.RegisterRequest;
    u2f.RegisterResponse;
    u2f.disconnect = function() {
      if (u2f.port_ && u2f.port_.port_) {
        u2f.port_.port_.disconnect();
        u2f.port_ = null;
      }
    };
    u2f.getMessagePort = function(callback) {
      if (typeof chrome != "undefined" && chrome.runtime) {
        var msg = {
          type: u2f.MessageTypes.U2F_SIGN_REQUEST,
          signRequests: []
        };
        chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {
          if (!chrome.runtime.lastError) {
            u2f.getChromeRuntimePort_(callback);
          } else {
            u2f.getIframePort_(callback);
          }
        });
      } else {
        u2f.getIframePort_(callback);
      }
    };
    u2f.getChromeRuntimePort_ = function(callback) {
      var port = chrome.runtime.connect(u2f.EXTENSION_ID, { "includeTlsChannelId": true });
      setTimeout(function() {
        callback(null, new u2f.WrappedChromeRuntimePort_(port));
      }, 0);
    };
    u2f.WrappedChromeRuntimePort_ = function(port) {
      this.port_ = port;
    };
    u2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {
      this.port_.postMessage(message);
    };
    u2f.WrappedChromeRuntimePort_.prototype.addEventListener = function(eventName, handler) {
      var name = eventName.toLowerCase();
      if (name == "message" || name == "onmessage") {
        this.port_.onMessage.addListener(function(message) {
          handler({ "data": message });
        });
      } else {
        console.error("WrappedChromeRuntimePort only supports onMessage");
      }
    };
    u2f.getIframePort_ = function(callback) {
      var iframeOrigin = "chrome-extension://" + u2f.EXTENSION_ID;
      var iframe = document.createElement("iframe");
      iframe.src = iframeOrigin + "/u2f-comms.html";
      iframe.setAttribute("style", "display:none");
      document.body.appendChild(iframe);
      var hasCalledBack = false;
      var channel = new MessageChannel();
      var ready = function(message) {
        if (message.data == "ready") {
          channel.port1.removeEventListener("message", ready);
          if (!hasCalledBack) {
            hasCalledBack = true;
            callback(null, channel.port1);
          }
        } else {
          console.error('First event on iframe port was not "ready"');
        }
      };
      channel.port1.addEventListener("message", ready);
      channel.port1.start();
      iframe.addEventListener("load", function() {
        iframe.contentWindow.postMessage("init", iframeOrigin, [channel.port2]);
      });
      setTimeout(function() {
        if (!hasCalledBack) {
          hasCalledBack = true;
          callback(new Error("IFrame extension not supported"));
        }
      }, 200);
    };
    u2f.EXTENSION_TIMEOUT_SEC = 30;
    u2f.port_ = null;
    u2f.waitingForPort_ = [];
    u2f.reqCounter_ = 0;
    u2f.callbackMap_ = {};
    u2f.getPortSingleton_ = function(callback) {
      if (u2f.port_) {
        callback(null, u2f.port_);
      } else {
        if (u2f.waitingForPort_.length == 0) {
          u2f.getMessagePort(function(err, port) {
            if (!err) {
              u2f.port_ = port;
              u2f.port_.addEventListener("message", u2f.responseHandler_);
            }
            while (u2f.waitingForPort_.length)
              u2f.waitingForPort_.shift()(err, port);
          });
        }
        u2f.waitingForPort_.push(callback);
      }
    };
    u2f.responseHandler_ = function(message) {
      var response = message.data;
      var reqId = response["requestId"];
      if (!reqId || !u2f.callbackMap_[reqId]) {
        console.error("Unknown or missing requestId in response.");
        return;
      }
      var cb = u2f.callbackMap_[reqId];
      delete u2f.callbackMap_[reqId];
      cb(null, response["responseData"]);
    };
    u2f.isSupported = function(callback) {
      u2f.getPortSingleton_(function(err, port) {
        callback(!err);
      });
    };
    u2f.sign = function(signRequests, callback, opt_timeoutSeconds) {
      u2f.getPortSingleton_(function(err, port) {
        if (err)
          return callback(err);
        var reqId = ++u2f.reqCounter_;
        u2f.callbackMap_[reqId] = callback;
        var req = {
          type: u2f.MessageTypes.U2F_SIGN_REQUEST,
          signRequests,
          timeoutSeconds: typeof opt_timeoutSeconds !== "undefined" ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC,
          requestId: reqId
        };
        port.postMessage(req);
      });
    };
    u2f.register = function(registerRequests, signRequests, callback, opt_timeoutSeconds) {
      u2f.getPortSingleton_(function(err, port) {
        if (err)
          return callback(err);
        var reqId = ++u2f.reqCounter_;
        u2f.callbackMap_[reqId] = callback;
        var req = {
          type: u2f.MessageTypes.U2F_REGISTER_REQUEST,
          signRequests,
          registerRequests,
          timeoutSeconds: typeof opt_timeoutSeconds !== "undefined" ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC,
          requestId: reqId
        };
        port.postMessage(req);
      });
    };
  }
});

// node_modules/u2f-api/lib/u2f-api.js
var require_u2f_api = __commonJS({
  "node_modules/u2f-api/lib/u2f-api.js"(exports, module) {
    "use strict";
    init_define_process_env();
    module.exports = API;
    var chromeApi = require_google_u2f_api();
    var isBrowser = typeof navigator !== "undefined" && !!navigator.userAgent;
    var isSafari = isBrowser && navigator.userAgent.match(/Safari\//) && !navigator.userAgent.match(/Chrome\//);
    var isEDGE = isBrowser && navigator.userAgent.match(/Edge\/1[2345]/);
    var _backend = null;
    function getBackend(Promise2) {
      if (!_backend)
        _backend = new Promise2(function(resolve, reject) {
          function notSupported() {
            resolve({ u2f: null, native: true });
          }
          if (!isBrowser)
            return notSupported();
          if (isSafari)
            return notSupported();
          var hasNativeSupport = typeof window.u2f !== "undefined" && typeof window.u2f.sign === "function";
          if (hasNativeSupport)
            resolve({ u2f: window.u2f, native: true });
          if (isEDGE)
            return notSupported();
          if (location.protocol === "http:")
            return notSupported();
          if (typeof MessageChannel === "undefined")
            return notSupported();
          chromeApi.isSupported(function(ok) {
            if (ok)
              resolve({ u2f: chromeApi, native: false });
            else
              notSupported();
          });
        });
      return _backend;
    }
    function API(Promise2) {
      return {
        isSupported: isSupported2.bind(Promise2),
        ensureSupport: ensureSupport.bind(Promise2),
        register: register.bind(Promise2),
        sign: sign2.bind(Promise2),
        ErrorCodes: API.ErrorCodes,
        ErrorNames: API.ErrorNames
      };
    }
    API.ErrorCodes = {
      CANCELLED: -1,
      OK: 0,
      OTHER_ERROR: 1,
      BAD_REQUEST: 2,
      CONFIGURATION_UNSUPPORTED: 3,
      DEVICE_INELIGIBLE: 4,
      TIMEOUT: 5
    };
    API.ErrorNames = {
      "-1": "CANCELLED",
      "0": "OK",
      "1": "OTHER_ERROR",
      "2": "BAD_REQUEST",
      "3": "CONFIGURATION_UNSUPPORTED",
      "4": "DEVICE_INELIGIBLE",
      "5": "TIMEOUT"
    };
    function makeError(msg, err) {
      var code = err != null ? err.errorCode : 1;
      var type = API.ErrorNames["" + code];
      var error = new Error(msg);
      error.metaData = {
        type,
        code
      };
      return error;
    }
    function deferPromise(Promise2, promise) {
      var ret = {};
      ret.promise = new Promise2(function(resolve, reject) {
        ret.resolve = resolve;
        ret.reject = reject;
        promise.then(resolve, reject);
      });
      ret.promise.cancel = function(msg, disconnect) {
        getBackend(Promise2).then(function(backend) {
          if (disconnect && !backend.native)
            backend.u2f.disconnect();
          ret.reject(makeError(msg, { errorCode: -1 }));
        });
      };
      return ret;
    }
    function isSupported2() {
      var Promise2 = this;
      return getBackend(Promise2).then(function(backend) {
        return !!backend.u2f;
      });
    }
    function _ensureSupport(backend) {
      if (!backend.u2f) {
        if (location.protocol === "http:")
          throw new Error("U2F isn't supported over http, only https");
        throw new Error("U2F not supported");
      }
    }
    function ensureSupport() {
      var Promise2 = this;
      return getBackend(Promise2).then(_ensureSupport);
    }
    function register(registerRequests, signRequests, timeout) {
      var Promise2 = this;
      if (!Array.isArray(registerRequests))
        registerRequests = [registerRequests];
      if (typeof signRequests === "number" && typeof timeout === "undefined") {
        timeout = signRequests;
        signRequests = null;
      }
      if (!signRequests)
        signRequests = [];
      return deferPromise(Promise2, getBackend(Promise2).then(function(backend) {
        _ensureSupport(backend);
        var native = backend.native;
        var u2f = backend.u2f;
        return new Promise2(function(resolve, reject) {
          function cbNative(response) {
            if (response.errorCode)
              reject(makeError("Registration failed", response));
            else {
              delete response.errorCode;
              resolve(response);
            }
          }
          function cbChrome(err, response) {
            if (err)
              reject(err);
            else if (response.errorCode)
              reject(makeError("Registration failed", response));
            else
              resolve(response);
          }
          if (native) {
            var appId = registerRequests[0].appId;
            u2f.register(appId, registerRequests, signRequests, cbNative, timeout);
          } else {
            u2f.register(registerRequests, signRequests, cbChrome, timeout);
          }
        });
      })).promise;
    }
    function sign2(signRequests, timeout) {
      var Promise2 = this;
      if (!Array.isArray(signRequests))
        signRequests = [signRequests];
      return deferPromise(Promise2, getBackend(Promise2).then(function(backend) {
        _ensureSupport(backend);
        var native = backend.native;
        var u2f = backend.u2f;
        return new Promise2(function(resolve, reject) {
          function cbNative(response) {
            if (response.errorCode)
              reject(makeError("Sign failed", response));
            else {
              delete response.errorCode;
              resolve(response);
            }
          }
          function cbChrome(err, response) {
            if (err)
              reject(err);
            else if (response.errorCode)
              reject(makeError("Sign failed", response));
            else
              resolve(response);
          }
          if (native) {
            var appId = signRequests[0].appId;
            var challenge = signRequests[0].challenge;
            u2f.sign(appId, challenge, signRequests, cbNative, timeout);
          } else {
            u2f.sign(signRequests, cbChrome, timeout);
          }
        });
      })).promise;
    }
    function makeDefault(func) {
      API[func] = function() {
        if (!global.Promise)
          throw new Error("The platform doesn't natively support promises");
        var args = [].slice.call(arguments);
        return API(global.Promise)[func].apply(null, args);
      };
    }
    makeDefault("isSupported");
    makeDefault("ensureSupport");
    makeDefault("register");
    makeDefault("sign");
  }
});

// node_modules/u2f-api/index.js
var require_u2f_api2 = __commonJS({
  "node_modules/u2f-api/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    module.exports = require_u2f_api();
  }
});

// node_modules/@ledgerhq/hw-transport-u2f/lib-es/TransportU2F.js
init_define_process_env();
var import_u2f_api = __toESM(require_u2f_api2());

// node_modules/@ledgerhq/hw-transport-u2f/node_modules/@ledgerhq/hw-transport/lib-es/Transport.js
init_define_process_env();
var import_events = __toESM(require_events());

// node_modules/@ledgerhq/hw-transport-u2f/node_modules/@ledgerhq/errors/dist/index.js
init_define_process_env();
var errorClasses = {};
var deserializers = {};
var addCustomErrorDeserializer = function(name, deserializer) {
  deserializers[name] = deserializer;
};
var createCustomErrorClass = function(name) {
  var C = function CustomError(message, fields) {
    Object.assign(this, fields);
    this.name = name;
    this.message = message || name;
    this.stack = new Error().stack;
  };
  C.prototype = new Error();
  errorClasses[name] = C;
  return C;
};
var AccountNameRequiredError = createCustomErrorClass("AccountNameRequired");
var AccountNotSupported = createCustomErrorClass("AccountNotSupported");
var AmountRequired = createCustomErrorClass("AmountRequired");
var BluetoothRequired = createCustomErrorClass("BluetoothRequired");
var BtcUnmatchedApp = createCustomErrorClass("BtcUnmatchedApp");
var CantOpenDevice = createCustomErrorClass("CantOpenDevice");
var CashAddrNotSupported = createCustomErrorClass("CashAddrNotSupported");
var CurrencyNotSupported = createCustomErrorClass("CurrencyNotSupported");
var DeviceAppVerifyNotSupported = createCustomErrorClass("DeviceAppVerifyNotSupported");
var DeviceGenuineSocketEarlyClose = createCustomErrorClass("DeviceGenuineSocketEarlyClose");
var DeviceNotGenuineError = createCustomErrorClass("DeviceNotGenuine");
var DeviceOnDashboardExpected = createCustomErrorClass("DeviceOnDashboardExpected");
var DeviceOnDashboardUnexpected = createCustomErrorClass("DeviceOnDashboardUnexpected");
var DeviceInOSUExpected = createCustomErrorClass("DeviceInOSUExpected");
var DeviceHalted = createCustomErrorClass("DeviceHalted");
var DeviceNameInvalid = createCustomErrorClass("DeviceNameInvalid");
var DeviceSocketFail = createCustomErrorClass("DeviceSocketFail");
var DeviceSocketNoBulkStatus = createCustomErrorClass("DeviceSocketNoBulkStatus");
var DisconnectedDevice = createCustomErrorClass("DisconnectedDevice");
var DisconnectedDeviceDuringOperation = createCustomErrorClass("DisconnectedDeviceDuringOperation");
var EnpointConfigError = createCustomErrorClass("EnpointConfig");
var EthAppPleaseEnableContractData = createCustomErrorClass("EthAppPleaseEnableContractData");
var FeeEstimationFailed = createCustomErrorClass("FeeEstimationFailed");
var FirmwareNotRecognized = createCustomErrorClass("FirmwareNotRecognized");
var HardResetFail = createCustomErrorClass("HardResetFail");
var InvalidXRPTag = createCustomErrorClass("InvalidXRPTag");
var InvalidAddress = createCustomErrorClass("InvalidAddress");
var InvalidAddressBecauseDestinationIsAlsoSource = createCustomErrorClass("InvalidAddressBecauseDestinationIsAlsoSource");
var LatestMCUInstalledError = createCustomErrorClass("LatestMCUInstalledError");
var UnknownMCU = createCustomErrorClass("UnknownMCU");
var LedgerAPIError = createCustomErrorClass("LedgerAPIError");
var LedgerAPIErrorWithMessage = createCustomErrorClass("LedgerAPIErrorWithMessage");
var LedgerAPINotAvailable = createCustomErrorClass("LedgerAPINotAvailable");
var ManagerAppAlreadyInstalledError = createCustomErrorClass("ManagerAppAlreadyInstalled");
var ManagerAppRelyOnBTCError = createCustomErrorClass("ManagerAppRelyOnBTC");
var ManagerAppDepInstallRequired = createCustomErrorClass("ManagerAppDepInstallRequired");
var ManagerAppDepUninstallRequired = createCustomErrorClass("ManagerAppDepUninstallRequired");
var ManagerDeviceLockedError = createCustomErrorClass("ManagerDeviceLocked");
var ManagerFirmwareNotEnoughSpaceError = createCustomErrorClass("ManagerFirmwareNotEnoughSpace");
var ManagerNotEnoughSpaceError = createCustomErrorClass("ManagerNotEnoughSpace");
var ManagerUninstallBTCDep = createCustomErrorClass("ManagerUninstallBTCDep");
var NetworkDown = createCustomErrorClass("NetworkDown");
var NoAddressesFound = createCustomErrorClass("NoAddressesFound");
var NotEnoughBalance = createCustomErrorClass("NotEnoughBalance");
var NotEnoughBalanceToDelegate = createCustomErrorClass("NotEnoughBalanceToDelegate");
var NotEnoughBalanceInParentAccount = createCustomErrorClass("NotEnoughBalanceInParentAccount");
var NotEnoughSpendableBalance = createCustomErrorClass("NotEnoughSpendableBalance");
var NotEnoughBalanceBecauseDestinationNotCreated = createCustomErrorClass("NotEnoughBalanceBecauseDestinationNotCreated");
var NoAccessToCamera = createCustomErrorClass("NoAccessToCamera");
var NotEnoughGas = createCustomErrorClass("NotEnoughGas");
var NotSupportedLegacyAddress = createCustomErrorClass("NotSupportedLegacyAddress");
var GasLessThanEstimate = createCustomErrorClass("GasLessThanEstimate");
var PasswordsDontMatchError = createCustomErrorClass("PasswordsDontMatch");
var PasswordIncorrectError = createCustomErrorClass("PasswordIncorrect");
var RecommendSubAccountsToEmpty = createCustomErrorClass("RecommendSubAccountsToEmpty");
var RecommendUndelegation = createCustomErrorClass("RecommendUndelegation");
var TimeoutTagged = createCustomErrorClass("TimeoutTagged");
var UnexpectedBootloader = createCustomErrorClass("UnexpectedBootloader");
var MCUNotGenuineToDashboard = createCustomErrorClass("MCUNotGenuineToDashboard");
var RecipientRequired = createCustomErrorClass("RecipientRequired");
var UnavailableTezosOriginatedAccountReceive = createCustomErrorClass("UnavailableTezosOriginatedAccountReceive");
var UnavailableTezosOriginatedAccountSend = createCustomErrorClass("UnavailableTezosOriginatedAccountSend");
var UpdateFetchFileFail = createCustomErrorClass("UpdateFetchFileFail");
var UpdateIncorrectHash = createCustomErrorClass("UpdateIncorrectHash");
var UpdateIncorrectSig = createCustomErrorClass("UpdateIncorrectSig");
var UpdateYourApp = createCustomErrorClass("UpdateYourApp");
var UserRefusedDeviceNameChange = createCustomErrorClass("UserRefusedDeviceNameChange");
var UserRefusedAddress = createCustomErrorClass("UserRefusedAddress");
var UserRefusedFirmwareUpdate = createCustomErrorClass("UserRefusedFirmwareUpdate");
var UserRefusedAllowManager = createCustomErrorClass("UserRefusedAllowManager");
var UserRefusedOnDevice = createCustomErrorClass("UserRefusedOnDevice");
var TransportOpenUserCancelled = createCustomErrorClass("TransportOpenUserCancelled");
var TransportInterfaceNotAvailable = createCustomErrorClass("TransportInterfaceNotAvailable");
var TransportRaceCondition = createCustomErrorClass("TransportRaceCondition");
var TransportWebUSBGestureRequired = createCustomErrorClass("TransportWebUSBGestureRequired");
var DeviceShouldStayInApp = createCustomErrorClass("DeviceShouldStayInApp");
var WebsocketConnectionError = createCustomErrorClass("WebsocketConnectionError");
var WebsocketConnectionFailed = createCustomErrorClass("WebsocketConnectionFailed");
var WrongDeviceForAccount = createCustomErrorClass("WrongDeviceForAccount");
var WrongAppForCurrency = createCustomErrorClass("WrongAppForCurrency");
var ETHAddressNonEIP = createCustomErrorClass("ETHAddressNonEIP");
var CantScanQRCode = createCustomErrorClass("CantScanQRCode");
var FeeNotLoaded = createCustomErrorClass("FeeNotLoaded");
var FeeRequired = createCustomErrorClass("FeeRequired");
var FeeTooHigh = createCustomErrorClass("FeeTooHigh");
var SyncError = createCustomErrorClass("SyncError");
var PairingFailed = createCustomErrorClass("PairingFailed");
var GenuineCheckFailed = createCustomErrorClass("GenuineCheckFailed");
var LedgerAPI4xx = createCustomErrorClass("LedgerAPI4xx");
var LedgerAPI5xx = createCustomErrorClass("LedgerAPI5xx");
var FirmwareOrAppUpdateRequired = createCustomErrorClass("FirmwareOrAppUpdateRequired");
var NoDBPathGiven = createCustomErrorClass("NoDBPathGiven");
var DBWrongPassword = createCustomErrorClass("DBWrongPassword");
var DBNotReset = createCustomErrorClass("DBNotReset");
function TransportError(message, id2) {
  this.name = "TransportError";
  this.message = message;
  this.stack = new Error().stack;
  this.id = id2;
}
TransportError.prototype = new Error();
addCustomErrorDeserializer("TransportError", function(e) {
  return new TransportError(e.message, e.id);
});
var StatusCodes = {
  PIN_REMAINING_ATTEMPTS: 25536,
  INCORRECT_LENGTH: 26368,
  MISSING_CRITICAL_PARAMETER: 26624,
  COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 27009,
  SECURITY_STATUS_NOT_SATISFIED: 27010,
  CONDITIONS_OF_USE_NOT_SATISFIED: 27013,
  INCORRECT_DATA: 27264,
  NOT_ENOUGH_MEMORY_SPACE: 27268,
  REFERENCED_DATA_NOT_FOUND: 27272,
  FILE_ALREADY_EXISTS: 27273,
  INCORRECT_P1_P2: 27392,
  INS_NOT_SUPPORTED: 27904,
  CLA_NOT_SUPPORTED: 28160,
  TECHNICAL_PROBLEM: 28416,
  OK: 36864,
  MEMORY_PROBLEM: 37440,
  NO_EF_SELECTED: 37888,
  INVALID_OFFSET: 37890,
  FILE_NOT_FOUND: 37892,
  INCONSISTENT_FILE: 37896,
  ALGORITHM_NOT_SUPPORTED: 38020,
  INVALID_KCV: 38021,
  CODE_NOT_INITIALIZED: 38914,
  ACCESS_CONDITION_NOT_FULFILLED: 38916,
  CONTRADICTION_SECRET_CODE_STATUS: 38920,
  CONTRADICTION_INVALIDATION: 38928,
  CODE_BLOCKED: 38976,
  MAX_VALUE_REACHED: 38992,
  GP_AUTH_FAILED: 25344,
  LICENSING: 28482,
  HALTED: 28586
};
function getAltStatusMessage(code) {
  switch (code) {
    case 26368:
      return "Incorrect length";
    case 26624:
      return "Missing critical parameter";
    case 27010:
      return "Security not satisfied (dongle locked or have invalid access rights)";
    case 27013:
      return "Condition of use not satisfied (denied by the user?)";
    case 27264:
      return "Invalid data received";
    case 27392:
      return "Invalid parameter received";
  }
  if (28416 <= code && code <= 28671) {
    return "Internal error, please report";
  }
}
function TransportStatusError(statusCode) {
  this.name = "TransportStatusError";
  var statusText = Object.keys(StatusCodes).find(function(k) {
    return StatusCodes[k] === statusCode;
  }) || "UNKNOWN_ERROR";
  var smsg = getAltStatusMessage(statusCode) || statusText;
  var statusCodeStr = statusCode.toString(16);
  this.message = "Ledger device: " + smsg + " (0x" + statusCodeStr + ")";
  this.stack = new Error().stack;
  this.statusCode = statusCode;
  this.statusText = statusText;
}
TransportStatusError.prototype = new Error();
addCustomErrorDeserializer("TransportStatusError", function(e) {
  return new TransportStatusError(e.statusCode);
});

// node_modules/@ledgerhq/hw-transport-u2f/node_modules/@ledgerhq/hw-transport/lib-es/Transport.js
var Transport = class {
  constructor() {
    this.exchangeTimeout = 3e4;
    this.unresponsiveTimeout = 15e3;
    this.deviceModel = null;
    this._events = new import_events.default();
    this.send = async (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [StatusCodes.OK]) => {
      if (data.length >= 256) {
        throw new TransportError("data.length exceed 256 bytes limit. Got: " + data.length, "DataLengthTooBig");
      }
      const response = await this.exchange(Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]));
      const sw = response.readUInt16BE(response.length - 2);
      if (!statusList.some((s) => s === sw)) {
        throw new TransportStatusError(sw);
      }
      return response;
    };
    this.exchangeBusyPromise = void 0;
    this.exchangeAtomicImpl = async (f) => {
      if (this.exchangeBusyPromise) {
        throw new TransportRaceCondition("An action was already pending on the Ledger device. Please deny or reconnect.");
      }
      let resolveBusy;
      const busyPromise = new Promise((r) => {
        resolveBusy = r;
      });
      this.exchangeBusyPromise = busyPromise;
      let unresponsiveReached = false;
      const timeout = setTimeout(() => {
        unresponsiveReached = true;
        this.emit("unresponsive");
      }, this.unresponsiveTimeout);
      try {
        const res = await f();
        if (unresponsiveReached) {
          this.emit("responsive");
        }
        return res;
      } finally {
        clearTimeout(timeout);
        if (resolveBusy)
          resolveBusy();
        this.exchangeBusyPromise = null;
      }
    };
    this._appAPIlock = null;
  }
  exchange(_apdu) {
    throw new Error("exchange not implemented");
  }
  setScrambleKey(_key) {
  }
  close() {
    return Promise.resolve();
  }
  on(eventName, cb) {
    this._events.on(eventName, cb);
  }
  off(eventName, cb) {
    this._events.removeListener(eventName, cb);
  }
  emit(event, ...args) {
    this._events.emit(event, ...args);
  }
  setDebugMode() {
    console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.");
  }
  setExchangeTimeout(exchangeTimeout) {
    this.exchangeTimeout = exchangeTimeout;
  }
  setExchangeUnresponsiveTimeout(unresponsiveTimeout) {
    this.unresponsiveTimeout = unresponsiveTimeout;
  }
  static create(openTimeout = 3e3, listenTimeout) {
    return new Promise((resolve, reject) => {
      let found = false;
      const sub = this.listen({
        next: (e) => {
          found = true;
          if (sub)
            sub.unsubscribe();
          if (listenTimeoutId)
            clearTimeout(listenTimeoutId);
          this.open(e.descriptor, openTimeout).then(resolve, reject);
        },
        error: (e) => {
          if (listenTimeoutId)
            clearTimeout(listenTimeoutId);
          reject(e);
        },
        complete: () => {
          if (listenTimeoutId)
            clearTimeout(listenTimeoutId);
          if (!found) {
            reject(new TransportError(this.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
          }
        }
      });
      const listenTimeoutId = listenTimeout ? setTimeout(() => {
        sub.unsubscribe();
        reject(new TransportError(this.ErrorMessage_ListenTimeout, "ListenTimeout"));
      }, listenTimeout) : null;
    });
  }
  decorateAppAPIMethods(self, methods, scrambleKey) {
    for (let methodName of methods) {
      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);
    }
  }
  decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {
    return async (...args) => {
      const {
        _appAPIlock
      } = this;
      if (_appAPIlock) {
        return Promise.reject(new TransportError("Ledger Device is busy (lock " + _appAPIlock + ")", "TransportLocked"));
      }
      try {
        this._appAPIlock = methodName;
        this.setScrambleKey(scrambleKey);
        return await f.apply(ctx, args);
      } finally {
        this._appAPIlock = null;
      }
    };
  }
};
Transport.isSupported = void 0;
Transport.list = void 0;
Transport.listen = void 0;
Transport.open = void 0;
Transport.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
Transport.ErrorMessage_NoDeviceFound = "No Ledger device found";

// node_modules/@ledgerhq/hw-transport-u2f/node_modules/@ledgerhq/logs/lib-es/index.js
init_define_process_env();
var id = 0;
var subscribers = [];
var log = (type, message, data) => {
  const obj = {
    type,
    id: String(++id),
    date: new Date()
  };
  if (message)
    obj.message = message;
  if (data)
    obj.data = data;
  dispatch(obj);
};
var listen = (cb) => {
  subscribers.push(cb);
  return () => {
    const i = subscribers.indexOf(cb);
    if (i !== -1) {
      subscribers[i] = subscribers[subscribers.length - 1];
      subscribers.pop();
    }
  };
};
function dispatch(log2) {
  for (let i = 0; i < subscribers.length; i++) {
    try {
      subscribers[i](log2);
    } catch (e) {
      console.error(e);
    }
  }
}
if (typeof window !== "undefined") {
  window.__ledgerLogsListen = listen;
}

// node_modules/@ledgerhq/hw-transport-u2f/lib-es/TransportU2F.js
function wrapU2FTransportError(originalError, message, id2) {
  const err = new TransportError(message, id2);
  err.originalError = originalError;
  return err;
}
function wrapApdu(apdu, key) {
  const result = Buffer.alloc(apdu.length);
  for (let i = 0; i < apdu.length; i++) {
    result[i] = apdu[i] ^ key[i % key.length];
  }
  return result;
}
var webSafe64 = (base64) => base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
var normal64 = (base64) => base64.replace(/-/g, "+").replace(/_/g, "/") + "==".substring(0, 3 * base64.length % 4);
function attemptExchange(apdu, timeoutMillis, scrambleKey, unwrap) {
  const keyHandle = wrapApdu(apdu, scrambleKey);
  const challenge = Buffer.from("0000000000000000000000000000000000000000000000000000000000000000", "hex");
  const signRequest = {
    version: "U2F_V2",
    keyHandle: webSafe64(keyHandle.toString("base64")),
    challenge: webSafe64(challenge.toString("base64")),
    appId: location.origin
  };
  log("apdu", "=> " + apdu.toString("hex"));
  return (0, import_u2f_api.sign)(signRequest, timeoutMillis / 1e3).then((response) => {
    const {
      signatureData
    } = response;
    if (typeof signatureData === "string") {
      const data = Buffer.from(normal64(signatureData), "base64");
      let result;
      if (!unwrap) {
        result = data;
      } else {
        result = data.slice(5);
      }
      log("apdu", "<= " + result.toString("hex"));
      return result;
    } else {
      throw response;
    }
  });
}
var transportInstances = [];
function emitDisconnect() {
  transportInstances.forEach((t) => t.emit("disconnect"));
  transportInstances = [];
}
function isTimeoutU2FError(u2fError) {
  return u2fError.metaData.code === 5;
}
var TransportU2F = class extends Transport {
  static async open(_, _openTimeout = 5e3) {
    return new TransportU2F();
  }
  constructor() {
    super();
    this.scrambleKey = void 0;
    this.unwrap = true;
    transportInstances.push(this);
  }
  async exchange(apdu) {
    try {
      return await attemptExchange(apdu, this.exchangeTimeout, this.scrambleKey, this.unwrap);
    } catch (e) {
      const isU2FError = typeof e.metaData === "object";
      if (isU2FError) {
        if (isTimeoutU2FError(e)) {
          emitDisconnect();
        }
        throw wrapU2FTransportError(e, "Failed to sign with Ledger device: U2F " + e.metaData.type, "U2F_" + e.metaData.code);
      } else {
        throw e;
      }
    }
  }
  setScrambleKey(scrambleKey) {
    this.scrambleKey = Buffer.from(scrambleKey, "ascii");
  }
  setUnwrap(unwrap) {
    this.unwrap = unwrap;
  }
  close() {
    return Promise.resolve();
  }
};
TransportU2F.isSupported = import_u2f_api.isSupported;
TransportU2F.list = () => (0, import_u2f_api.isSupported)().then((supported) => supported ? [null] : []);
TransportU2F.listen = (observer) => {
  let unsubscribed = false;
  (0, import_u2f_api.isSupported)().then((supported) => {
    if (unsubscribed)
      return;
    if (supported) {
      observer.next({
        type: "add",
        descriptor: null
      });
      observer.complete();
    } else {
      observer.error(new TransportError("U2F browser support is needed for Ledger. Please use Chrome, Opera or Firefox with a U2F extension. Also make sure you're on an HTTPS connection", "U2FNotSupported"));
    }
  });
  return {
    unsubscribe: () => {
      unsubscribed = true;
    }
  };
};
export {
  TransportU2F as default
};
//# sourceMappingURL=TransportU2F-3WPFX4AY.js.map
