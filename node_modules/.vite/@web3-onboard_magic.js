import {
  __spreadProps,
  __spreadValues,
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// dep:@web3-onboard_magic
init_define_process_env();

// node_modules/@web3-onboard/magic/dist/index.js
init_define_process_env();
function magic(options) {
  const { apiKey } = options;
  const walletName = "Magic Wallet";
  return () => {
    return {
      label: walletName,
      getIcon: async () => (await import("./icon-87babf0a-2VR4BVZH.js")).default,
      getInterface: async ({ EventEmitter, BigNumber, chains }) => {
        const { Magic, RPCErrorCode } = await import("./es-BVFCV7J4.js");
        const loginModal = (await import("./login-modal-59f258c3-MLNMTZIU.js")).default;
        const brandingHTML = (await import("./branding-111ba967-2B234TIV.js")).default;
        let loggedIn = false;
        const { createEIP1193Provider, ProviderRpcErrorCode, ProviderRpcError } = await import("./dist-3LUD4YRJ.js");
        const emitter = new EventEmitter();
        if (!chains.length)
          throw new Error("Atleast one Chain must be passed to onboard in order to connect");
        let currentChain = chains[0];
        let customNodeOptions = {
          chainId: parseInt(currentChain.id),
          rpcUrl: currentChain.rpcUrl
        };
        let magicInstance = new Magic(apiKey, {
          network: customNodeOptions
        });
        const loginWithEmail = async (emailAddress) => {
          try {
            await magicInstance.auth.loginWithMagicLink({ email: emailAddress });
            return await magicInstance.user.isLoggedIn();
          } catch (err) {
            throw new Error(`An error occurred while connecting your Magic wallet, please try again: ${err}`);
          }
        };
        const handleLogin = async () => {
          loggedIn = await loginModal({
            walletName,
            brandingHTMLString: brandingHTML,
            emailLoginFunction: loginWithEmail
          });
        };
        let magicProvider = magicInstance.rpcProvider;
        let provider;
        let activeAddress;
        function patchProvider() {
          const patchedProvider = createEIP1193Provider(magicProvider, {
            eth_requestAccounts: async ({ baseRequest }) => {
              try {
                if (!loggedIn)
                  await handleLogin();
                const accounts = await baseRequest({ method: "eth_accounts" });
                activeAddress = accounts[0];
                return accounts;
              } catch (error) {
                const { code } = error;
                if (code === RPCErrorCode.InternalError) {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.ACCOUNT_ACCESS_REJECTED,
                    message: "Account access rejected"
                  });
                }
                return [];
              }
            },
            eth_selectAccounts: null,
            eth_getBalance: async ({ baseRequest }) => {
              const balance = await baseRequest({
                method: "eth_getBalance",
                params: [activeAddress, "latest"]
              });
              return balance ? BigNumber.from(balance).mul("1000000000000000000").toString() : "0";
            },
            wallet_switchEthereumChain: async ({ params }) => {
              const chain = chains.find(({ id }) => id === params[0].chainId);
              if (!chain)
                throw new Error("Chain must be set before switching");
              currentChain = chain;
              customNodeOptions = {
                chainId: parseInt(currentChain.id),
                rpcUrl: currentChain.rpcUrl
              };
              magicInstance = new Magic(apiKey, {
                network: customNodeOptions
              });
              magicProvider = magicInstance.rpcProvider;
              emitter.emit("chainChanged", currentChain.id);
              patchProvider();
              return null;
            },
            eth_sign: async ({ params }) => {
              const receipt = await magicProvider.send("eth_sign", params);
              return receipt && receipt.hasOwnProperty("tx") && receipt.tx.hasOwnProperty("hash") ? receipt.tx.hash : "";
            },
            eth_signTypedData: async ({ params }) => {
              const receipt = await magicProvider.send("eth_sign", params);
              return receipt && receipt.hasOwnProperty("tx") && receipt.tx.hasOwnProperty("hash") ? receipt.tx.hash : "";
            },
            eth_chainId: async () => currentChain && currentChain.hasOwnProperty("id") ? currentChain.id : "0x1",
            eth_signTransaction: async ({ params: [transactionObject] }) => {
              let destination;
              if (transactionObject.hasOwnProperty("to")) {
                destination = transactionObject.to;
              }
              const receipt = await magicProvider.send("eth_signTransaction", [
                __spreadProps(__spreadValues({}, transactionObject), {
                  nonce: transactionObject.hasOwnProperty("nonce") && typeof transactionObject.nonce === "number" ? parseInt(transactionObject.nonce) : "",
                  from: activeAddress,
                  to: destination
                })
              ]);
              return receipt && receipt.hasOwnProperty("tx") && receipt.tx.hasOwnProperty("hash") ? receipt.tx.hash : "";
            }
          });
          if (!provider) {
            patchedProvider.on = emitter.on.bind(emitter);
            patchedProvider.disconnect = () => magicInstance.user.logout();
            return patchedProvider;
          } else {
            provider.request = patchedProvider.request.bind(patchedProvider);
            provider.send = patchedProvider.send.bind(patchedProvider);
            provider.sendAsync = patchedProvider.sendAsync.bind(patchedProvider);
            return provider;
          }
        }
        provider = patchProvider();
        return {
          provider,
          instance: magicInstance
        };
      }
    };
  };
}

// dep:@web3-onboard_magic
var web3_onboard_magic_default = magic;
export {
  web3_onboard_magic_default as default
};
//# sourceMappingURL=@web3-onboard_magic.js.map
