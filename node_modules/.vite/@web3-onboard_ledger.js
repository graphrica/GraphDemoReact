import {
  require_dist
} from "./chunk-J63UC7XR.js";
import "./chunk-ESWKWXUO.js";
import "./chunk-HRG2DHFT.js";
import "./chunk-6XVHBKXF.js";
import "./chunk-QJBX42KY.js";
import "./chunk-UTWHOSAQ.js";
import "./chunk-BTG65MVN.js";
import "./chunk-K2K3O27I.js";
import {
  require_buffer
} from "./chunk-557FO4FU.js";
import "./chunk-S5NSXQRL.js";
import "./chunk-QMSD3UEV.js";
import "./chunk-27CSTQIU.js";
import "./chunk-VIQ6GMKA.js";
import "./chunk-PX4IM7JA.js";
import {
  __spreadProps,
  __spreadValues,
  __toESM,
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// dep:@web3-onboard_ledger
init_define_process_env();

// node_modules/@web3-onboard/ledger/dist/index.js
init_define_process_env();
var import_eth_sig_util = __toESM(require_dist(), 1);
var import_buffer = __toESM(require_buffer(), 1);
var LEDGER_LIVE_PATH = `m/44'/60'`;
var LEDGER_DEFAULT_PATH = `m/44'/60'/0'`;
var DEFAULT_BASE_PATHS = [
  {
    label: "Ledger Live",
    value: LEDGER_LIVE_PATH
  },
  {
    label: "Ledger Legacy",
    value: LEDGER_DEFAULT_PATH
  }
];
var assets = [
  {
    label: "ETH"
  }
];
var supportsWebUSB = () => Promise.resolve(!!navigator && !!navigator.usb && typeof navigator.usb.getDevices === "function");
var getTransport = async () => (await supportsWebUSB() ? (await import("./TransportWebUSB-B7H5EM3N.js")).default : (await import("./TransportU2F-3WPFX4AY.js")).default).create();
var getAccount = async (derivationPath, asset, index, provider, eth) => {
  const dPath = derivationPath === LEDGER_LIVE_PATH ? `${derivationPath}/${index}'/0/0` : `${derivationPath}/${index}`;
  const { address } = await eth.getAddress(dPath);
  return {
    derivationPath: dPath,
    address,
    balance: {
      asset: asset.label,
      value: await provider.getBalance(address)
    }
  };
};
var getAddresses = async (derivationPath, asset, provider, eth) => {
  const accounts = [];
  let index = 0;
  let zeroBalanceAccounts = 0;
  while (zeroBalanceAccounts < 5) {
    const acc = await getAccount(derivationPath, asset, index, provider, eth);
    if (acc.balance.value.isZero()) {
      zeroBalanceAccounts++;
      accounts.push(acc);
    } else {
      accounts.push(acc);
      zeroBalanceAccounts = 0;
    }
    index++;
  }
  return accounts;
};
function ledger({ customNetwork } = {}) {
  const getIcon = async () => (await import("./icon-L76ILX47.js")).default;
  return () => {
    let accounts;
    return {
      label: "Ledger",
      getIcon,
      getInterface: async ({ EventEmitter, chains }) => {
        const Eth = (await import("./Eth-E5HK3BFG.js")).default;
        const { default: Common, Hardfork } = await import("./dist-4XGLEIV5.js");
        const ethUtil = await import("./dist-JPBCCQ4F.js");
        const { SignTypedDataVersion } = await import("./dist-AD4U5YIV.js");
        const { StaticJsonRpcProvider } = await import("./lib-5NF7NHOH.js");
        const { accountSelect, createEIP1193Provider, ProviderRpcError } = await import("./dist-3LUD4YRJ.js");
        const { TransactionFactory: Transaction, Capability } = await import("./dist-LOC4KPXA.js");
        const transport = await getTransport();
        const eth = new Eth(transport);
        const eventEmitter = new EventEmitter();
        let currentChain = chains[0];
        const scanAccounts = async ({ derivationPath, chainId, asset }) => {
          try {
            currentChain = chains.find(({ id }) => id === chainId) || currentChain;
            const provider2 = new StaticJsonRpcProvider(currentChain.rpcUrl);
            if (derivationPath !== LEDGER_LIVE_PATH && derivationPath !== LEDGER_DEFAULT_PATH) {
              const { address } = await eth.getAddress(derivationPath);
              return [
                {
                  derivationPath,
                  address,
                  balance: {
                    asset: asset.label,
                    value: await provider2.getBalance(address)
                  }
                }
              ];
            }
            return getAddresses(derivationPath, asset, provider2, eth);
          } catch (error) {
            const { statusText } = error;
            throw new Error(statusText === "UNKNOWN_ERROR" ? "Ledger device is locked, please unlock to continue" : statusText);
          }
        };
        const getAccounts = async () => {
          accounts = await accountSelect({
            basePaths: DEFAULT_BASE_PATHS,
            assets,
            chains,
            scanAccounts
          });
          if (accounts && accounts.length) {
            eventEmitter.emit("accountsChanged", [accounts[0].address]);
          }
          return accounts;
        };
        const request = async ({ method, params }) => {
          const response = await fetch(currentChain.rpcUrl, {
            method: "POST",
            body: JSON.stringify({
              id: "42",
              method,
              params
            })
          }).then((res) => res.json());
          if (response.result) {
            return response.result;
          } else {
            throw response.error;
          }
        };
        const ledgerProvider = { request };
        const provider = createEIP1193Provider(ledgerProvider, {
          eth_requestAccounts: async () => {
            const accounts2 = await getAccounts();
            if (!Array.isArray(accounts2))
              throw new Error("No account selected. Must call eth_requestAccounts first.");
            if (accounts2.length === 0) {
              throw new ProviderRpcError({
                code: 4001,
                message: "User rejected the request."
              });
            }
            if (!accounts2[0].hasOwnProperty("address"))
              throw new Error("No address property associated with the selected account");
            return [accounts2[0].address];
          },
          eth_selectAccounts: async () => {
            const accounts2 = await getAccounts();
            return accounts2.map(({ address }) => address);
          },
          eth_accounts: async () => {
            return Array.isArray(accounts) && accounts.length && accounts[0].hasOwnProperty("address") ? [accounts[0].address] : [];
          },
          eth_chainId: async () => {
            return currentChain && currentChain.id || "";
          },
          eth_signTransaction: async ({ params: [transactionObject] }) => {
            if (!accounts || !Array.isArray(accounts) || !accounts.length)
              throw new Error("No account selected. Must call eth_requestAccounts first.");
            let account;
            if (transactionObject.hasOwnProperty("from")) {
              account = accounts.find((account2) => account2.address === transactionObject.from);
            }
            account = account ? account : accounts[0];
            const { address: from, derivationPath } = account;
            transactionObject = __spreadProps(__spreadValues({}, transactionObject), { from });
            const CommonConstructor = Common.default || Common;
            const common = new CommonConstructor({
              chain: customNetwork || currentChain.hasOwnProperty("id") ? Number.parseInt(currentChain.id) : 1,
              hardfork: Hardfork.Berlin,
              eips: [1559]
            });
            transactionObject.gasLimit = transactionObject.gas || transactionObject.gasLimit;
            const transaction = Transaction.fromTxData(__spreadValues({}, transactionObject), { common });
            let unsignedTx = transaction.getMessageToSign(false);
            if (!transaction.supports(Capability.EIP1559FeeMarket)) {
              unsignedTx = ethUtil.rlp.encode(unsignedTx);
            }
            const { v, r, s } = await eth.signTransaction(derivationPath, unsignedTx.toString("hex"));
            const signedTx = Transaction.fromTxData(__spreadProps(__spreadValues({}, transactionObject), {
              v: `0x${v}`,
              r: `0x${r}`,
              s: `0x${s}`
            }), { common });
            return signedTx ? `0x${signedTx.serialize().toString("hex")}` : "";
          },
          eth_sendTransaction: async ({ baseRequest, params }) => {
            const signedTx = await provider.request({
              method: "eth_signTransaction",
              params
            });
            const transactionHash = await baseRequest({
              method: "eth_sendRawTransaction",
              params: [signedTx]
            });
            return transactionHash;
          },
          eth_sign: async ({ params: [address, message] }) => {
            if (!(accounts && accounts.length && accounts.length > 0))
              throw new Error("No account selected. Must call eth_requestAccounts first.");
            const account = accounts.find((account2) => account2.address === address) || accounts[0];
            return eth.signPersonalMessage(account.derivationPath, import_buffer.Buffer.from(message).toString("hex")).then((result) => {
              let v = (result["v"] - 27).toString(16);
              if (v.length < 2) {
                v = "0" + v;
              }
              return `0x${result["r"]}${result["s"]}${v}`;
            });
          },
          eth_signTypedData: async ({ params: [address, typedData] }) => {
            if (!(accounts && accounts.length && accounts.length > 0))
              throw new Error("No account selected. Must call eth_requestAccounts first.");
            const account = accounts.find((account2) => account2.address === address) || accounts[0];
            const domainHash = import_eth_sig_util.TypedDataUtils.hashStruct("EIP712Domain", typedData.domain, typedData.types, SignTypedDataVersion.V3).toString("hex");
            const messageHash = import_eth_sig_util.TypedDataUtils.hashStruct(typedData.primaryType, typedData.message, typedData.types, SignTypedDataVersion.V3).toString("hex");
            return eth.signEIP712HashedMessage(account.derivationPath, domainHash, messageHash).then((result) => {
              let v = (result["v"] - 27).toString(16);
              if (v.length < 2) {
                v = "0" + v;
              }
              return `0x${result["r"]}${result["s"]}${v}`;
            });
          },
          wallet_switchEthereumChain: async ({ params: [{ chainId }] }) => {
            currentChain = chains.find(({ id }) => id === chainId) || currentChain;
            if (!currentChain)
              throw new Error("chain must be set before switching");
            eventEmitter.emit("chainChanged", currentChain.id);
            return null;
          },
          wallet_addEthereumChain: null
        });
        provider.on = eventEmitter.on.bind(eventEmitter);
        return {
          provider
        };
      }
    };
  };
}
var dist_default = ledger;

// dep:@web3-onboard_ledger
var web3_onboard_ledger_default = dist_default;
export {
  web3_onboard_ledger_default as default
};
//# sourceMappingURL=@web3-onboard_ledger.js.map
