import {
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// dep:@web3-onboard_keepkey
init_define_process_env();

// node_modules/@web3-onboard/keepkey/dist/index.js
init_define_process_env();
var DEFAULT_PATH = `m/44'/60'/0'/0/0`;
var DEFAULT_BASE_PATHS = [
  {
    label: "Ethereum Mainnet",
    value: DEFAULT_PATH
  }
];
var assets = [
  {
    label: "ETH"
  }
];
var ERROR_BUSY = "busy";
var ERROR_PAIRING = "pairing";
var errorMessages = {
  [ERROR_BUSY]: `Your KeepKey is currently connected to another application.
  Please close any other browser tabs or applications that may be connected to your device and try again.`,
  [ERROR_PAIRING]: "There was an error pairing the device. Please disconnect and reconnect the device and try again."
};
function keepkey() {
  const getIcon = async () => (await import("./icon-RDI2MO2T.js")).default;
  return () => {
    let accounts;
    return {
      label: "KeepKey",
      getIcon,
      getInterface: async ({ EventEmitter, chains }) => {
        const { WebUSBKeepKeyAdapter } = await import("./dist-VFUFQXAS.js");
        const { Keyring, Events, bip32ToAddressNList, addressNListToBIP32, HDWalletErrorType } = await import("./dist-WAGEDMQY.js");
        const { accountSelect, createEIP1193Provider, ProviderRpcError, entryModal } = await import("./dist-3LUD4YRJ.js");
        const { StaticJsonRpcProvider } = await import("./lib-5NF7NHOH.js");
        const ethUtil = await import("./dist-JPBCCQ4F.js");
        const keyring = new Keyring();
        const keepKeyAdapter = WebUSBKeepKeyAdapter.useKeyring(keyring);
        const eventEmitter = new EventEmitter();
        let keepKeyWallet;
        let currentChain = chains[0];
        keyring.on(["*", "*", Events.DISCONNECT], async () => {
          eventEmitter.emit("accountsChanged", []);
        });
        keyring.on(["*", "*", Events.PIN_REQUEST], () => {
          entryModal("pin", (val) => keepKeyWallet.sendPin(val), () => keepKeyWallet.cancel());
        });
        keyring.on(["*", "*", Events.PASSPHRASE_REQUEST], () => {
          entryModal("passphrase", (val) => keepKeyWallet.sendPassphrase(val), () => keepKeyWallet.cancel());
        });
        const getAccountIdx = (derivationPath) => {
          const { accountIdx } = keepKeyWallet.describePath({
            path: bip32ToAddressNList(derivationPath),
            coin: "Ethereum"
          });
          if (accountIdx === void 0)
            throw new Error(`Could not derive account from path: ${derivationPath}`);
          return accountIdx;
        };
        const getPaths = (accountIdx) => {
          const [paths] = keepKeyWallet.ethGetAccountPaths({
            coin: "Ethereum",
            accountIdx
          });
          return paths;
        };
        const getAccount = async ({ accountIdx, provider: provider2, asset }) => {
          const paths = getPaths(accountIdx);
          const address = await keepKeyWallet.ethGetAddress({
            addressNList: paths.addressNList,
            showDisplay: false
          });
          const balance = await provider2.getBalance(address);
          return {
            derivationPath: addressNListToBIP32(paths.addressNList),
            address,
            balance: {
              asset: asset.label,
              value: balance
            }
          };
        };
        const getAllAccounts = async ({ derivationPath, asset, provider: provider2 }) => {
          let index = getAccountIdx(derivationPath);
          let zeroBalanceAccounts = 0;
          const accounts2 = [];
          while (zeroBalanceAccounts < 5) {
            const acc = await getAccount({
              accountIdx: index,
              provider: provider2,
              asset
            });
            if (acc && acc.balance && acc.balance.value && acc.balance.value.isZero()) {
              zeroBalanceAccounts++;
              accounts2.push(acc);
            } else {
              accounts2.push(acc);
              zeroBalanceAccounts = 0;
            }
            index++;
          }
          return accounts2;
        };
        const scanAccounts = async ({ derivationPath, chainId, asset }) => {
          if (!keepKeyWallet)
            throw new Error("Device must be connected before scanning accounts");
          currentChain = chains.find(({ id }) => id === chainId) || currentChain;
          const provider2 = new StaticJsonRpcProvider(currentChain.rpcUrl);
          if (!DEFAULT_BASE_PATHS.find(({ value }) => value === derivationPath)) {
            try {
              const accountIdx = getAccountIdx(derivationPath);
              const account = await getAccount({ accountIdx, provider: provider2, asset });
              return [account];
            } catch (error) {
              throw new Error("Invalid derivation path");
            }
          }
          return getAllAccounts({ derivationPath, asset, provider: provider2 });
        };
        const getAccounts = async () => {
          accounts = await accountSelect({
            basePaths: DEFAULT_BASE_PATHS,
            assets,
            chains,
            scanAccounts
          });
          if (!accounts)
            throw new Error("No accounts were found");
          if (accounts.length) {
            eventEmitter.emit("accountsChanged", [accounts[0].address]);
          }
          return accounts;
        };
        const request = async ({ method, params }) => {
          const response = await fetch(currentChain.rpcUrl, {
            method: "POST",
            body: JSON.stringify({
              id: "42",
              method,
              params
            })
          }).then((res) => res.json());
          if (response.result) {
            return response.result;
          } else {
            throw response.error;
          }
        };
        const keepKeyProvider = { request };
        const provider = createEIP1193Provider(keepKeyProvider, {
          eth_requestAccounts: async () => {
            if (keepKeyWallet && typeof keepKeyWallet.cancel === "function") {
              keepKeyWallet.cancel();
            }
            try {
              keepKeyWallet = await keepKeyAdapter.pairDevice();
            } catch (error) {
              const { name } = error;
              if (name === HDWalletErrorType.ConflictingApp) {
                throw new ProviderRpcError({
                  code: 4001,
                  message: errorMessages[ERROR_BUSY]
                });
              } else if (name === HDWalletErrorType.WebUSBCouldNotPair) {
                throw new ProviderRpcError({
                  code: 4001,
                  message: errorMessages[ERROR_PAIRING]
                });
              }
            }
            const accounts2 = await getAccounts();
            if (!accounts2 || !Array.isArray(accounts2)) {
              throw new Error("No accounts were returned from Keepkey device");
            }
            if (!accounts2.length) {
              throw new ProviderRpcError({
                code: 4001,
                message: "User rejected the request."
              });
            }
            if (!accounts2[0].hasOwnProperty("address")) {
              throw new Error("The account returned does not have a required address field");
            }
            return [accounts2[0].address];
          },
          eth_selectAccounts: async () => {
            const accounts2 = await getAccounts();
            return accounts2.map(({ address }) => address);
          },
          eth_accounts: async () => {
            if (!accounts || !Array.isArray(accounts)) {
              throw new Error("No accounts were returned from Keepkey device");
            }
            return accounts[0].hasOwnProperty("address") ? [accounts[0].address] : [];
          },
          eth_chainId: async () => {
            return currentChain && currentChain.id != void 0 ? currentChain.id : "0x0";
          },
          eth_signTransaction: async ({ params: [transactionObject] }) => {
            if (!accounts || !Array.isArray(accounts) || !accounts.length)
              throw new Error("No account selected. Must call eth_requestAccounts first.");
            const account = !transactionObject || !transactionObject.hasOwnProperty("from") ? accounts[0] : accounts.find((account2) => account2.address === transactionObject.from);
            const { derivationPath } = account || accounts[0];
            const addressNList = bip32ToAddressNList(derivationPath);
            const { nonce, gasPrice, gas, gasLimit, to, value, data, maxFeePerGas, maxPriorityFeePerGas } = transactionObject;
            const { serialized } = await keepKeyWallet.ethSignTx({
              addressNList,
              nonce: nonce || "0x0",
              gasPrice,
              gasLimit: gasLimit || gas || "0x5208",
              to,
              value: value || "0x0",
              data: data || "",
              maxFeePerGas,
              maxPriorityFeePerGas,
              chainId: parseInt(currentChain.id)
            });
            return serialized;
          },
          eth_sendTransaction: async ({ baseRequest, params }) => {
            const signedTx = await provider.request({
              method: "eth_signTransaction",
              params
            });
            const transactionHash = await baseRequest({
              method: "eth_sendRawTransaction",
              params: [signedTx]
            });
            return transactionHash;
          },
          eth_sign: async ({ params: [address, message] }) => {
            if (!accounts || !Array.isArray(accounts) || !(accounts.length && accounts.length > 0))
              throw new Error("No account selected. Must call eth_requestAccounts first.");
            const account = accounts.find((account2) => account2.address === address) || accounts[0];
            const { derivationPath } = account;
            const accountIdx = getAccountIdx(derivationPath);
            const { addressNList } = getPaths(accountIdx);
            const { signature } = await keepKeyWallet.ethSignMessage({
              addressNList,
              message: message.slice(0, 2) === "0x" ? (ethUtil.default || ethUtil).toBuffer(message).toString("utf8") : message
            });
            return signature;
          },
          eth_signTypedData: null,
          wallet_switchEthereumChain: async ({ params: [{ chainId }] }) => {
            currentChain = chains.find(({ id }) => id === chainId) || currentChain;
            if (!currentChain)
              throw new Error("chain must be set before switching");
            eventEmitter.emit("chainChanged", currentChain.id);
            return null;
          },
          wallet_addEthereumChain: null
        });
        provider.on = eventEmitter.on.bind(eventEmitter);
        return {
          provider,
          instance: {
            selectAccount: getAccounts
          }
        };
      }
    };
  };
}
var dist_default = keepkey;

// dep:@web3-onboard_keepkey
var web3_onboard_keepkey_default = dist_default;
export {
  web3_onboard_keepkey_default as default
};
//# sourceMappingURL=@web3-onboard_keepkey.js.map
