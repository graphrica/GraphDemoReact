import {
  ProviderRpcError,
  ProviderRpcErrorCode,
  accountSelect,
  createEIP1193Provider
} from "./chunk-QLIZTXI5.js";
import "./chunk-BRDLAWJG.js";
import "./chunk-AAFDKQNN.js";
import "./chunk-YSJ6UD5Q.js";
import "./chunk-WBSSQYQH.js";
import "./chunk-GZNO4Y3K.js";
import "./chunk-77TI47IA.js";
import "./chunk-DJCW4LVW.js";
import "./chunk-VFG3R5NB.js";
import "./chunk-QLJNFGTT.js";
import "./chunk-HEQAI6WE.js";
import "./chunk-QMSD3UEV.js";
import "./chunk-27CSTQIU.js";
import "./chunk-VIQ6GMKA.js";
import "./chunk-PX4IM7JA.js";
import {
  __spreadProps,
  __spreadValues,
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// dep:@web3-onboard_keystone
init_define_process_env();

// node_modules/@web3-onboard/keystone/dist/index.js
init_define_process_env();
var DEFAULT_BASE_PATH = "m/44'/60'/0'/0";
var basePaths = [
  {
    label: "Keystone",
    value: DEFAULT_BASE_PATH
  }
];
var assets = [
  {
    label: "ETH"
  }
];
var getAccount = async (keyring, provider, index) => {
  const address = (await keyring.addAccounts())[index];
  const derivationPath = await keyring._pathFromAddress(address);
  return {
    derivationPath,
    address,
    balance: {
      asset: "",
      value: await provider.getBalance(address)
    }
  };
};
var generateAccounts = async (keyring, provider) => {
  const accounts = [];
  let zeroBalanceAccounts = 0, index = 0;
  while (zeroBalanceAccounts < 5) {
    const account = await getAccount(keyring, provider, index);
    if (account.balance.value.isZero()) {
      zeroBalanceAccounts++;
      accounts.push(account);
    } else {
      accounts.push(account);
      zeroBalanceAccounts = 0;
    }
    index++;
  }
  return accounts;
};
function keystone({ customNetwork } = {}) {
  const getIcon = async () => (await import("./icon-CM7LIMG4.js")).default;
  return () => {
    let accounts;
    return {
      label: "Keystone",
      getIcon,
      getInterface: async ({ EventEmitter, chains }) => {
        const { StaticJsonRpcProvider } = await import("./lib-5NF7NHOH.js");
        const { default: Common, Hardfork } = await import("./dist-4XGLEIV5.js");
        const { default: AirGappedKeyring } = await import("./dist-HUMVDRJ2.js");
        const { TransactionFactory: Transaction } = await import("./dist-LOC4KPXA.js");
        const keyring = AirGappedKeyring.getEmptyKeyring();
        await keyring.readKeyring();
        const eventEmitter = new EventEmitter();
        let currentChain = chains[0];
        const scanAccounts = async ({ derivationPath, chainId, asset }) => {
          currentChain = chains.find(({ id }) => id === chainId) || currentChain;
          const provider2 = new StaticJsonRpcProvider(currentChain.rpcUrl);
          return generateAccounts(keyring, provider2);
        };
        const getAccounts = async () => {
          accounts = await accountSelect({
            basePaths,
            assets,
            chains,
            scanAccounts,
            supportsCustomPath: false
          });
          if (accounts.length) {
            eventEmitter.emit("accountsChanged", [accounts[0].address]);
          }
          return accounts;
        };
        const request = async ({ method, params }) => {
          const response = await fetch(currentChain.rpcUrl, {
            method: "POST",
            body: JSON.stringify({
              id: "42",
              method,
              params
            })
          }).then((res) => res.json());
          if (response.result) {
            return response.result;
          } else {
            throw response.error;
          }
        };
        const keystoneProvider = { request };
        const provider = createEIP1193Provider(keystoneProvider, {
          eth_requestAccounts: async () => {
            const accounts2 = await getAccounts();
            if (accounts2.length === 0) {
              throw new ProviderRpcError({
                code: ProviderRpcErrorCode.ACCOUNT_ACCESS_REJECTED,
                message: "User rejected the request."
              });
            }
            return accounts2[0] ? [accounts2[0].address] : [];
          },
          eth_selectAccounts: async () => {
            const accounts2 = await getAccounts();
            return accounts2.map(({ address }) => address);
          },
          eth_accounts: async () => {
            return accounts && accounts[0].address ? [accounts[0].address] : [];
          },
          eth_chainId: async () => {
            return currentChain.id;
          },
          eth_signTransaction: async ({ params: [transactionObject] }) => {
            if (!accounts)
              throw new Error("No account selected. Must call eth_requestAccounts first.");
            if (!transactionObject)
              throw new ProviderRpcError({
                message: "Invalid method parameters",
                code: ProviderRpcErrorCode.INVALID_PARAMS,
                data: transactionObject
              });
            const account = accounts.find((account2) => account2.address === transactionObject.from) || accounts[0];
            const { address: from } = account;
            transactionObject = __spreadProps(__spreadValues({}, transactionObject), { from });
            const CommonConstructor = Common.default || Common;
            const common = new Common({
              chain: customNetwork || Number.parseInt(currentChain.id) || 1,
              hardfork: Hardfork.Berlin,
              eips: [1559]
            });
            transactionObject.gasLimit = transactionObject.gas || transactionObject.gasLimit;
            const transaction = Transaction.fromTxData(__spreadValues({}, transactionObject), { common, freeze: false });
            const signedTx = await keyring.signTransaction(from, transaction);
            return `0x${signedTx.serialize().toString("hex")}`;
          },
          eth_sendTransaction: async ({ baseRequest, params }) => {
            const signedTx = await provider.request({
              method: "eth_signTransaction",
              params
            });
            const transactionHash = await baseRequest({
              method: "eth_sendRawTransaction",
              params: [signedTx]
            });
            return transactionHash;
          },
          eth_sign: async ({ params: [address, message] }) => {
            if (!(accounts && accounts.length && accounts.length > 0))
              throw new Error("No account selected. Must call eth_requestAccounts first.");
            const account = accounts.find((account2) => account2.address === address) || accounts[0];
            return keyring.signMessage(account.address, message);
          },
          eth_signTypedData: async ({ params: [address, typedData] }) => {
            if (!(accounts && accounts.length && accounts.length > 0))
              throw new Error("No account selected. Must call eth_requestAccounts first.");
            const account = accounts.find((account2) => account2.address === address) || accounts[0];
            return keyring.signTypedData(account.address, typedData);
          },
          wallet_switchEthereumChain: async ({ params: [{ chainId }] }) => {
            currentChain = chains.find(({ id }) => id === chainId) || currentChain;
            if (!currentChain)
              throw new Error("chain must be set before switching");
            eventEmitter.emit("chainChanged", currentChain.id);
            return null;
          },
          wallet_addEthereumChain: null
        });
        provider.on = eventEmitter.on.bind(eventEmitter);
        return {
          provider
        };
      }
    };
  };
}
var dist_default = keystone;

// dep:@web3-onboard_keystone
var web3_onboard_keystone_default = dist_default;
export {
  web3_onboard_keystone_default as default
};
//# sourceMappingURL=@web3-onboard_keystone.js.map
