import {
  HDNode,
  decryptJsonWallet,
  decryptJsonWalletSync,
  defaultPath,
  encrypt,
  entropyToMnemonic,
  init_lib2 as init_lib15,
  init_lib3 as init_lib17,
  require_aes_js
} from "./chunk-YSJ6UD5Q.js";
import {
  Indexed,
  Interface,
  checkResultErrors,
  init_lib as init_lib9
} from "./chunk-WBSSQYQH.js";
import {
  Provider,
  Signer,
  VoidSigner,
  init_lib as init_lib10,
  init_lib2 as init_lib11,
  init_lib4 as init_lib14,
  init_lib5 as init_lib16,
  randomBytes,
  sha256
} from "./chunk-GZNO4Y3K.js";
import {
  require_bech32
} from "./chunk-77TI47IA.js";
import {
  require_scrypt
} from "./chunk-DJCW4LVW.js";
import {
  SigningKey,
  accessListify,
  computeAddress,
  init_lib as init_lib12,
  init_lib2 as init_lib13,
  recoverAddress,
  serialize
} from "./chunk-VFG3R5NB.js";
import {
  BigNumber,
  Logger,
  TypedDataEncoder,
  arrayify,
  concat,
  deepCopy,
  defineReadOnly,
  formatFixed,
  getAddress,
  getContractAddress,
  getStatic,
  hashMessage,
  hexDataSlice,
  hexlify,
  init_lib,
  init_lib10 as init_lib8,
  init_lib2,
  init_lib3,
  init_lib4,
  init_lib5,
  init_lib7 as init_lib6,
  init_lib9 as init_lib7,
  isBytes,
  isHexString,
  joinSignature,
  keccak256,
  parseFixed,
  resolveProperties,
  shallowCopy,
  toUtf8Bytes,
  zeroPad
} from "./chunk-QLJNFGTT.js";
import {
  require_sha3
} from "./chunk-HEQAI6WE.js";
import {
  require_hash
} from "./chunk-QMSD3UEV.js";
import {
  require_bn
} from "./chunk-VIQ6GMKA.js";
import {
  __export,
  __toESM,
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// node_modules/@ethersproject/contracts/lib.esm/index.js
init_define_process_env();
init_lib9();
init_lib10();
init_lib11();
init_lib6();
init_lib3();
init_lib2();
init_lib4();
init_lib13();
init_lib();

// node_modules/@ethersproject/contracts/lib.esm/_version.js
init_define_process_env();
var version = "contracts/5.5.0";

// node_modules/@ethersproject/contracts/lib.esm/index.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger = new Logger(version);
var allowedTransactionKeys = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true
};
function resolveName(resolver, nameOrPromise) {
  return __awaiter(this, void 0, void 0, function* () {
    const name2 = yield nameOrPromise;
    if (typeof name2 !== "string") {
      logger.throwArgumentError("invalid address or ENS name", "name", name2);
    }
    try {
      return getAddress(name2);
    } catch (error) {
    }
    if (!resolver) {
      logger.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name2);
    if (address == null) {
      logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes = arrayify(data);
      for (let i = 0; i < bytes.length; i++) {
        intrinsic += 4;
        if (bytes[i]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    const leftovers = Object.keys(overrides).filter((key6) => overrides[key6] != null);
    if (leftovers.length) {
      logger.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }
  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
var RunningEvent = class {
  constructor(tag, filter) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter);
    this._listeners = [];
  }
  addListener(listener, once) {
    this._listeners.push({ listener, once });
  }
  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter((item) => {
      if (done || item.listener !== listener) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i) => i.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {
  }
  getEmit(event) {
    return [event];
  }
};
var ErrorRunningEvent = class extends RunningEvent {
  constructor() {
    super("error", null);
  }
};
var FragmentRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter.topics = topics.slice();
    } else {
      filter.topics = [topic];
    }
    super(getEventTag(filter), filter);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data, topics) => {
      return this.interface.decodeEventLog(this.fragment, data, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors = checkResultErrors(event.args);
    if (errors.length) {
      throw errors[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
};
var WildcardRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
};
var BaseContract = class {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    logger.checkNew(new.target, Contract);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name2) => {
        const filters = uniqueFilters[name2];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name2, this.filters[filters[0]]);
        } else {
          logger.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
      } catch (error) {
        logger.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature6) => {
      const fragment = this.interface.functions[signature6];
      if (uniqueSignatures[signature6]) {
        logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature6)}`);
        return;
      }
      uniqueSignatures[signature6] = true;
      {
        const name2 = fragment.name;
        if (!uniqueNames[`%${name2}`]) {
          uniqueNames[`%${name2}`] = [];
        }
        uniqueNames[`%${name2}`].push(signature6);
      }
      if (this[signature6] == null) {
        defineReadOnly(this, signature6, buildDefault(this, fragment, true));
      }
      if (this.functions[signature6] == null) {
        defineReadOnly(this.functions, signature6, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature6] == null) {
        defineReadOnly(this.callStatic, signature6, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature6] == null) {
        defineReadOnly(this.populateTransaction, signature6, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature6] == null) {
        defineReadOnly(this.estimateGas, signature6, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name2) => {
      const signatures = uniqueNames[name2];
      if (signatures.length > 1) {
        return;
      }
      name2 = name2.substring(1);
      const signature6 = signatures[0];
      try {
        if (this[name2] == null) {
          defineReadOnly(this, name2, this[signature6]);
        }
      } catch (e) {
      }
      if (this.functions[name2] == null) {
        defineReadOnly(this.functions, name2, this.functions[signature6]);
      }
      if (this.callStatic[name2] == null) {
        defineReadOnly(this.callStatic, name2, this.callStatic[signature6]);
      }
      if (this.populateTransaction[name2] == null) {
        defineReadOnly(this.populateTransaction, name2, this.populateTransaction[signature6]);
      }
      if (this.estimateGas[name2] == null) {
        defineReadOnly(this.estimateGas, name2, this.estimateGas[signature6]);
      }
    });
  }
  static getContractAddress(transaction) {
    return getContractAddress(transaction);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
          if (code === "0x") {
            logger.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  fallback(overrides) {
    if (!this.signer) {
      logger.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy(overrides || {});
    ["from", "to"].forEach(function(key6) {
      if (tx[key6] == null) {
        return;
      }
      logger.throwError("cannot override " + key6, Logger.errors.UNSUPPORTED_OPERATION, { operation: key6 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  _wrapEvent(runningEvent, log, listener) {
    const event = deepCopy(log);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once) {
    if (!this.provider) {
      logger.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log) => {
        let event = this._wrapEvent(runningEvent, log, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter = shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter.blockHash = fromBlockOrBlockhash;
    } else {
      filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter).then((logs) => {
      return logs.map((log) => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key6) => {
        return accum + this._runningEvents[key6].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
};
var Contract = class extends BaseContract {
};
var ContractFactory = class {
  constructor(contractInterface, bytecode, signer) {
    let bytecodeHex = null;
    if (typeof bytecode === "string") {
      bytecodeHex = bytecode;
    } else if (isBytes(bytecode)) {
      bytecodeHex = hexlify(bytecode);
    } else if (bytecode && typeof bytecode.object === "string") {
      bytecodeHex = bytecode.object;
    } else {
      bytecodeHex = "!";
    }
    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    }
    if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
      logger.throwArgumentError("invalid bytecode", "bytecode", bytecode);
    }
    if (signer && !Signer.isSigner(signer)) {
      logger.throwArgumentError("invalid signer", "signer", signer);
    }
    defineReadOnly(this, "bytecode", bytecodeHex);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    defineReadOnly(this, "signer", signer || null);
  }
  getDeployTransaction(...args) {
    let tx = {};
    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = shallowCopy(args.pop());
      for (const key6 in tx) {
        if (!allowedTransactionKeys[key6]) {
          throw new Error("unknown transaction override " + key6);
        }
      }
    }
    ["data", "from", "to"].forEach((key6) => {
      if (tx[key6] == null) {
        return;
      }
      logger.throwError("cannot override " + key6, Logger.errors.UNSUPPORTED_OPERATION, { operation: key6 });
    });
    if (tx.value) {
      const value = BigNumber.from(tx.value);
      if (!value.isZero() && !this.interface.deploy.payable) {
        logger.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    }
    logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
    tx.data = hexlify(concat([
      this.bytecode,
      this.interface.encodeDeploy(args)
    ]));
    return tx;
  }
  deploy(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      }
      logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides);
      const unsignedTx = this.getDeployTransaction(...params);
      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address = getStatic(this.constructor, "getContractAddress")(tx);
      const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
      addContractWait(contract, tx);
      defineReadOnly(contract, "deployTransaction", tx);
      return contract;
    });
  }
  attach(address) {
    return this.constructor.getContract(address, this.interface, this.signer);
  }
  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }
  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
    }
    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }
    const abi = compilerOutput.abi;
    let bytecode = null;
    if (compilerOutput.bytecode) {
      bytecode = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode = compilerOutput.evm.bytecode;
    }
    return new this(abi, bytecode, signer);
  }
  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }
  static getContractAddress(tx) {
    return getContractAddress(tx);
  }
  static getContract(address, contractInterface, signer) {
    return new Contract(address, contractInterface, signer);
  }
};

// node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn = __toESM(require_bn());

// node_modules/ethers/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version2 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger2 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger2.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger2.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger2.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger2.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX[value[i] >> 4];
            hex += HEX[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger2.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger2.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger2.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger2.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger2(version2);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger2.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version134) {
    return new Logger2(version134);
  }
};
Logger2.errors = ErrorCode;
Logger2.levels = LogLevel;

// node_modules/ethers/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version3 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger2 = new Logger2(version3);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes2(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify2(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger2.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString2(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger2.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes2(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger2.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString2(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters = "0123456789abcdef";
function hexlify2(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger2.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString2(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger2.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes2(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  return logger2.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify2(value);
  } else if (!isHexString2(value)) {
    logger2.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger2.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version4 = "bignumber/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN = import_bn.default.BN;
var logger3 = new Logger2(version4);
var _constructorGuard = {};
var MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber2.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString2(value) || typeof value === "bigint" || isBytes2(value));
}
var _warnedToStringRadix = false;
var BigNumber2 = class {
  constructor(constructorGuard, hex) {
    logger3.checkNew(new.target, BigNumber2);
    if (constructorGuard !== _constructorGuard) {
      logger3.throwError("cannot call constructor directly; use BigNumber.from", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber2.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o = BigNumber2.from(other);
    if (o.isZero()) {
      throwFault("division by zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("cannot modulo negative values", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("cannot raise to negative values", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'and' negative values", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'or' negative values", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'xor' negative values", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot mask negative values", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot shift negative values", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot shift negative values", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger3.throwError("this platform does not support BigInt", Logger2.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger3.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger3.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger2.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger3.throwError("BigNumber.toString does not accept parameters", Logger2.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber2) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber2(_constructorGuard, toHex(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber2(_constructorGuard, toHex(new BN(value)));
      }
      return logger3.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return BigNumber2.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber2.from(anyValue.toString());
    }
    if (isBytes2(anyValue)) {
      return BigNumber2.from(hexlify2(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber2.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString2(hex) || hex[0] === "-" && isHexString2(hex.substring(1))) {
            return BigNumber2.from(hex);
          }
        }
      }
    }
    return logger3.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger3.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber2.from(toHex(value));
}
function toBN(value) {
  const hex = BigNumber2.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger3.throwError(fault, Logger2.errors.NUMERIC_FAULT, params);
}

// node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger4 = new Logger2(version4);
var _constructorGuard2 = {};
var Zero = BigNumber2.from(0);
var NegativeOne = BigNumber2.from(-1);
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger4.throwError(message, Logger2.errors.NUMERIC_FAULT, params);
}
var zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber2.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger4.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed2(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber2.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed2(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger4.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger4.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger4.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber2.from(whole);
  const fractionValue = BigNumber2.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var FixedFormat = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard2) {
      logger4.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger4.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger4.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger4.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger4.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard2, signed, width, decimals);
  }
};
var FixedNumber = class {
  constructor(constructorGuard, hex, value, format) {
    logger4.checkNew(new.target, FixedNumber);
    if (constructorGuard !== _constructorGuard2) {
      logger4.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger4.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed2(this._value, this.format.decimals);
    const b = parseFixed2(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed2(this._value, this.format.decimals);
    const b = parseFixed2(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed2(this._value, this.format.decimals);
    const b = parseFixed2(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed2(this._value, this.format.decimals);
    const b = parseFixed2(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger4.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger4.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber2.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber.fromString(formatFixed2(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed2(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero)) {
      throwFault2("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed2(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify2(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber2.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed2(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }
    if (isBytes2(value)) {
      return FixedNumber.fromBytes(value, format);
    }
    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger2.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger4.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE = FixedNumber.from(1);
var BUMP = FixedNumber.from("0.5");

// node_modules/ethers/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version5 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors2 = false;
var _censorErrors2 = false;
var LogLevels2 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel2 = LogLevels2["default"];
var _globalLogger2 = null;
function _checkNormalize2() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError2 = _checkNormalize2();
var LogLevel2;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel2 || (LogLevel2 = {}));
var ErrorCode2;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode2 || (ErrorCode2 = {}));
var HEX2 = "0123456789abcdef";
var Logger3 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels2[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel2 > LogLevels2[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger3.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger3.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger3.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors2) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger3.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX2[value[i] >> 4];
            hex += HEX2[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode2.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode2.CALL_EXCEPTION:
      case ErrorCode2.INSUFFICIENT_FUNDS:
      case ErrorCode2.MISSING_NEW:
      case ErrorCode2.NONCE_EXPIRED:
      case ErrorCode2.REPLACEMENT_UNDERPRICED:
      case ErrorCode2.TRANSACTION_REPLACED:
      case ErrorCode2.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger3.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError2) {
      this.throwError("platform missing String.prototype.normalize", Logger3.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError2
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger3.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger3.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger3.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger3.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger3.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger3.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger3.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger2) {
      _globalLogger2 = new Logger3(version5);
    }
    return _globalLogger2;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger3.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors2) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger3.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors2 = !!censorship;
    _permanentCensorErrors2 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels2[logLevel.toLowerCase()];
    if (level == null) {
      Logger3.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel2 = level;
  }
  static from(version134) {
    return new Logger3(version134);
  }
};
Logger3.errors = ErrorCode2;
Logger3.levels = LogLevel2;

// node_modules/ethers/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version6 = "properties/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/properties/lib.esm/index.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger5 = new Logger3(version6);
function defineReadOnly2(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function resolveProperties2(object) {
  return __awaiter2(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key6) => {
      const value = object[key6];
      return Promise.resolve(value).then((v) => ({ key: key6, value: v }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function shallowCopy2(object) {
  const result = {};
  for (const key6 in object) {
    result[key6] = object[key6];
  }
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
init_define_process_env();
var version7 = "abstract-signer/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib.esm/index.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger6 = new Logger3(version7);
var allowedTransactionKeys2 = [
  "accessList",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
var forwardErrors = [
  Logger3.errors.INSUFFICIENT_FUNDS,
  Logger3.errors.NONCE_EXPIRED,
  Logger3.errors.REPLACEMENT_UNDERPRICED
];
var Signer2 = class {
  constructor() {
    logger6.checkAbstract(new.target, Signer2);
    defineReadOnly2(this, "_isSigner", true);
  }
  getBalance(blockTag) {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  estimateGas(transaction) {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties2(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  call(transaction, blockTag) {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties2(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  sendTransaction(transaction) {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  checkTransaction(transaction) {
    for (const key6 in transaction) {
      if (allowedTransactionKeys2.indexOf(key6) === -1) {
        logger6.throwArgumentError("invalid transaction key: " + key6, "transaction", transaction);
      }
    }
    const tx = shallowCopy2(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger6.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  populateTransaction(transaction) {
    return __awaiter3(this, void 0, void 0, function* () {
      const tx = yield resolveProperties2(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter3(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger6.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger6.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger6.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger6.throwError("network does not support EIP-1559", Logger3.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger6.throwError("failed to get consistent fee data", Logger3.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger6.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger3.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger6.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties2(tx);
    });
  }
  _checkProvider(operation) {
    if (!this.provider) {
      logger6.throwError("missing provider", Logger3.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
};
var VoidSigner2 = class extends Signer2 {
  constructor(address, provider) {
    logger6.checkNew(new.target, VoidSigner2);
    super();
    defineReadOnly2(this, "address", address);
    defineReadOnly2(this, "provider", provider || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger6.throwError(message, Logger3.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain, types, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider) {
    return new VoidSigner2(this.address, provider);
  }
};

// node_modules/@ethersproject/wallet/lib.esm/index.js
init_define_process_env();
init_lib6();
init_lib10();
init_lib11();
init_lib2();
init_lib8();
init_lib15();
init_lib5();
init_lib4();
init_lib16();
init_lib12();
init_lib17();
init_lib13();
init_lib();

// node_modules/@ethersproject/wallet/lib.esm/_version.js
init_define_process_env();
var version8 = "wallet/5.5.0";

// node_modules/@ethersproject/wallet/lib.esm/index.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger7 = new Logger(version8);
function isAccount(value) {
  return value != null && isHexString(value.privateKey, 32) && value.address != null;
}
function hasMnemonic(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
var Wallet = class extends Signer {
  constructor(privateKey, provider) {
    logger7.checkNew(new.target, Wallet);
    super();
    if (isAccount(privateKey)) {
      const signingKey = new SigningKey(privateKey.privateKey);
      defineReadOnly(this, "_signingKey", () => signingKey);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
      if (this.address !== getAddress(privateKey.address)) {
        logger7.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
      }
      if (hasMnemonic(privateKey)) {
        const srcMnemonic = privateKey.mnemonic;
        defineReadOnly(this, "_mnemonic", () => ({
          phrase: srcMnemonic.phrase,
          path: srcMnemonic.path || defaultPath,
          locale: srcMnemonic.locale || "en"
        }));
        const mnemonic = this.mnemonic;
        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
        if (computeAddress(node.privateKey) !== this.address) {
          logger7.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
        }
      } else {
        defineReadOnly(this, "_mnemonic", () => null);
      }
    } else {
      if (SigningKey.isSigningKey(privateKey)) {
        if (privateKey.curve !== "secp256k1") {
          logger7.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
        }
        defineReadOnly(this, "_signingKey", () => privateKey);
      } else {
        if (typeof privateKey === "string") {
          if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
            privateKey = "0x" + privateKey;
          }
        }
        const signingKey = new SigningKey(privateKey);
        defineReadOnly(this, "_signingKey", () => signingKey);
      }
      defineReadOnly(this, "_mnemonic", () => null);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
    }
    if (provider && !Provider.isProvider(provider)) {
      logger7.throwArgumentError("invalid provider", "provider", provider);
    }
    defineReadOnly(this, "provider", provider || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(provider) {
    return new Wallet(this, provider);
  }
  signTransaction(transaction) {
    return resolveProperties(transaction).then((tx) => {
      if (tx.from != null) {
        if (getAddress(tx.from) !== this.address) {
          logger7.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
        }
        delete tx.from;
      }
      const signature6 = this._signingKey().signDigest(keccak256(serialize(tx)));
      return serialize(tx, signature6);
    });
  }
  signMessage(message) {
    return __awaiter4(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage(message)));
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter4(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name2) => {
        if (this.provider == null) {
          logger7.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName",
            value: name2
          });
        }
        return this.provider.resolveName(name2);
      });
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
    });
  }
  encrypt(password, options, progressCallback) {
    if (typeof options === "function" && !progressCallback) {
      progressCallback = options;
      options = {};
    }
    if (progressCallback && typeof progressCallback !== "function") {
      throw new Error("invalid callback");
    }
    if (!options) {
      options = {};
    }
    return encrypt(this, password, options, progressCallback);
  }
  static createRandom(options) {
    let entropy = randomBytes(16);
    if (!options) {
      options = {};
    }
    if (options.extraEntropy) {
      entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));
    }
    const mnemonic = entropyToMnemonic(entropy, options.locale);
    return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
  }
  static fromEncryptedJson(json, password, progressCallback) {
    return decryptJsonWallet(json, password, progressCallback).then((account) => {
      return new Wallet(account);
    });
  }
  static fromEncryptedJsonSync(json, password) {
    return new Wallet(decryptJsonWalletSync(json, password));
  }
  static fromMnemonic(mnemonic, path, wordlist4) {
    if (!path) {
      path = defaultPath;
    }
    return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist4).derivePath(path));
  }
};
function verifyMessage(message, signature6) {
  return recoverAddress(hashMessage(message), signature6);
}
function verifyTypedData(domain, types, value, signature6) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature6);
}

// node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  AddressZero: () => AddressZero,
  EtherSymbol: () => EtherSymbol,
  HashZero: () => HashZero,
  MaxInt256: () => MaxInt256,
  MaxUint256: () => MaxUint256,
  MinInt256: () => MinInt256,
  NegativeOne: () => NegativeOne3,
  One: () => One,
  Two: () => Two,
  WeiPerEther: () => WeiPerEther,
  Zero: () => Zero3
});
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();
var AddressZero = "0x0000000000000000000000000000000000000000";

// node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn2 = __toESM(require_bn());

// node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version9 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors3 = false;
var _censorErrors3 = false;
var LogLevels3 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel3 = LogLevels3["default"];
var _globalLogger3 = null;
function _checkNormalize3() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError3 = _checkNormalize3();
var LogLevel3;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel3 || (LogLevel3 = {}));
var ErrorCode3;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode3 || (ErrorCode3 = {}));
var HEX3 = "0123456789abcdef";
var Logger4 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels3[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel3 > LogLevels3[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger4.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger4.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger4.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors3) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger4.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX3[value[i] >> 4];
            hex += HEX3[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode3.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode3.CALL_EXCEPTION:
      case ErrorCode3.INSUFFICIENT_FUNDS:
      case ErrorCode3.MISSING_NEW:
      case ErrorCode3.NONCE_EXPIRED:
      case ErrorCode3.REPLACEMENT_UNDERPRICED:
      case ErrorCode3.TRANSACTION_REPLACED:
      case ErrorCode3.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger4.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError3) {
      this.throwError("platform missing String.prototype.normalize", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError3
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger4.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger4.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger4.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger4.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger4.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger4.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger4.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger3) {
      _globalLogger3 = new Logger4(version9);
    }
    return _globalLogger3;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors3) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors3 = !!censorship;
    _permanentCensorErrors3 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels3[logLevel.toLowerCase()];
    if (level == null) {
      Logger4.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel3 = level;
  }
  static from(version134) {
    return new Logger4(version134);
  }
};
Logger4.errors = ErrorCode3;
Logger4.levels = LogLevel3;

// node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version10 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger8 = new Logger4(version10);
function isHexable2(value) {
  return !!value.toHexString;
}
function addSlice2(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice2(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger2(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes3(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger2(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger2(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify3(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger8.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice2(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable2(value)) {
    value = value.toHexString();
  }
  if (isHexString3(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger8.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice2(new Uint8Array(result));
  }
  if (isBytes3(value)) {
    return addSlice2(new Uint8Array(value));
  }
  return logger8.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString3(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters2 = "0123456789abcdef";
function hexlify3(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger8.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters2[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable2(value)) {
    return value.toHexString();
  }
  if (isHexString3(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger8.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes3(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters2[(v & 240) >> 4] + HexCharacters2[v & 15];
    }
    return result;
  }
  return logger8.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad2(value, length) {
  if (typeof value !== "string") {
    value = hexlify3(value);
  } else if (!isHexString3(value)) {
    logger8.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger8.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version11 = "bignumber/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN2 = import_bn2.default.BN;
var logger9 = new Logger4(version11);
var _constructorGuard3 = {};
var MAX_SAFE2 = 9007199254740991;
function isBigNumberish2(value) {
  return value != null && (BigNumber3.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString3(value) || typeof value === "bigint" || isBytes3(value));
}
var _warnedToStringRadix2 = false;
var BigNumber3 = class {
  constructor(constructorGuard, hex) {
    logger9.checkNew(new.target, BigNumber3);
    if (constructorGuard !== _constructorGuard3) {
      logger9.throwError("cannot call constructor directly; use BigNumber.from", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber2(toBN2(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber2(toBN2(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber3.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber2(toBN2(this).add(toBN2(other)));
  }
  sub(other) {
    return toBigNumber2(toBN2(this).sub(toBN2(other)));
  }
  div(other) {
    const o = BigNumber3.from(other);
    if (o.isZero()) {
      throwFault3("division-by-zero", "div");
    }
    return toBigNumber2(toBN2(this).div(toBN2(other)));
  }
  mul(other) {
    return toBigNumber2(toBN2(this).mul(toBN2(other)));
  }
  mod(other) {
    const value = toBN2(other);
    if (value.isNeg()) {
      throwFault3("division-by-zero", "mod");
    }
    return toBigNumber2(toBN2(this).umod(value));
  }
  pow(other) {
    const value = toBN2(other);
    if (value.isNeg()) {
      throwFault3("negative-power", "pow");
    }
    return toBigNumber2(toBN2(this).pow(value));
  }
  and(other) {
    const value = toBN2(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault3("unbound-bitwise-result", "and");
    }
    return toBigNumber2(toBN2(this).and(value));
  }
  or(other) {
    const value = toBN2(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault3("unbound-bitwise-result", "or");
    }
    return toBigNumber2(toBN2(this).or(value));
  }
  xor(other) {
    const value = toBN2(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault3("unbound-bitwise-result", "xor");
    }
    return toBigNumber2(toBN2(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault3("negative-width", "mask");
    }
    return toBigNumber2(toBN2(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault3("negative-width", "shl");
    }
    return toBigNumber2(toBN2(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault3("negative-width", "shr");
    }
    return toBigNumber2(toBN2(this).shrn(value));
  }
  eq(other) {
    return toBN2(this).eq(toBN2(other));
  }
  lt(other) {
    return toBN2(this).lt(toBN2(other));
  }
  lte(other) {
    return toBN2(this).lte(toBN2(other));
  }
  gt(other) {
    return toBN2(this).gt(toBN2(other));
  }
  gte(other) {
    return toBN2(this).gte(toBN2(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN2(this).isZero();
  }
  toNumber() {
    try {
      return toBN2(this).toNumber();
    } catch (error) {
      throwFault3("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger9.throwError("this platform does not support BigInt", Logger4.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix2) {
          _warnedToStringRadix2 = true;
          logger9.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger9.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger4.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger9.throwError("BigNumber.toString does not accept parameters", Logger4.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN2(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber3) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber3(_constructorGuard3, toHex2(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber3(_constructorGuard3, toHex2(new BN2(value)));
      }
      return logger9.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault3("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE2 || value <= -MAX_SAFE2) {
        throwFault3("overflow", "BigNumber.from", value);
      }
      return BigNumber3.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber3.from(anyValue.toString());
    }
    if (isBytes3(anyValue)) {
      return BigNumber3.from(hexlify3(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber3.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString3(hex) || hex[0] === "-" && isHexString3(hex.substring(1))) {
            return BigNumber3.from(hex);
          }
        }
      }
    }
    return logger9.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex2(value) {
  if (typeof value !== "string") {
    return toHex2(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger9.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex2(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber2(value) {
  return BigNumber3.from(toHex2(value));
}
function toBN2(value) {
  const hex = BigNumber3.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN2("-" + hex.substring(3), 16);
  }
  return new BN2(hex.substring(2), 16);
}
function throwFault3(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger9.throwError(fault, Logger4.errors.NUMERIC_FAULT, params);
}

// node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger10 = new Logger4(version11);
var _constructorGuard4 = {};
var Zero2 = BigNumber3.from(0);
var NegativeOne2 = BigNumber3.from(-1);
function throwFault4(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger10.throwError(message, Logger4.errors.NUMERIC_FAULT, params);
}
var zeros2 = "0";
while (zeros2.length < 256) {
  zeros2 += zeros2;
}
function getMultiplier2(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber3.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros2.substring(0, decimals);
  }
  return logger10.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed3(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier2(decimals);
  value = BigNumber3.from(value);
  const negative = value.lt(Zero2);
  if (negative) {
    value = value.mul(NegativeOne2);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed3(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier2(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger10.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger10.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger10.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault4("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber3.from(whole);
  const fractionValue = BigNumber3.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne2);
  }
  return wei;
}
var FixedFormat2 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard4) {
      logger10.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier2(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat2) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger10.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger10.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger10.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger10.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat2(_constructorGuard4, signed, width, decimals);
  }
};
var FixedNumber2 = class {
  constructor(constructorGuard, hex, value, format) {
    logger10.checkNew(new.target, FixedNumber2);
    if (constructorGuard !== _constructorGuard4) {
      logger10.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger10.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed3(this._value, this.format.decimals);
    const b = parseFixed3(other._value, other.format.decimals);
    return FixedNumber2.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed3(this._value, this.format.decimals);
    const b = parseFixed3(other._value, other.format.decimals);
    return FixedNumber2.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed3(this._value, this.format.decimals);
    const b = parseFixed3(other._value, other.format.decimals);
    return FixedNumber2.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed3(this._value, this.format.decimals);
    const b = parseFixed3(other._value, other.format.decimals);
    return FixedNumber2.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber2.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE2.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber2.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE2.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger10.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber2.from("1" + zeros2.substring(0, decimals), this.format);
    const bump = BUMP2.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger10.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber3.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad2(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber2.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish2(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber2.fromString(formatFixed3(value, decimals), FixedFormat2.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat2.from(format);
    const numeric = parseFixed3(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero2)) {
      throwFault4("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad2(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed3(numeric, fixedFormat.decimals);
    return new FixedNumber2(_constructorGuard4, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat2.from(format);
    if (arrayify3(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber3.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed3(numeric, fixedFormat.decimals);
    return new FixedNumber2(_constructorGuard4, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber2.fromString(value, format);
    }
    if (isBytes3(value)) {
      return FixedNumber2.fromBytes(value, format);
    }
    try {
      return FixedNumber2.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger4.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger10.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE2 = FixedNumber2.from(1);
var BUMP2 = FixedNumber2.from("0.5");

// node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne3 = BigNumber3.from(-1);
var Zero3 = BigNumber3.from(0);
var One = BigNumber3.from(1);
var Two = BigNumber3.from(2);
var WeiPerEther = BigNumber3.from("1000000000000000000");
var MaxUint256 = BigNumber3.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigNumber3.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt256 = BigNumber3.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();
var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

// node_modules/ethers/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();
var EtherSymbol = "\u039E";

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  AlchemyProvider: () => AlchemyProvider,
  AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
  BaseProvider: () => BaseProvider,
  CloudflareProvider: () => CloudflareProvider,
  EtherscanProvider: () => EtherscanProvider,
  FallbackProvider: () => FallbackProvider,
  Formatter: () => Formatter,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  IpcProvider: () => IpcProvider,
  JsonRpcBatchProvider: () => JsonRpcBatchProvider,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcSigner: () => JsonRpcSigner,
  NodesmithProvider: () => NodesmithProvider,
  PocketProvider: () => PocketProvider,
  Provider: () => Provider2,
  Resolver: () => Resolver,
  StaticJsonRpcProvider: () => StaticJsonRpcProvider,
  UrlJsonRpcProvider: () => UrlJsonRpcProvider,
  Web3Provider: () => Web3Provider,
  WebSocketProvider: () => WebSocketProvider,
  getDefaultProvider: () => getDefaultProvider,
  getNetwork: () => getNetwork,
  isCommunityResourcable: () => isCommunityResourcable,
  isCommunityResource: () => isCommunityResource,
  showThrottleMessage: () => showThrottleMessage
});
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-provider/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn3 = __toESM(require_bn());

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version12 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors4 = false;
var _censorErrors4 = false;
var LogLevels4 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel4 = LogLevels4["default"];
var _globalLogger4 = null;
function _checkNormalize4() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError4 = _checkNormalize4();
var LogLevel4;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel4 || (LogLevel4 = {}));
var ErrorCode4;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode4 || (ErrorCode4 = {}));
var HEX4 = "0123456789abcdef";
var Logger5 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels4[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel4 > LogLevels4[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger5.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger5.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger5.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors4) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger5.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX4[value[i] >> 4];
            hex += HEX4[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode4.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode4.CALL_EXCEPTION:
      case ErrorCode4.INSUFFICIENT_FUNDS:
      case ErrorCode4.MISSING_NEW:
      case ErrorCode4.NONCE_EXPIRED:
      case ErrorCode4.REPLACEMENT_UNDERPRICED:
      case ErrorCode4.TRANSACTION_REPLACED:
      case ErrorCode4.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger5.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError4) {
      this.throwError("platform missing String.prototype.normalize", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError4
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger5.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger5.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger5.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger5.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger5.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger5.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger5.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger4) {
      _globalLogger4 = new Logger5(version12);
    }
    return _globalLogger4;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors4) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors4 = !!censorship;
    _permanentCensorErrors4 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels4[logLevel.toLowerCase()];
    if (level == null) {
      Logger5.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel4 = level;
  }
  static from(version134) {
    return new Logger5(version134);
  }
};
Logger5.errors = ErrorCode4;
Logger5.levels = LogLevel4;

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version13 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger11 = new Logger5(version13);
function isHexable3(value) {
  return !!value.toHexString;
}
function addSlice3(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice3(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString4(value) && !(value.length % 2) || isBytes4(value);
}
function isInteger3(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes4(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger3(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger3(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify4(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger11.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice3(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable3(value)) {
    value = value.toHexString();
  }
  if (isHexString4(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger11.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice3(new Uint8Array(result));
  }
  if (isBytes4(value)) {
    return addSlice3(new Uint8Array(value));
  }
  return logger11.throwArgumentError("invalid arrayify value", "value", value);
}
function concat2(items) {
  const objects = items.map((item) => arrayify4(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice3(result);
}
function stripZeros(value) {
  let result = arrayify4(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad2(value, length) {
  value = arrayify4(value);
  if (value.length > length) {
    logger11.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice3(result);
}
function isHexString4(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters3 = "0123456789abcdef";
function hexlify4(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger11.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters3[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable3(value)) {
    return value.toHexString();
  }
  if (isHexString4(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger11.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes4(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters3[(v & 240) >> 4] + HexCharacters3[v & 15];
    }
    return result;
  }
  return logger11.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify4(data);
  } else if (!isHexString4(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice2(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify4(data);
  } else if (!isHexString4(data) || data.length % 2) {
    logger11.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify4(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify4(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify4(value);
  }
  if (!isHexString4(value)) {
    logger11.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad3(value, length) {
  if (typeof value !== "string") {
    value = hexlify4(value);
  } else if (!isHexString4(value)) {
    logger11.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger11.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature6) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature6)) {
    let bytes = arrayify4(signature6);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify4(bytes.slice(0, 32));
      result.s = hexlify4(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify4(bytes.slice(0, 32));
      result.s = hexlify4(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger11.throwArgumentError("invalid signature string", "signature", signature6);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger11.throwArgumentError("signature invalid v byte", "signature", signature6);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify4(bytes.slice(32, 64));
  } else {
    result.r = signature6.r;
    result.s = signature6.s;
    result.v = signature6.v;
    result.recoveryParam = signature6.recoveryParam;
    result._vs = signature6._vs;
    if (result._vs != null) {
      const vs2 = zeroPad2(arrayify4(result._vs), 32);
      result._vs = hexlify4(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger11.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature6);
      }
      vs2[0] &= 127;
      const s = hexlify4(vs2);
      if (result.s == null) {
        result.s = s;
      } else if (result.s !== s) {
        logger11.throwArgumentError("signature v mismatch _vs", "signature", signature6);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger11.throwArgumentError("signature missing v and recoveryParam", "signature", signature6);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger11.throwArgumentError("signature recoveryParam mismatch v", "signature", signature6);
        }
      }
    }
    if (result.r == null || !isHexString4(result.r)) {
      logger11.throwArgumentError("signature missing or invalid r", "signature", signature6);
    } else {
      result.r = hexZeroPad3(result.r, 32);
    }
    if (result.s == null || !isHexString4(result.s)) {
      logger11.throwArgumentError("signature missing or invalid s", "signature", signature6);
    } else {
      result.s = hexZeroPad3(result.s, 32);
    }
    const vs = arrayify4(result.s);
    if (vs[0] >= 128) {
      logger11.throwArgumentError("signature s out of range", "signature", signature6);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify4(vs);
    if (result._vs) {
      if (!isHexString4(result._vs)) {
        logger11.throwArgumentError("signature invalid _vs", "signature", signature6);
      }
      result._vs = hexZeroPad3(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger11.throwArgumentError("signature _vs mismatch v and s", "signature", signature6);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version14 = "bignumber/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN3 = import_bn3.default.BN;
var logger12 = new Logger5(version14);
var _constructorGuard5 = {};
var MAX_SAFE3 = 9007199254740991;
function isBigNumberish3(value) {
  return value != null && (BigNumber4.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString4(value) || typeof value === "bigint" || isBytes4(value));
}
var _warnedToStringRadix3 = false;
var BigNumber4 = class {
  constructor(constructorGuard, hex) {
    logger12.checkNew(new.target, BigNumber4);
    if (constructorGuard !== _constructorGuard5) {
      logger12.throwError("cannot call constructor directly; use BigNumber.from", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber3(toBN3(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber3(toBN3(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber4.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber3(toBN3(this).add(toBN3(other)));
  }
  sub(other) {
    return toBigNumber3(toBN3(this).sub(toBN3(other)));
  }
  div(other) {
    const o = BigNumber4.from(other);
    if (o.isZero()) {
      throwFault5("division-by-zero", "div");
    }
    return toBigNumber3(toBN3(this).div(toBN3(other)));
  }
  mul(other) {
    return toBigNumber3(toBN3(this).mul(toBN3(other)));
  }
  mod(other) {
    const value = toBN3(other);
    if (value.isNeg()) {
      throwFault5("division-by-zero", "mod");
    }
    return toBigNumber3(toBN3(this).umod(value));
  }
  pow(other) {
    const value = toBN3(other);
    if (value.isNeg()) {
      throwFault5("negative-power", "pow");
    }
    return toBigNumber3(toBN3(this).pow(value));
  }
  and(other) {
    const value = toBN3(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault5("unbound-bitwise-result", "and");
    }
    return toBigNumber3(toBN3(this).and(value));
  }
  or(other) {
    const value = toBN3(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault5("unbound-bitwise-result", "or");
    }
    return toBigNumber3(toBN3(this).or(value));
  }
  xor(other) {
    const value = toBN3(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault5("unbound-bitwise-result", "xor");
    }
    return toBigNumber3(toBN3(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault5("negative-width", "mask");
    }
    return toBigNumber3(toBN3(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault5("negative-width", "shl");
    }
    return toBigNumber3(toBN3(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault5("negative-width", "shr");
    }
    return toBigNumber3(toBN3(this).shrn(value));
  }
  eq(other) {
    return toBN3(this).eq(toBN3(other));
  }
  lt(other) {
    return toBN3(this).lt(toBN3(other));
  }
  lte(other) {
    return toBN3(this).lte(toBN3(other));
  }
  gt(other) {
    return toBN3(this).gt(toBN3(other));
  }
  gte(other) {
    return toBN3(this).gte(toBN3(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN3(this).isZero();
  }
  toNumber() {
    try {
      return toBN3(this).toNumber();
    } catch (error) {
      throwFault5("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger12.throwError("this platform does not support BigInt", Logger5.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix3) {
          _warnedToStringRadix3 = true;
          logger12.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger12.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger5.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger12.throwError("BigNumber.toString does not accept parameters", Logger5.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN3(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber4) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber4(_constructorGuard5, toHex3(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber4(_constructorGuard5, toHex3(new BN3(value)));
      }
      return logger12.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault5("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE3 || value <= -MAX_SAFE3) {
        throwFault5("overflow", "BigNumber.from", value);
      }
      return BigNumber4.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber4.from(anyValue.toString());
    }
    if (isBytes4(anyValue)) {
      return BigNumber4.from(hexlify4(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber4.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString4(hex) || hex[0] === "-" && isHexString4(hex.substring(1))) {
            return BigNumber4.from(hex);
          }
        }
      }
    }
    return logger12.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex3(value) {
  if (typeof value !== "string") {
    return toHex3(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger12.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex3(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber3(value) {
  return BigNumber4.from(toHex3(value));
}
function toBN3(value) {
  const hex = BigNumber4.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN3("-" + hex.substring(3), 16);
  }
  return new BN3(hex.substring(2), 16);
}
function throwFault5(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger12.throwError(fault, Logger5.errors.NUMERIC_FAULT, params);
}
function _base36To163(value) {
  return new BN3(value, 36).toString(16);
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger13 = new Logger5(version14);
var _constructorGuard6 = {};
var Zero4 = BigNumber4.from(0);
var NegativeOne4 = BigNumber4.from(-1);
function throwFault6(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger13.throwError(message, Logger5.errors.NUMERIC_FAULT, params);
}
var zeros3 = "0";
while (zeros3.length < 256) {
  zeros3 += zeros3;
}
function getMultiplier3(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber4.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros3.substring(0, decimals);
  }
  return logger13.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed4(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier3(decimals);
  value = BigNumber4.from(value);
  const negative = value.lt(Zero4);
  if (negative) {
    value = value.mul(NegativeOne4);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed4(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier3(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger13.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger13.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger13.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault6("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber4.from(whole);
  const fractionValue = BigNumber4.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne4);
  }
  return wei;
}
var FixedFormat3 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard6) {
      logger13.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier3(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat3) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger13.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger13.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger13.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger13.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat3(_constructorGuard6, signed, width, decimals);
  }
};
var FixedNumber3 = class {
  constructor(constructorGuard, hex, value, format) {
    logger13.checkNew(new.target, FixedNumber3);
    if (constructorGuard !== _constructorGuard6) {
      logger13.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger13.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed4(this._value, this.format.decimals);
    const b = parseFixed4(other._value, other.format.decimals);
    return FixedNumber3.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed4(this._value, this.format.decimals);
    const b = parseFixed4(other._value, other.format.decimals);
    return FixedNumber3.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed4(this._value, this.format.decimals);
    const b = parseFixed4(other._value, other.format.decimals);
    return FixedNumber3.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed4(this._value, this.format.decimals);
    const b = parseFixed4(other._value, other.format.decimals);
    return FixedNumber3.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber3.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE3.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber3.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE3.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger13.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber3.from("1" + zeros3.substring(0, decimals), this.format);
    const bump = BUMP3.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger13.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber4.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad3(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber3.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish3(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber3.fromString(formatFixed4(value, decimals), FixedFormat3.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat3.from(format);
    const numeric = parseFixed4(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero4)) {
      throwFault6("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad3(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed4(numeric, fixedFormat.decimals);
    return new FixedNumber3(_constructorGuard6, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat3.from(format);
    if (arrayify4(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber4.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed4(numeric, fixedFormat.decimals);
    return new FixedNumber3(_constructorGuard6, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber3.fromString(value, format);
    }
    if (isBytes4(value)) {
      return FixedNumber3.fromBytes(value, format);
    }
    try {
      return FixedNumber3.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger5.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger13.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE3 = FixedNumber3.from(1);
var BUMP3 = FixedNumber3.from("0.5");

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version15 = "properties/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/properties/lib.esm/index.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger14 = new Logger5(version15);
function defineReadOnly3(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic2(ctor, key6) {
  for (let i = 0; i < 32; i++) {
    if (ctor[key6]) {
      return ctor[key6];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties3(object) {
  return __awaiter5(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key6) => {
      const value = object[key6];
      return Promise.resolve(value).then((v) => ({ key: key6, value: v }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger14.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key6) => {
    if (!properties[key6]) {
      logger14.throwArgumentError("invalid object key - " + key6, "transaction:" + key6, object);
    }
  });
}
function shallowCopy3(object) {
  const result = {};
  for (const key6 in object) {
    result[key6] = object[key6];
  }
  return result;
}
var opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
      let value = null;
      try {
        value = object[keys[i]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger14.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy2(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key6 in object) {
      const value = object[key6];
      if (value === void 0) {
        continue;
      }
      defineReadOnly3(result, key6, deepCopy2(value));
    }
    return result;
  }
  return logger14.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy2(object) {
  return _deepCopy(object);
}
var Description = class {
  constructor(info) {
    for (const key6 in info) {
      this[key6] = deepCopy2(info[key6]);
    }
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
init_define_process_env();
var version16 = "abstract-provider/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-provider/lib.esm/index.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger15 = new Logger5(version16);
var ForkEvent = class extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
};
var Provider2 = class {
  constructor() {
    logger15.checkAbstract(new.target, Provider2);
    defineReadOnly3(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter6(this, void 0, void 0, function* () {
      const { block, gasPrice } = yield resolveProperties3({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = BigNumber4.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/networks/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/networks/lib.esm/_version.js
init_define_process_env();
var version17 = "networks/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/networks/lib.esm/index.js
var logger16 = new Logger5(version17);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip = ["goerli", "ropsten", "rinkeby"];
      try {
        const provider = new providers.PocketProvider(network);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        providerList.push(new providers.AnkrProvider(network, options.ankr));
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
var homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
var ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
var classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
var networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: { chainId: 137, name: "matic" },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: { chainId: 10, name: "optimism" },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name2 in networks) {
      const standard2 = networks[name2];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger16.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger16.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/base-provider.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/basex/lib.esm/index.js
init_define_process_env();
var BaseX = class {
  constructor(alphabet) {
    defineReadOnly3(this, "alphabet", alphabet);
    defineReadOnly3(this, "base", alphabet.length);
    defineReadOnly3(this, "_alphabetMap", {});
    defineReadOnly3(this, "_leader", alphabet.charAt(0));
    for (let i = 0; i < alphabet.length; i++) {
      this._alphabetMap[alphabet.charAt(i)] = i;
    }
  }
  encode(value) {
    let source = arrayify4(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i = 0; i < source.length; ++i) {
      let carry = source[i];
      for (let j = 0; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
      string += this._leader;
    }
    for (let q = digits.length - 1; q >= 0; --q) {
      string += this.alphabet[digits[q]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i = 0; i < value.length; i++) {
      let byte = this._alphabetMap[value[i]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j = 0; j < bytes.length; ++j) {
        carry += bytes[j] * this.base;
        bytes[j] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
      bytes.push(0);
    }
    return arrayify4(new Uint8Array(bytes.reverse()));
  }
};
var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
var Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();
var AddressZero2 = "0x0000000000000000000000000000000000000000";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();
var NegativeOne5 = BigNumber4.from(-1);
var Zero5 = BigNumber4.from(0);
var One2 = BigNumber4.from(1);
var Two2 = BigNumber4.from(2);
var WeiPerEther2 = BigNumber4.from("1000000000000000000");
var MaxUint2562 = BigNumber4.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2562 = BigNumber4.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2562 = BigNumber4.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();
var HashZero2 = "0x0000000000000000000000000000000000000000000000000000000000000000";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/id.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha3 = __toESM(require_sha3());
function keccak2562(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify4(data));
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version18 = "strings/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger17 = new Logger5(version18);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger17.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify4(bytes);
  const result = [];
  let i = 0;
  while (i < bytes.length) {
    const c = bytes[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
      } else {
        i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes.length) {
      i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes[i];
      if ((nextChar & 192) != 128) {
        i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes2(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger17.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify4(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes2(str, form));
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i = 0; i < ranges.length; i++) {
    let range = ranges[i];
    lo += range.l;
    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range;
    }
  }
  return null;
}
var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
var Table_B_2_ranges = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range = matchMap(codepoint, Table_B_2_ranges);
  if (range) {
    return [codepoint + range.s];
  }
  let codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints(value);
  codes = flatten(codes.map((code) => {
    if (Table_B_1_flags.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 65024 && code <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code];
  }));
  codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
  codes.forEach((code) => {
    if (_nameprepTableC(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code) => {
    if (_nameprepTableA1(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String(codes);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  if (name2.length > 63) {
    throw new Error("too long");
  }
  return name2;
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/id.js
function id(text) {
  return keccak2562(toUtf8Bytes2(text));
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/namehash.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/_version.js
init_define_process_env();
var version19 = "hash/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger18 = new Logger5(version19);
var Zeros = new Uint8Array(32);
Zeros.fill(0);
var Partition = new RegExp("^((.*)\\.)?([^.]+)$");
function namehash(name2) {
  if (typeof name2 !== "string") {
    logger18.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let current = name2;
  let result = Zeros;
  while (current.length) {
    const partition = current.match(Partition);
    if (partition == null || partition[2] === "") {
      logger18.throwArgumentError("invalid ENS address; missing component", "name", name2);
    }
    const label = toUtf8Bytes2(nameprep(partition[3]));
    result = keccak2562(concat2([result, keccak2562(label)]));
    current = partition[2] || "";
  }
  return hexlify4(result);
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/message.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/typed-data.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version20 = "rlp/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger19 = new Logger5(version20);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger19.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify4(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode(object) {
  return hexlify4(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger19.throwError("child data too short", Logger5.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  if (data.length === 0) {
    logger19.throwError("data too short", Logger5.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger19.throwError("data short segment too short", Logger5.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger19.throwError("data long segment too short", Logger5.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger19.throwError("data array too short", Logger5.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger19.throwError("data array too short", Logger5.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger19.throwError("data array too short", Logger5.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify4(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger19.throwError("data too short", Logger5.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify4(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify4(data[offset]) };
}
function decode(data) {
  const bytes = arrayify4(data);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger19.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version21 = "address/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/address/lib.esm/index.js
var logger20 = new Logger5(version21);
function getChecksumAddress(address) {
  if (!isHexString4(address, 20)) {
    logger20.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify4(keccak2562(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function log10(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
var ibanLookup = {};
for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress2(address) {
  let result = null;
  if (typeof address !== "string") {
    logger20.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger20.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger20.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To163(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger20.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function getContractAddress2(transaction) {
  let from = null;
  try {
    from = getAddress2(transaction.from);
  } catch (error) {
    logger20.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify4(BigNumber4.from(transaction.nonce).toHexString()));
  return getAddress2(hexDataSlice2(keccak2562(encode([from, nonce])), 12));
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/typed-data.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger21 = new Logger5(version19);
var padding = new Uint8Array(32);
padding.fill(0);
var NegativeOne6 = BigNumber4.from(-1);
var Zero6 = BigNumber4.from(0);
var One3 = BigNumber4.from(1);
var MaxUint2563 = BigNumber4.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes = arrayify4(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }
  return hexlify4(bytes);
}
var hexTrue = hexZeroPad3(One3.toHexString(), 32);
var hexFalse = hexZeroPad3(Zero6.toHexString(), 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key6) {
  return function(value) {
    if (typeof value !== "string") {
      logger21.throwArgumentError(`invalid domain value for ${JSON.stringify(key6)}`, `domain.${key6}`, value);
    }
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber4.from(value).toString();
    } catch (error) {
    }
    return logger21.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress2(value).toLowerCase();
    } catch (error) {
    }
    return logger21.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify4(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify4(bytes);
    } catch (error) {
    }
    return logger21.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger21.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint2563.mask(signed ? width - 1 : width);
      const boundsLower = signed ? boundsUpper.add(One3).mul(NegativeOne6) : Zero6;
      return function(value) {
        const v = BigNumber4.from(value);
        if (v.lt(boundsLower) || v.gt(boundsUpper)) {
          logger21.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad3(v.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger21.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes = arrayify4(value);
        if (bytes.length !== width) {
          logger21.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad3(getAddress2(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak2562(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
var TypedDataEncoder2 = class {
  constructor(types) {
    defineReadOnly3(this, "types", Object.freeze(deepCopy2(types)));
    defineReadOnly3(this, "_encoderCache", {});
    defineReadOnly3(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types).forEach((type) => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name2 in types) {
      const uniqueNames = {};
      types[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger21.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger21.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        }
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger21.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n) => parents[n].length === 0);
    if (primaryTypes.length === 0) {
      logger21.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger21.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", types);
    }
    defineReadOnly3(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger21.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
      }
      found[type] = true;
      Object.keys(links[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st = Object.keys(subtypes[name2]);
      st.sort();
      this._types[name2] = encodeType(name2, types[name2]) + st.map((t) => encodeType(t, types[t])).join("");
    }
  }
  getEncoder(type) {
    let encoder = this._encoderCache[type];
    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder;
  }
  _getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return (value) => {
        if (length >= 0 && value.length !== length) {
          logger21.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak2562);
        }
        return keccak2562(hexConcat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this._types[type]);
      return (value) => {
        const values = fields.map(({ name: name2, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name2]);
          if (this._types[type2]) {
            return keccak2562(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger21.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger21.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name2, value) {
    return keccak2562(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);
      if (length >= 0 && value.length !== length) {
        logger21.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v) => this._visit(subtype, v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type2 }) => {
        accum[name2] = this._visit(type2, value[name2], callback);
        return accum;
      }, {});
    }
    return logger21.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types) {
    return new TypedDataEncoder2(types);
  }
  static getPrimaryType(types) {
    return TypedDataEncoder2.from(types).primaryType;
  }
  static hashStruct(name2, types, value) {
    return TypedDataEncoder2.from(types).hashStruct(name2, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name2 in domain) {
      const type = domainFieldTypes[name2];
      if (!type) {
        logger21.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain);
      }
      domainFields.push({ name: name2, type });
    }
    domainFields.sort((a, b) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
    });
    return TypedDataEncoder2.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types, value) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder2.hashDomain(domain),
      TypedDataEncoder2.from(types).hash(value)
    ]);
  }
  static hash(domain, types, value) {
    return keccak2562(TypedDataEncoder2.encode(domain, types, value));
  }
  static resolveNames(domain, types, value, resolveName2) {
    return __awaiter7(this, void 0, void 0, function* () {
      domain = shallowCopy3(domain);
      const ensCache = {};
      if (domain.verifyingContract && !isHexString4(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder2.from(types);
      encoder.visit(value, (type, value2) => {
        if (type === "address" && !isHexString4(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName2(name2);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder.visit(value, (type, value2) => {
        if (type === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    });
  }
  static getPayload(domain, types, value) {
    TypedDataEncoder2.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value2 = domain[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
    });
    const encoder = TypedDataEncoder2.from(types);
    const typesWithDomain = shallowCopy3(types);
    if (typesWithDomain.EIP712Domain) {
      logger21.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify4(arrayify4(value2));
        }
        if (type.match(/^u?int/)) {
          return BigNumber4.from(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger21.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger21.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/sha2/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/sha2/lib.esm/sha2.js
init_define_process_env();
var import_hash2 = __toESM(require_hash());

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/sha2/lib.esm/types.js
init_define_process_env();
var SupportedAlgorithm;
(function(SupportedAlgorithm5) {
  SupportedAlgorithm5["sha256"] = "sha256";
  SupportedAlgorithm5["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/sha2/lib.esm/_version.js
init_define_process_env();
var version22 = "sha2/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/sha2/lib.esm/sha2.js
var logger22 = new Logger5(version22);
function sha2562(data) {
  return "0x" + import_hash2.default.sha256().update(arrayify4(data)).digest("hex");
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/web/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/base64/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/base64/lib.esm/base64.js
init_define_process_env();
function decode2(textData) {
  textData = atob(textData);
  const data = [];
  for (let i = 0; i < textData.length; i++) {
    data.push(textData.charCodeAt(i));
  }
  return arrayify4(data);
}
function encode2(data) {
  data = arrayify4(data);
  let textData = "";
  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/web/lib.esm/_version.js
init_define_process_env();
var version23 = "web/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/web/lib.esm/geturl.js
init_define_process_env();
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter8(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    ;
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key6) => {
        headers[key6.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key6) => {
        headers[key6.toLowerCase()] = response.headers.get(key6);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify4(new Uint8Array(body))
    };
  });
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/web/lib.esm/index.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger23 = new Logger5(version23);
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
      ;
    }
    return hexlify4(value);
  }
  return value;
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger23.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger23.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger23.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key6 in connection.headers) {
        headers[key6.toLowerCase()] = { key: key6, value: String(connection.headers[key6]) };
        if (["if-none-match", "if-modified-since"].indexOf(key6.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger23.throwError("basic authentication requires a secure https url", Logger5.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode2(toUtf8Bytes2(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
  }
  const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] },
        body: decode2(dataMatch[2])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger23.throwError("processing response error", Logger5.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key6) => {
    const header = headers[key6];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger23.makeError("timeout", Logger5.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter9(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location = response.headers.location || "";
              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall3 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall3 = parseInt(retryAfter) * 1e3;
                } else {
                  stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall3);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger23.throwError("missing response", Logger5.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger23.throwError("bad response", Logger5.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger23.throwError("processing response error", Logger5.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger23.throwError("failed response", Logger5.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger23.throwError("invalid JSON", Logger5.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes2(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy3(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k) => k.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy3(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy3(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer2 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/base-provider.js
var import_bech32 = __toESM(require_bech32());

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/_version.js
init_define_process_env();
var version24 = "providers/5.5.3";

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/formatter.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/transactions/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/signing-key/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
init_define_process_env();
var import_bn4 = __toESM(require_bn());
var import_hash3 = __toESM(require_hash());
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base6) {
      return commonjsRequire(path, base6 === void 0 || base6 === null ? module.path : base6);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || "Assertion failed: " + l + " != " + r);
};
var utils_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var utils = exports;
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex13(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex13;
  utils.encode = function encode18(arr, enc) {
    if (enc === "hex")
      return toHex13(arr);
    else
      return arr;
  };
});
var utils_1$1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert;
  utils.toArray = utils_1.toArray;
  utils.zero2 = utils_1.zero2;
  utils.toHex = utils_1.toHex;
  utils.encode = utils_1.encode;
  function getNAF6(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF6;
  function getJSF6(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF6;
  function cachedProperty(obj, name2, computer) {
    var key6 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key6] !== void 0 ? this[key6] : this[key6] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn4.default(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new import_bn4.default(conf.p, 16);
  this.red = conf.prime ? import_bn4.default.red(conf.prime) : import_bn4.default.mont(this.p);
  this.zero = new import_bn4.default(0).toRed(this.red);
  this.one = new import_bn4.default(1).toRed(this.red);
  this.two = new import_bn4.default(2).toRed(this.red);
  this.n = conf.n && new import_bn4.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert$1(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k, w, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);
    if (i < 0)
      break;
    var z = naf[i];
    assert$1(z !== 0);
    if (p.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [
      points[a],
      null,
      null,
      points[b]
    ];
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;
    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][z - 1 >> 1];
      else if (z < 0)
        p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === "affine")
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  for (i = 0; i < len; i++)
    wnd[i] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$1(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$1(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode2(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x);
  return [4].concat(x, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode3(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl11 = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl11);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};
var inherits_browser = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new import_bn4.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn4.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn4.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn4.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn4.default(vec.a, 16),
        b: new import_bn4.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : import_bn4.default.mont(num);
  var tinv = new import_bn4.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new import_bn4.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u = lambda;
  var v = this.n.clone();
  var x1 = new import_bn4.default(1);
  var y1 = new import_bn4.default(0);
  var x2 = new import_bn4.default(0);
  var y2 = new import_bn4.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));
    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1, k2 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new import_bn4.default(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
};
ShortCurve.prototype.validate = function validate3(point11) {
  if (point11.inf)
    return true;
  var x = point11.x;
  var y = point11.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point(curve, x, y, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn4.default(x, 16);
    this.y = new import_bn4.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function point2(x, y, isRed) {
  return new Point(this, x, y, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p) {
  if (this.inf)
    return p;
  if (p.inf)
    return this;
  if (this.eq(p))
    return this.dbl();
  if (this.neg().eq(p))
    return this.curve.point(null, null);
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul(k) {
  k = new import_bn4.default(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k]);
  else
    return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq2(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x, y, z) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn4.default(0);
  } else {
    this.x = new import_bn4.default(x, 16);
    this.y = new import_bn4.default(y, 16);
    this.z = new import_bn4.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add2(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p) {
  if (this.isInfinity())
    return p.toJ();
  if (p.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }
  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx);
    var t = m.redSqr().redISub(s).redISub(s);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t;
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = b.redSqr();
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    var e = a.redAdd(a).redIAdd(a);
    var f = e.redSqr();
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f.redISub(d).redISub(d);
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t = m.redSqr().redISub(s).redISub(s);
    nx = t;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m = xx.redAdd(xx).redIAdd(xx);
  var mm = m.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee = e.redSqr();
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k, kbase) {
  k = new import_bn4.default(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint.prototype.eq = function eq3(p) {
  if (p.type === "affine")
    return this.eq(p.toJ());
  if (this === p)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base;
  curve.short = short_1;
  curve.mont = null;
  curve.edwards = null;
});
var curves_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert6 = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert6(this.g.validate(), "Invalid curve");
    assert6(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash3.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash3.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash3.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash3.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash3.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash3.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash3.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash3.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0;
    this.V[i] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac() {
  return new import_hash3.default.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add11, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add11;
    add11 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add11 = utils_1.toArray(add11, addEnc);
  minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add11 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add11, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add11;
    add11 = enc;
    enc = null;
  }
  if (add11) {
    add11 = utils_1.toArray(add11, addEnc || "hex");
    this._update(add11);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add11);
  this._reseed++;
  return utils_1.encode(res, enc);
};
var assert$3 = utils_1$1.assert;
function KeyPair(ec6, options) {
  this.ec = ec6;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec6, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec6, {
    pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec6, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec6, {
    priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate4() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key6, enc) {
  this.priv = new import_bn4.default(key6, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key6, enc) {
  if (key6.x || key6.y) {
    if (this.ec.curve.type === "mont") {
      assert$3(key6.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3(key6.x && key6.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key6.x, key6.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key6, enc);
};
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature6) {
  return this.ec.verify(msg, signature6, this);
};
KeyPair.prototype.inspect = function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new import_bn4.default(options.r, 16);
  this.s = new import_bn4.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 48) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data.length) {
    return false;
  }
  if (data[p.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 2) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 128) {
      r = r.slice(1);
    } else {
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 128) {
      s = s.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn4.default(r);
  this.s = new import_bn4.default(s);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();
  if (r[0] & 128)
    r = [0].concat(r);
  if (s[0] & 128)
    s = [0].concat(s);
  r = rmPadding(r);
  s = rmPadding(s);
  while (!s[0] && !(s[1] & 128)) {
    s = s.slice(1);
  }
  var arr = [2];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(2);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};
var rand = function() {
  throw new Error("unsupported");
};
var assert$5 = utils_1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options), "Unknown curve " + options);
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn4.default(2));
  for (; ; ) {
    var priv = new import_bn4.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign2(msg, key6, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key6 = this.keyFromPrivate(key6, enc);
  msg = this._truncateToN(new import_bn4.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key6.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn4.default(1));
  for (var iter = 0; ; iter++) {
    var k = options.k ? options.k(iter) : new import_bn4.default(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;
    var s = k.invm(this.n).mul(r.mul(key6.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }
    return new signature({ r, s, recoveryParam });
  }
};
EC.prototype.verify = function verify2(msg, signature$1, key6, enc) {
  msg = this._truncateToN(new import_bn4.default(msg, 16));
  key6 = this.keyFromPublic(key6, enc);
  signature$1 = new signature(signature$1, "hex");
  var r = signature$1.r;
  var s = signature$1.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;
  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key6.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  }
  p = this.g.jmulAdd(u1, key6.getPublic(), u2);
  if (p.isInfinity())
    return false;
  return p.eqXToP(r);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$5((3 & j) === j, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n = this.n;
  var e = new import_bn4.default(msg);
  var r = signature$1.r;
  var s = signature$1.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r, s2);
};
EC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec;
  elliptic.eddsa = null;
});
var EC$1 = elliptic_1.ec;

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/signing-key/lib.esm/_version.js
init_define_process_env();
var version25 = "signing-key/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger24 = new Logger5(version25);
var _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
var SigningKey2 = class {
  constructor(privateKey) {
    defineReadOnly3(this, "curve", "secp256k1");
    defineReadOnly3(this, "privateKey", hexlify4(privateKey));
    const keyPair6 = getCurve().keyFromPrivate(arrayify4(this.privateKey));
    defineReadOnly3(this, "publicKey", "0x" + keyPair6.getPublic(false, "hex"));
    defineReadOnly3(this, "compressedPublicKey", "0x" + keyPair6.getPublic(true, "hex"));
    defineReadOnly3(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify4(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify4(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest) {
    const keyPair6 = getCurve().keyFromPrivate(arrayify4(this.privateKey));
    const digestBytes = arrayify4(digest);
    if (digestBytes.length !== 32) {
      logger24.throwArgumentError("bad digest length", "digest", digest);
    }
    const signature6 = keyPair6.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature6.recoveryParam,
      r: hexZeroPad3("0x" + signature6.r.toString(16), 32),
      s: hexZeroPad3("0x" + signature6.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair6 = getCurve().keyFromPrivate(arrayify4(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify4(computePublicKey(otherKey)));
    return hexZeroPad3("0x" + keyPair6.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
function recoverPublicKey(digest, signature6) {
  const sig = splitSignature(signature6);
  const rs = { r: arrayify4(sig.r), s: arrayify4(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify4(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key6, compressed) {
  const bytes = arrayify4(key6);
  if (bytes.length === 32) {
    const signingKey = new SigningKey2(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify4(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify4(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger24.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/transactions/lib.esm/_version.js
init_define_process_env();
var version26 = "transactions/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/transactions/lib.esm/index.js
var logger25 = new Logger5(version26);
var TransactionTypes;
(function(TransactionTypes5) {
  TransactionTypes5[TransactionTypes5["legacy"] = 0] = "legacy";
  TransactionTypes5[TransactionTypes5["eip2930"] = 1] = "eip2930";
  TransactionTypes5[TransactionTypes5["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress2(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero5;
  }
  return BigNumber4.from(value);
}
function computeAddress2(key6) {
  const publicKey = computePublicKey(key6);
  return getAddress2(hexDataSlice2(keccak2562(hexDataSlice2(publicKey, 1)), 12));
}
function recoverAddress2(digest, signature6) {
  return computeAddress2(recoverPublicKey(arrayify4(digest), signature6));
}
function formatNumber(value, name2) {
  const result = stripZeros(BigNumber4.from(value).toHexString());
  if (result.length > 32) {
    logger25.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress2(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength(storageKey) !== 32) {
        logger25.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify2(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger25.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
        }
        return accessSetify(set[0], set[1]);
      }
      return accessSetify(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b) => a.address.localeCompare(b.address));
  return result;
}
function formatAccessList(value) {
  return accessListify2(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature6) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber4.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber4.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger25.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress2(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature6) {
    const sig = splitSignature(signature6);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode(fields)]);
}
function _serializeEip2930(transaction, signature6) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress2(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature6) {
    const sig = splitSignature(signature6);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode(fields)]);
}
function _parseEipSignature(tx, fields, serialize4) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger25.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad3(fields[1], 32);
  tx.s = hexZeroPad3(fields[2], 32);
  try {
    const digest = keccak2562(serialize4(tx));
    tx.from = recoverAddress2(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
    console.log(error);
  }
}
function _parseEip1559(payload) {
  const transaction = decode(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger25.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify4(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify2(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak2562(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger25.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify4(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify2(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak2562(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger25.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber4.from(transaction[6]).toNumber();
  } catch (error) {
    console.log(error);
    return tx;
  }
  tx.r = hexZeroPad3(transaction[7], 32);
  tx.s = hexZeroPad3(transaction[8], 32);
  if (BigNumber4.from(tx.r).isZero() && BigNumber4.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify4(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest = keccak2562(encode(raw));
    try {
      tx.from = recoverAddress2(digest, { r: hexlify4(tx.r), s: hexlify4(tx.s), recoveryParam });
    } catch (error) {
      console.log(error);
    }
    tx.hash = keccak2562(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse(rawTransaction) {
  const payload = arrayify4(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
    default:
      break;
  }
  return logger25.throwError(`unsupported transaction type: ${payload[0]}`, Logger5.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/formatter.js
var logger26 = new Logger5(version24);
var Formatter = class {
  constructor() {
    logger26.checkNew(new.target, Formatter);
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash10 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v) => {
      return this.data(v, true);
    };
    formats.transaction = {
      hash: hash10,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash10, null),
      blockNumber: Formatter.allowNull(number, null),
      transactionIndex: Formatter.allowNull(number, null),
      confirmations: Formatter.allowNull(number, null),
      from: address,
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number,
      data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash10,
      address,
      topics: Formatter.arrayOf(hash10),
      data,
      logIndex: number,
      blockHash: hash10
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number,
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash10,
      transactionHash: hash10,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number),
      type
    };
    formats.block = {
      hash: hash10,
      parentHash: hash10,
      number,
      timestamp: number,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: address,
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash10)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy3(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash10, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number),
      blockHash: Formatter.allowNull(hash10),
      transactionIndex: number,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash10),
      transactionHash: hash10,
      logIndex: number
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify2(accessList || []);
  }
  number(number) {
    if (number === "0x") {
      return 0;
    }
    return BigNumber4.from(number).toNumber();
  }
  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }
    return BigNumber4.from(number).toNumber();
  }
  bigNumber(value) {
    return BigNumber4.from(value);
  }
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString4(value)) {
        return value.toLowerCase();
      }
    }
    return logger26.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  address(value) {
    return getAddress2(value);
  }
  callAddress(value) {
    if (!isHexString4(value, 32)) {
      return null;
    }
    const address = getAddress2(hexDataSlice2(value, 12));
    return address === AddressZero2 ? null : address;
  }
  contractAddress(value) {
    return getContractAddress2(value);
  }
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    if (blockTag === "latest" || blockTag === "pending") {
      return blockTag;
    }
    if (typeof blockTag === "number" || isHexString4(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger26.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v = BigNumber4.from(value);
    try {
      return v.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString4(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad3(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber4.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber4.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString4(chainId)) {
        chainId = BigNumber4.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString4(chainId)) {
        chainId = BigNumber4.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber4.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger26.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger26.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger26.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v) => this.topics(v));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object) {
    const result = {};
    for (const key6 in format) {
      try {
        const value = format[key6](object[key6]);
        if (value !== void 0) {
          result[key6] = value;
        }
      } catch (error) {
        error.checkKey = key6;
        error.checkValue = object[key6];
        throw error;
      }
    }
    return result;
  }
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  static arrayOf(format) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
};
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
var throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/base-provider.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger27 = new Logger5(version24);
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger27.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag2(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger27.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return new Date().getTime();
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
var PollableEvents = ["block", "network", "pending", "poll"];
var Event = class {
  constructor(tag, listener, once) {
    defineReadOnly3(this, "tag", tag);
    defineReadOnly3(this, "listener", listener);
    defineReadOnly3(this, "once", once);
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter = {};
    if (topics.length > 0) {
      filter.topics = topics;
    }
    if (address && address !== "*") {
      filter.address = address;
    }
    return filter;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
var coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad3(BigNumber4.from(value).toHexString(), 32);
}
function base58Encode(data) {
  return Base58.encode(concat2([data, hexDataSlice2(sha2562(sha2562(data)), 0, 4)]));
}
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result) {
  try {
    return toUtf8String(_parseBytes(result));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber4.from(hexDataSlice2(result, 0, 32)).toNumber();
  const length = BigNumber4.from(hexDataSlice2(result, offset, offset + 32)).toNumber();
  return hexDataSlice2(result, offset + 32, offset + 32 + length);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger27.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
var Resolver = class {
  constructor(provider, address, name2, resolvedAddress) {
    defineReadOnly3(this, "provider", provider);
    defineReadOnly3(this, "name", name2);
    defineReadOnly3(this, "address", provider.formatter.address(address));
    defineReadOnly3(this, "_resolvedAddress", resolvedAddress);
  }
  _fetchBytes(selector, parameters) {
    return __awaiter10(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      try {
        return _parseBytes(yield this.provider.call(tx));
      } catch (error) {
        if (error.code === Logger5.errors.CALL_EXCEPTION) {
          return null;
        }
        return null;
      }
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger27.throwError(`unsupported coin type: ${coinType}`, Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = arrayify4(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat2([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat2([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length = bytes[1];
      let version134 = bytes[0];
      if (version134 === 0) {
        if (length !== 20 && length !== 32) {
          version134 = -1;
        }
      } else {
        version134 = -1;
      }
      if (version134 >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
        const words4 = import_bech32.default.toWords(bytes.slice(2));
        words4.unshift(version134);
        return import_bech32.default.encode(coinInfo.prefix, words4);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const transaction = {
            to: this.address,
            data: "0x3b3b57de" + namehash(this.name).substring(2)
          };
          const hexBytes2 = yield this.provider.call(transaction);
          if (hexBytes2 === "0x" || hexBytes2 === HashZero2) {
            return null;
          }
          return this.provider.formatter.callAddress(hexBytes2);
        } catch (error) {
          if (error.code === Logger5.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger27.throwError(`invalid or unsupported coin data`, Logger5.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter10(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i = 0; i < matchers.length; i++) {
          const match = avatar.match(matchers[i]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad3(BigNumber4.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber4.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad3(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx));
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter10(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      return logger27.throwError(`invalid or unsupported content hash data`, Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key6) {
    return __awaiter10(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes2(key6);
      keyBytes = concat2([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat2([keyBytes, hexZeroPad3("0x", 32 - key6.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify4(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
};
var defaultFormatter = null;
var nextPollId = 1;
var BaseProvider = class extends Provider2 {
  constructor(network) {
    logger27.checkNew(new.target, Provider2);
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.formatter = new.target.getFormatter();
    defineReadOnly3(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic2(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly3(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger27.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter10(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger27.throwError("no network detected", Logger5.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly3(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger5.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  _getInternalBlockNumber(maxAge) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties3({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber4.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter10(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger27.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger27.makeError("network block skew detected", Logger5.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i = this._emitted.block + 1; i <= blockNumber; i++) {
          this.emit("block", i);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key6) => {
          if (key6 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key6];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key6];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash10 = event.hash;
            let runner = this.getTransactionReceipt(hash10).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash10] = receipt.blockNumber;
              this.emit(hash10, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            const filter = event.filter;
            filter.fromBlock = this._lastBlockNumber + 1;
            filter.toBlock = blockNumber;
            const runner = this.getLogs(filter).then((logs) => {
              if (logs.length === 0) {
                return;
              }
              logs.forEach((log) => {
                this._emitted["b:" + log.blockHash] = log.blockNumber;
                this._emitted["t:" + log.transactionHash] = log.blockNumber;
                this.emit(filter, log);
              });
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return __awaiter10(this, void 0, void 0, function* () {
      return logger27.throwError("provider does not support network detection", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter10(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger27.makeError("underlying network changed", Logger5.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now2 = getTime();
    if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now2;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter10(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter10(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter10(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter10(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger27.makeError("transaction was replaced", Logger5.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer2 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger27.makeError("timeout exceeded", Logger5.errors.TIMEOUT, { timeout }));
          }, timeout);
          if (timer2.unref) {
            timer2.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer2);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter10(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber4.from(result);
      } catch (error) {
        return logger27.throwError("bad result from backend", Logger5.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties3({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber4.from(result);
      } catch (error) {
        return logger27.throwError("bad result from backend", Logger5.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties3({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber4.from(result).toNumber();
      } catch (error) {
        return logger27.throwError("bad result from backend", Logger5.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties3({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify4(result);
      } catch (error) {
        return logger27.throwError("bad result from backend", Logger5.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties3({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p) => hexValue(p))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify4(result);
      } catch (error) {
        return logger27.throwError("bad result from backend", Logger5.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  _wrapTransaction(tx, hash10, startBlock) {
    if (hash10 != null && hexDataLength(hash10) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash10 != null && tx.hash !== hash10) {
      logger27.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger5.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash10 });
    }
    result.wait = (confirms, timeout) => __awaiter10(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger27.throwError("transaction failed", Logger5.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t) => hexlify4(t));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash10 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash10, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter10(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key6) => {
        if (values[key6] == null) {
          return;
        }
        tx[key6] = Promise.resolve(values[key6]).then((v) => v ? this._getAddress(v) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key6) => {
        if (values[key6] == null) {
          return;
        }
        tx[key6] = Promise.resolve(values[key6]).then((v) => v ? BigNumber4.from(v) : null);
      });
      ["type"].forEach((key6) => {
        if (values[key6] == null) {
          return;
        }
        tx[key6] = Promise.resolve(values[key6]).then((v) => v != null ? v : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key6) => {
        if (values[key6] == null) {
          return;
        }
        tx[key6] = Promise.resolve(values[key6]).then((v) => v ? hexlify4(v) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties3(tx));
    });
  }
  _getFilter(filter) {
    return __awaiter10(this, void 0, void 0, function* () {
      filter = yield filter;
      const result = {};
      if (filter.address != null) {
        result.address = this._getAddress(filter.address);
      }
      ["blockHash", "topics"].forEach((key6) => {
        if (filter[key6] == null) {
          return;
        }
        result[key6] = filter[key6];
      });
      ["fromBlock", "toBlock"].forEach((key6) => {
        if (filter[key6] == null) {
          return;
        }
        result[key6] = this._getBlockTag(filter[key6]);
      });
      return this.formatter.filter(yield resolveProperties3(result));
    });
  }
  call(transaction, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties3({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("call", params);
      try {
        return hexlify4(result);
      } catch (error) {
        return logger27.throwError("bad result from backend", Logger5.errors.SERVER_ERROR, {
          method: "call",
          params,
          result,
          error
        });
      }
    });
  }
  estimateGas(transaction) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties3({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber4.from(result);
      } catch (error) {
        return logger27.throwError("bad result from backend", Logger5.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter10(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger27.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger27.throwError("ENS name not configured", Logger5.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString4(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString4(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger27.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter10(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i = 0; i < block.transactions.length; i++) {
            const tx = block.transactions[i];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter10(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter10(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter) {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties3({ filter: this._getFilter(filter) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter10(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger27.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter10(this, void 0, void 0, function* () {
      try {
        const address = yield this._getResolver(name2);
        if (address == null) {
          return null;
        }
        return new Resolver(this, address, name2);
      } catch (error) {
        if (error.code === Logger5.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _getResolver(name2) {
    return __awaiter10(this, void 0, void 0, function* () {
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger27.throwError("network does not support ENS", Logger5.errors.UNSUPPORTED_OPERATION, { operation: "ENS", network: network.name });
      }
      const transaction = {
        to: network.ensAddress,
        data: "0x0178b8bf" + namehash(name2).substring(2)
      };
      try {
        return this.formatter.callAddress(yield this.call(transaction));
      } catch (error) {
        if (error.code === Logger5.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  resolveName(name2) {
    return __awaiter10(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error) {
        if (isHexString4(name2)) {
          throw error;
        }
      }
      if (typeof name2 !== "string") {
        logger27.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter10(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddress = yield this._getResolver(reverseName);
      if (!resolverAddress) {
        return null;
      }
      let bytes = arrayify4(yield this.call({
        to: resolverAddress,
        data: "0x691f3431" + namehash(reverseName).substring(2)
      }));
      if (bytes.length < 32 || !BigNumber4.from(bytes.slice(0, 32)).eq(32)) {
        return null;
      }
      bytes = bytes.slice(32);
      if (bytes.length < 32) {
        return null;
      }
      const length = BigNumber4.from(bytes.slice(0, 32)).toNumber();
      bytes = bytes.slice(32);
      if (length > bytes.length) {
        return null;
      }
      const name2 = toUtf8String(bytes.slice(0, length));
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter10(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString4(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(reverseName);
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, "_", address);
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger27.throwError(method + " not implemented", Logger5.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e) => e.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e) => e.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event(getEventTag2(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-signer/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
init_define_process_env();
var version27 = "abstract-signer/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-signer/lib.esm/index.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger28 = new Logger5(version27);
var allowedTransactionKeys3 = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
var forwardErrors2 = [
  Logger5.errors.INSUFFICIENT_FUNDS,
  Logger5.errors.NONCE_EXPIRED,
  Logger5.errors.REPLACEMENT_UNDERPRICED
];
var Signer3 = class {
  constructor() {
    logger28.checkAbstract(new.target, Signer3);
    defineReadOnly3(this, "_isSigner", true);
  }
  getBalance(blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  estimateGas(transaction) {
    return __awaiter11(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties3(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  call(transaction, blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties3(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  sendTransaction(transaction) {
    return __awaiter11(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter11(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter11(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter11(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter11(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  checkTransaction(transaction) {
    for (const key6 in transaction) {
      if (allowedTransactionKeys3.indexOf(key6) === -1) {
        logger28.throwArgumentError("invalid transaction key: " + key6, "transaction", transaction);
      }
    }
    const tx = shallowCopy3(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger28.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  populateTransaction(transaction) {
    return __awaiter11(this, void 0, void 0, function* () {
      const tx = yield resolveProperties3(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter11(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger28.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger28.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger28.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger28.throwError("network does not support EIP-1559", Logger5.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger28.throwError("failed to get consistent fee data", Logger5.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors2.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger28.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger5.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger28.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties3(tx);
    });
  }
  _checkProvider(operation) {
    if (!this.provider) {
      logger28.throwError("missing provider", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger29 = new Logger5(version24);
var errorGas = ["call", "estimateGas"];
function checkError(method, error, params) {
  if (method === "call" && error.code === Logger5.errors.SERVER_ERROR) {
    const e = error.error;
    if (e && e.message.match("reverted") && isHexString4(e.data)) {
      return e.data;
    }
    logger29.throwError("missing revert data in call exception", Logger5.errors.CALL_EXCEPTION, {
      error,
      data: "0x"
    });
  }
  let message = error.message;
  if (error.code === Logger5.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  const transaction = params.transaction || params.signedTransaction;
  if (message.match(/insufficient funds|base fee exceeds gas limit/)) {
    logger29.throwError("insufficient funds for intrinsic transaction cost", Logger5.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce too low/)) {
    logger29.throwError("nonce has already been used", Logger5.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced/)) {
    logger29.throwError("replacement fee too low", Logger5.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/)) {
    logger29.throwError("legacy pre-eip-155 transactions not supported", Logger5.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
    logger29.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger5.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer(timeout) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
var _constructorGuard7 = {};
var JsonRpcSigner = class extends Signer3 {
  constructor(constructorGuard, provider, addressOrIndex) {
    logger29.checkNew(new.target, JsonRpcSigner);
    super();
    if (constructorGuard !== _constructorGuard7) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly3(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly3(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly3(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly3(this, "_index", addressOrIndex);
      defineReadOnly3(this, "_address", null);
    } else {
      logger29.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger29.throwError("cannot alter JSON-RPC Signer connection", Logger5.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard7, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger29.throwError("unknown account #" + this._index, Logger5.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy3(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy3(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter12(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger29.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties3({
      tx: resolveProperties3(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger29.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash10) => {
        return hash10;
      }, (error) => {
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger29.throwError("signing transactions is unsupported", Logger5.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter12(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash10 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter12(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash10);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash10, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash10;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter12(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes2(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("personal_sign", [hexlify4(data), address.toLowerCase()]);
    });
  }
  _legacySignMessage(message) {
    return __awaiter12(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes2(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify4(data)]);
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter12(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder2.resolveNames(domain, types, value, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      return yield this.provider.send("eth_signTypedData_v4", [
        address.toLowerCase(),
        JSON.stringify(TypedDataEncoder2.getPayload(populated.domain, types, populated.value))
      ]);
    });
  }
  unlock(password) {
    return __awaiter12(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
};
var UncheckedJsonRpcSigner = class extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash10) => {
      return {
        hash: hash10,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash10, confirmations);
        }
      };
    });
  }
};
var allowedTransactionKeys4 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
var JsonRpcProvider = class extends BaseProvider {
  constructor(url, network) {
    logger29.checkNew(new.target, JsonRpcProvider);
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic2(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly3(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly3(this, "connection", Object.freeze(shallowCopy3(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter12(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic2(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber4.from(chainId).toNumber());
        } catch (error) {
          return logger29.throwError("could not detect network", Logger5.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger29.throwError("could not detect network", Logger5.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard7, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a) => this.formatter.address(a));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy2(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic2(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic2(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
      default:
        break;
    }
    return null;
  }
  perform(method, params) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber4.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy3(params);
              params.transaction = shallowCopy3(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger29.throwError(method + " not implemented", Logger5.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll3() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash10) {
            self2._emitted["t:" + hash10.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash10).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll3();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll3();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy3(allowedTransactionKeys4);
    if (allowExtra) {
      for (const key6 in allowExtra) {
        if (allowExtra[key6]) {
          allowed[key6] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key6) {
      if (transaction[key6] == null) {
        return;
      }
      const value = hexValue(transaction[key6]);
      if (key6 === "gasLimit") {
        key6 = "gas";
      }
      result[key6] = value;
    });
    ["from", "to", "data"].forEach(function(key6) {
      if (transaction[key6] == null) {
        return;
      }
      result[key6] = hexlify4(transaction[key6]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify2(transaction.accessList);
    }
    return result;
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/ws.js
init_define_process_env();
var WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger147 = new Logger5(version24);
  WS = function() {
    logger147.throwError("WebSockets not supported in this environment", Logger5.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger30 = new Logger5(version24);
var NextId = 1;
var WebSocketProvider = class extends JsonRpcProvider {
  constructor(url, network) {
    if (network === "any") {
      logger30.throwError("WebSocketProvider does not support 'any' network yet", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    super(url, network);
    this._pollingInterval = -1;
    this._wsReady = false;
    defineReadOnly3(this, "_websocket", new WS(this.connection.url));
    defineReadOnly3(this, "_requests", {});
    defineReadOnly3(this, "_subs", {});
    defineReadOnly3(this, "_subIds", {});
    defineReadOnly3(this, "_detectNetwork", super.detectNetwork());
    this._websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id7) => {
        this._websocket.send(this._requests[id7].payload);
      });
    };
    this._websocket.onmessage = (messageEvent) => {
      const data = messageEvent.data;
      const result = JSON.parse(data);
      if (result.id != null) {
        const id7 = String(result.id);
        const request = this._requests[id7];
        delete this._requests[id7];
        if (result.result !== void 0) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            defineReadOnly3(error, "code", result.error.code || null);
            defineReadOnly3(error, "response", data);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, void 0);
          this.emit("debug", {
            action: "response",
            error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger30.throwError("cannot reset events block on WebSocketProvider", Logger5.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger30.throwError("cannot set polling interval on WebSocketProvider", Logger5.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter13(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger30.throwError("cannot set polling on WebSocketProvider", Logger5.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this._websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter13(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = BigNumber4.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = (event2) => {
          const hash10 = event2.hash;
          this.getTransactionReceipt(hash10).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash10, receipt);
          });
        };
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e) => e.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e) => e.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter13(this, void 0, void 0, function* () {
      if (this._websocket.readyState === WS.CONNECTING) {
        yield new Promise((resolve) => {
          this._websocket.onopen = function() {
            resolve(true);
          };
          this._websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this._websocket.close(1e3);
    });
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
init_define_process_env();
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger31 = new Logger5(version24);
var StaticJsonRpcProvider = class extends JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter14(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger31.throwError("no network detected", Logger5.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          defineReadOnly3(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
};
var UrlJsonRpcProvider = class extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger31.checkAbstract(new.target, UrlJsonRpcProvider);
    network = getStatic2(new.target, "getNetwork")(network);
    apiKey = getStatic2(new.target, "getApiKey")(apiKey);
    const connection = getStatic2(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      defineReadOnly3(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key6) => {
        defineReadOnly3(this, key6, apiKey[key6]);
      });
    }
  }
  _startPending() {
    logger31.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger31.throwError("API provider does not support signing", Logger5.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  static getApiKey(apiKey) {
    return apiKey;
  }
  static getUrl(network, apiKey) {
    return logger31.throwError("not implemented; sub-classes must override getUrl", Logger5.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var logger32 = new Logger5(version24);
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
var AlchemyWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new AlchemyProvider(network, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    defineReadOnly3(this, "apiKey", provider.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};
var AlchemyProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger32.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "ropsten":
        host = "eth-ropsten.alchemyapi.io/v2/";
        break;
      case "rinkeby":
        host = "eth-rinkeby.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.alchemyapi.io/v2/";
        break;
      case "kovan":
        host = "eth-kovan.alchemyapi.io/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-rinkeby":
        host = "arb-rinkeby.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-kovan":
        host = "opt-kovan.g.alchemy.com/v2/";
        break;
      default:
        logger32.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https://" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
init_define_process_env();
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger33 = new Logger5(version24);
var CloudflareProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger33.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger33.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter15(this, void 0, void 0, function* () {
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
        return block.number;
      }
      return _super.perform.call(this, method, params);
    });
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
init_define_process_env();
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger34 = new Logger5(version24);
function getTransactionPostData(transaction) {
  const result = {};
  for (let key6 in transaction) {
    if (transaction[key6] == null) {
      continue;
    }
    let value = transaction[key6];
    if (key6 === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key6]) {
      value = hexValue(hexlify4(value));
    } else if (key6 === "accessList") {
      value = "[" + accessListify2(value).map((set) => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify4(value);
    }
    result[key6] = value;
  }
  return result;
}
function getResult2(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || result.message != "OK") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
var defaultApiKey2 = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";
function checkError2(method, error, transaction) {
  if (method === "call" && error.code === Logger5.errors.SERVER_ERROR) {
    const e = error.error;
    if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
      let data = e.data;
      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }
      if (isHexString4(data)) {
        return data;
      }
      logger34.throwError("missing revert data in call exception", Logger5.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === Logger5.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger34.throwError("insufficient funds for intrinsic transaction cost", Logger5.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger34.throwError("nonce has already been used", Logger5.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger34.throwError("replacement fee too low", Logger5.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger34.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger5.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
var EtherscanProvider = class extends BaseProvider {
  constructor(network, apiKey) {
    logger34.checkNew(new.target, EtherscanProvider);
    super(network);
    defineReadOnly3(this, "baseUrl", this.getBaseUrl());
    defineReadOnly3(this, "apiKey", apiKey || defaultApiKey2);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "ropsten":
        return "https://api-ropsten.etherscan.io";
      case "rinkeby":
        return "https://api-rinkeby.etherscan.io";
      case "kovan":
        return "https://api-kovan.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      default:
    }
    return logger34.throwArgumentError("unsupported network", "network", name);
  }
  getUrl(module, params) {
    const query = Object.keys(params).reduce((accum, key6) => {
      const value = params[key6];
      if (value != null) {
        accum += `&${key6}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module, params, post) {
    return __awaiter16(this, void 0, void 0, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module, params);
      const payload = post ? this.getPostData(module, params) : null;
      const procFunc = module === "proxy" ? getJsonResult : getResult2;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url,
        throttleSlotInterval: 1e3,
        throttleCallback: (attempt, url2) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
        payloadStr = Object.keys(payload).map((key6) => {
          return `${key6}=${payload[key6]}`;
        }).join("&");
      }
      const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: deepCopy2(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter16(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter16(this, void 0, void 0, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch((error) => {
            return checkError2("sendTransaction", error, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call": {
          if (params.blockTag !== "latest") {
            throw new Error("EtherscanProvider does not support blockTag for call");
          }
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_call";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("call", error, params.transaction);
          }
        }
        case "estimateGas": {
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("estimateGas", error, params.transaction);
          }
        }
        case "getLogs": {
          const args = { action: "getLogs" };
          if (params.filter.fromBlock) {
            args.fromBlock = checkLogTag(params.filter.fromBlock);
          }
          if (params.filter.toBlock) {
            args.toBlock = checkLogTag(params.filter.toBlock);
          }
          if (params.filter.address) {
            args.address = params.filter.address;
          }
          if (params.filter.topics && params.filter.topics.length > 0) {
            if (params.filter.topics.length > 1) {
              logger34.throwError("unsupported topic count", Logger5.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
            }
            if (params.filter.topics.length === 1) {
              const topic0 = params.filter.topics[0];
              if (typeof topic0 !== "string" || topic0.length !== 66) {
                logger34.throwError("unsupported topic format", Logger5.errors.UNSUPPORTED_OPERATION, { topic0 });
              }
              args.topic0 = topic0;
            }
          }
          const logs = yield this.fetch("logs", args);
          let blocks = {};
          for (let i = 0; i < logs.length; i++) {
            const log = logs[i];
            if (log.blockHash != null) {
              continue;
            }
            if (blocks[log.blockNumber] == null) {
              const block = yield this.getBlock(log.blockNumber);
              if (block) {
                blocks[log.blockNumber] = block.hash;
              }
            }
            log.blockHash = blocks[log.blockNumber];
          }
          return logs;
        }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0;
          }
          return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
        default:
          break;
      }
      return _super.perform.call(this, method, params);
    });
  }
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter16(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map((tx) => {
        ["contractAddress", "to"].forEach(function(key6) {
          if (tx[key6] == "") {
            delete tx[key6];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/random/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/random/lib.esm/random.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/random/lib.esm/_version.js
init_define_process_env();
var version28 = "random/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/random/lib.esm/random.js
var logger35 = new Logger5(version28);
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal = getGlobal();
var crypto = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto || !crypto.getRandomValues) {
  logger35.warn("WARNING: Missing strong random number source");
  crypto = {
    getRandomValues: function(buffer) {
      return logger35.throwError("no secure random source avaialble", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}

// node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/random/lib.esm/shuffle.js
init_define_process_env();
function shuffled(array) {
  array = array.slice();
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }
  return array;
}

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger36 = new Logger5(version24);
function now() {
  return new Date().getTime();
}
function checkNetworks(networks2) {
  let result = null;
  for (let i = 0; i < networks2.length; i++) {
    const network = networks2[i];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger36.throwArgumentError("provider mismatch", "networks", networks2);
      }
    } else {
      result = network;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a = values[middle - 1], b = values[middle];
  if (maxDelta != null && Math.abs(a - b) > maxDelta) {
    return null;
  }
  return (a + b) / 2;
}
function serialize2(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber4.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i) => serialize2(i)));
  } else if (typeof value === "object") {
    const keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map((key6) => {
      let v = value[key6];
      if (typeof v === "function") {
        v = "[function]";
      } else {
        v = serialize2(v);
      }
      return JSON.stringify(key6) + ":" + v;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
var nextRid = 1;
function stall2(duration) {
  let cancel = null;
  let timer2 = null;
  let promise = new Promise((resolve) => {
    cancel = function() {
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
      }
      resolve();
    };
    timer2 = setTimeout(cancel, duration);
  });
  const wait = (func) => {
    promise = promise.then(func);
    return promise;
  };
  function getPromise() {
    return promise;
  }
  return { cancel, getPromise, wait };
}
var ForwardErrors = [
  Logger5.errors.CALL_EXCEPTION,
  Logger5.errors.INSUFFICIENT_FUNDS,
  Logger5.errors.NONCE_EXPIRED,
  Logger5.errors.REPLACEMENT_UNDERPRICED,
  Logger5.errors.UNPREDICTABLE_GAS_LIMIT
];
var ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(config, now2) {
  const result = {
    weight: config.weight
  };
  Object.defineProperty(result, "provider", { get: () => config.provider });
  if (config.start) {
    result.start = config.start;
  }
  if (now2) {
    result.duration = now2 - config.start;
  }
  if (config.done) {
    if (config.error) {
      result.error = config.error;
    } else {
      result.result = config.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c) => {
      const value = normalize(c.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c.result };
      }
      tally[value].count++;
    });
    const keys = Object.keys(tally);
    for (let i = 0; i < keys.length; i++) {
      const check = tally[keys[i]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider, method, params) {
  let normalize = serialize2;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c) => c.result);
        let blockNumber = median(configs.map((c) => c.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c) => c.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c) => c.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy3(tx);
        tx.confirmations = -1;
        return serialize2(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy3(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy3(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize2(block);
        };
      } else {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          return serialize2(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize, provider.quorum);
}
function waitForSync(config, blockNumber) {
  return __awaiter17(this, void 0, void 0, function* () {
    const provider = config.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          if (config.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider });
  });
}
function getRunner(config, currentBlockNumber, method, params) {
  return __awaiter17(this, void 0, void 0, function* () {
    let provider = config.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString4(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString4(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString4(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString4(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs": {
        let filter = params.filter;
        if (filter.fromBlock && isHexString4(filter.fromBlock) || filter.toBlock && isHexString4(filter.toBlock)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getLogs(filter);
      }
    }
    return logger36.throwError("unknown method error", Logger5.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
var FallbackProvider = class extends BaseProvider {
  constructor(providers, quorum) {
    logger36.checkNew(new.target, FallbackProvider);
    if (providers.length === 0) {
      logger36.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index) => {
      if (Provider2.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config = shallowCopy3(configOrProvider);
      if (config.priority == null) {
        config.priority = 1;
      }
      if (config.stallTimeout == null) {
        config.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
      }
      if (config.weight == null) {
        config.weight = 1;
      }
      const weight = config.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger36.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
      }
      return Object.freeze(config);
    });
    const total = providerConfigs.reduce((accum, c) => accum + c.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger36.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c) => c.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    defineReadOnly3(this, "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly3(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter17(this, void 0, void 0, function* () {
      const networks2 = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));
      return checkNetworks(networks2);
    });
  }
  perform(method, params) {
    return __awaiter17(this, void 0, void 0, function* () {
      if (method === "sendTransaction") {
        const results = yield Promise.all(this.providerConfigs.map((c) => {
          return c.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error) => {
            return error;
          });
        }));
        for (let i2 = 0; i2 < results.length; i2++) {
          const result = results[i2];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results[0];
      }
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      const configs = shuffled(this.providerConfigs.map(shallowCopy3));
      configs.sort((a, b) => a.priority - b.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i = 0;
      let first = true;
      while (true) {
        const t0 = now();
        let inflightWeight = configs.filter((c) => c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c) => accum + c.weight, 0);
        while (inflightWeight < this.quorum && i < configs.length) {
          const config = configs[i++];
          const rid = nextRid++;
          config.start = now();
          config.staller = stall2(config.stallTimeout);
          config.staller.wait(() => {
            config.staller = null;
          });
          config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {
            config.done = true;
            config.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config, now()),
                request: { method, params: deepCopy2(params) },
                provider: this
              });
            }
          }, (error) => {
            config.done = true;
            config.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config, now()),
                request: { method, params: deepCopy2(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config, null),
              request: { method, params: deepCopy2(params) },
              provider: this
            });
          }
          inflightWeight += config.weight;
        }
        const waiting = [];
        configs.forEach((c) => {
          if (c.done || !c.runner) {
            return;
          }
          waiting.push(c.runner);
          if (c.staller) {
            waiting.push(c.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results = configs.filter((c) => c.done && c.error == null);
        if (results.length >= this.quorum) {
          const result = processFunc(results);
          if (result !== void 0) {
            configs.forEach((c) => {
              if (c.staller) {
                c.staller.cancel();
              }
              c.cancelled = true;
            });
            return result;
          }
          if (!first) {
            yield stall2(100).getPromise();
          }
          first = false;
        }
        const errors = configs.reduce((accum, c) => {
          if (!c.done || c.error == null) {
            return accum;
          }
          const code = c.error.code;
          if (ForwardErrors.indexOf(code) >= 0) {
            if (!accum[code]) {
              accum[code] = { error: c.error, weight: 0 };
            }
            accum[code].weight += c.weight;
          }
          return accum;
        }, {});
        Object.keys(errors).forEach((errorCode) => {
          const tally = errors[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c) => {
            if (c.staller) {
              c.staller.cancel();
            }
            c.cancelled = true;
          });
          const e = tally.error;
          const props = {};
          ForwardProperties.forEach((name2) => {
            if (e[name2] == null) {
              return;
            }
            props[name2] = e[name2];
          });
          logger36.throwError(e.reason || e.message, errorCode, props);
        });
        if (configs.filter((c) => !c.done).length === 0) {
          break;
        }
      }
      configs.forEach((c) => {
        if (c.staller) {
          c.staller.cancel();
        }
        c.cancelled = true;
      });
      return logger36.throwError("failed to meet quorum", Logger5.errors.SERVER_ERROR, {
        method,
        params,
        results: configs.map((c) => exposeDebugConfig(c)),
        provider: this
      });
    });
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
init_define_process_env();
var IpcProvider = null;

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/infura-provider.js
init_define_process_env();
var logger37 = new Logger5(version24);
var defaultProjectId = "84842078b09946638c03157f83405213";
var InfuraWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger37.throwError("INFURA WebSocket project secrets unsupported", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    defineReadOnly3(this, "apiKey", provider.projectId);
    defineReadOnly3(this, "projectId", provider.projectId);
    defineReadOnly3(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};
var InfuraProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger37.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger37.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "ropsten":
        host = "ropsten.infura.io";
        break;
      case "rinkeby":
        host = "rinkeby.infura.io";
        break;
      case "kovan":
        host = "kovan.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-kovan":
        host = "optimism-kovan.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-rinkeby":
        host = "arbitrum-rinkeby.infura.io";
        break;
      default:
        logger37.throwError("unsupported network", Logger5.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
init_define_process_env();
var JsonRpcBatchProvider = class extends JsonRpcProvider {
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = { request, resolve: null, reject: null };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        const request2 = batch.map((inflight) => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: deepCopy2(request2),
          provider: this
        });
        return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
          this.emit("debug", {
            action: "response",
            request: request2,
            response: result,
            provider: this
          });
          batch.forEach((inflightRequest2, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest2.reject(error);
            } else {
              inflightRequest2.resolve(payload.result);
            }
          });
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request: request2,
            provider: this
          });
          batch.forEach((inflightRequest2) => {
            inflightRequest2.reject(error);
          });
        });
      }, 10);
    }
    return promise;
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
init_define_process_env();
var logger38 = new Logger5(version24);
var defaultApiKey3 = "ETHERS_JS_SHARED";
var NodesmithProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger38.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey3;
  }
  static getUrl(network, apiKey) {
    logger38.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger38.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
init_define_process_env();
var logger39 = new Logger5(version24);
var defaultApplicationIds = {
  homestead: "6004bcd10040261633ade990",
  ropsten: "6004bd4d0040261633ade991",
  rinkeby: "6004bda20040261633ade994",
  goerli: "6004bd860040261633ade992"
};
var PocketProvider = class extends UrlJsonRpcProvider {
  constructor(network, apiKey) {
    if (apiKey == null) {
      const n = getStatic2(new.target, "getNetwork")(network);
      if (n) {
        const applicationId = defaultApplicationIds[n.name];
        if (applicationId) {
          apiKey = {
            applicationId,
            loadBalancer: true
          };
        }
      }
      if (apiKey == null) {
        logger39.throwError("unsupported network", Logger5.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
      }
    }
    super(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      logger39.throwArgumentError("PocketProvider.getApiKey does not support null apiKey", "apiKey", apiKey);
    }
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: false,
      applicationSecretKey: null
    };
    if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      logger39.assertArgument(typeof apiKey.applicationId === "string", "applicationSecretKey requires an applicationId", "applicationId", apiKey.applicationId);
      logger39.assertArgument(typeof apiKey.applicationSecretKey === "string", "invalid applicationSecretKey", "applicationSecretKey", "[REDACTED]");
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
      apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
    } else if (apiKey.applicationId) {
      logger39.assertArgument(typeof apiKey.applicationId === "string", "apiKey.applicationId must be a string", "apiKey.applicationId", apiKey.applicationId);
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
    } else {
      logger39.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      default:
        logger39.throwError("unsupported network", Logger5.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    let url = null;
    if (apiKey.loadBalancer) {
      url = `https://${host}/v1/lb/${apiKey.applicationId}`;
    } else {
      url = `https://${host}/v1/${apiKey.applicationId}`;
    }
    const connection = { url };
    connection.headers = {};
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationIds[this.network.name];
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/web3-provider.js
init_define_process_env();
var logger40 = new Logger5(version24);
var _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy2(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy2(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
var Web3Provider = class extends JsonRpcProvider {
  constructor(provider, network) {
    logger40.checkNew(new.target, Web3Provider);
    if (provider == null) {
      logger40.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger40.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly3(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly3(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
};

// node_modules/ethers/node_modules/@ethersproject/providers/lib.esm/index.js
var logger41 = new Logger5(version24);
function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1]) {
        case "http":
          return new JsonRpcProvider(network);
        case "ws":
          return new WebSocketProvider(network);
        default:
          logger41.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n = getNetwork(network);
  if (!n || !n._defaultProvider) {
    logger41.throwError("unsupported getDefaultProvider network", Logger5.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}

// node_modules/ethers/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/id.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha32 = __toESM(require_sha3());

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version29 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors5 = false;
var _censorErrors5 = false;
var LogLevels5 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel5 = LogLevels5["default"];
var _globalLogger5 = null;
function _checkNormalize5() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError5 = _checkNormalize5();
var LogLevel5;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel5 || (LogLevel5 = {}));
var ErrorCode5;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode5 || (ErrorCode5 = {}));
var HEX5 = "0123456789abcdef";
var Logger6 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels5[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel5 > LogLevels5[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger6.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger6.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger6.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors5) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger6.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX5[value[i] >> 4];
            hex += HEX5[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode5.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode5.CALL_EXCEPTION:
      case ErrorCode5.INSUFFICIENT_FUNDS:
      case ErrorCode5.MISSING_NEW:
      case ErrorCode5.NONCE_EXPIRED:
      case ErrorCode5.REPLACEMENT_UNDERPRICED:
      case ErrorCode5.TRANSACTION_REPLACED:
      case ErrorCode5.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger6.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError5) {
      this.throwError("platform missing String.prototype.normalize", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError5
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger6.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger6.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger6.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger6.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger6.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger6.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger6.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger5) {
      _globalLogger5 = new Logger6(version29);
    }
    return _globalLogger5;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors5) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors5 = !!censorship;
    _permanentCensorErrors5 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels5[logLevel.toLowerCase()];
    if (level == null) {
      Logger6.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel5 = level;
  }
  static from(version134) {
    return new Logger6(version134);
  }
};
Logger6.errors = ErrorCode5;
Logger6.levels = LogLevel5;

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version30 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger42 = new Logger6(version30);
function isHexable4(value) {
  return !!value.toHexString;
}
function addSlice4(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice4(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger4(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes5(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger4(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger4(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify5(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger42.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice4(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable4(value)) {
    value = value.toHexString();
  }
  if (isHexString5(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger42.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice4(new Uint8Array(result));
  }
  if (isBytes5(value)) {
    return addSlice4(new Uint8Array(value));
  }
  return logger42.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString5(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters4 = "0123456789abcdef";
function hexlify5(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger42.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters4[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable4(value)) {
    return value.toHexString();
  }
  if (isHexString5(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger42.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes5(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters4[(v & 240) >> 4] + HexCharacters4[v & 15];
    }
    return result;
  }
  return logger42.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad4(value, length) {
  if (typeof value !== "string") {
    value = hexlify5(value);
  } else if (!isHexString5(value)) {
    logger42.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger42.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/keccak256/lib.esm/index.js
function keccak2563(data) {
  return "0x" + import_js_sha32.default.keccak_256(arrayify5(data));
}

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn5 = __toESM(require_bn());

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version31 = "bignumber/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN5 = import_bn5.default.BN;
var logger43 = new Logger6(version31);
var _constructorGuard8 = {};
var MAX_SAFE4 = 9007199254740991;
function isBigNumberish4(value) {
  return value != null && (BigNumber5.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString5(value) || typeof value === "bigint" || isBytes5(value));
}
var _warnedToStringRadix4 = false;
var BigNumber5 = class {
  constructor(constructorGuard, hex) {
    logger43.checkNew(new.target, BigNumber5);
    if (constructorGuard !== _constructorGuard8) {
      logger43.throwError("cannot call constructor directly; use BigNumber.from", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber4(toBN4(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber4(toBN4(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber5.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber4(toBN4(this).add(toBN4(other)));
  }
  sub(other) {
    return toBigNumber4(toBN4(this).sub(toBN4(other)));
  }
  div(other) {
    const o = BigNumber5.from(other);
    if (o.isZero()) {
      throwFault7("division-by-zero", "div");
    }
    return toBigNumber4(toBN4(this).div(toBN4(other)));
  }
  mul(other) {
    return toBigNumber4(toBN4(this).mul(toBN4(other)));
  }
  mod(other) {
    const value = toBN4(other);
    if (value.isNeg()) {
      throwFault7("division-by-zero", "mod");
    }
    return toBigNumber4(toBN4(this).umod(value));
  }
  pow(other) {
    const value = toBN4(other);
    if (value.isNeg()) {
      throwFault7("negative-power", "pow");
    }
    return toBigNumber4(toBN4(this).pow(value));
  }
  and(other) {
    const value = toBN4(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault7("unbound-bitwise-result", "and");
    }
    return toBigNumber4(toBN4(this).and(value));
  }
  or(other) {
    const value = toBN4(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault7("unbound-bitwise-result", "or");
    }
    return toBigNumber4(toBN4(this).or(value));
  }
  xor(other) {
    const value = toBN4(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault7("unbound-bitwise-result", "xor");
    }
    return toBigNumber4(toBN4(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault7("negative-width", "mask");
    }
    return toBigNumber4(toBN4(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault7("negative-width", "shl");
    }
    return toBigNumber4(toBN4(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault7("negative-width", "shr");
    }
    return toBigNumber4(toBN4(this).shrn(value));
  }
  eq(other) {
    return toBN4(this).eq(toBN4(other));
  }
  lt(other) {
    return toBN4(this).lt(toBN4(other));
  }
  lte(other) {
    return toBN4(this).lte(toBN4(other));
  }
  gt(other) {
    return toBN4(this).gt(toBN4(other));
  }
  gte(other) {
    return toBN4(this).gte(toBN4(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN4(this).isZero();
  }
  toNumber() {
    try {
      return toBN4(this).toNumber();
    } catch (error) {
      throwFault7("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger43.throwError("this platform does not support BigInt", Logger6.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix4) {
          _warnedToStringRadix4 = true;
          logger43.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger43.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger6.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger43.throwError("BigNumber.toString does not accept parameters", Logger6.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN4(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber5) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber5(_constructorGuard8, toHex4(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber5(_constructorGuard8, toHex4(new BN5(value)));
      }
      return logger43.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault7("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE4 || value <= -MAX_SAFE4) {
        throwFault7("overflow", "BigNumber.from", value);
      }
      return BigNumber5.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber5.from(anyValue.toString());
    }
    if (isBytes5(anyValue)) {
      return BigNumber5.from(hexlify5(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber5.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString5(hex) || hex[0] === "-" && isHexString5(hex.substring(1))) {
            return BigNumber5.from(hex);
          }
        }
      }
    }
    return logger43.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex4(value) {
  if (typeof value !== "string") {
    return toHex4(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger43.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex4(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber4(value) {
  return BigNumber5.from(toHex4(value));
}
function toBN4(value) {
  const hex = BigNumber5.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN5("-" + hex.substring(3), 16);
  }
  return new BN5(hex.substring(2), 16);
}
function throwFault7(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger43.throwError(fault, Logger6.errors.NUMERIC_FAULT, params);
}
function _base36To164(value) {
  return new BN5(value, 36).toString(16);
}

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger44 = new Logger6(version31);
var _constructorGuard9 = {};
var Zero7 = BigNumber5.from(0);
var NegativeOne7 = BigNumber5.from(-1);
function throwFault8(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger44.throwError(message, Logger6.errors.NUMERIC_FAULT, params);
}
var zeros4 = "0";
while (zeros4.length < 256) {
  zeros4 += zeros4;
}
function getMultiplier4(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber5.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros4.substring(0, decimals);
  }
  return logger44.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed5(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier4(decimals);
  value = BigNumber5.from(value);
  const negative = value.lt(Zero7);
  if (negative) {
    value = value.mul(NegativeOne7);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed5(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier4(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger44.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger44.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger44.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault8("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber5.from(whole);
  const fractionValue = BigNumber5.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne7);
  }
  return wei;
}
var FixedFormat4 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard9) {
      logger44.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier4(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat4) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger44.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger44.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger44.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger44.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat4(_constructorGuard9, signed, width, decimals);
  }
};
var FixedNumber4 = class {
  constructor(constructorGuard, hex, value, format) {
    logger44.checkNew(new.target, FixedNumber4);
    if (constructorGuard !== _constructorGuard9) {
      logger44.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger44.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed5(this._value, this.format.decimals);
    const b = parseFixed5(other._value, other.format.decimals);
    return FixedNumber4.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed5(this._value, this.format.decimals);
    const b = parseFixed5(other._value, other.format.decimals);
    return FixedNumber4.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed5(this._value, this.format.decimals);
    const b = parseFixed5(other._value, other.format.decimals);
    return FixedNumber4.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed5(this._value, this.format.decimals);
    const b = parseFixed5(other._value, other.format.decimals);
    return FixedNumber4.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber4.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE4.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber4.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE4.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger44.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber4.from("1" + zeros4.substring(0, decimals), this.format);
    const bump = BUMP4.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger44.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber5.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad4(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber4.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish4(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber4.fromString(formatFixed5(value, decimals), FixedFormat4.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat4.from(format);
    const numeric = parseFixed5(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero7)) {
      throwFault8("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad4(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed5(numeric, fixedFormat.decimals);
    return new FixedNumber4(_constructorGuard9, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat4.from(format);
    if (arrayify5(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber5.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed5(numeric, fixedFormat.decimals);
    return new FixedNumber4(_constructorGuard9, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber4.fromString(value, format);
    }
    if (isBytes5(value)) {
      return FixedNumber4.fromBytes(value, format);
    }
    try {
      return FixedNumber4.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger6.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger44.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE4 = FixedNumber4.from(1);
var BUMP4 = FixedNumber4.from("0.5");

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne8 = BigNumber5.from(-1);
var Zero8 = BigNumber5.from(0);
var One4 = BigNumber5.from(1);
var Two3 = BigNumber5.from(2);
var WeiPerEther3 = BigNumber5.from("1000000000000000000");
var MaxUint2564 = BigNumber5.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2563 = BigNumber5.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2563 = BigNumber5.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version32 = "strings/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger45 = new Logger6(version32);
var UnicodeNormalizationForm2;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm2 || (UnicodeNormalizationForm2 = {}));
var Utf8ErrorReason2;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason2 || (Utf8ErrorReason2 = {}));
function errorFunc2(reason, offset, bytes, output, badCodepoint) {
  return logger45.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc2(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason2.BAD_PREFIX || reason === Utf8ErrorReason2.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason2.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc2(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason2.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc2(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs2 = Object.freeze({
  error: errorFunc2,
  ignore: ignoreFunc2,
  replace: replaceFunc2
});
function toUtf8Bytes3(str, form = UnicodeNormalizationForm2.current) {
  if (form != UnicodeNormalizationForm2.current) {
    logger45.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify5(result);
}

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes22(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable2(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable2(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges2 = createRangeTable2("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags2 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
var Table_B_2_lut_abs2 = createTable2("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel2 = createTable2("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex2 = createTable2("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes22);
var Table_C_ranges2 = createRangeTable2("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/id.js
function id2(text) {
  return keccak2563(toUtf8Bytes3(text));
}

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/namehash.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/_version.js
init_define_process_env();
var version33 = "hash/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger46 = new Logger6(version33);
var Zeros2 = new Uint8Array(32);
Zeros2.fill(0);
var Partition2 = new RegExp("^((.*)\\.)?([^.]+)$");

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/message.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/typed-data.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version34 = "rlp/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger47 = new Logger6(version34);

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version35 = "address/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/address/lib.esm/index.js
var logger48 = new Logger6(version35);
function getChecksumAddress2(address) {
  if (!isHexString5(address, 20)) {
    logger48.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify5(keccak2563(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER2 = 9007199254740991;
function log102(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
var ibanLookup2 = {};
for (let i = 0; i < 10; i++) {
  ibanLookup2[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup2[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits2 = Math.floor(log102(MAX_SAFE_INTEGER2));
function ibanChecksum2(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup2[c];
  }).join("");
  while (expanded.length >= safeDigits2) {
    let block = expanded.substring(0, safeDigits2);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress3(address) {
  let result = null;
  if (typeof address !== "string") {
    logger48.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress2(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger48.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum2(address)) {
      logger48.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To164(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress2("0x" + result);
  } else {
    logger48.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version36 = "properties/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/properties/lib.esm/index.js
var logger49 = new Logger6(version36);
function defineReadOnly4(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/typed-data.js
var logger50 = new Logger6(version33);
var padding2 = new Uint8Array(32);
padding2.fill(0);
var NegativeOne9 = BigNumber5.from(-1);
var Zero9 = BigNumber5.from(0);
var One5 = BigNumber5.from(1);
var MaxUint2565 = BigNumber5.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var hexTrue2 = hexZeroPad4(One5.toHexString(), 32);
var hexFalse2 = hexZeroPad4(Zero9.toHexString(), 32);
function checkString2(key6) {
  return function(value) {
    if (typeof value !== "string") {
      logger50.throwArgumentError(`invalid domain value for ${JSON.stringify(key6)}`, `domain.${key6}`, value);
    }
    return value;
  };
}
var domainChecks2 = {
  name: checkString2("name"),
  version: checkString2("version"),
  chainId: function(value) {
    try {
      return BigNumber5.from(value).toString();
    } catch (error) {
    }
    return logger50.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress3(value).toLowerCase();
    } catch (error) {
    }
    return logger50.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify5(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify5(bytes);
    } catch (error) {
    }
    return logger50.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};

// node_modules/ethers/node_modules/@ethersproject/wordlists/lib.esm/_version.js
init_define_process_env();
var version37 = "wordlists/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist = false;
var logger51 = new Logger6(version37);
var Wordlist = class {
  constructor(locale) {
    logger51.checkAbstract(new.target, Wordlist);
    defineReadOnly4(this, "locale", locale);
  }
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  join(words4) {
    return words4.join(" ");
  }
  static check(wordlist4) {
    const words4 = [];
    for (let i = 0; i < 2048; i++) {
      const word = wordlist4.getWord(i);
      if (i !== wordlist4.getWordIndex(word)) {
        return "0x";
      }
      words4.push(word);
    }
    return id2(words4.join("\n") + "\n");
  }
  static register(lang, name2) {
    if (!name2) {
      name2 = lang.locale;
    }
    if (exportWordlist) {
      try {
        const anyGlobal4 = window;
        if (anyGlobal4._ethers && anyGlobal4._ethers.wordlists) {
          if (!anyGlobal4._ethers.wordlists[name2]) {
            defineReadOnly4(anyGlobal4._ethers.wordlists, name2, lang);
          }
        }
      } catch (error) {
      }
    }
  }
};

// node_modules/ethers/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
init_define_process_env();
var words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
var wordlist = null;
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var LangEn = class extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(index) {
    loadWords(this);
    return wordlist[index];
  }
  getWordIndex(word) {
    loadWords(this);
    return wordlist.indexOf(word);
  }
};
var langEn = new LangEn();
Wordlist.register(langEn);

// node_modules/ethers/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
var wordlists = {
  en: langEn
};

// node_modules/ethers/node_modules/@ethersproject/wordlists/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version38 = "logger/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors6 = false;
var _censorErrors6 = false;
var LogLevels6 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel6 = LogLevels6["default"];
var _globalLogger6 = null;
function _checkNormalize6() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError6 = _checkNormalize6();
var LogLevel6;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel6 || (LogLevel6 = {}));
var ErrorCode6;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode6 || (ErrorCode6 = {}));
var HEX6 = "0123456789abcdef";
var Logger7 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels6[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel6 > LogLevels6[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger7.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger7.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger7.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors6) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger7.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX6[value[i] >> 4];
            hex += HEX6[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger7.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError6) {
      this.throwError("platform missing String.prototype.normalize", Logger7.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError6
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger7.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger7.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger7.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger7.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger7.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger7.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger7.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger6) {
      _globalLogger6 = new Logger7(version38);
    }
    return _globalLogger6;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger7.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors6) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger7.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors6 = !!censorship;
    _permanentCensorErrors6 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels6[logLevel.toLowerCase()];
    if (level == null) {
      Logger7.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel6 = level;
  }
  static from(version134) {
    return new Logger7(version134);
  }
};
Logger7.errors = ErrorCode6;
Logger7.levels = LogLevel6;

// node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode2,
  Indexed: () => Indexed2,
  Interface: () => Interface2,
  LogDescription: () => LogDescription,
  Logger: () => Logger7,
  ParamType: () => ParamType,
  RLP: () => lib_exports7,
  SigningKey: () => SigningKey5,
  SupportedAlgorithm: () => SupportedAlgorithm4,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes4,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm7,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs7,
  Utf8ErrorReason: () => Utf8ErrorReason7,
  _TypedDataEncoder: () => TypedDataEncoder5,
  _fetchData: () => _fetchData2,
  _toEscapedUtf8String: () => _toEscapedUtf8String7,
  accessListify: () => accessListify3,
  arrayify: () => arrayify10,
  base58: () => Base582,
  base64: () => lib_exports4,
  checkProperties: () => checkProperties4,
  checkResultErrors: () => checkResultErrors2,
  commify: () => commify,
  computeAddress: () => computeAddress5,
  computeHmac: () => computeHmac4,
  computePublicKey: () => computePublicKey4,
  concat: () => concat6,
  deepCopy: () => deepCopy8,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath2,
  defineReadOnly: () => defineReadOnly10,
  entropyToMnemonic: () => entropyToMnemonic2,
  fetchJson: () => fetchJson2,
  formatBytes32String: () => formatBytes32String7,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress5,
  getContractAddress: () => getContractAddress3,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic4,
  hashMessage: () => hashMessage5,
  hexConcat: () => hexConcat4,
  hexDataLength: () => hexDataLength5,
  hexDataSlice: () => hexDataSlice6,
  hexStripZeros: () => hexStripZeros2,
  hexValue: () => hexValue2,
  hexZeroPad: () => hexZeroPad7,
  hexlify: () => hexlify8,
  id: () => id4,
  isAddress: () => isAddress,
  isBytes: () => isBytes10,
  isBytesLike: () => isBytesLike5,
  isHexString: () => isHexString10,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName4,
  joinSignature: () => joinSignature2,
  keccak256: () => keccak2569,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash4,
  nameprep: () => nameprep7,
  parseBytes32String: () => parseBytes32String7,
  parseEther: () => parseEther,
  parseTransaction: () => parse2,
  parseUnits: () => parseUnits,
  poll: () => poll2,
  randomBytes: () => randomBytes4,
  recoverAddress: () => recoverAddress3,
  recoverPublicKey: () => recoverPublicKey4,
  resolveProperties: () => resolveProperties4,
  ripemd160: () => ripemd1604,
  serializeTransaction: () => serialize3,
  sha256: () => sha2565,
  sha512: () => sha5124,
  shallowCopy: () => shallowCopy9,
  shuffled: () => shuffled3,
  solidityKeccak256: () => keccak25610,
  solidityPack: () => pack2,
  soliditySha256: () => sha2566,
  splitSignature: () => splitSignature2,
  stripZeros: () => stripZeros5,
  toUtf8Bytes: () => toUtf8Bytes8,
  toUtf8CodePoints: () => toUtf8CodePoints7,
  toUtf8String: () => toUtf8String7,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad3
});
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/fragments.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn6 = __toESM(require_bn());

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version39 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors7 = false;
var _censorErrors7 = false;
var LogLevels7 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel7 = LogLevels7["default"];
var _globalLogger7 = null;
function _checkNormalize7() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError7 = _checkNormalize7();
var LogLevel7;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel7 || (LogLevel7 = {}));
var ErrorCode7;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode7 || (ErrorCode7 = {}));
var HEX7 = "0123456789abcdef";
var Logger8 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels7[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel7 > LogLevels7[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger8.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger8.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger8.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors7) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger8.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX7[value[i] >> 4];
            hex += HEX7[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode7.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode7.CALL_EXCEPTION:
      case ErrorCode7.INSUFFICIENT_FUNDS:
      case ErrorCode7.MISSING_NEW:
      case ErrorCode7.NONCE_EXPIRED:
      case ErrorCode7.REPLACEMENT_UNDERPRICED:
      case ErrorCode7.TRANSACTION_REPLACED:
      case ErrorCode7.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger8.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError7) {
      this.throwError("platform missing String.prototype.normalize", Logger8.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError7
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger8.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger8.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger8.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger8.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger8.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger8.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger8.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger7) {
      _globalLogger7 = new Logger8(version39);
    }
    return _globalLogger7;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger8.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors7) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger8.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors7 = !!censorship;
    _permanentCensorErrors7 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels7[logLevel.toLowerCase()];
    if (level == null) {
      Logger8.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel7 = level;
  }
  static from(version134) {
    return new Logger8(version134);
  }
};
Logger8.errors = ErrorCode7;
Logger8.levels = LogLevel7;

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version40 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger52 = new Logger8(version40);
function isHexable5(value) {
  return !!value.toHexString;
}
function addSlice5(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice5(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger5(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes6(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger5(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger5(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify6(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger52.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice5(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable5(value)) {
    value = value.toHexString();
  }
  if (isHexString6(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger52.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice5(new Uint8Array(result));
  }
  if (isBytes6(value)) {
    return addSlice5(new Uint8Array(value));
  }
  return logger52.throwArgumentError("invalid arrayify value", "value", value);
}
function concat4(items) {
  const objects = items.map((item) => arrayify6(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice5(result);
}
function isHexString6(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters5 = "0123456789abcdef";
function hexlify6(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger52.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters5[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable5(value)) {
    return value.toHexString();
  }
  if (isHexString6(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger52.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes6(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters5[(v & 240) >> 4] + HexCharacters5[v & 15];
    }
    return result;
  }
  return logger52.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataSlice4(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify6(data);
  } else if (!isHexString6(data) || data.length % 2) {
    logger52.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat3(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify6(item).substring(2);
  });
  return result;
}
function hexZeroPad5(value, length) {
  if (typeof value !== "string") {
    value = hexlify6(value);
  } else if (!isHexString6(value)) {
    logger52.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger52.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version41 = "bignumber/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN6 = import_bn6.default.BN;
var logger53 = new Logger8(version41);
var _constructorGuard10 = {};
var MAX_SAFE5 = 9007199254740991;
function isBigNumberish5(value) {
  return value != null && (BigNumber6.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString6(value) || typeof value === "bigint" || isBytes6(value));
}
var _warnedToStringRadix5 = false;
var BigNumber6 = class {
  constructor(constructorGuard, hex) {
    logger53.checkNew(new.target, BigNumber6);
    if (constructorGuard !== _constructorGuard10) {
      logger53.throwError("cannot call constructor directly; use BigNumber.from", Logger8.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber5(toBN5(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber5(toBN5(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber6.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber5(toBN5(this).add(toBN5(other)));
  }
  sub(other) {
    return toBigNumber5(toBN5(this).sub(toBN5(other)));
  }
  div(other) {
    const o = BigNumber6.from(other);
    if (o.isZero()) {
      throwFault9("division-by-zero", "div");
    }
    return toBigNumber5(toBN5(this).div(toBN5(other)));
  }
  mul(other) {
    return toBigNumber5(toBN5(this).mul(toBN5(other)));
  }
  mod(other) {
    const value = toBN5(other);
    if (value.isNeg()) {
      throwFault9("division-by-zero", "mod");
    }
    return toBigNumber5(toBN5(this).umod(value));
  }
  pow(other) {
    const value = toBN5(other);
    if (value.isNeg()) {
      throwFault9("negative-power", "pow");
    }
    return toBigNumber5(toBN5(this).pow(value));
  }
  and(other) {
    const value = toBN5(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault9("unbound-bitwise-result", "and");
    }
    return toBigNumber5(toBN5(this).and(value));
  }
  or(other) {
    const value = toBN5(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault9("unbound-bitwise-result", "or");
    }
    return toBigNumber5(toBN5(this).or(value));
  }
  xor(other) {
    const value = toBN5(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault9("unbound-bitwise-result", "xor");
    }
    return toBigNumber5(toBN5(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault9("negative-width", "mask");
    }
    return toBigNumber5(toBN5(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault9("negative-width", "shl");
    }
    return toBigNumber5(toBN5(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault9("negative-width", "shr");
    }
    return toBigNumber5(toBN5(this).shrn(value));
  }
  eq(other) {
    return toBN5(this).eq(toBN5(other));
  }
  lt(other) {
    return toBN5(this).lt(toBN5(other));
  }
  lte(other) {
    return toBN5(this).lte(toBN5(other));
  }
  gt(other) {
    return toBN5(this).gt(toBN5(other));
  }
  gte(other) {
    return toBN5(this).gte(toBN5(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN5(this).isZero();
  }
  toNumber() {
    try {
      return toBN5(this).toNumber();
    } catch (error) {
      throwFault9("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger53.throwError("this platform does not support BigInt", Logger8.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix5) {
          _warnedToStringRadix5 = true;
          logger53.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger53.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger8.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger53.throwError("BigNumber.toString does not accept parameters", Logger8.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN5(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber6) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber6(_constructorGuard10, toHex5(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber6(_constructorGuard10, toHex5(new BN6(value)));
      }
      return logger53.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault9("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE5 || value <= -MAX_SAFE5) {
        throwFault9("overflow", "BigNumber.from", value);
      }
      return BigNumber6.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber6.from(anyValue.toString());
    }
    if (isBytes6(anyValue)) {
      return BigNumber6.from(hexlify6(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber6.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString6(hex) || hex[0] === "-" && isHexString6(hex.substring(1))) {
            return BigNumber6.from(hex);
          }
        }
      }
    }
    return logger53.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex5(value) {
  if (typeof value !== "string") {
    return toHex5(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger53.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex5(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber5(value) {
  return BigNumber6.from(toHex5(value));
}
function toBN5(value) {
  const hex = BigNumber6.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN6("-" + hex.substring(3), 16);
  }
  return new BN6(hex.substring(2), 16);
}
function throwFault9(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger53.throwError(fault, Logger8.errors.NUMERIC_FAULT, params);
}
function _base36To165(value) {
  return new BN6(value, 36).toString(16);
}

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger54 = new Logger8(version41);
var _constructorGuard11 = {};
var Zero10 = BigNumber6.from(0);
var NegativeOne10 = BigNumber6.from(-1);
function throwFault10(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger54.throwError(message, Logger8.errors.NUMERIC_FAULT, params);
}
var zeros5 = "0";
while (zeros5.length < 256) {
  zeros5 += zeros5;
}
function getMultiplier5(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber6.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros5.substring(0, decimals);
  }
  return logger54.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed6(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier5(decimals);
  value = BigNumber6.from(value);
  const negative = value.lt(Zero10);
  if (negative) {
    value = value.mul(NegativeOne10);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed6(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier5(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger54.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger54.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger54.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault10("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber6.from(whole);
  const fractionValue = BigNumber6.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne10);
  }
  return wei;
}
var FixedFormat5 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard11) {
      logger54.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger8.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier5(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat5) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger54.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger54.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger54.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger54.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat5(_constructorGuard11, signed, width, decimals);
  }
};
var FixedNumber5 = class {
  constructor(constructorGuard, hex, value, format) {
    logger54.checkNew(new.target, FixedNumber5);
    if (constructorGuard !== _constructorGuard11) {
      logger54.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger8.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger54.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed6(this._value, this.format.decimals);
    const b = parseFixed6(other._value, other.format.decimals);
    return FixedNumber5.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed6(this._value, this.format.decimals);
    const b = parseFixed6(other._value, other.format.decimals);
    return FixedNumber5.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed6(this._value, this.format.decimals);
    const b = parseFixed6(other._value, other.format.decimals);
    return FixedNumber5.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed6(this._value, this.format.decimals);
    const b = parseFixed6(other._value, other.format.decimals);
    return FixedNumber5.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber5.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE5.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber5.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE5.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger54.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber5.from("1" + zeros5.substring(0, decimals), this.format);
    const bump = BUMP5.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger54.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber6.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad5(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber5.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish5(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber5.fromString(formatFixed6(value, decimals), FixedFormat5.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat5.from(format);
    const numeric = parseFixed6(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero10)) {
      throwFault10("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad5(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed6(numeric, fixedFormat.decimals);
    return new FixedNumber5(_constructorGuard11, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat5.from(format);
    if (arrayify6(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber6.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed6(numeric, fixedFormat.decimals);
    return new FixedNumber5(_constructorGuard11, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber5.fromString(value, format);
    }
    if (isBytes6(value)) {
      return FixedNumber5.fromBytes(value, format);
    }
    try {
      return FixedNumber5.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger8.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger54.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE5 = FixedNumber5.from(1);
var BUMP5 = FixedNumber5.from("0.5");

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version42 = "properties/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/lib.esm/index.js
var logger55 = new Logger8(version42);
function defineReadOnly5(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic3(ctor, key6) {
  for (let i = 0; i < 32; i++) {
    if (ctor[key6]) {
      return ctor[key6];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
var opaque2 = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen2(object) {
  if (object === void 0 || object === null || opaque2[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
      let value = null;
      try {
        value = object[keys[i]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen2(value)) {
        return false;
      }
    }
    return true;
  }
  return logger55.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy2(object) {
  if (_isFrozen2(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy4(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key6 in object) {
      const value = object[key6];
      if (value === void 0) {
        continue;
      }
      defineReadOnly5(result, key6, deepCopy4(value));
    }
    return result;
  }
  return logger55.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy4(object) {
  return _deepCopy2(object);
}
var Description2 = class {
  constructor(info) {
    for (const key6 in info) {
      this[key6] = deepCopy4(info[key6]);
    }
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/_version.js
init_define_process_env();
var version43 = "abi/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/fragments.js
var logger56 = new Logger8(version43);
var _constructorGuard12 = {};
var ModifiersBytes = { calldata: true, memory: true, storage: true };
var ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name2) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger56.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i) {
    logger56.throwArgumentError(`unexpected character at position ${i}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i = 0; i < param.length; i++) {
    let c = param[i];
    switch (c) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError(i);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError(i);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i);
              }
              if (node.indexed) {
                throwError(i);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError(i);
        }
        node.type += c;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError(i);
        }
        node.type += c;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c;
        } else {
          throwError(i);
        }
    }
  }
  if (node.parent) {
    logger56.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key6 in params) {
    defineReadOnly5(object, key6, params[key6]);
  }
}
var FormatTypes = Object.freeze({
  sighash: "sighash",
  minimal: "minimal",
  full: "full",
  json: "json"
});
var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
var ParamType = class {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard12) {
      logger56.throwError("use fromString", Logger8.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger56.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard12, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node) {
      return ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
};
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
var Fragment = class {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard12) {
      logger56.throwError("use a static from method", Logger8.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger56.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger56.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
};
var EventFragment = class extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger56.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger56.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard12, params);
  }
  static fromString(value) {
    let match = value.match(regexParen);
    if (!match) {
      logger56.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger56.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
};
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger56.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger56.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber6.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger56.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger56.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger56.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger56.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger56.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
var ConstructorFragment = class extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger56.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    if (format === FormatTypes.sighash) {
      logger56.throwError("cannot format a constructor for sighash", Logger8.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger56.throwArgumentError("invalid constructor object", "value", value);
    }
    let state = verifyState(value);
    if (state.constant) {
      logger56.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? BigNumber6.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard12, params);
  }
  static fromString(value) {
    let params = { type: "constructor" };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger56.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
};
var FunctionFragment = class extends ConstructorFragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger56.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
        outputs: this.outputs.map((output) => JSON.parse(output.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger56.throwArgumentError("invalid function object", "value", value);
    }
    let state = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? BigNumber6.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard12, params);
  }
  static fromString(value) {
    let params = { type: "function" };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger56.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger56.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger56.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
};
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger56.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
var ErrorFragment = class extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger56.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger56.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard12, params));
  }
  static fromString(value) {
    let params = { type: "error" };
    let parens = value.match(regexParen);
    if (!parens) {
      logger56.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
};
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger56.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c = value[offset];
    if (c === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c;
      if (c === "(") {
        depth++;
      } else if (c === ")") {
        depth--;
        if (depth === -1) {
          logger56.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/abi-coder.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
init_define_process_env();
var logger57 = new Logger8(version43);
function checkResultErrors2(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key6 in object) {
      const childPath = path.slice();
      childPath.push(key6);
      try {
        checkErrors(childPath, object[key6]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
var Coder = class {
  constructor(name2, type, localName, dynamic) {
    this.name = name2;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger57.throwArgumentError(message, this.localName, value);
  }
};
var Writer = class {
  constructor(wordSize) {
    defineReadOnly5(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat3(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this._writeData(concat4(writer._data));
  }
  writeBytes(value) {
    let bytes = arrayify6(value);
    const paddingOffset = bytes.length % this.wordSize;
    if (paddingOffset) {
      bytes = concat4([bytes, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes);
  }
  _getValue(value) {
    let bytes = arrayify6(BigNumber6.from(value));
    if (bytes.length > this.wordSize) {
      logger57.throwError("value out-of-bounds", Logger8.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes.length
      });
    }
    if (bytes.length % this.wordSize) {
      bytes = concat4([this._padding.slice(bytes.length % this.wordSize), bytes]);
    }
    return bytes;
  }
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset] = this._getValue(value);
    };
  }
};
var Reader = class {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    defineReadOnly5(this, "_data", arrayify6(data));
    defineReadOnly5(this, "wordSize", wordSize || 32);
    defineReadOnly5(this, "_coerceFunc", coerceFunc);
    defineReadOnly5(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify6(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(name2, value) {
    let match = name2.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name2, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name2, value);
    }
    return Reader.coerce(name2, value);
  }
  _peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger57.throwError("data out-of-bounds", Logger8.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length, loose) {
    let bytes = this._peekBytes(0, length, !!loose);
    this._offset += bytes.length;
    return bytes.slice(0, length);
  }
  readValue() {
    return BigNumber6.from(this.readBytes(this.wordSize));
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/address.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha33 = __toESM(require_sha3());
function keccak2564(data) {
  return "0x" + import_js_sha33.default.keccak_256(arrayify6(data));
}

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version44 = "rlp/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger58 = new Logger8(version44);

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version45 = "address/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/lib.esm/index.js
var logger59 = new Logger8(version45);
function getChecksumAddress3(address) {
  if (!isHexString6(address, 20)) {
    logger59.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify6(keccak2564(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER3 = 9007199254740991;
function log103(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
var ibanLookup3 = {};
for (let i = 0; i < 10; i++) {
  ibanLookup3[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup3[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits3 = Math.floor(log103(MAX_SAFE_INTEGER3));
function ibanChecksum3(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup3[c];
  }).join("");
  while (expanded.length >= safeDigits3) {
    let block = expanded.substring(0, safeDigits3);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress4(address) {
  let result = null;
  if (typeof address !== "string") {
    logger59.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress3(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger59.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum3(address)) {
      logger59.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To165(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress3("0x" + result);
  } else {
    logger59.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/address.js
var AddressCoder = class extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress4(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress4(hexZeroPad5(reader.readValue().toHexString(), 20));
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/array.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
init_define_process_env();
var AnonymousCoder = class extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/array.js
var logger60 = new Logger8(version43);
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger60.throwError("cannot encode object for signature with missing names", Logger8.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name2]) {
        logger60.throwError("cannot encode object for signature with duplicate names", Logger8.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name2] = true;
      return values[name2];
    });
  } else {
    logger60.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger60.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger8.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger8.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name2] = value;
    }
  });
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (value instanceof Error) {
      Object.defineProperty(values, i, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
var ArrayCoder = class extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    logger60.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readValue().toNumber();
      if (count * 32 > reader._data.length) {
        logger60.throwError("insufficient data length", Logger8.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count
        });
      }
    }
    let coders = [];
    for (let i = 0; i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
init_define_process_env();
var BooleanCoder = class extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
init_define_process_env();
var DynamicBytesCoder = class extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify6(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
};
var BytesCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify6(super.decode(reader)));
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
init_define_process_env();
var FixedBytesCoder = class extends Coder {
  constructor(size, localName) {
    let name2 = "bytes" + String(size);
    super(name2, name2, localName, false);
    this.size = size;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data = arrayify6(value);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify6(reader.readBytes(this.size)));
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/null.js
init_define_process_env();
var NullCoder = class extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/number.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();
var NegativeOne11 = BigNumber6.from(-1);
var Zero11 = BigNumber6.from(0);
var One6 = BigNumber6.from(1);
var Two4 = BigNumber6.from(2);
var WeiPerEther4 = BigNumber6.from("1000000000000000000");
var MaxUint2566 = BigNumber6.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2564 = BigNumber6.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2564 = BigNumber6.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/number.js
var NumberCoder = class extends Coder {
  constructor(size, signed, localName) {
    const name2 = (signed ? "int" : "uint") + size * 8;
    super(name2, name2, localName, false);
    this.size = size;
    this.signed = signed;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v = BigNumber6.from(value);
    let maxUintValue = MaxUint2566.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v.gt(bounds) || v.lt(bounds.add(One6).mul(NegativeOne11))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v.lt(Zero11) || v.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v = v.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/string.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version46 = "strings/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger61 = new Logger8(version46);
var UnicodeNormalizationForm3;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm3 || (UnicodeNormalizationForm3 = {}));
var Utf8ErrorReason3;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason3 || (Utf8ErrorReason3 = {}));
function errorFunc3(reason, offset, bytes, output, badCodepoint) {
  return logger61.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc3(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason3.BAD_PREFIX || reason === Utf8ErrorReason3.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason3.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc3(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason3.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc3(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs3 = Object.freeze({
  error: errorFunc3,
  ignore: ignoreFunc3,
  replace: replaceFunc3
});
function getUtf8CodePoints2(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs3.error;
  }
  bytes = arrayify6(bytes);
  const result = [];
  let i = 0;
  while (i < bytes.length) {
    const c = bytes[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError(Utf8ErrorReason3.UNEXPECTED_CONTINUE, i - 1, bytes, result);
      } else {
        i += onError(Utf8ErrorReason3.BAD_PREFIX, i - 1, bytes, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes.length) {
      i += onError(Utf8ErrorReason3.OVERRUN, i - 1, bytes, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes[i];
      if ((nextChar & 192) != 128) {
        i += onError(Utf8ErrorReason3.MISSING_CONTINUE, i, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError(Utf8ErrorReason3.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError(Utf8ErrorReason3.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason3.OVERLONG, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes4(str, form = UnicodeNormalizationForm3.current) {
  if (form != UnicodeNormalizationForm3.current) {
    logger61.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify6(result);
}
function _toUtf8String3(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String3(bytes, onError) {
  return _toUtf8String3(getUtf8CodePoints2(bytes, onError));
}

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes23(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable3(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable3(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges3 = createRangeTable3("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags3 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
var Table_B_2_lut_abs3 = createTable3("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel3 = createTable3("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex3 = createTable3("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes23);
var Table_C_ranges3 = createRangeTable3("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/string.js
var StringCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes4(value));
  }
  decode(reader) {
    return toUtf8String3(super.decode(reader));
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
init_define_process_env();
var TupleCoder = class extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      values[name2] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/abi-coder.js
var logger62 = new Logger8(version43);
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var AbiCoder = class {
  constructor(coerceFunc) {
    logger62.checkNew(new.target, AbiCoder);
    defineReadOnly5(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      if (size === 0 || size > 256 || size % 8 !== 0) {
        logger62.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      if (size === 0 || size > 32) {
        logger62.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size, param.name);
    }
    return logger62.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data, allowLoose) {
    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types, values) {
    if (types.length !== values.length) {
      logger62.throwError("types/values length mismatch", Logger8.errors.INVALID_ARGUMENT, {
        count: { types: types.length, values: values.length },
        value: { types, values }
      });
    }
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types, data, loose) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify6(data), loose));
  }
};
var defaultAbiCoder = new AbiCoder();

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/interface.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/id.js
init_define_process_env();
function id3(text) {
  return keccak2564(toUtf8Bytes4(text));
}

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/namehash.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/_version.js
init_define_process_env();
var version47 = "hash/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger63 = new Logger8(version47);
var Zeros3 = new Uint8Array(32);
Zeros3.fill(0);
var Partition3 = new RegExp("^((.*)\\.)?([^.]+)$");

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/message.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/typed-data.js
init_define_process_env();
var logger64 = new Logger8(version47);
var padding3 = new Uint8Array(32);
padding3.fill(0);
var NegativeOne12 = BigNumber6.from(-1);
var Zero12 = BigNumber6.from(0);
var One7 = BigNumber6.from(1);
var MaxUint2567 = BigNumber6.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var hexTrue3 = hexZeroPad5(One7.toHexString(), 32);
var hexFalse3 = hexZeroPad5(Zero12.toHexString(), 32);
function checkString3(key6) {
  return function(value) {
    if (typeof value !== "string") {
      logger64.throwArgumentError(`invalid domain value for ${JSON.stringify(key6)}`, `domain.${key6}`, value);
    }
    return value;
  };
}
var domainChecks3 = {
  name: checkString3("name"),
  version: checkString3("version"),
  chainId: function(value) {
    try {
      return BigNumber6.from(value).toString();
    } catch (error) {
    }
    return logger64.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress4(value).toLowerCase();
    } catch (error) {
    }
    return logger64.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify6(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify6(bytes);
    } catch (error) {
    }
    return logger64.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};

// node_modules/ethers/node_modules/@ethersproject/abi/lib.esm/interface.js
var logger65 = new Logger8(version43);
var LogDescription = class extends Description2 {
};
var TransactionDescription = class extends Description2 {
};
var ErrorDescription = class extends Description2 {
};
var Indexed2 = class extends Description2 {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
};
var BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
var Interface2 = class {
  constructor(fragments) {
    logger65.checkNew(new.target, Interface2);
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    defineReadOnly5(this, "fragments", abi.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly5(this, "_abiCoder", getStatic3(new.target, "getAbiCoder")());
    defineReadOnly5(this, "functions", {});
    defineReadOnly5(this, "errors", {});
    defineReadOnly5(this, "events", {});
    defineReadOnly5(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger65.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly5(this, "deploy", fragment);
          return;
        case "function":
          bucket = this.functions;
          break;
        case "event":
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature6 = fragment.format();
      if (bucket[signature6]) {
        logger65.warn("duplicate definition - " + signature6);
        return;
      }
      bucket[signature6] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly5(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly5(this, "_isInterface", true);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.full;
    }
    if (format === FormatTypes.sighash) {
      logger65.throwArgumentError("interface does not support formatting sighash", "format", format);
    }
    const abi = this.fragments.map((fragment) => fragment.format(format));
    if (format === FormatTypes.json) {
      return JSON.stringify(abi.map((j) => JSON.parse(j)));
    }
    return abi;
  }
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress4(address);
  }
  static getSighash(fragment) {
    return hexDataSlice4(id3(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id3(eventFragment.format());
  }
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString6(nameOrSignatureOrSighash)) {
      for (const name2 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name2)) {
          return this.functions[name2];
        }
      }
      logger65.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f) => f.split("(")[0] === name2);
      if (matching.length === 0) {
        logger65.throwArgumentError("no matching function", "name", name2);
      } else if (matching.length > 1) {
        logger65.throwArgumentError("multiple matching functions", "name", name2);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger65.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString6(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name2 in this.events) {
        if (topichash === this.getEventTopic(name2)) {
          return this.events[name2];
        }
      }
      logger65.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f) => f.split("(")[0] === name2);
      if (matching.length === 0) {
        logger65.throwArgumentError("no matching event", "name", name2);
      } else if (matching.length > 1) {
        logger65.throwArgumentError("multiple matching events", "name", name2);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger65.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  getError(nameOrSignatureOrSighash) {
    if (isHexString6(nameOrSignatureOrSighash)) {
      const getSighash = getStatic3(this.constructor, "getSighash");
      for (const name2 in this.errors) {
        const error = this.errors[name2];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name2];
        }
      }
      logger65.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f) => f.split("(")[0] === name2);
      if (matching.length === 0) {
        logger65.throwArgumentError("no matching error", "name", name2);
      } else if (matching.length > 1) {
        logger65.throwArgumentError("multiple matching errors", "name", name2);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger65.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_) {
          throw error;
        }
      }
    }
    return getStatic3(this.constructor, "getSighash")(fragment);
  }
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic3(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data) {
    return this._abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes = arrayify6(data);
    if (hexlify6(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
      logger65.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify6(bytes));
    }
    return this._decodeParams(fragment.inputs, bytes.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify6(concat4([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values || [])
    ]));
  }
  decodeFunctionData(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes = arrayify6(data);
    if (hexlify6(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger65.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify6(bytes));
    }
    return this._decodeParams(functionFragment.inputs, bytes.slice(4));
  }
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify6(concat4([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values || [])
    ]));
  }
  decodeFunctionResult(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes = arrayify6(data);
    let reason = null;
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes);
        } catch (error) {
        }
        break;
      case 4: {
        const selector = hexlify6(bytes.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
        } else {
          try {
            const error = this.getError(selector);
            errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
            errorName = error.name;
            errorSignature = error.format();
          } catch (error) {
            console.log(error);
          }
        }
        break;
      }
    }
    return logger65.throwError("call revert exception", Logger8.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify6(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger65.throwError("too many arguments for " + eventFragment.format(), Logger8.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id3(value);
      } else if (param.type === "bytes") {
        return keccak2564(hexlify6(value));
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad5(hexlify6(value), 32);
    };
    values.forEach((value, index) => {
      let param = eventFragment.inputs[index];
      if (!param.indexed) {
        if (value != null) {
          logger65.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger65.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger65.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id3(value));
        } else if (param.type === "bytes") {
          topics.push(keccak2564(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  decodeEventLog(eventFragment, data, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString6(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger65.throwError("fragment/topic mismatch", Logger8.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat4(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index] = new Indexed2({ _isIndexed: true, hash: null });
        } else if (dynamic[index]) {
          result[index] = new Indexed2({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index] = error;
          }
        }
      } else {
        try {
          result[index] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index] = error;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i = 0; i < result.length; i++) {
      const value = result[i];
      if (value instanceof Error) {
        Object.defineProperty(result, i, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber6.from(tx.value || "0")
    });
  }
  parseLog(log) {
    let fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  }
  parseError(data) {
    const hexData = hexlify6(data);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
};

// node_modules/ethers/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version48 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors8 = false;
var _censorErrors8 = false;
var LogLevels8 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel8 = LogLevels8["default"];
var _globalLogger8 = null;
function _checkNormalize8() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError8 = _checkNormalize8();
var LogLevel8;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel8 || (LogLevel8 = {}));
var ErrorCode8;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode8 || (ErrorCode8 = {}));
var HEX8 = "0123456789abcdef";
var Logger9 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels8[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel8 > LogLevels8[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger9.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger9.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger9.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors8) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger9.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX8[value[i] >> 4];
            hex += HEX8[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode8.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode8.CALL_EXCEPTION:
      case ErrorCode8.INSUFFICIENT_FUNDS:
      case ErrorCode8.MISSING_NEW:
      case ErrorCode8.NONCE_EXPIRED:
      case ErrorCode8.REPLACEMENT_UNDERPRICED:
      case ErrorCode8.TRANSACTION_REPLACED:
      case ErrorCode8.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger9.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError8) {
      this.throwError("platform missing String.prototype.normalize", Logger9.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError8
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger9.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger9.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger9.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger9.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger9.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger9.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger9.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger8) {
      _globalLogger8 = new Logger9(version48);
    }
    return _globalLogger8;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger9.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors8) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger9.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors8 = !!censorship;
    _permanentCensorErrors8 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels8[logLevel.toLowerCase()];
    if (level == null) {
      Logger9.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel8 = level;
  }
  static from(version134) {
    return new Logger9(version134);
  }
};
Logger9.errors = ErrorCode8;
Logger9.levels = LogLevel8;

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version49 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger66 = new Logger9(version49);
function isHexable6(value) {
  return !!value.toHexString;
}
function addSlice6(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice6(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike4(value) {
  return isHexString7(value) && !(value.length % 2) || isBytes7(value);
}
function isInteger6(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes7(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger6(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger6(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify7(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger66.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice6(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable6(value)) {
    value = value.toHexString();
  }
  if (isHexString7(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger66.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice6(new Uint8Array(result));
  }
  if (isBytes7(value)) {
    return addSlice6(new Uint8Array(value));
  }
  return logger66.throwArgumentError("invalid arrayify value", "value", value);
}
function concat5(items) {
  const objects = items.map((item) => arrayify7(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice6(result);
}
function stripZeros4(value) {
  let result = arrayify7(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function isHexString7(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters6 = "0123456789abcdef";
function hexlify7(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger66.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters6[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable6(value)) {
    return value.toHexString();
  }
  if (isHexString7(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger66.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes7(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters6[(v & 240) >> 4] + HexCharacters6[v & 15];
    }
    return result;
  }
  return logger66.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength4(data) {
  if (typeof data !== "string") {
    data = hexlify7(data);
  } else if (!isHexString7(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice5(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify7(data);
  } else if (!isHexString7(data) || data.length % 2) {
    logger66.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexZeroPad6(value, length) {
  if (typeof value !== "string") {
    value = hexlify7(value);
  } else if (!isHexString7(value)) {
    logger66.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger66.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn7 = __toESM(require_bn());

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version50 = "bignumber/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN7 = import_bn7.default.BN;
var logger67 = new Logger9(version50);
var _constructorGuard13 = {};
var MAX_SAFE6 = 9007199254740991;
function isBigNumberish6(value) {
  return value != null && (BigNumber7.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString7(value) || typeof value === "bigint" || isBytes7(value));
}
var _warnedToStringRadix6 = false;
var BigNumber7 = class {
  constructor(constructorGuard, hex) {
    logger67.checkNew(new.target, BigNumber7);
    if (constructorGuard !== _constructorGuard13) {
      logger67.throwError("cannot call constructor directly; use BigNumber.from", Logger9.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber6(toBN6(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber6(toBN6(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber7.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber6(toBN6(this).add(toBN6(other)));
  }
  sub(other) {
    return toBigNumber6(toBN6(this).sub(toBN6(other)));
  }
  div(other) {
    const o = BigNumber7.from(other);
    if (o.isZero()) {
      throwFault11("division-by-zero", "div");
    }
    return toBigNumber6(toBN6(this).div(toBN6(other)));
  }
  mul(other) {
    return toBigNumber6(toBN6(this).mul(toBN6(other)));
  }
  mod(other) {
    const value = toBN6(other);
    if (value.isNeg()) {
      throwFault11("division-by-zero", "mod");
    }
    return toBigNumber6(toBN6(this).umod(value));
  }
  pow(other) {
    const value = toBN6(other);
    if (value.isNeg()) {
      throwFault11("negative-power", "pow");
    }
    return toBigNumber6(toBN6(this).pow(value));
  }
  and(other) {
    const value = toBN6(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault11("unbound-bitwise-result", "and");
    }
    return toBigNumber6(toBN6(this).and(value));
  }
  or(other) {
    const value = toBN6(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault11("unbound-bitwise-result", "or");
    }
    return toBigNumber6(toBN6(this).or(value));
  }
  xor(other) {
    const value = toBN6(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault11("unbound-bitwise-result", "xor");
    }
    return toBigNumber6(toBN6(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault11("negative-width", "mask");
    }
    return toBigNumber6(toBN6(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault11("negative-width", "shl");
    }
    return toBigNumber6(toBN6(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault11("negative-width", "shr");
    }
    return toBigNumber6(toBN6(this).shrn(value));
  }
  eq(other) {
    return toBN6(this).eq(toBN6(other));
  }
  lt(other) {
    return toBN6(this).lt(toBN6(other));
  }
  lte(other) {
    return toBN6(this).lte(toBN6(other));
  }
  gt(other) {
    return toBN6(this).gt(toBN6(other));
  }
  gte(other) {
    return toBN6(this).gte(toBN6(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN6(this).isZero();
  }
  toNumber() {
    try {
      return toBN6(this).toNumber();
    } catch (error) {
      throwFault11("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger67.throwError("this platform does not support BigInt", Logger9.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix6) {
          _warnedToStringRadix6 = true;
          logger67.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger67.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger9.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger67.throwError("BigNumber.toString does not accept parameters", Logger9.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN6(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber7) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber7(_constructorGuard13, toHex6(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber7(_constructorGuard13, toHex6(new BN7(value)));
      }
      return logger67.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault11("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE6 || value <= -MAX_SAFE6) {
        throwFault11("overflow", "BigNumber.from", value);
      }
      return BigNumber7.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber7.from(anyValue.toString());
    }
    if (isBytes7(anyValue)) {
      return BigNumber7.from(hexlify7(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber7.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString7(hex) || hex[0] === "-" && isHexString7(hex.substring(1))) {
            return BigNumber7.from(hex);
          }
        }
      }
    }
    return logger67.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex6(value) {
  if (typeof value !== "string") {
    return toHex6(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger67.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex6(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber6(value) {
  return BigNumber7.from(toHex6(value));
}
function toBN6(value) {
  const hex = BigNumber7.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN7("-" + hex.substring(3), 16);
  }
  return new BN7(hex.substring(2), 16);
}
function throwFault11(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger67.throwError(fault, Logger9.errors.NUMERIC_FAULT, params);
}
function _base36To166(value) {
  return new BN7(value, 36).toString(16);
}
function _base16To366(value) {
  return new BN7(value, 16).toString(36);
}

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger68 = new Logger9(version50);
var _constructorGuard14 = {};
var Zero13 = BigNumber7.from(0);
var NegativeOne13 = BigNumber7.from(-1);
function throwFault12(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger68.throwError(message, Logger9.errors.NUMERIC_FAULT, params);
}
var zeros6 = "0";
while (zeros6.length < 256) {
  zeros6 += zeros6;
}
function getMultiplier6(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber7.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros6.substring(0, decimals);
  }
  return logger68.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed7(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier6(decimals);
  value = BigNumber7.from(value);
  const negative = value.lt(Zero13);
  if (negative) {
    value = value.mul(NegativeOne13);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed7(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier6(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger68.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger68.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger68.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault12("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber7.from(whole);
  const fractionValue = BigNumber7.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne13);
  }
  return wei;
}
var FixedFormat6 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard14) {
      logger68.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger9.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier6(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat6) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger68.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger68.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger68.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger68.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat6(_constructorGuard14, signed, width, decimals);
  }
};
var FixedNumber6 = class {
  constructor(constructorGuard, hex, value, format) {
    logger68.checkNew(new.target, FixedNumber6);
    if (constructorGuard !== _constructorGuard14) {
      logger68.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger9.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger68.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed7(this._value, this.format.decimals);
    const b = parseFixed7(other._value, other.format.decimals);
    return FixedNumber6.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed7(this._value, this.format.decimals);
    const b = parseFixed7(other._value, other.format.decimals);
    return FixedNumber6.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed7(this._value, this.format.decimals);
    const b = parseFixed7(other._value, other.format.decimals);
    return FixedNumber6.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed7(this._value, this.format.decimals);
    const b = parseFixed7(other._value, other.format.decimals);
    return FixedNumber6.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber6.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE6.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber6.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE6.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger68.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber6.from("1" + zeros6.substring(0, decimals), this.format);
    const bump = BUMP6.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger68.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber7.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad6(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber6.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish6(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber6.fromString(formatFixed7(value, decimals), FixedFormat6.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat6.from(format);
    const numeric = parseFixed7(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero13)) {
      throwFault12("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad6(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed7(numeric, fixedFormat.decimals);
    return new FixedNumber6(_constructorGuard14, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat6.from(format);
    if (arrayify7(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber7.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed7(numeric, fixedFormat.decimals);
    return new FixedNumber6(_constructorGuard14, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber6.fromString(value, format);
    }
    if (isBytes7(value)) {
      return FixedNumber6.fromBytes(value, format);
    }
    try {
      return FixedNumber6.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger9.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger68.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE6 = FixedNumber6.from(1);
var BUMP6 = FixedNumber6.from("0.5");

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha34 = __toESM(require_sha3());
function keccak2565(data) {
  return "0x" + import_js_sha34.default.keccak_256(arrayify7(data));
}

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version51 = "rlp/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger69 = new Logger9(version51);
function arrayifyInteger2(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode3(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode3(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger2(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike4(object)) {
    logger69.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify7(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger2(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode6(object) {
  return hexlify7(_encode3(object));
}

// node_modules/ethers/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version52 = "address/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/address/lib.esm/index.js
var logger70 = new Logger9(version52);
function getChecksumAddress4(address) {
  if (!isHexString7(address, 20)) {
    logger70.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify7(keccak2565(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER4 = 9007199254740991;
function log104(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
var ibanLookup4 = {};
for (let i = 0; i < 10; i++) {
  ibanLookup4[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup4[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits4 = Math.floor(log104(MAX_SAFE_INTEGER4));
function ibanChecksum4(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup4[c];
  }).join("");
  while (expanded.length >= safeDigits4) {
    let block = expanded.substring(0, safeDigits4);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress5(address) {
  let result = null;
  if (typeof address !== "string") {
    logger70.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress4(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger70.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum4(address)) {
      logger70.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To166(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress4("0x" + result);
  } else {
    logger70.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress5(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To366(getAddress5(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum4("XE00" + base36) + base36;
}
function getContractAddress3(transaction) {
  let from = null;
  try {
    from = getAddress5(transaction.from);
  } catch (error) {
    logger70.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros4(arrayify7(BigNumber7.from(transaction.nonce).toHexString()));
  return getAddress5(hexDataSlice5(keccak2565(encode6([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
  if (hexDataLength4(salt) !== 32) {
    logger70.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength4(initCodeHash) !== 32) {
    logger70.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress5(hexDataSlice5(keccak2565(concat5(["0xff", getAddress5(from), salt, initCodeHash])), 12));
}

// node_modules/ethers/node_modules/@ethersproject/base64/lib.esm/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  decode: () => decode3,
  encode: () => encode7
});
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/base64/lib.esm/base64.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/base64/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/base64/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/base64/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version53 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/base64/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors9 = false;
var _censorErrors9 = false;
var LogLevels9 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel9 = LogLevels9["default"];
var _globalLogger9 = null;
function _checkNormalize9() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError9 = _checkNormalize9();
var LogLevel9;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel9 || (LogLevel9 = {}));
var ErrorCode9;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode9 || (ErrorCode9 = {}));
var HEX9 = "0123456789abcdef";
var Logger10 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels9[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel9 > LogLevels9[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger10.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger10.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger10.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors9) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger10.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX9[value[i] >> 4];
            hex += HEX9[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode9.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode9.CALL_EXCEPTION:
      case ErrorCode9.INSUFFICIENT_FUNDS:
      case ErrorCode9.MISSING_NEW:
      case ErrorCode9.NONCE_EXPIRED:
      case ErrorCode9.REPLACEMENT_UNDERPRICED:
      case ErrorCode9.TRANSACTION_REPLACED:
      case ErrorCode9.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger10.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError9) {
      this.throwError("platform missing String.prototype.normalize", Logger10.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError9
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger10.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger10.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger10.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger10.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger10.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger10.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger10.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger9) {
      _globalLogger9 = new Logger10(version53);
    }
    return _globalLogger9;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger10.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors9) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger10.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors9 = !!censorship;
    _permanentCensorErrors9 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels9[logLevel.toLowerCase()];
    if (level == null) {
      Logger10.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel9 = level;
  }
  static from(version134) {
    return new Logger10(version134);
  }
};
Logger10.errors = ErrorCode9;
Logger10.levels = LogLevel9;

// node_modules/ethers/node_modules/@ethersproject/base64/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version54 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/base64/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger71 = new Logger10(version54);
function isHexable7(value) {
  return !!value.toHexString;
}
function addSlice7(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice7(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger7(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes8(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger7(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger7(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify8(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger71.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice7(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable7(value)) {
    value = value.toHexString();
  }
  if (isHexString8(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger71.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice7(new Uint8Array(result));
  }
  if (isBytes8(value)) {
    return addSlice7(new Uint8Array(value));
  }
  return logger71.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString8(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

// node_modules/ethers/node_modules/@ethersproject/base64/lib.esm/base64.js
function decode3(textData) {
  textData = atob(textData);
  const data = [];
  for (let i = 0; i < textData.length; i++) {
    data.push(textData.charCodeAt(i));
  }
  return arrayify8(data);
}
function encode7(data) {
  data = arrayify8(data);
  let textData = "";
  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}

// node_modules/ethers/node_modules/@ethersproject/basex/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version55 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors10 = false;
var _censorErrors10 = false;
var LogLevels10 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel10 = LogLevels10["default"];
var _globalLogger10 = null;
function _checkNormalize10() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError10 = _checkNormalize10();
var LogLevel10;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel10 || (LogLevel10 = {}));
var ErrorCode10;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode10 || (ErrorCode10 = {}));
var HEX10 = "0123456789abcdef";
var Logger11 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels10[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel10 > LogLevels10[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger11.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger11.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger11.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors10) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger11.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX10[value[i] >> 4];
            hex += HEX10[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode10.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode10.CALL_EXCEPTION:
      case ErrorCode10.INSUFFICIENT_FUNDS:
      case ErrorCode10.MISSING_NEW:
      case ErrorCode10.NONCE_EXPIRED:
      case ErrorCode10.REPLACEMENT_UNDERPRICED:
      case ErrorCode10.TRANSACTION_REPLACED:
      case ErrorCode10.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger11.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError10) {
      this.throwError("platform missing String.prototype.normalize", Logger11.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError10
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger11.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger11.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger11.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger11.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger11.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger11.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger11.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger10) {
      _globalLogger10 = new Logger11(version55);
    }
    return _globalLogger10;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger11.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors10) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger11.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors10 = !!censorship;
    _permanentCensorErrors10 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels10[logLevel.toLowerCase()];
    if (level == null) {
      Logger11.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel10 = level;
  }
  static from(version134) {
    return new Logger11(version134);
  }
};
Logger11.errors = ErrorCode10;
Logger11.levels = LogLevel10;

// node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version56 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger72 = new Logger11(version56);
function isHexable8(value) {
  return !!value.toHexString;
}
function addSlice8(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice8(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger8(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes9(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger8(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger8(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify9(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger72.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice8(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable8(value)) {
    value = value.toHexString();
  }
  if (isHexString9(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger72.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice8(new Uint8Array(result));
  }
  if (isBytes9(value)) {
    return addSlice8(new Uint8Array(value));
  }
  return logger72.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString9(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

// node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version57 = "properties/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/properties/lib.esm/index.js
var logger73 = new Logger11(version57);
function defineReadOnly6(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/ethers/node_modules/@ethersproject/basex/lib.esm/index.js
var BaseX2 = class {
  constructor(alphabet) {
    defineReadOnly6(this, "alphabet", alphabet);
    defineReadOnly6(this, "base", alphabet.length);
    defineReadOnly6(this, "_alphabetMap", {});
    defineReadOnly6(this, "_leader", alphabet.charAt(0));
    for (let i = 0; i < alphabet.length; i++) {
      this._alphabetMap[alphabet.charAt(i)] = i;
    }
  }
  encode(value) {
    let source = arrayify9(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i = 0; i < source.length; ++i) {
      let carry = source[i];
      for (let j = 0; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
      string += this._leader;
    }
    for (let q = digits.length - 1; q >= 0; --q) {
      string += this.alphabet[digits[q]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i = 0; i < value.length; i++) {
      let byte = this._alphabetMap[value[i]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j = 0; j < bytes.length; ++j) {
        carry += bytes[j] * this.base;
        bytes[j] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
      bytes.push(0);
    }
    return arrayify9(new Uint8Array(bytes.reverse()));
  }
};
var Base322 = new BaseX2("abcdefghijklmnopqrstuvwxyz234567");
var Base582 = new BaseX2("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/bytes/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/bytes/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version58 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/bytes/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors11 = false;
var _censorErrors11 = false;
var LogLevels11 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel11 = LogLevels11["default"];
var _globalLogger11 = null;
function _checkNormalize11() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError11 = _checkNormalize11();
var LogLevel11;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel11 || (LogLevel11 = {}));
var ErrorCode11;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode11 || (ErrorCode11 = {}));
var HEX11 = "0123456789abcdef";
var Logger12 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels11[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel11 > LogLevels11[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger12.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger12.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger12.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors11) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger12.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX11[value[i] >> 4];
            hex += HEX11[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode11.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode11.CALL_EXCEPTION:
      case ErrorCode11.INSUFFICIENT_FUNDS:
      case ErrorCode11.MISSING_NEW:
      case ErrorCode11.NONCE_EXPIRED:
      case ErrorCode11.REPLACEMENT_UNDERPRICED:
      case ErrorCode11.TRANSACTION_REPLACED:
      case ErrorCode11.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger12.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError11) {
      this.throwError("platform missing String.prototype.normalize", Logger12.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError11
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger12.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger12.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger12.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger12.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger12.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger12.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger12.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger11) {
      _globalLogger11 = new Logger12(version58);
    }
    return _globalLogger11;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger12.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors11) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger12.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors11 = !!censorship;
    _permanentCensorErrors11 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels11[logLevel.toLowerCase()];
    if (level == null) {
      Logger12.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel11 = level;
  }
  static from(version134) {
    return new Logger12(version134);
  }
};
Logger12.errors = ErrorCode11;
Logger12.levels = LogLevel11;

// node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version59 = "bytes/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger74 = new Logger12(version59);
function isHexable9(value) {
  return !!value.toHexString;
}
function addSlice9(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice9(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike5(value) {
  return isHexString10(value) && !(value.length % 2) || isBytes10(value);
}
function isInteger9(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes10(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger9(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger9(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify10(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger74.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice9(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable9(value)) {
    value = value.toHexString();
  }
  if (isHexString10(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0x0" + hex.substring(2);
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger74.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice9(new Uint8Array(result));
  }
  if (isBytes10(value)) {
    return addSlice9(new Uint8Array(value));
  }
  return logger74.throwArgumentError("invalid arrayify value", "value", value);
}
function concat6(items) {
  const objects = items.map((item) => arrayify10(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice9(result);
}
function stripZeros5(value) {
  let result = arrayify10(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad3(value, length) {
  value = arrayify10(value);
  if (value.length > length) {
    logger74.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice9(result);
}
function isHexString10(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters7 = "0123456789abcdef";
function hexlify8(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger74.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters7[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable9(value)) {
    return value.toHexString();
  }
  if (isHexString10(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger74.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes10(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters7[(v & 240) >> 4] + HexCharacters7[v & 15];
    }
    return result;
  }
  return logger74.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength5(data) {
  if (typeof data !== "string") {
    data = hexlify8(data);
  } else if (!isHexString10(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice6(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify8(data);
  } else if (!isHexString10(data) || data.length % 2) {
    logger74.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat4(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify8(item).substring(2);
  });
  return result;
}
function hexValue2(value) {
  const trimmed = hexStripZeros2(hexlify8(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros2(value) {
  if (typeof value !== "string") {
    value = hexlify8(value);
  }
  if (!isHexString10(value)) {
    logger74.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad7(value, length) {
  if (typeof value !== "string") {
    value = hexlify8(value);
  } else if (!isHexString10(value)) {
    logger74.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger74.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature2(signature6) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0
  };
  if (isBytesLike5(signature6)) {
    const bytes = arrayify10(signature6);
    if (bytes.length !== 65) {
      logger74.throwArgumentError("invalid signature string; must be 65 bytes", "signature", signature6);
    }
    result.r = hexlify8(bytes.slice(0, 32));
    result.s = hexlify8(bytes.slice(32, 64));
    result.v = bytes[64];
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger74.throwArgumentError("signature invalid v byte", "signature", signature6);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify8(bytes.slice(32, 64));
  } else {
    result.r = signature6.r;
    result.s = signature6.s;
    result.v = signature6.v;
    result.recoveryParam = signature6.recoveryParam;
    result._vs = signature6._vs;
    if (result._vs != null) {
      const vs2 = zeroPad3(arrayify10(result._vs), 32);
      result._vs = hexlify8(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger74.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature6);
      }
      vs2[0] &= 127;
      const s = hexlify8(vs2);
      if (result.s == null) {
        result.s = s;
      } else if (result.s !== s) {
        logger74.throwArgumentError("signature v mismatch _vs", "signature", signature6);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger74.throwArgumentError("signature missing v and recoveryParam", "signature", signature6);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger74.throwArgumentError("signature recoveryParam mismatch v", "signature", signature6);
        }
      }
    }
    if (result.r == null || !isHexString10(result.r)) {
      logger74.throwArgumentError("signature missing or invalid r", "signature", signature6);
    } else {
      result.r = hexZeroPad7(result.r, 32);
    }
    if (result.s == null || !isHexString10(result.s)) {
      logger74.throwArgumentError("signature missing or invalid s", "signature", signature6);
    } else {
      result.s = hexZeroPad7(result.s, 32);
    }
    const vs = arrayify10(result.s);
    if (vs[0] >= 128) {
      logger74.throwArgumentError("signature s out of range", "signature", signature6);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify8(vs);
    if (result._vs) {
      if (!isHexString10(result._vs)) {
        logger74.throwArgumentError("signature invalid _vs", "signature", signature6);
      }
      result._vs = hexZeroPad7(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger74.throwArgumentError("signature _vs mismatch v and s", "signature", signature6);
    }
  }
  return result;
}
function joinSignature2(signature6) {
  signature6 = splitSignature2(signature6);
  return hexlify8(concat6([
    signature6.r,
    signature6.s,
    signature6.recoveryParam ? "0x1c" : "0x1b"
  ]));
}

// node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/id.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha35 = __toESM(require_sha3());

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version60 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors12 = false;
var _censorErrors12 = false;
var LogLevels12 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel12 = LogLevels12["default"];
var _globalLogger12 = null;
function _checkNormalize12() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError12 = _checkNormalize12();
var LogLevel12;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel12 || (LogLevel12 = {}));
var ErrorCode12;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode12 || (ErrorCode12 = {}));
var HEX12 = "0123456789abcdef";
var Logger13 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels12[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel12 > LogLevels12[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger13.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger13.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger13.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors12) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger13.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX12[value[i] >> 4];
            hex += HEX12[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode12.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode12.CALL_EXCEPTION:
      case ErrorCode12.INSUFFICIENT_FUNDS:
      case ErrorCode12.MISSING_NEW:
      case ErrorCode12.NONCE_EXPIRED:
      case ErrorCode12.REPLACEMENT_UNDERPRICED:
      case ErrorCode12.TRANSACTION_REPLACED:
      case ErrorCode12.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger13.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError12) {
      this.throwError("platform missing String.prototype.normalize", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError12
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger13.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger13.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger13.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger13.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger13.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger13.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger13.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger12) {
      _globalLogger12 = new Logger13(version60);
    }
    return _globalLogger12;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors12) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors12 = !!censorship;
    _permanentCensorErrors12 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels12[logLevel.toLowerCase()];
    if (level == null) {
      Logger13.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel12 = level;
  }
  static from(version134) {
    return new Logger13(version134);
  }
};
Logger13.errors = ErrorCode12;
Logger13.levels = LogLevel12;

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version61 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger75 = new Logger13(version61);
function isHexable10(value) {
  return !!value.toHexString;
}
function addSlice10(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice10(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger10(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes11(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger10(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger10(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify11(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger75.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice10(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable10(value)) {
    value = value.toHexString();
  }
  if (isHexString11(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger75.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice10(new Uint8Array(result));
  }
  if (isBytes11(value)) {
    return addSlice10(new Uint8Array(value));
  }
  return logger75.throwArgumentError("invalid arrayify value", "value", value);
}
function concat7(items) {
  const objects = items.map((item) => arrayify11(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice10(result);
}
function isHexString11(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters8 = "0123456789abcdef";
function hexlify9(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger75.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters8[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable10(value)) {
    return value.toHexString();
  }
  if (isHexString11(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger75.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes11(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters8[(v & 240) >> 4] + HexCharacters8[v & 15];
    }
    return result;
  }
  return logger75.throwArgumentError("invalid hexlify value", "value", value);
}
function hexConcat5(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify9(item).substring(2);
  });
  return result;
}
function hexZeroPad8(value, length) {
  if (typeof value !== "string") {
    value = hexlify9(value);
  } else if (!isHexString11(value)) {
    logger75.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger75.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/keccak256/lib.esm/index.js
function keccak2566(data) {
  return "0x" + import_js_sha35.default.keccak_256(arrayify11(data));
}

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn8 = __toESM(require_bn());

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version62 = "bignumber/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN8 = import_bn8.default.BN;
var logger76 = new Logger13(version62);
var _constructorGuard15 = {};
var MAX_SAFE7 = 9007199254740991;
function isBigNumberish7(value) {
  return value != null && (BigNumber8.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString11(value) || typeof value === "bigint" || isBytes11(value));
}
var _warnedToStringRadix7 = false;
var BigNumber8 = class {
  constructor(constructorGuard, hex) {
    logger76.checkNew(new.target, BigNumber8);
    if (constructorGuard !== _constructorGuard15) {
      logger76.throwError("cannot call constructor directly; use BigNumber.from", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber7(toBN7(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber7(toBN7(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber8.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber7(toBN7(this).add(toBN7(other)));
  }
  sub(other) {
    return toBigNumber7(toBN7(this).sub(toBN7(other)));
  }
  div(other) {
    const o = BigNumber8.from(other);
    if (o.isZero()) {
      throwFault13("division-by-zero", "div");
    }
    return toBigNumber7(toBN7(this).div(toBN7(other)));
  }
  mul(other) {
    return toBigNumber7(toBN7(this).mul(toBN7(other)));
  }
  mod(other) {
    const value = toBN7(other);
    if (value.isNeg()) {
      throwFault13("division-by-zero", "mod");
    }
    return toBigNumber7(toBN7(this).umod(value));
  }
  pow(other) {
    const value = toBN7(other);
    if (value.isNeg()) {
      throwFault13("negative-power", "pow");
    }
    return toBigNumber7(toBN7(this).pow(value));
  }
  and(other) {
    const value = toBN7(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault13("unbound-bitwise-result", "and");
    }
    return toBigNumber7(toBN7(this).and(value));
  }
  or(other) {
    const value = toBN7(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault13("unbound-bitwise-result", "or");
    }
    return toBigNumber7(toBN7(this).or(value));
  }
  xor(other) {
    const value = toBN7(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault13("unbound-bitwise-result", "xor");
    }
    return toBigNumber7(toBN7(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault13("negative-width", "mask");
    }
    return toBigNumber7(toBN7(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault13("negative-width", "shl");
    }
    return toBigNumber7(toBN7(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault13("negative-width", "shr");
    }
    return toBigNumber7(toBN7(this).shrn(value));
  }
  eq(other) {
    return toBN7(this).eq(toBN7(other));
  }
  lt(other) {
    return toBN7(this).lt(toBN7(other));
  }
  lte(other) {
    return toBN7(this).lte(toBN7(other));
  }
  gt(other) {
    return toBN7(this).gt(toBN7(other));
  }
  gte(other) {
    return toBN7(this).gte(toBN7(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN7(this).isZero();
  }
  toNumber() {
    try {
      return toBN7(this).toNumber();
    } catch (error) {
      throwFault13("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger76.throwError("this platform does not support BigInt", Logger13.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix7) {
          _warnedToStringRadix7 = true;
          logger76.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger76.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger13.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger76.throwError("BigNumber.toString does not accept parameters", Logger13.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN7(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber8) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber8(_constructorGuard15, toHex7(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber8(_constructorGuard15, toHex7(new BN8(value)));
      }
      return logger76.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault13("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE7 || value <= -MAX_SAFE7) {
        throwFault13("overflow", "BigNumber.from", value);
      }
      return BigNumber8.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber8.from(anyValue.toString());
    }
    if (isBytes11(anyValue)) {
      return BigNumber8.from(hexlify9(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber8.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString11(hex) || hex[0] === "-" && isHexString11(hex.substring(1))) {
            return BigNumber8.from(hex);
          }
        }
      }
    }
    return logger76.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex7(value) {
  if (typeof value !== "string") {
    return toHex7(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger76.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex7(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber7(value) {
  return BigNumber8.from(toHex7(value));
}
function toBN7(value) {
  const hex = BigNumber8.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN8("-" + hex.substring(3), 16);
  }
  return new BN8(hex.substring(2), 16);
}
function throwFault13(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger76.throwError(fault, Logger13.errors.NUMERIC_FAULT, params);
}
function _base36To167(value) {
  return new BN8(value, 36).toString(16);
}

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger77 = new Logger13(version62);
var _constructorGuard16 = {};
var Zero14 = BigNumber8.from(0);
var NegativeOne14 = BigNumber8.from(-1);
function throwFault14(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger77.throwError(message, Logger13.errors.NUMERIC_FAULT, params);
}
var zeros7 = "0";
while (zeros7.length < 256) {
  zeros7 += zeros7;
}
function getMultiplier7(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber8.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros7.substring(0, decimals);
  }
  return logger77.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed8(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier7(decimals);
  value = BigNumber8.from(value);
  const negative = value.lt(Zero14);
  if (negative) {
    value = value.mul(NegativeOne14);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed8(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier7(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger77.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger77.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger77.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault14("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber8.from(whole);
  const fractionValue = BigNumber8.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne14);
  }
  return wei;
}
var FixedFormat7 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard16) {
      logger77.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier7(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat7) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger77.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger77.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger77.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger77.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat7(_constructorGuard16, signed, width, decimals);
  }
};
var FixedNumber7 = class {
  constructor(constructorGuard, hex, value, format) {
    logger77.checkNew(new.target, FixedNumber7);
    if (constructorGuard !== _constructorGuard16) {
      logger77.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger77.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed8(this._value, this.format.decimals);
    const b = parseFixed8(other._value, other.format.decimals);
    return FixedNumber7.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed8(this._value, this.format.decimals);
    const b = parseFixed8(other._value, other.format.decimals);
    return FixedNumber7.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed8(this._value, this.format.decimals);
    const b = parseFixed8(other._value, other.format.decimals);
    return FixedNumber7.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed8(this._value, this.format.decimals);
    const b = parseFixed8(other._value, other.format.decimals);
    return FixedNumber7.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber7.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE7.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber7.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE7.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger77.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber7.from("1" + zeros7.substring(0, decimals), this.format);
    const bump = BUMP7.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger77.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber8.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad8(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber7.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish7(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber7.fromString(formatFixed8(value, decimals), FixedFormat7.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat7.from(format);
    const numeric = parseFixed8(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero14)) {
      throwFault14("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad8(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed8(numeric, fixedFormat.decimals);
    return new FixedNumber7(_constructorGuard16, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat7.from(format);
    if (arrayify11(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber8.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed8(numeric, fixedFormat.decimals);
    return new FixedNumber7(_constructorGuard16, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber7.fromString(value, format);
    }
    if (isBytes11(value)) {
      return FixedNumber7.fromBytes(value, format);
    }
    try {
      return FixedNumber7.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger13.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger77.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE7 = FixedNumber7.from(1);
var BUMP7 = FixedNumber7.from("0.5");

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne15 = BigNumber8.from(-1);
var Zero15 = BigNumber8.from(0);
var One8 = BigNumber8.from(1);
var Two5 = BigNumber8.from(2);
var WeiPerEther5 = BigNumber8.from("1000000000000000000");
var MaxUint2568 = BigNumber8.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2565 = BigNumber8.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2565 = BigNumber8.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version63 = "strings/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger78 = new Logger13(version63);
var UnicodeNormalizationForm4;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm4 || (UnicodeNormalizationForm4 = {}));
var Utf8ErrorReason4;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason4 || (Utf8ErrorReason4 = {}));
function errorFunc4(reason, offset, bytes, output, badCodepoint) {
  return logger78.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc4(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason4.BAD_PREFIX || reason === Utf8ErrorReason4.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason4.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc4(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason4.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc4(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs4 = Object.freeze({
  error: errorFunc4,
  ignore: ignoreFunc4,
  replace: replaceFunc4
});
function getUtf8CodePoints3(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs4.error;
  }
  bytes = arrayify11(bytes);
  const result = [];
  let i = 0;
  while (i < bytes.length) {
    const c = bytes[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError(Utf8ErrorReason4.UNEXPECTED_CONTINUE, i - 1, bytes, result);
      } else {
        i += onError(Utf8ErrorReason4.BAD_PREFIX, i - 1, bytes, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes.length) {
      i += onError(Utf8ErrorReason4.OVERRUN, i - 1, bytes, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes[i];
      if ((nextChar & 192) != 128) {
        i += onError(Utf8ErrorReason4.MISSING_CONTINUE, i, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError(Utf8ErrorReason4.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError(Utf8ErrorReason4.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason4.OVERLONG, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes5(str, form = UnicodeNormalizationForm4.current) {
  if (form != UnicodeNormalizationForm4.current) {
    logger78.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify11(result);
}
function _toUtf8String4(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8CodePoints4(str, form = UnicodeNormalizationForm4.current) {
  return getUtf8CodePoints3(toUtf8Bytes5(str, form));
}

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes24(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable4(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable4(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap2(value, ranges) {
  let lo = 0;
  for (let i = 0; i < ranges.length; i++) {
    let range = ranges[i];
    lo += range.l;
    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range;
    }
  }
  return null;
}
var Table_A_1_ranges4 = createRangeTable4("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags4 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
var Table_B_2_ranges2 = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
var Table_B_2_lut_abs4 = createTable4("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel4 = createTable4("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex4 = createTable4("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes24);
var Table_C_ranges4 = createRangeTable4("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten2(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA12(codepoint) {
  return !!matchMap2(codepoint, Table_A_1_ranges4);
}
function _nameprepTableB22(codepoint) {
  let range = matchMap2(codepoint, Table_B_2_ranges2);
  if (range) {
    return [codepoint + range.s];
  }
  let codes = Table_B_2_lut_abs4[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel4[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex4[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC2(codepoint) {
  return !!matchMap2(codepoint, Table_C_ranges4);
}
function nameprep4(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints4(value);
  codes = flatten2(codes.map((code) => {
    if (Table_B_1_flags4.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 65024 && code <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB22(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code];
  }));
  codes = toUtf8CodePoints4(_toUtf8String4(codes), UnicodeNormalizationForm4.NFKC);
  codes.forEach((code) => {
    if (_nameprepTableC2(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code) => {
    if (_nameprepTableA12(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String4(codes);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  if (name2.length > 63) {
    throw new Error("too long");
  }
  return name2;
}

// node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/id.js
function id4(text) {
  return keccak2566(toUtf8Bytes5(text));
}

// node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/namehash.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/_version.js
init_define_process_env();
var version64 = "hash/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger79 = new Logger13(version64);
var Zeros4 = new Uint8Array(32);
Zeros4.fill(0);
var Partition4 = new RegExp("^((.*)\\.)?([^.]+)$");
function isValidName4(name2) {
  try {
    const comps = name2.split(".");
    for (let i = 0; i < comps.length; i++) {
      if (nameprep4(comps[i]).length === 0) {
        throw new Error("empty");
      }
    }
    return true;
  } catch (error) {
  }
  return false;
}
function namehash4(name2) {
  if (typeof name2 !== "string") {
    logger79.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let current = name2;
  let result = Zeros4;
  while (current.length) {
    const partition = current.match(Partition4);
    if (partition == null || partition[2] === "") {
      logger79.throwArgumentError("invalid ENS address; missing component", "name", name2);
    }
    const label = toUtf8Bytes5(nameprep4(partition[3]));
    result = keccak2566(concat7([result, keccak2566(label)]));
    current = partition[2] || "";
  }
  return hexlify9(result);
}

// node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/message.js
init_define_process_env();
var messagePrefix4 = "Ethereum Signed Message:\n";
function hashMessage5(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes5(message);
  }
  return keccak2566(concat7([
    toUtf8Bytes5(messagePrefix4),
    toUtf8Bytes5(String(message.length)),
    message
  ]));
}

// node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/typed-data.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version65 = "rlp/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger80 = new Logger13(version65);

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version66 = "address/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/lib.esm/index.js
var logger81 = new Logger13(version66);
function getChecksumAddress5(address) {
  if (!isHexString11(address, 20)) {
    logger81.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify11(keccak2566(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER5 = 9007199254740991;
function log105(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
var ibanLookup5 = {};
for (let i = 0; i < 10; i++) {
  ibanLookup5[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup5[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits5 = Math.floor(log105(MAX_SAFE_INTEGER5));
function ibanChecksum5(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup5[c];
  }).join("");
  while (expanded.length >= safeDigits5) {
    let block = expanded.substring(0, safeDigits5);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress6(address) {
  let result = null;
  if (typeof address !== "string") {
    logger81.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress5(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger81.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum5(address)) {
      logger81.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To167(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress5("0x" + result);
  } else {
    logger81.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version67 = "properties/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/properties/lib.esm/index.js
var logger82 = new Logger13(version67);
function defineReadOnly7(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function shallowCopy6(object) {
  const result = {};
  for (const key6 in object) {
    result[key6] = object[key6];
  }
  return result;
}
var opaque3 = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen3(object) {
  if (object === void 0 || object === null || opaque3[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
      let value = null;
      try {
        value = object[keys[i]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen3(value)) {
        return false;
      }
    }
    return true;
  }
  return logger82.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy3(object) {
  if (_isFrozen3(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy5(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key6 in object) {
      const value = object[key6];
      if (value === void 0) {
        continue;
      }
      defineReadOnly7(result, key6, deepCopy5(value));
    }
    return result;
  }
  return logger82.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy5(object) {
  return _deepCopy3(object);
}

// node_modules/ethers/node_modules/@ethersproject/hash/lib.esm/typed-data.js
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger83 = new Logger13(version64);
var padding4 = new Uint8Array(32);
padding4.fill(0);
var NegativeOne16 = BigNumber8.from(-1);
var Zero16 = BigNumber8.from(0);
var One9 = BigNumber8.from(1);
var MaxUint2569 = BigNumber8.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight2(value) {
  const bytes = arrayify11(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat5([bytes, padding4.slice(padOffset)]);
  }
  return hexlify9(bytes);
}
var hexTrue4 = hexZeroPad8(One9.toHexString(), 32);
var hexFalse4 = hexZeroPad8(Zero16.toHexString(), 32);
var domainFieldTypes2 = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames2 = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString4(key6) {
  return function(value) {
    if (typeof value !== "string") {
      logger83.throwArgumentError(`invalid domain value for ${JSON.stringify(key6)}`, `domain.${key6}`, value);
    }
    return value;
  };
}
var domainChecks4 = {
  name: checkString4("name"),
  version: checkString4("version"),
  chainId: function(value) {
    try {
      return BigNumber8.from(value).toString();
    } catch (error) {
    }
    return logger83.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress6(value).toLowerCase();
    } catch (error) {
    }
    return logger83.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify11(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify9(bytes);
    } catch (error) {
    }
    return logger83.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder2(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger83.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint2569.mask(signed ? width - 1 : width);
      const boundsLower = signed ? boundsUpper.add(One9).mul(NegativeOne16) : Zero16;
      return function(value) {
        const v = BigNumber8.from(value);
        if (v.lt(boundsLower) || v.gt(boundsUpper)) {
          logger83.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad8(v.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger83.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes = arrayify11(value);
        if (bytes.length !== width) {
          logger83.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight2(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad8(getAddress6(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse4 : hexTrue4;
      };
    case "bytes":
      return function(value) {
        return keccak2566(value);
      };
    case "string":
      return function(value) {
        return id4(value);
      };
  }
  return null;
}
function encodeType2(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
var TypedDataEncoder5 = class {
  constructor(types) {
    defineReadOnly7(this, "types", Object.freeze(deepCopy5(types)));
    defineReadOnly7(this, "_encoderCache", {});
    defineReadOnly7(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types).forEach((type) => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name2 in types) {
      const uniqueNames = {};
      types[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger83.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger83.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        }
        const encoder = getBaseEncoder2(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger83.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n) => parents[n].length === 0);
    if (primaryTypes.length === 0) {
      logger83.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger83.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", types);
    }
    defineReadOnly7(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger83.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
      }
      found[type] = true;
      Object.keys(links[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st = Object.keys(subtypes[name2]);
      st.sort();
      this._types[name2] = encodeType2(name2, types[name2]) + st.map((t) => encodeType2(t, types[t])).join("");
    }
  }
  getEncoder(type) {
    let encoder = this._encoderCache[type];
    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder;
  }
  _getEncoder(type) {
    {
      const encoder = getBaseEncoder2(type);
      if (encoder) {
        return encoder;
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return (value) => {
        if (length >= 0 && value.length !== length) {
          logger83.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak2566);
        }
        return keccak2566(hexConcat5(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id4(this._types[type]);
      return (value) => {
        const values = fields.map(({ name: name2, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name2]);
          if (this._types[type2]) {
            return keccak2566(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat5(values);
      };
    }
    return logger83.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger83.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name2, value) {
    return keccak2566(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder2(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);
      if (length >= 0 && value.length !== length) {
        logger83.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v) => this._visit(subtype, v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type2 }) => {
        accum[name2] = this._visit(type2, value[name2], callback);
        return accum;
      }, {});
    }
    return logger83.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types) {
    return new TypedDataEncoder5(types);
  }
  static getPrimaryType(types) {
    return TypedDataEncoder5.from(types).primaryType;
  }
  static hashStruct(name2, types, value) {
    return TypedDataEncoder5.from(types).hashStruct(name2, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name2 in domain) {
      const type = domainFieldTypes2[name2];
      if (!type) {
        logger83.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain);
      }
      domainFields.push({ name: name2, type });
    }
    domainFields.sort((a, b) => {
      return domainFieldNames2.indexOf(a.name) - domainFieldNames2.indexOf(b.name);
    });
    return TypedDataEncoder5.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types, value) {
    return hexConcat5([
      "0x1901",
      TypedDataEncoder5.hashDomain(domain),
      TypedDataEncoder5.from(types).hash(value)
    ]);
  }
  static hash(domain, types, value) {
    return keccak2566(TypedDataEncoder5.encode(domain, types, value));
  }
  static resolveNames(domain, types, value, resolveName2) {
    return __awaiter18(this, void 0, void 0, function* () {
      domain = shallowCopy6(domain);
      const ensCache = {};
      if (domain.verifyingContract && !isHexString11(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder5.from(types);
      encoder.visit(value, (type, value2) => {
        if (type === "address" && !isHexString11(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName2(name2);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder.visit(value, (type, value2) => {
        if (type === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    });
  }
  static getPayload(domain, types, value) {
    TypedDataEncoder5.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames2.forEach((name2) => {
      const value2 = domain[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks4[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes2[name2] });
    });
    const encoder = TypedDataEncoder5.from(types);
    const typesWithDomain = shallowCopy6(types);
    if (typesWithDomain.EIP712Domain) {
      logger83.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify9(arrayify11(value2));
        }
        if (type.match(/^u?int/)) {
          return BigNumber8.from(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger83.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger83.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
};

// node_modules/ethers/node_modules/@ethersproject/hdnode/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/basex/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version68 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors13 = false;
var _censorErrors13 = false;
var LogLevels13 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel13 = LogLevels13["default"];
var _globalLogger13 = null;
function _checkNormalize13() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError13 = _checkNormalize13();
var LogLevel13;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel13 || (LogLevel13 = {}));
var ErrorCode13;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode13 || (ErrorCode13 = {}));
var HEX13 = "0123456789abcdef";
var Logger14 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels13[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel13 > LogLevels13[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger14.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger14.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger14.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors13) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger14.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX13[value[i] >> 4];
            hex += HEX13[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode13.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode13.CALL_EXCEPTION:
      case ErrorCode13.INSUFFICIENT_FUNDS:
      case ErrorCode13.MISSING_NEW:
      case ErrorCode13.NONCE_EXPIRED:
      case ErrorCode13.REPLACEMENT_UNDERPRICED:
      case ErrorCode13.TRANSACTION_REPLACED:
      case ErrorCode13.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger14.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError13) {
      this.throwError("platform missing String.prototype.normalize", Logger14.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError13
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger14.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger14.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger14.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger14.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger14.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger14.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger14.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger13) {
      _globalLogger13 = new Logger14(version68);
    }
    return _globalLogger13;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger14.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors13) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger14.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors13 = !!censorship;
    _permanentCensorErrors13 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels13[logLevel.toLowerCase()];
    if (level == null) {
      Logger14.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel13 = level;
  }
  static from(version134) {
    return new Logger14(version134);
  }
};
Logger14.errors = ErrorCode13;
Logger14.levels = LogLevel13;

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version69 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger84 = new Logger14(version69);
function isHexable11(value) {
  return !!value.toHexString;
}
function addSlice11(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice11(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike7(value) {
  return isHexString12(value) && !(value.length % 2) || isBytes12(value);
}
function isInteger11(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes12(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger11(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger11(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify12(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger84.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice11(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable11(value)) {
    value = value.toHexString();
  }
  if (isHexString12(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger84.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice11(new Uint8Array(result));
  }
  if (isBytes12(value)) {
    return addSlice11(new Uint8Array(value));
  }
  return logger84.throwArgumentError("invalid arrayify value", "value", value);
}
function concat8(items) {
  const objects = items.map((item) => arrayify12(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice11(result);
}
function zeroPad4(value, length) {
  value = arrayify12(value);
  if (value.length > length) {
    logger84.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice11(result);
}
function isHexString12(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters9 = "0123456789abcdef";
function hexlify10(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger84.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters9[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable11(value)) {
    return value.toHexString();
  }
  if (isHexString12(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger84.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes12(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters9[(v & 240) >> 4] + HexCharacters9[v & 15];
    }
    return result;
  }
  return logger84.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataSlice8(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify10(data);
  } else if (!isHexString12(data) || data.length % 2) {
    logger84.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexZeroPad9(value, length) {
  if (typeof value !== "string") {
    value = hexlify10(value);
  } else if (!isHexString12(value)) {
    logger84.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger84.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature3(signature6) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike7(signature6)) {
    let bytes = arrayify12(signature6);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify10(bytes.slice(0, 32));
      result.s = hexlify10(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify10(bytes.slice(0, 32));
      result.s = hexlify10(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger84.throwArgumentError("invalid signature string", "signature", signature6);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger84.throwArgumentError("signature invalid v byte", "signature", signature6);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify10(bytes.slice(32, 64));
  } else {
    result.r = signature6.r;
    result.s = signature6.s;
    result.v = signature6.v;
    result.recoveryParam = signature6.recoveryParam;
    result._vs = signature6._vs;
    if (result._vs != null) {
      const vs2 = zeroPad4(arrayify12(result._vs), 32);
      result._vs = hexlify10(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger84.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature6);
      }
      vs2[0] &= 127;
      const s = hexlify10(vs2);
      if (result.s == null) {
        result.s = s;
      } else if (result.s !== s) {
        logger84.throwArgumentError("signature v mismatch _vs", "signature", signature6);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger84.throwArgumentError("signature missing v and recoveryParam", "signature", signature6);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger84.throwArgumentError("signature recoveryParam mismatch v", "signature", signature6);
        }
      }
    }
    if (result.r == null || !isHexString12(result.r)) {
      logger84.throwArgumentError("signature missing or invalid r", "signature", signature6);
    } else {
      result.r = hexZeroPad9(result.r, 32);
    }
    if (result.s == null || !isHexString12(result.s)) {
      logger84.throwArgumentError("signature missing or invalid s", "signature", signature6);
    } else {
      result.s = hexZeroPad9(result.s, 32);
    }
    const vs = arrayify12(result.s);
    if (vs[0] >= 128) {
      logger84.throwArgumentError("signature s out of range", "signature", signature6);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify10(vs);
    if (result._vs) {
      if (!isHexString12(result._vs)) {
        logger84.throwArgumentError("signature invalid _vs", "signature", signature6);
      }
      result._vs = hexZeroPad9(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger84.throwArgumentError("signature _vs mismatch v and s", "signature", signature6);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version70 = "properties/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/properties/lib.esm/index.js
var logger85 = new Logger14(version70);
function defineReadOnly8(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/basex/lib.esm/index.js
var BaseX3 = class {
  constructor(alphabet) {
    defineReadOnly8(this, "alphabet", alphabet);
    defineReadOnly8(this, "base", alphabet.length);
    defineReadOnly8(this, "_alphabetMap", {});
    defineReadOnly8(this, "_leader", alphabet.charAt(0));
    for (let i = 0; i < alphabet.length; i++) {
      this._alphabetMap[alphabet.charAt(i)] = i;
    }
  }
  encode(value) {
    let source = arrayify12(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i = 0; i < source.length; ++i) {
      let carry = source[i];
      for (let j = 0; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
      string += this._leader;
    }
    for (let q = digits.length - 1; q >= 0; --q) {
      string += this.alphabet[digits[q]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i = 0; i < value.length; i++) {
      let byte = this._alphabetMap[value[i]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j = 0; j < bytes.length; ++j) {
        carry += bytes[j] * this.base;
        bytes[j] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
      bytes.push(0);
    }
    return arrayify12(new Uint8Array(bytes.reverse()));
  }
};
var Base323 = new BaseX3("abcdefghijklmnopqrstuvwxyz234567");
var Base583 = new BaseX3("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn9 = __toESM(require_bn());

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version71 = "bignumber/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN9 = import_bn9.default.BN;
var logger86 = new Logger14(version71);
var _constructorGuard17 = {};
var MAX_SAFE8 = 9007199254740991;
function isBigNumberish8(value) {
  return value != null && (BigNumber9.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString12(value) || typeof value === "bigint" || isBytes12(value));
}
var _warnedToStringRadix8 = false;
var BigNumber9 = class {
  constructor(constructorGuard, hex) {
    logger86.checkNew(new.target, BigNumber9);
    if (constructorGuard !== _constructorGuard17) {
      logger86.throwError("cannot call constructor directly; use BigNumber.from", Logger14.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber8(toBN8(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber8(toBN8(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber9.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber8(toBN8(this).add(toBN8(other)));
  }
  sub(other) {
    return toBigNumber8(toBN8(this).sub(toBN8(other)));
  }
  div(other) {
    const o = BigNumber9.from(other);
    if (o.isZero()) {
      throwFault15("division-by-zero", "div");
    }
    return toBigNumber8(toBN8(this).div(toBN8(other)));
  }
  mul(other) {
    return toBigNumber8(toBN8(this).mul(toBN8(other)));
  }
  mod(other) {
    const value = toBN8(other);
    if (value.isNeg()) {
      throwFault15("division-by-zero", "mod");
    }
    return toBigNumber8(toBN8(this).umod(value));
  }
  pow(other) {
    const value = toBN8(other);
    if (value.isNeg()) {
      throwFault15("negative-power", "pow");
    }
    return toBigNumber8(toBN8(this).pow(value));
  }
  and(other) {
    const value = toBN8(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault15("unbound-bitwise-result", "and");
    }
    return toBigNumber8(toBN8(this).and(value));
  }
  or(other) {
    const value = toBN8(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault15("unbound-bitwise-result", "or");
    }
    return toBigNumber8(toBN8(this).or(value));
  }
  xor(other) {
    const value = toBN8(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault15("unbound-bitwise-result", "xor");
    }
    return toBigNumber8(toBN8(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault15("negative-width", "mask");
    }
    return toBigNumber8(toBN8(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault15("negative-width", "shl");
    }
    return toBigNumber8(toBN8(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault15("negative-width", "shr");
    }
    return toBigNumber8(toBN8(this).shrn(value));
  }
  eq(other) {
    return toBN8(this).eq(toBN8(other));
  }
  lt(other) {
    return toBN8(this).lt(toBN8(other));
  }
  lte(other) {
    return toBN8(this).lte(toBN8(other));
  }
  gt(other) {
    return toBN8(this).gt(toBN8(other));
  }
  gte(other) {
    return toBN8(this).gte(toBN8(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN8(this).isZero();
  }
  toNumber() {
    try {
      return toBN8(this).toNumber();
    } catch (error) {
      throwFault15("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger86.throwError("this platform does not support BigInt", Logger14.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix8) {
          _warnedToStringRadix8 = true;
          logger86.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger86.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger14.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger86.throwError("BigNumber.toString does not accept parameters", Logger14.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN8(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber9) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber9(_constructorGuard17, toHex8(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber9(_constructorGuard17, toHex8(new BN9(value)));
      }
      return logger86.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault15("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE8 || value <= -MAX_SAFE8) {
        throwFault15("overflow", "BigNumber.from", value);
      }
      return BigNumber9.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber9.from(anyValue.toString());
    }
    if (isBytes12(anyValue)) {
      return BigNumber9.from(hexlify10(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber9.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString12(hex) || hex[0] === "-" && isHexString12(hex.substring(1))) {
            return BigNumber9.from(hex);
          }
        }
      }
    }
    return logger86.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex8(value) {
  if (typeof value !== "string") {
    return toHex8(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger86.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex8(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber8(value) {
  return BigNumber9.from(toHex8(value));
}
function toBN8(value) {
  const hex = BigNumber9.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN9("-" + hex.substring(3), 16);
  }
  return new BN9(hex.substring(2), 16);
}
function throwFault15(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger86.throwError(fault, Logger14.errors.NUMERIC_FAULT, params);
}
function _base36To168(value) {
  return new BN9(value, 36).toString(16);
}

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger87 = new Logger14(version71);
var _constructorGuard18 = {};
var Zero17 = BigNumber9.from(0);
var NegativeOne17 = BigNumber9.from(-1);
function throwFault16(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger87.throwError(message, Logger14.errors.NUMERIC_FAULT, params);
}
var zeros8 = "0";
while (zeros8.length < 256) {
  zeros8 += zeros8;
}
function getMultiplier8(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber9.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros8.substring(0, decimals);
  }
  return logger87.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed9(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier8(decimals);
  value = BigNumber9.from(value);
  const negative = value.lt(Zero17);
  if (negative) {
    value = value.mul(NegativeOne17);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed9(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier8(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger87.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger87.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger87.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault16("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber9.from(whole);
  const fractionValue = BigNumber9.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne17);
  }
  return wei;
}
var FixedFormat8 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard18) {
      logger87.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger14.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier8(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat8) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger87.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger87.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger87.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger87.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat8(_constructorGuard18, signed, width, decimals);
  }
};
var FixedNumber8 = class {
  constructor(constructorGuard, hex, value, format) {
    logger87.checkNew(new.target, FixedNumber8);
    if (constructorGuard !== _constructorGuard18) {
      logger87.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger14.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger87.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed9(this._value, this.format.decimals);
    const b = parseFixed9(other._value, other.format.decimals);
    return FixedNumber8.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed9(this._value, this.format.decimals);
    const b = parseFixed9(other._value, other.format.decimals);
    return FixedNumber8.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed9(this._value, this.format.decimals);
    const b = parseFixed9(other._value, other.format.decimals);
    return FixedNumber8.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed9(this._value, this.format.decimals);
    const b = parseFixed9(other._value, other.format.decimals);
    return FixedNumber8.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber8.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE8.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber8.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE8.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger87.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber8.from("1" + zeros8.substring(0, decimals), this.format);
    const bump = BUMP8.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger87.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber9.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad9(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber8.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish8(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber8.fromString(formatFixed9(value, decimals), FixedFormat8.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat8.from(format);
    const numeric = parseFixed9(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero17)) {
      throwFault16("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad9(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed9(numeric, fixedFormat.decimals);
    return new FixedNumber8(_constructorGuard18, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat8.from(format);
    if (arrayify12(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber9.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed9(numeric, fixedFormat.decimals);
    return new FixedNumber8(_constructorGuard18, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber8.fromString(value, format);
    }
    if (isBytes12(value)) {
      return FixedNumber8.fromBytes(value, format);
    }
    try {
      return FixedNumber8.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger14.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger87.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE8 = FixedNumber8.from(1);
var BUMP8 = FixedNumber8.from("0.5");

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();
var NegativeOne18 = BigNumber9.from(-1);
var Zero18 = BigNumber9.from(0);
var One10 = BigNumber9.from(1);
var Two6 = BigNumber9.from(2);
var WeiPerEther6 = BigNumber9.from("1000000000000000000");
var MaxUint25610 = BigNumber9.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2566 = BigNumber9.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2566 = BigNumber9.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version72 = "strings/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger88 = new Logger14(version72);
var UnicodeNormalizationForm5;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm5 || (UnicodeNormalizationForm5 = {}));
var Utf8ErrorReason5;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason5 || (Utf8ErrorReason5 = {}));
function errorFunc5(reason, offset, bytes, output, badCodepoint) {
  return logger88.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc5(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason5.BAD_PREFIX || reason === Utf8ErrorReason5.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason5.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc5(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason5.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc5(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs5 = Object.freeze({
  error: errorFunc5,
  ignore: ignoreFunc5,
  replace: replaceFunc5
});
function toUtf8Bytes6(str, form = UnicodeNormalizationForm5.current) {
  if (form != UnicodeNormalizationForm5.current) {
    logger88.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify12(result);
}

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes25(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable5(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable5(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges5 = createRangeTable5("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags5 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
var Table_B_2_lut_abs5 = createTable5("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel5 = createTable5("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex5 = createTable5("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes25);
var Table_C_ranges5 = createRangeTable5("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/lib.esm/sha2.js
init_define_process_env();
var import_hash8 = __toESM(require_hash());

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/lib.esm/types.js
init_define_process_env();
var SupportedAlgorithm2;
(function(SupportedAlgorithm5) {
  SupportedAlgorithm5["sha256"] = "sha256";
  SupportedAlgorithm5["sha512"] = "sha512";
})(SupportedAlgorithm2 || (SupportedAlgorithm2 = {}));

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/lib.esm/_version.js
init_define_process_env();
var version73 = "sha2/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/lib.esm/sha2.js
var logger89 = new Logger14(version73);
function ripemd1602(data) {
  return "0x" + import_hash8.default.ripemd160().update(arrayify12(data)).digest("hex");
}
function sha2563(data) {
  return "0x" + import_hash8.default.sha256().update(arrayify12(data)).digest("hex");
}
function computeHmac2(algorithm, key6, data) {
  if (!SupportedAlgorithm2[algorithm]) {
    logger89.throwError("unsupported algorithm " + algorithm, Logger14.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + import_hash8.default.hmac(import_hash8.default[algorithm], arrayify12(key6)).update(arrayify12(data)).digest("hex");
}

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify12(password);
  salt = arrayify12(salt);
  let hLen;
  let l = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r;
  let T;
  for (let i = 1; i <= l; i++) {
    block1[salt.length] = i >> 24 & 255;
    block1[salt.length + 1] = i >> 16 & 255;
    block1[salt.length + 2] = i >> 8 & 255;
    block1[salt.length + 3] = i & 255;
    let U = arrayify12(computeHmac2(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U.length;
      T = new Uint8Array(hLen);
      l = Math.ceil(keylen / hLen);
      r = keylen - (l - 1) * hLen;
    }
    T.set(U);
    for (let j = 1; j < iterations; j++) {
      U = arrayify12(computeHmac2(hashAlgorithm, password, U));
      for (let k = 0; k < hLen; k++)
        T[k] ^= U[k];
    }
    const destPos = (i - 1) * hLen;
    const len = i === l ? r : hLen;
    DK.set(arrayify12(T).slice(0, len), destPos);
  }
  return hexlify10(DK);
}

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
init_define_process_env();
var import_bn10 = __toESM(require_bn());
var import_hash9 = __toESM(require_hash());
function createCommonjsModule2(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base6) {
      return commonjsRequire2(path, base6 === void 0 || base6 === null ? module.path : base6);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire2() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert2 = assert2;
function assert2(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert2.equal = function assertEqual2(l, r, msg) {
  if (l != r)
    throw new Error(msg || "Assertion failed: " + l + " != " + r);
};
var utils_12 = createCommonjsModule2(function(module, exports) {
  "use strict";
  var utils = exports;
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex13(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex13;
  utils.encode = function encode18(arr, enc) {
    if (enc === "hex")
      return toHex13(arr);
    else
      return arr;
  };
});
var utils_1$12 = createCommonjsModule2(function(module, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert2;
  utils.toArray = utils_12.toArray;
  utils.zero2 = utils_12.zero2;
  utils.toHex = utils_12.toHex;
  utils.encode = utils_12.encode;
  function getNAF6(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF6;
  function getJSF6(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF6;
  function cachedProperty(obj, name2, computer) {
    var key6 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key6] !== void 0 ? this[key6] : this[key6] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn10.default(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});
var getNAF2 = utils_1$12.getNAF;
var getJSF2 = utils_1$12.getJSF;
var assert$12 = utils_1$12.assert;
function BaseCurve2(type, conf) {
  this.type = type;
  this.p = new import_bn10.default(conf.p, 16);
  this.red = conf.prime ? import_bn10.default.red(conf.prime) : import_bn10.default.mont(this.p);
  this.zero = new import_bn10.default(0).toRed(this.red);
  this.one = new import_bn10.default(1).toRed(this.red);
  this.two = new import_bn10.default(2).toRed(this.red);
  this.n = conf.n && new import_bn10.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base2 = BaseCurve2;
BaseCurve2.prototype.point = function point3() {
  throw new Error("Not implemented");
};
BaseCurve2.prototype.validate = function validate5() {
  throw new Error("Not implemented");
};
BaseCurve2.prototype._fixedNafMul = function _fixedNafMul2(p, k) {
  assert$12(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF2(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};
BaseCurve2.prototype._wnafMul = function _wnafMul2(p, k) {
  var w = 4;
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF2(k, w, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);
    if (i < 0)
      break;
    var z = naf[i];
    assert$12(z !== 0);
    if (p.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p.type === "affine" ? acc.toP() : acc;
};
BaseCurve2.prototype._wnafMulAdd = function _wnafMulAdd2(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF2(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF2(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [
      points[a],
      null,
      null,
      points[b]
    ];
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF2(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;
    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][z - 1 >> 1];
      else if (z < 0)
        p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === "affine")
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  for (i = 0; i < len; i++)
    wnd[i] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint2(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve2.BasePoint = BasePoint2;
BasePoint2.prototype.eq = function eq4() {
  throw new Error("Not implemented");
};
BasePoint2.prototype.validate = function validate6() {
  return this.curve.validate(this);
};
BaseCurve2.prototype.decodePoint = function decodePoint2(bytes, enc) {
  bytes = utils_1$12.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$12(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$12(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint2.prototype.encodeCompressed = function encodeCompressed2(enc) {
  return this.encode(enc, true);
};
BasePoint2.prototype._encode = function _encode4(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x);
  return [4].concat(x, this.getY().toArray("be", len));
};
BasePoint2.prototype.encode = function encode9(enc, compact) {
  return utils_1$12.encode(this._encode(compact), enc);
};
BasePoint2.prototype.precompute = function precompute2(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint2.prototype._hasDoubles = function _hasDoubles2(k) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint2.prototype._getDoubles = function _getDoubles2(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint2.prototype._getNAFPoints = function _getNAFPoints2(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl11 = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl11);
  return {
    wnd,
    points: res
  };
};
BasePoint2.prototype._getBeta = function _getBeta3() {
  return null;
};
BasePoint2.prototype.dblp = function dblp3(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};
var inherits_browser2 = createCommonjsModule2(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$22 = utils_1$12.assert;
function ShortCurve2(conf) {
  base2.call(this, "short", conf);
  this.a = new import_bn10.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn10.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser2(ShortCurve2, base2);
var short_12 = ShortCurve2;
ShortCurve2.prototype._getEndomorphism = function _getEndomorphism2(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn10.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn10.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$22(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn10.default(vec.a, 16),
        b: new import_bn10.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve2.prototype._getEndoRoots = function _getEndoRoots2(num) {
  var red = num === this.p ? this.red : import_bn10.default.mont(num);
  var tinv = new import_bn10.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new import_bn10.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
};
ShortCurve2.prototype._getEndoBasis = function _getEndoBasis2(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u = lambda;
  var v = this.n.clone();
  var x1 = new import_bn10.default(1);
  var y1 = new import_bn10.default(0);
  var x2 = new import_bn10.default(0);
  var y2 = new import_bn10.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));
    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve2.prototype._endoSplit = function _endoSplit2(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1, k2 };
};
ShortCurve2.prototype.pointFromX = function pointFromX2(x, odd) {
  x = new import_bn10.default(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
};
ShortCurve2.prototype.validate = function validate7(point11) {
  if (point11.inf)
    return true;
  var x = point11.x;
  var y = point11.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve2.prototype._endoWnafMulAdd = function _endoWnafMulAdd2(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point2(curve, x, y, isRed) {
  base2.BasePoint.call(this, curve, "affine");
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn10.default(x, 16);
    this.y = new import_bn10.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser2(Point2, base2.BasePoint);
ShortCurve2.prototype.point = function point4(x, y, isRed) {
  return new Point2(this, x, y, isRed);
};
ShortCurve2.prototype.pointFromJSON = function pointFromJSON2(obj, red) {
  return Point2.fromJSON(this, obj, red);
};
Point2.prototype._getBeta = function _getBeta4() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point2.prototype.toJSON = function toJSON2() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point2.fromJSON = function fromJSON2(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point2.prototype.inspect = function inspect4() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point2.prototype.isInfinity = function isInfinity3() {
  return this.inf;
};
Point2.prototype.add = function add3(p) {
  if (this.inf)
    return p;
  if (p.inf)
    return this;
  if (this.eq(p))
    return this.dbl();
  if (this.neg().eq(p))
    return this.curve.point(null, null);
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point2.prototype.dbl = function dbl3() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point2.prototype.getX = function getX2() {
  return this.x.fromRed();
};
Point2.prototype.getY = function getY2() {
  return this.y.fromRed();
};
Point2.prototype.mul = function mul3(k) {
  k = new import_bn10.default(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k]);
  else
    return this.curve._wnafMul(this, k);
};
Point2.prototype.mulAdd = function mulAdd2(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point2.prototype.jmulAdd = function jmulAdd2(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point2.prototype.eq = function eq5(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point2.prototype.neg = function neg3(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point2.prototype.toJ = function toJ2() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint2(curve, x, y, z) {
  base2.BasePoint.call(this, curve, "jacobian");
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn10.default(0);
  } else {
    this.x = new import_bn10.default(x, 16);
    this.y = new import_bn10.default(y, 16);
    this.z = new import_bn10.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser2(JPoint2, base2.BasePoint);
ShortCurve2.prototype.jpoint = function jpoint2(x, y, z) {
  return new JPoint2(this, x, y, z);
};
JPoint2.prototype.toP = function toP2() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint2.prototype.neg = function neg4() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint2.prototype.add = function add4(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint2.prototype.mixedAdd = function mixedAdd2(p) {
  if (this.isInfinity())
    return p.toJ();
  if (p.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint2.prototype.dblp = function dblp4(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }
  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint2.prototype.dbl = function dbl4() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint2.prototype._zeroDbl = function _zeroDbl2() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx);
    var t = m.redSqr().redISub(s).redISub(s);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t;
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = b.redSqr();
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    var e = a.redAdd(a).redIAdd(a);
    var f = e.redSqr();
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f.redISub(d).redISub(d);
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint2.prototype._threeDbl = function _threeDbl2() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t = m.redSqr().redISub(s).redISub(s);
    nx = t;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint2.prototype._dbl = function _dbl2() {
  var a = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint2.prototype.trpl = function trpl2() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m = xx.redAdd(xx).redIAdd(xx);
  var mm = m.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee = e.redSqr();
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint2.prototype.mul = function mul4(k, kbase) {
  k = new import_bn10.default(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint2.prototype.eq = function eq6(p) {
  if (p.type === "affine")
    return this.eq(p.toJ());
  if (this === p)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint2.prototype.eqXToP = function eqXToP2(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint2.prototype.inspect = function inspect5() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint2.prototype.isInfinity = function isInfinity4() {
  return this.z.cmpn(0) === 0;
};
var curve_12 = createCommonjsModule2(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base2;
  curve.short = short_12;
  curve.mont = null;
  curve.edwards = null;
});
var curves_12 = createCommonjsModule2(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert6 = utils_1$12.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_12.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_12.edwards(options);
    else
      this.curve = new curve_12.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert6(this.g.validate(), "Invalid curve");
    assert6(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash9.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash9.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash9.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash9.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash9.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash9.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash9.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash9.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG2(options) {
  if (!(this instanceof HmacDRBG2))
    return new HmacDRBG2(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_12.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_12.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_12.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert2(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg2 = HmacDRBG2;
HmacDRBG2.prototype._init = function init2(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0;
    this.V[i] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG2.prototype._hmac = function hmac2() {
  return new import_hash9.default.hmac(this.hash, this.K);
};
HmacDRBG2.prototype._update = function update2(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG2.prototype.reseed = function reseed2(entropy, entropyEnc, add11, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add11;
    add11 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_12.toArray(entropy, entropyEnc);
  add11 = utils_12.toArray(add11, addEnc);
  minimalisticAssert2(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add11 || []));
  this._reseed = 1;
};
HmacDRBG2.prototype.generate = function generate2(len, enc, add11, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add11;
    add11 = enc;
    enc = null;
  }
  if (add11) {
    add11 = utils_12.toArray(add11, addEnc || "hex");
    this._update(add11);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add11);
  this._reseed++;
  return utils_12.encode(res, enc);
};
var assert$32 = utils_1$12.assert;
function KeyPair2(ec6, options) {
  this.ec = ec6;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key2 = KeyPair2;
KeyPair2.fromPublic = function fromPublic2(ec6, pub, enc) {
  if (pub instanceof KeyPair2)
    return pub;
  return new KeyPair2(ec6, {
    pub,
    pubEnc: enc
  });
};
KeyPair2.fromPrivate = function fromPrivate2(ec6, priv, enc) {
  if (priv instanceof KeyPair2)
    return priv;
  return new KeyPair2(ec6, {
    priv,
    privEnc: enc
  });
};
KeyPair2.prototype.validate = function validate8() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair2.prototype.getPublic = function getPublic2(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair2.prototype.getPrivate = function getPrivate2(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair2.prototype._importPrivate = function _importPrivate2(key6, enc) {
  this.priv = new import_bn10.default(key6, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair2.prototype._importPublic = function _importPublic2(key6, enc) {
  if (key6.x || key6.y) {
    if (this.ec.curve.type === "mont") {
      assert$32(key6.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$32(key6.x && key6.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key6.x, key6.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key6, enc);
};
KeyPair2.prototype.derive = function derive2(pub) {
  if (!pub.validate()) {
    assert$32(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair2.prototype.sign = function sign3(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair2.prototype.verify = function verify3(msg, signature6) {
  return this.ec.verify(msg, signature6, this);
};
KeyPair2.prototype.inspect = function inspect6() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$42 = utils_1$12.assert;
function Signature2(options, enc) {
  if (options instanceof Signature2)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$42(options.r && options.s, "Signature without r or s");
  this.r = new import_bn10.default(options.r, 16);
  this.s = new import_bn10.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature2 = Signature2;
function Position2() {
  this.place = 0;
}
function getLength2(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
function rmPadding2(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature2.prototype._importDER = function _importDER2(data, enc) {
  data = utils_1$12.toArray(data, enc);
  var p = new Position2();
  if (data[p.place++] !== 48) {
    return false;
  }
  var len = getLength2(data, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data.length) {
    return false;
  }
  if (data[p.place++] !== 2) {
    return false;
  }
  var rlen = getLength2(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 2) {
    return false;
  }
  var slen = getLength2(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 128) {
      r = r.slice(1);
    } else {
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 128) {
      s = s.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn10.default(r);
  this.s = new import_bn10.default(s);
  this.recoveryParam = null;
  return true;
};
function constructLength2(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature2.prototype.toDER = function toDER2(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();
  if (r[0] & 128)
    r = [0].concat(r);
  if (s[0] & 128)
    s = [0].concat(s);
  r = rmPadding2(r);
  s = rmPadding2(s);
  while (!s[0] && !(s[1] & 128)) {
    s = s.slice(1);
  }
  var arr = [2];
  constructLength2(arr, r.length);
  arr = arr.concat(r);
  arr.push(2);
  constructLength2(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [48];
  constructLength2(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$12.encode(res, enc);
};
var rand2 = function() {
  throw new Error("unsupported");
};
var assert$52 = utils_1$12.assert;
function EC2(options) {
  if (!(this instanceof EC2))
    return new EC2(options);
  if (typeof options === "string") {
    assert$52(Object.prototype.hasOwnProperty.call(curves_12, options), "Unknown curve " + options);
    options = curves_12[options];
  }
  if (options instanceof curves_12.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec2 = EC2;
EC2.prototype.keyPair = function keyPair2(options) {
  return new key2(this, options);
};
EC2.prototype.keyFromPrivate = function keyFromPrivate2(priv, enc) {
  return key2.fromPrivate(this, priv, enc);
};
EC2.prototype.keyFromPublic = function keyFromPublic2(pub, enc) {
  return key2.fromPublic(this, pub, enc);
};
EC2.prototype.genKeyPair = function genKeyPair2(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg2({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand2(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn10.default(2));
  for (; ; ) {
    var priv = new import_bn10.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC2.prototype._truncateToN = function _truncateToN2(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC2.prototype.sign = function sign4(msg, key6, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key6 = this.keyFromPrivate(key6, enc);
  msg = this._truncateToN(new import_bn10.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key6.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg2({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn10.default(1));
  for (var iter = 0; ; iter++) {
    var k = options.k ? options.k(iter) : new import_bn10.default(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;
    var s = k.invm(this.n).mul(r.mul(key6.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }
    return new signature2({ r, s, recoveryParam });
  }
};
EC2.prototype.verify = function verify4(msg, signature$1, key6, enc) {
  msg = this._truncateToN(new import_bn10.default(msg, 16));
  key6 = this.keyFromPublic(key6, enc);
  signature$1 = new signature2(signature$1, "hex");
  var r = signature$1.r;
  var s = signature$1.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;
  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key6.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  }
  p = this.g.jmulAdd(u1, key6.getPublic(), u2);
  if (p.isInfinity())
    return false;
  return p.eqXToP(r);
};
EC2.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$52((3 & j) === j, "The recovery param is more than two bits");
  signature$1 = new signature2(signature$1, enc);
  var n = this.n;
  var e = new import_bn10.default(msg);
  var r = signature$1.r;
  var s = signature$1.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r, s2);
};
EC2.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {
  signature$1 = new signature2(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_12 = createCommonjsModule2(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$12;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_12;
  elliptic.curves = curves_12;
  elliptic.ec = ec2;
  elliptic.eddsa = null;
});
var EC$12 = elliptic_12.ec;

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/lib.esm/_version.js
init_define_process_env();
var version74 = "signing-key/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger90 = new Logger14(version74);
var _curve2 = null;
function getCurve2() {
  if (!_curve2) {
    _curve2 = new EC$12("secp256k1");
  }
  return _curve2;
}
var SigningKey3 = class {
  constructor(privateKey) {
    defineReadOnly8(this, "curve", "secp256k1");
    defineReadOnly8(this, "privateKey", hexlify10(privateKey));
    const keyPair6 = getCurve2().keyFromPrivate(arrayify12(this.privateKey));
    defineReadOnly8(this, "publicKey", "0x" + keyPair6.getPublic(false, "hex"));
    defineReadOnly8(this, "compressedPublicKey", "0x" + keyPair6.getPublic(true, "hex"));
    defineReadOnly8(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve2().keyFromPublic(arrayify12(this.publicKey));
    const p1 = getCurve2().keyFromPublic(arrayify12(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest) {
    const keyPair6 = getCurve2().keyFromPrivate(arrayify12(this.privateKey));
    const digestBytes = arrayify12(digest);
    if (digestBytes.length !== 32) {
      logger90.throwArgumentError("bad digest length", "digest", digest);
    }
    const signature6 = keyPair6.sign(digestBytes, { canonical: true });
    return splitSignature3({
      recoveryParam: signature6.recoveryParam,
      r: hexZeroPad9("0x" + signature6.r.toString(16), 32),
      s: hexZeroPad9("0x" + signature6.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair6 = getCurve2().keyFromPrivate(arrayify12(this.privateKey));
    const otherKeyPair = getCurve2().keyFromPublic(arrayify12(computePublicKey2(otherKey)));
    return hexZeroPad9("0x" + keyPair6.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
function computePublicKey2(key6, compressed) {
  const bytes = arrayify12(key6);
  if (bytes.length === 32) {
    const signingKey = new SigningKey3(bytes);
    if (compressed) {
      return "0x" + getCurve2().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify10(bytes);
    }
    return "0x" + getCurve2().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify10(bytes);
    }
    return "0x" + getCurve2().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger90.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha36 = __toESM(require_sha3());
function keccak2567(data) {
  return "0x" + import_js_sha36.default.keccak_256(arrayify12(data));
}

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version75 = "rlp/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger91 = new Logger14(version75);

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version76 = "address/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/lib.esm/index.js
var logger92 = new Logger14(version76);
function getChecksumAddress6(address) {
  if (!isHexString12(address, 20)) {
    logger92.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify12(keccak2567(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER6 = 9007199254740991;
function log106(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
var ibanLookup6 = {};
for (let i = 0; i < 10; i++) {
  ibanLookup6[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup6[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits6 = Math.floor(log106(MAX_SAFE_INTEGER6));
function ibanChecksum6(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup6[c];
  }).join("");
  while (expanded.length >= safeDigits6) {
    let block = expanded.substring(0, safeDigits6);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress7(address) {
  let result = null;
  if (typeof address !== "string") {
    logger92.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress6(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger92.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum6(address)) {
      logger92.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To168(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress6("0x" + result);
  } else {
    logger92.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/lib.esm/_version.js
init_define_process_env();
var version77 = "transactions/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/lib.esm/index.js
var logger93 = new Logger14(version77);
var TransactionTypes2;
(function(TransactionTypes5) {
  TransactionTypes5[TransactionTypes5["legacy"] = 0] = "legacy";
  TransactionTypes5[TransactionTypes5["eip2930"] = 1] = "eip2930";
  TransactionTypes5[TransactionTypes5["eip1559"] = 2] = "eip1559";
})(TransactionTypes2 || (TransactionTypes2 = {}));
function computeAddress3(key6) {
  const publicKey = computePublicKey2(key6);
  return getAddress7(hexDataSlice8(keccak2567(hexDataSlice8(publicKey, 1)), 12));
}

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/id.js
init_define_process_env();
function id5(text) {
  return keccak2567(toUtf8Bytes6(text));
}

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/namehash.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/_version.js
init_define_process_env();
var version78 = "hash/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger94 = new Logger14(version78);
var Zeros5 = new Uint8Array(32);
Zeros5.fill(0);
var Partition5 = new RegExp("^((.*)\\.)?([^.]+)$");

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/message.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/typed-data.js
init_define_process_env();
var logger95 = new Logger14(version78);
var padding5 = new Uint8Array(32);
padding5.fill(0);
var NegativeOne19 = BigNumber9.from(-1);
var Zero19 = BigNumber9.from(0);
var One11 = BigNumber9.from(1);
var MaxUint25611 = BigNumber9.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var hexTrue5 = hexZeroPad9(One11.toHexString(), 32);
var hexFalse5 = hexZeroPad9(Zero19.toHexString(), 32);
function checkString5(key6) {
  return function(value) {
    if (typeof value !== "string") {
      logger95.throwArgumentError(`invalid domain value for ${JSON.stringify(key6)}`, `domain.${key6}`, value);
    }
    return value;
  };
}
var domainChecks5 = {
  name: checkString5("name"),
  version: checkString5("version"),
  chainId: function(value) {
    try {
      return BigNumber9.from(value).toString();
    } catch (error) {
    }
    return logger95.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress7(value).toLowerCase();
    } catch (error) {
    }
    return logger95.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify12(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify10(bytes);
    } catch (error) {
    }
    return logger95.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/_version.js
init_define_process_env();
var version79 = "wordlists/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist2 = false;
var logger96 = new Logger14(version79);
var Wordlist2 = class {
  constructor(locale) {
    logger96.checkAbstract(new.target, Wordlist2);
    defineReadOnly8(this, "locale", locale);
  }
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  join(words4) {
    return words4.join(" ");
  }
  static check(wordlist4) {
    const words4 = [];
    for (let i = 0; i < 2048; i++) {
      const word = wordlist4.getWord(i);
      if (i !== wordlist4.getWordIndex(word)) {
        return "0x";
      }
      words4.push(word);
    }
    return id5(words4.join("\n") + "\n");
  }
  static register(lang, name2) {
    if (!name2) {
      name2 = lang.locale;
    }
    if (exportWordlist2) {
      try {
        const anyGlobal4 = window;
        if (anyGlobal4._ethers && anyGlobal4._ethers.wordlists) {
          if (!anyGlobal4._ethers.wordlists[name2]) {
            defineReadOnly8(anyGlobal4._ethers.wordlists, name2, lang);
          }
        }
      } catch (error) {
      }
    }
  }
};

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
init_define_process_env();
var words2 = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
var wordlist2 = null;
function loadWords2(lang) {
  if (wordlist2 != null) {
    return;
  }
  wordlist2 = words2.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist2.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist2 = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var LangEn2 = class extends Wordlist2 {
  constructor() {
    super("en");
  }
  getWord(index) {
    loadWords2(this);
    return wordlist2[index];
  }
  getWordIndex(word) {
    loadWords2(this);
    return wordlist2.indexOf(word);
  }
};
var langEn2 = new LangEn2();
Wordlist2.register(langEn2);

// node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
var wordlists2 = {
  en: langEn2
};

// node_modules/ethers/node_modules/@ethersproject/hdnode/lib.esm/_version.js
init_define_process_env();
var version80 = "hdnode/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/hdnode/lib.esm/index.js
var logger97 = new Logger14(version80);
var N = BigNumber9.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var MasterSecret = toUtf8Bytes6("Bitcoin seed");
var HardenedBit = 2147483648;
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return hexZeroPad9(hexlify10(value), 32);
}
function base58check(data) {
  return Base583.encode(concat8([data, hexDataSlice8(sha2563(sha2563(data)), 0, 4)]));
}
function getWordlist(wordlist4) {
  if (wordlist4 == null) {
    return wordlists2["en"];
  }
  if (typeof wordlist4 === "string") {
    const words4 = wordlists2[wordlist4];
    if (words4 == null) {
      logger97.throwArgumentError("unknown locale", "wordlist", wordlist4);
    }
    return words4;
  }
  return wordlist4;
}
var _constructorGuard19 = {};
var defaultPath2 = "m/44'/60'/0'/0/0";
var HDNode2 = class {
  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
    logger97.checkNew(new.target, HDNode2);
    if (constructorGuard !== _constructorGuard19) {
      throw new Error("HDNode constructor cannot be called directly");
    }
    if (privateKey) {
      const signingKey = new SigningKey3(privateKey);
      defineReadOnly8(this, "privateKey", signingKey.privateKey);
      defineReadOnly8(this, "publicKey", signingKey.compressedPublicKey);
    } else {
      defineReadOnly8(this, "privateKey", null);
      defineReadOnly8(this, "publicKey", hexlify10(publicKey));
    }
    defineReadOnly8(this, "parentFingerprint", parentFingerprint);
    defineReadOnly8(this, "fingerprint", hexDataSlice8(ripemd1602(sha2563(this.publicKey)), 0, 4));
    defineReadOnly8(this, "address", computeAddress3(this.publicKey));
    defineReadOnly8(this, "chainCode", chainCode);
    defineReadOnly8(this, "index", index);
    defineReadOnly8(this, "depth", depth);
    if (mnemonicOrPath == null) {
      defineReadOnly8(this, "mnemonic", null);
      defineReadOnly8(this, "path", null);
    } else if (typeof mnemonicOrPath === "string") {
      defineReadOnly8(this, "mnemonic", null);
      defineReadOnly8(this, "path", mnemonicOrPath);
    } else {
      defineReadOnly8(this, "mnemonic", mnemonicOrPath);
      defineReadOnly8(this, "path", mnemonicOrPath.path);
    }
  }
  get extendedKey() {
    if (this.depth >= 256) {
      throw new Error("Depth too large!");
    }
    return base58check(concat8([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      hexlify10(this.depth),
      this.parentFingerprint,
      hexZeroPad9(hexlify10(this.index), 4),
      this.chainCode,
      this.privateKey != null ? concat8(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new HDNode2(_constructorGuard19, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(index) {
    if (index > 4294967295) {
      throw new Error("invalid index - " + String(index));
    }
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
    }
    const data = new Uint8Array(37);
    if (index & HardenedBit) {
      if (!this.privateKey) {
        throw new Error("cannot derive child of neutered node");
      }
      data.set(arrayify12(this.privateKey), 1);
      if (path) {
        path += "'";
      }
    } else {
      data.set(arrayify12(this.publicKey));
    }
    for (let i = 24; i >= 0; i -= 8) {
      data[33 + (i >> 3)] = index >> 24 - i & 255;
    }
    const I = arrayify12(computeHmac2(SupportedAlgorithm2.sha512, this.chainCode, data));
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    let ki = null;
    let Ki = null;
    if (this.privateKey) {
      ki = bytes32(BigNumber9.from(IL).add(this.privateKey).mod(N));
    } else {
      const ek = new SigningKey3(hexlify10(IL));
      Ki = ek._addPoint(this.publicKey);
    }
    let mnemonicOrPath = path;
    const srcMnemonic = this.mnemonic;
    if (srcMnemonic) {
      mnemonicOrPath = Object.freeze({
        phrase: srcMnemonic.phrase,
        path,
        locale: srcMnemonic.locale || "en"
      });
    }
    return new HDNode2(_constructorGuard19, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
  }
  derivePath(path) {
    const components = path.split("/");
    if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
      throw new Error("invalid path - " + path);
    }
    if (components[0] === "m") {
      components.shift();
    }
    let result = this;
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      if (component.match(/^[0-9]+'$/)) {
        const index = parseInt(component.substring(0, component.length - 1));
        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(HardenedBit + index);
      } else if (component.match(/^[0-9]+$/)) {
        const index = parseInt(component);
        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(index);
      } else {
        throw new Error("invalid path component - " + component);
      }
    }
    return result;
  }
  static _fromSeed(seed, mnemonic) {
    const seedArray = arrayify12(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new Error("invalid seed");
    }
    const I = arrayify12(computeHmac2(SupportedAlgorithm2.sha512, MasterSecret, seedArray));
    return new HDNode2(_constructorGuard19, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);
  }
  static fromMnemonic(mnemonic, password, wordlist4) {
    wordlist4 = getWordlist(wordlist4);
    mnemonic = entropyToMnemonic2(mnemonicToEntropy(mnemonic, wordlist4), wordlist4);
    return HDNode2._fromSeed(mnemonicToSeed(mnemonic, password), {
      phrase: mnemonic,
      path: "m",
      locale: wordlist4.locale
    });
  }
  static fromSeed(seed) {
    return HDNode2._fromSeed(seed, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes = Base583.decode(extendedKey);
    if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
      logger97.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
    const depth = bytes[4];
    const parentFingerprint = hexlify10(bytes.slice(5, 9));
    const index = parseInt(hexlify10(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify10(bytes.slice(13, 45));
    const key6 = bytes.slice(45, 78);
    switch (hexlify10(bytes.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode2(_constructorGuard19, null, hexlify10(key6), parentFingerprint, chainCode, index, depth, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (key6[0] !== 0) {
          break;
        }
        return new HDNode2(_constructorGuard19, hexlify10(key6.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
    }
    return logger97.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
};
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes6("mnemonic" + password, UnicodeNormalizationForm5.NFKD);
  return pbkdf2(toUtf8Bytes6(mnemonic, UnicodeNormalizationForm5.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist4) {
  wordlist4 = getWordlist(wordlist4);
  logger97.checkNormalize();
  const words4 = wordlist4.split(mnemonic);
  if (words4.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify12(new Uint8Array(Math.ceil(11 * words4.length / 8)));
  let offset = 0;
  for (let i = 0; i < words4.length; i++) {
    let index = wordlist4.getWordIndex(words4[i].normalize("NFKD"));
    if (index === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words4.length / 3;
  const checksumBits = words4.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify12(sha2563(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify10(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic2(entropy, wordlist4) {
  wordlist4 = getWordlist(wordlist4);
  entropy = arrayify12(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify12(sha2563(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist4.join(indices.map((index) => wordlist4.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist4) {
  try {
    mnemonicToEntropy(mnemonic, wordlist4);
    return true;
  } catch (error) {
  }
  return false;
}
function getAccountPath(index) {
  if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
    logger97.throwArgumentError("invalid account index", "index", index);
  }
  return `m/44'/60'/${index}'/0/0`;
}

// node_modules/ethers/node_modules/@ethersproject/json-wallets/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
init_define_process_env();
var import_aes_js = __toESM(require_aes_js());

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version81 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors14 = false;
var _censorErrors14 = false;
var LogLevels14 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel14 = LogLevels14["default"];
var _globalLogger14 = null;
function _checkNormalize14() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError14 = _checkNormalize14();
var LogLevel14;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel14 || (LogLevel14 = {}));
var ErrorCode14;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode14 || (ErrorCode14 = {}));
var HEX14 = "0123456789abcdef";
var Logger15 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels14[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel14 > LogLevels14[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger15.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger15.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger15.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors14) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger15.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX14[value[i] >> 4];
            hex += HEX14[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode14.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode14.CALL_EXCEPTION:
      case ErrorCode14.INSUFFICIENT_FUNDS:
      case ErrorCode14.MISSING_NEW:
      case ErrorCode14.NONCE_EXPIRED:
      case ErrorCode14.REPLACEMENT_UNDERPRICED:
      case ErrorCode14.TRANSACTION_REPLACED:
      case ErrorCode14.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger15.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError14) {
      this.throwError("platform missing String.prototype.normalize", Logger15.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError14
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger15.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger15.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger15.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger15.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger15.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger15.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger15.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger14) {
      _globalLogger14 = new Logger15(version81);
    }
    return _globalLogger14;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger15.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors14) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger15.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors14 = !!censorship;
    _permanentCensorErrors14 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels14[logLevel.toLowerCase()];
    if (level == null) {
      Logger15.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel14 = level;
  }
  static from(version134) {
    return new Logger15(version134);
  }
};
Logger15.errors = ErrorCode14;
Logger15.levels = LogLevel14;

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version82 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger98 = new Logger15(version82);
function isHexable12(value) {
  return !!value.toHexString;
}
function addSlice12(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice12(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger12(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes13(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger12(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger12(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify13(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger98.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice12(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable12(value)) {
    value = value.toHexString();
  }
  if (isHexString13(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger98.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice12(new Uint8Array(result));
  }
  if (isBytes13(value)) {
    return addSlice12(new Uint8Array(value));
  }
  return logger98.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString13(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters10 = "0123456789abcdef";
function hexlify11(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger98.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters10[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable12(value)) {
    return value.toHexString();
  }
  if (isHexString13(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger98.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes13(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters10[(v & 240) >> 4] + HexCharacters10[v & 15];
    }
    return result;
  }
  return logger98.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad10(value, length) {
  if (typeof value !== "string") {
    value = hexlify11(value);
  } else if (!isHexString13(value)) {
    logger98.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger98.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn11 = __toESM(require_bn());

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version83 = "bignumber/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN11 = import_bn11.default.BN;
var logger99 = new Logger15(version83);
var _constructorGuard20 = {};
var MAX_SAFE9 = 9007199254740991;
function isBigNumberish9(value) {
  return value != null && (BigNumber10.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString13(value) || typeof value === "bigint" || isBytes13(value));
}
var _warnedToStringRadix9 = false;
var BigNumber10 = class {
  constructor(constructorGuard, hex) {
    logger99.checkNew(new.target, BigNumber10);
    if (constructorGuard !== _constructorGuard20) {
      logger99.throwError("cannot call constructor directly; use BigNumber.from", Logger15.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber9(toBN9(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber9(toBN9(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber10.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber9(toBN9(this).add(toBN9(other)));
  }
  sub(other) {
    return toBigNumber9(toBN9(this).sub(toBN9(other)));
  }
  div(other) {
    const o = BigNumber10.from(other);
    if (o.isZero()) {
      throwFault17("division-by-zero", "div");
    }
    return toBigNumber9(toBN9(this).div(toBN9(other)));
  }
  mul(other) {
    return toBigNumber9(toBN9(this).mul(toBN9(other)));
  }
  mod(other) {
    const value = toBN9(other);
    if (value.isNeg()) {
      throwFault17("division-by-zero", "mod");
    }
    return toBigNumber9(toBN9(this).umod(value));
  }
  pow(other) {
    const value = toBN9(other);
    if (value.isNeg()) {
      throwFault17("negative-power", "pow");
    }
    return toBigNumber9(toBN9(this).pow(value));
  }
  and(other) {
    const value = toBN9(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault17("unbound-bitwise-result", "and");
    }
    return toBigNumber9(toBN9(this).and(value));
  }
  or(other) {
    const value = toBN9(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault17("unbound-bitwise-result", "or");
    }
    return toBigNumber9(toBN9(this).or(value));
  }
  xor(other) {
    const value = toBN9(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault17("unbound-bitwise-result", "xor");
    }
    return toBigNumber9(toBN9(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault17("negative-width", "mask");
    }
    return toBigNumber9(toBN9(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault17("negative-width", "shl");
    }
    return toBigNumber9(toBN9(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault17("negative-width", "shr");
    }
    return toBigNumber9(toBN9(this).shrn(value));
  }
  eq(other) {
    return toBN9(this).eq(toBN9(other));
  }
  lt(other) {
    return toBN9(this).lt(toBN9(other));
  }
  lte(other) {
    return toBN9(this).lte(toBN9(other));
  }
  gt(other) {
    return toBN9(this).gt(toBN9(other));
  }
  gte(other) {
    return toBN9(this).gte(toBN9(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN9(this).isZero();
  }
  toNumber() {
    try {
      return toBN9(this).toNumber();
    } catch (error) {
      throwFault17("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger99.throwError("this platform does not support BigInt", Logger15.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix9) {
          _warnedToStringRadix9 = true;
          logger99.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger99.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger15.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger99.throwError("BigNumber.toString does not accept parameters", Logger15.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN9(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber10) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber10(_constructorGuard20, toHex9(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber10(_constructorGuard20, toHex9(new BN11(value)));
      }
      return logger99.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault17("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE9 || value <= -MAX_SAFE9) {
        throwFault17("overflow", "BigNumber.from", value);
      }
      return BigNumber10.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber10.from(anyValue.toString());
    }
    if (isBytes13(anyValue)) {
      return BigNumber10.from(hexlify11(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber10.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString13(hex) || hex[0] === "-" && isHexString13(hex.substring(1))) {
            return BigNumber10.from(hex);
          }
        }
      }
    }
    return logger99.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex9(value) {
  if (typeof value !== "string") {
    return toHex9(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger99.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex9(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber9(value) {
  return BigNumber10.from(toHex9(value));
}
function toBN9(value) {
  const hex = BigNumber10.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN11("-" + hex.substring(3), 16);
  }
  return new BN11(hex.substring(2), 16);
}
function throwFault17(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger99.throwError(fault, Logger15.errors.NUMERIC_FAULT, params);
}
function _base36To169(value) {
  return new BN11(value, 36).toString(16);
}

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger100 = new Logger15(version83);
var _constructorGuard21 = {};
var Zero20 = BigNumber10.from(0);
var NegativeOne20 = BigNumber10.from(-1);
function throwFault18(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger100.throwError(message, Logger15.errors.NUMERIC_FAULT, params);
}
var zeros9 = "0";
while (zeros9.length < 256) {
  zeros9 += zeros9;
}
function getMultiplier9(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber10.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros9.substring(0, decimals);
  }
  return logger100.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed10(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier9(decimals);
  value = BigNumber10.from(value);
  const negative = value.lt(Zero20);
  if (negative) {
    value = value.mul(NegativeOne20);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed10(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier9(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger100.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger100.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger100.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault18("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber10.from(whole);
  const fractionValue = BigNumber10.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne20);
  }
  return wei;
}
var FixedFormat9 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard21) {
      logger100.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger15.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier9(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat9) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger100.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger100.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger100.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger100.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat9(_constructorGuard21, signed, width, decimals);
  }
};
var FixedNumber9 = class {
  constructor(constructorGuard, hex, value, format) {
    logger100.checkNew(new.target, FixedNumber9);
    if (constructorGuard !== _constructorGuard21) {
      logger100.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger15.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger100.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed10(this._value, this.format.decimals);
    const b = parseFixed10(other._value, other.format.decimals);
    return FixedNumber9.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed10(this._value, this.format.decimals);
    const b = parseFixed10(other._value, other.format.decimals);
    return FixedNumber9.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed10(this._value, this.format.decimals);
    const b = parseFixed10(other._value, other.format.decimals);
    return FixedNumber9.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed10(this._value, this.format.decimals);
    const b = parseFixed10(other._value, other.format.decimals);
    return FixedNumber9.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber9.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE9.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber9.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE9.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger100.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber9.from("1" + zeros9.substring(0, decimals), this.format);
    const bump = BUMP9.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger100.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber10.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad10(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber9.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish9(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber9.fromString(formatFixed10(value, decimals), FixedFormat9.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat9.from(format);
    const numeric = parseFixed10(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero20)) {
      throwFault18("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad10(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed10(numeric, fixedFormat.decimals);
    return new FixedNumber9(_constructorGuard21, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat9.from(format);
    if (arrayify13(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber10.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed10(numeric, fixedFormat.decimals);
    return new FixedNumber9(_constructorGuard21, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber9.fromString(value, format);
    }
    if (isBytes13(value)) {
      return FixedNumber9.fromBytes(value, format);
    }
    try {
      return FixedNumber9.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger15.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger100.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE9 = FixedNumber9.from(1);
var BUMP9 = FixedNumber9.from("0.5");

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha37 = __toESM(require_sha3());
function keccak2568(data) {
  return "0x" + import_js_sha37.default.keccak_256(arrayify13(data));
}

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version84 = "rlp/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger101 = new Logger15(version84);

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version85 = "address/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/lib.esm/index.js
var logger102 = new Logger15(version85);
function getChecksumAddress7(address) {
  if (!isHexString13(address, 20)) {
    logger102.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify13(keccak2568(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER7 = 9007199254740991;
function log107(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
var ibanLookup7 = {};
for (let i = 0; i < 10; i++) {
  ibanLookup7[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup7[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits7 = Math.floor(log107(MAX_SAFE_INTEGER7));
function ibanChecksum7(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup7[c];
  }).join("");
  while (expanded.length >= safeDigits7) {
    let block = expanded.substring(0, safeDigits7);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress8(address) {
  let result = null;
  if (typeof address !== "string") {
    logger102.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress7(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger102.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum7(address)) {
      logger102.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To169(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress7("0x" + result);
  } else {
    logger102.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/pbkdf2/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/sha2/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/sha2/lib.esm/sha2.js
init_define_process_env();
var import_hash11 = __toESM(require_hash());

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/sha2/lib.esm/types.js
init_define_process_env();
var SupportedAlgorithm3;
(function(SupportedAlgorithm5) {
  SupportedAlgorithm5["sha256"] = "sha256";
  SupportedAlgorithm5["sha512"] = "sha512";
})(SupportedAlgorithm3 || (SupportedAlgorithm3 = {}));

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/sha2/lib.esm/_version.js
init_define_process_env();
var version86 = "sha2/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/sha2/lib.esm/sha2.js
var logger103 = new Logger15(version86);

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();
var NegativeOne21 = BigNumber10.from(-1);
var Zero21 = BigNumber10.from(0);
var One12 = BigNumber10.from(1);
var Two7 = BigNumber10.from(2);
var WeiPerEther7 = BigNumber10.from("1000000000000000000");
var MaxUint25612 = BigNumber10.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2567 = BigNumber10.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2567 = BigNumber10.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version87 = "strings/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger104 = new Logger15(version87);
var UnicodeNormalizationForm6;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm6 || (UnicodeNormalizationForm6 = {}));
var Utf8ErrorReason6;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason6 || (Utf8ErrorReason6 = {}));
function errorFunc6(reason, offset, bytes, output, badCodepoint) {
  return logger104.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc6(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason6.BAD_PREFIX || reason === Utf8ErrorReason6.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason6.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc6(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason6.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc6(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs6 = Object.freeze({
  error: errorFunc6,
  ignore: ignoreFunc6,
  replace: replaceFunc6
});
function toUtf8Bytes7(str, form = UnicodeNormalizationForm6.current) {
  if (form != UnicodeNormalizationForm6.current) {
    logger104.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify13(result);
}

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes26(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable6(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable6(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges6 = createRangeTable6("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags6 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
var Table_B_2_lut_abs6 = createTable6("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel6 = createTable6("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex6 = createTable6("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes26);
var Table_C_ranges6 = createRangeTable6("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version88 = "properties/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/properties/lib.esm/index.js
var logger105 = new Logger15(version88);
function defineReadOnly9(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/ethers/node_modules/@ethersproject/json-wallets/lib.esm/_version.js
init_define_process_env();
var version89 = "json-wallets/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/lib.esm/utils.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
var logger106 = new Logger15(version89);

// node_modules/ethers/node_modules/@ethersproject/json-wallets/lib.esm/inspect.js
init_define_process_env();
function isCrowdsaleWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return getAddress8(JSON.parse(json).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json)) {
    try {
      return getAddress8(JSON.parse(json).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}

// node_modules/ethers/node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
init_define_process_env();
var import_aes_js2 = __toESM(require_aes_js());
var import_scrypt_js = __toESM(require_scrypt());

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hdnode/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/basex/lib.esm/index.js
init_define_process_env();
var BaseX4 = class {
  constructor(alphabet) {
    defineReadOnly9(this, "alphabet", alphabet);
    defineReadOnly9(this, "base", alphabet.length);
    defineReadOnly9(this, "_alphabetMap", {});
    defineReadOnly9(this, "_leader", alphabet.charAt(0));
    for (let i = 0; i < alphabet.length; i++) {
      this._alphabetMap[alphabet.charAt(i)] = i;
    }
  }
  encode(value) {
    let source = arrayify13(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i = 0; i < source.length; ++i) {
      let carry = source[i];
      for (let j = 0; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
      string += this._leader;
    }
    for (let q = digits.length - 1; q >= 0; --q) {
      string += this.alphabet[digits[q]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i = 0; i < value.length; i++) {
      let byte = this._alphabetMap[value[i]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j = 0; j < bytes.length; ++j) {
        carry += bytes[j] * this.base;
        bytes[j] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
      bytes.push(0);
    }
    return arrayify13(new Uint8Array(bytes.reverse()));
  }
};
var Base324 = new BaseX4("abcdefghijklmnopqrstuvwxyz234567");
var Base584 = new BaseX4("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/signing-key/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
init_define_process_env();
var import_bn12 = __toESM(require_bn());
var import_hash12 = __toESM(require_hash());
function createCommonjsModule3(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base6) {
      return commonjsRequire3(path, base6 === void 0 || base6 === null ? module.path : base6);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire3() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert3 = assert3;
function assert3(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert3.equal = function assertEqual3(l, r, msg) {
  if (l != r)
    throw new Error(msg || "Assertion failed: " + l + " != " + r);
};
var utils_13 = createCommonjsModule3(function(module, exports) {
  "use strict";
  var utils = exports;
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex13(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex13;
  utils.encode = function encode18(arr, enc) {
    if (enc === "hex")
      return toHex13(arr);
    else
      return arr;
  };
});
var utils_1$13 = createCommonjsModule3(function(module, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert3;
  utils.toArray = utils_13.toArray;
  utils.zero2 = utils_13.zero2;
  utils.toHex = utils_13.toHex;
  utils.encode = utils_13.encode;
  function getNAF6(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF6;
  function getJSF6(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF6;
  function cachedProperty(obj, name2, computer) {
    var key6 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key6] !== void 0 ? this[key6] : this[key6] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn12.default(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});
var getNAF3 = utils_1$13.getNAF;
var getJSF3 = utils_1$13.getJSF;
var assert$13 = utils_1$13.assert;
function BaseCurve3(type, conf) {
  this.type = type;
  this.p = new import_bn12.default(conf.p, 16);
  this.red = conf.prime ? import_bn12.default.red(conf.prime) : import_bn12.default.mont(this.p);
  this.zero = new import_bn12.default(0).toRed(this.red);
  this.one = new import_bn12.default(1).toRed(this.red);
  this.two = new import_bn12.default(2).toRed(this.red);
  this.n = conf.n && new import_bn12.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base3 = BaseCurve3;
BaseCurve3.prototype.point = function point5() {
  throw new Error("Not implemented");
};
BaseCurve3.prototype.validate = function validate9() {
  throw new Error("Not implemented");
};
BaseCurve3.prototype._fixedNafMul = function _fixedNafMul3(p, k) {
  assert$13(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF3(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};
BaseCurve3.prototype._wnafMul = function _wnafMul3(p, k) {
  var w = 4;
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF3(k, w, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);
    if (i < 0)
      break;
    var z = naf[i];
    assert$13(z !== 0);
    if (p.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p.type === "affine" ? acc.toP() : acc;
};
BaseCurve3.prototype._wnafMulAdd = function _wnafMulAdd3(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF3(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF3(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [
      points[a],
      null,
      null,
      points[b]
    ];
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF3(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;
    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][z - 1 >> 1];
      else if (z < 0)
        p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === "affine")
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  for (i = 0; i < len; i++)
    wnd[i] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint3(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve3.BasePoint = BasePoint3;
BasePoint3.prototype.eq = function eq7() {
  throw new Error("Not implemented");
};
BasePoint3.prototype.validate = function validate10() {
  return this.curve.validate(this);
};
BaseCurve3.prototype.decodePoint = function decodePoint3(bytes, enc) {
  bytes = utils_1$13.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$13(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$13(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint3.prototype.encodeCompressed = function encodeCompressed3(enc) {
  return this.encode(enc, true);
};
BasePoint3.prototype._encode = function _encode5(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x);
  return [4].concat(x, this.getY().toArray("be", len));
};
BasePoint3.prototype.encode = function encode12(enc, compact) {
  return utils_1$13.encode(this._encode(compact), enc);
};
BasePoint3.prototype.precompute = function precompute3(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint3.prototype._hasDoubles = function _hasDoubles3(k) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint3.prototype._getDoubles = function _getDoubles3(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint3.prototype._getNAFPoints = function _getNAFPoints3(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl11 = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl11);
  return {
    wnd,
    points: res
  };
};
BasePoint3.prototype._getBeta = function _getBeta5() {
  return null;
};
BasePoint3.prototype.dblp = function dblp5(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};
var inherits_browser3 = createCommonjsModule3(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$23 = utils_1$13.assert;
function ShortCurve3(conf) {
  base3.call(this, "short", conf);
  this.a = new import_bn12.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn12.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser3(ShortCurve3, base3);
var short_13 = ShortCurve3;
ShortCurve3.prototype._getEndomorphism = function _getEndomorphism3(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn12.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn12.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$23(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn12.default(vec.a, 16),
        b: new import_bn12.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve3.prototype._getEndoRoots = function _getEndoRoots3(num) {
  var red = num === this.p ? this.red : import_bn12.default.mont(num);
  var tinv = new import_bn12.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new import_bn12.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
};
ShortCurve3.prototype._getEndoBasis = function _getEndoBasis3(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u = lambda;
  var v = this.n.clone();
  var x1 = new import_bn12.default(1);
  var y1 = new import_bn12.default(0);
  var x2 = new import_bn12.default(0);
  var y2 = new import_bn12.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));
    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve3.prototype._endoSplit = function _endoSplit3(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1, k2 };
};
ShortCurve3.prototype.pointFromX = function pointFromX3(x, odd) {
  x = new import_bn12.default(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
};
ShortCurve3.prototype.validate = function validate11(point11) {
  if (point11.inf)
    return true;
  var x = point11.x;
  var y = point11.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve3.prototype._endoWnafMulAdd = function _endoWnafMulAdd3(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point3(curve, x, y, isRed) {
  base3.BasePoint.call(this, curve, "affine");
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn12.default(x, 16);
    this.y = new import_bn12.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser3(Point3, base3.BasePoint);
ShortCurve3.prototype.point = function point6(x, y, isRed) {
  return new Point3(this, x, y, isRed);
};
ShortCurve3.prototype.pointFromJSON = function pointFromJSON3(obj, red) {
  return Point3.fromJSON(this, obj, red);
};
Point3.prototype._getBeta = function _getBeta6() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point3.prototype.toJSON = function toJSON3() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point3.fromJSON = function fromJSON3(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point3.prototype.inspect = function inspect7() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point3.prototype.isInfinity = function isInfinity5() {
  return this.inf;
};
Point3.prototype.add = function add5(p) {
  if (this.inf)
    return p;
  if (p.inf)
    return this;
  if (this.eq(p))
    return this.dbl();
  if (this.neg().eq(p))
    return this.curve.point(null, null);
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point3.prototype.dbl = function dbl5() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point3.prototype.getX = function getX3() {
  return this.x.fromRed();
};
Point3.prototype.getY = function getY3() {
  return this.y.fromRed();
};
Point3.prototype.mul = function mul5(k) {
  k = new import_bn12.default(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k]);
  else
    return this.curve._wnafMul(this, k);
};
Point3.prototype.mulAdd = function mulAdd3(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point3.prototype.jmulAdd = function jmulAdd3(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point3.prototype.eq = function eq8(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point3.prototype.neg = function neg5(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point3.prototype.toJ = function toJ3() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint3(curve, x, y, z) {
  base3.BasePoint.call(this, curve, "jacobian");
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn12.default(0);
  } else {
    this.x = new import_bn12.default(x, 16);
    this.y = new import_bn12.default(y, 16);
    this.z = new import_bn12.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser3(JPoint3, base3.BasePoint);
ShortCurve3.prototype.jpoint = function jpoint3(x, y, z) {
  return new JPoint3(this, x, y, z);
};
JPoint3.prototype.toP = function toP3() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint3.prototype.neg = function neg6() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint3.prototype.add = function add6(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint3.prototype.mixedAdd = function mixedAdd3(p) {
  if (this.isInfinity())
    return p.toJ();
  if (p.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint3.prototype.dblp = function dblp6(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }
  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint3.prototype.dbl = function dbl6() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint3.prototype._zeroDbl = function _zeroDbl3() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx);
    var t = m.redSqr().redISub(s).redISub(s);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t;
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = b.redSqr();
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    var e = a.redAdd(a).redIAdd(a);
    var f = e.redSqr();
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f.redISub(d).redISub(d);
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint3.prototype._threeDbl = function _threeDbl3() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t = m.redSqr().redISub(s).redISub(s);
    nx = t;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint3.prototype._dbl = function _dbl3() {
  var a = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint3.prototype.trpl = function trpl3() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m = xx.redAdd(xx).redIAdd(xx);
  var mm = m.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee = e.redSqr();
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint3.prototype.mul = function mul6(k, kbase) {
  k = new import_bn12.default(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint3.prototype.eq = function eq9(p) {
  if (p.type === "affine")
    return this.eq(p.toJ());
  if (this === p)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint3.prototype.eqXToP = function eqXToP3(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint3.prototype.inspect = function inspect8() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint3.prototype.isInfinity = function isInfinity6() {
  return this.z.cmpn(0) === 0;
};
var curve_13 = createCommonjsModule3(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base3;
  curve.short = short_13;
  curve.mont = null;
  curve.edwards = null;
});
var curves_13 = createCommonjsModule3(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert6 = utils_1$13.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_13.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_13.edwards(options);
    else
      this.curve = new curve_13.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert6(this.g.validate(), "Invalid curve");
    assert6(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash12.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash12.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash12.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash12.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash12.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash12.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash12.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash12.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG3(options) {
  if (!(this instanceof HmacDRBG3))
    return new HmacDRBG3(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_13.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_13.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_13.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert3(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg3 = HmacDRBG3;
HmacDRBG3.prototype._init = function init3(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0;
    this.V[i] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG3.prototype._hmac = function hmac3() {
  return new import_hash12.default.hmac(this.hash, this.K);
};
HmacDRBG3.prototype._update = function update3(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG3.prototype.reseed = function reseed3(entropy, entropyEnc, add11, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add11;
    add11 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_13.toArray(entropy, entropyEnc);
  add11 = utils_13.toArray(add11, addEnc);
  minimalisticAssert3(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add11 || []));
  this._reseed = 1;
};
HmacDRBG3.prototype.generate = function generate3(len, enc, add11, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add11;
    add11 = enc;
    enc = null;
  }
  if (add11) {
    add11 = utils_13.toArray(add11, addEnc || "hex");
    this._update(add11);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add11);
  this._reseed++;
  return utils_13.encode(res, enc);
};
var assert$33 = utils_1$13.assert;
function KeyPair3(ec6, options) {
  this.ec = ec6;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key3 = KeyPair3;
KeyPair3.fromPublic = function fromPublic3(ec6, pub, enc) {
  if (pub instanceof KeyPair3)
    return pub;
  return new KeyPair3(ec6, {
    pub,
    pubEnc: enc
  });
};
KeyPair3.fromPrivate = function fromPrivate3(ec6, priv, enc) {
  if (priv instanceof KeyPair3)
    return priv;
  return new KeyPair3(ec6, {
    priv,
    privEnc: enc
  });
};
KeyPair3.prototype.validate = function validate12() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair3.prototype.getPublic = function getPublic3(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair3.prototype.getPrivate = function getPrivate3(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair3.prototype._importPrivate = function _importPrivate3(key6, enc) {
  this.priv = new import_bn12.default(key6, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair3.prototype._importPublic = function _importPublic3(key6, enc) {
  if (key6.x || key6.y) {
    if (this.ec.curve.type === "mont") {
      assert$33(key6.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$33(key6.x && key6.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key6.x, key6.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key6, enc);
};
KeyPair3.prototype.derive = function derive3(pub) {
  if (!pub.validate()) {
    assert$33(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair3.prototype.sign = function sign5(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair3.prototype.verify = function verify5(msg, signature6) {
  return this.ec.verify(msg, signature6, this);
};
KeyPair3.prototype.inspect = function inspect9() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$43 = utils_1$13.assert;
function Signature3(options, enc) {
  if (options instanceof Signature3)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$43(options.r && options.s, "Signature without r or s");
  this.r = new import_bn12.default(options.r, 16);
  this.s = new import_bn12.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature3 = Signature3;
function Position3() {
  this.place = 0;
}
function getLength3(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
function rmPadding3(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature3.prototype._importDER = function _importDER3(data, enc) {
  data = utils_1$13.toArray(data, enc);
  var p = new Position3();
  if (data[p.place++] !== 48) {
    return false;
  }
  var len = getLength3(data, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data.length) {
    return false;
  }
  if (data[p.place++] !== 2) {
    return false;
  }
  var rlen = getLength3(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 2) {
    return false;
  }
  var slen = getLength3(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 128) {
      r = r.slice(1);
    } else {
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 128) {
      s = s.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn12.default(r);
  this.s = new import_bn12.default(s);
  this.recoveryParam = null;
  return true;
};
function constructLength3(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature3.prototype.toDER = function toDER3(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();
  if (r[0] & 128)
    r = [0].concat(r);
  if (s[0] & 128)
    s = [0].concat(s);
  r = rmPadding3(r);
  s = rmPadding3(s);
  while (!s[0] && !(s[1] & 128)) {
    s = s.slice(1);
  }
  var arr = [2];
  constructLength3(arr, r.length);
  arr = arr.concat(r);
  arr.push(2);
  constructLength3(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [48];
  constructLength3(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$13.encode(res, enc);
};
var rand3 = function() {
  throw new Error("unsupported");
};
var assert$53 = utils_1$13.assert;
function EC3(options) {
  if (!(this instanceof EC3))
    return new EC3(options);
  if (typeof options === "string") {
    assert$53(Object.prototype.hasOwnProperty.call(curves_13, options), "Unknown curve " + options);
    options = curves_13[options];
  }
  if (options instanceof curves_13.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec3 = EC3;
EC3.prototype.keyPair = function keyPair3(options) {
  return new key3(this, options);
};
EC3.prototype.keyFromPrivate = function keyFromPrivate3(priv, enc) {
  return key3.fromPrivate(this, priv, enc);
};
EC3.prototype.keyFromPublic = function keyFromPublic3(pub, enc) {
  return key3.fromPublic(this, pub, enc);
};
EC3.prototype.genKeyPair = function genKeyPair3(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg3({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand3(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn12.default(2));
  for (; ; ) {
    var priv = new import_bn12.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC3.prototype._truncateToN = function _truncateToN3(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC3.prototype.sign = function sign6(msg, key6, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key6 = this.keyFromPrivate(key6, enc);
  msg = this._truncateToN(new import_bn12.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key6.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg3({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn12.default(1));
  for (var iter = 0; ; iter++) {
    var k = options.k ? options.k(iter) : new import_bn12.default(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;
    var s = k.invm(this.n).mul(r.mul(key6.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }
    return new signature3({ r, s, recoveryParam });
  }
};
EC3.prototype.verify = function verify6(msg, signature$1, key6, enc) {
  msg = this._truncateToN(new import_bn12.default(msg, 16));
  key6 = this.keyFromPublic(key6, enc);
  signature$1 = new signature3(signature$1, "hex");
  var r = signature$1.r;
  var s = signature$1.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;
  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key6.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  }
  p = this.g.jmulAdd(u1, key6.getPublic(), u2);
  if (p.isInfinity())
    return false;
  return p.eqXToP(r);
};
EC3.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$53((3 & j) === j, "The recovery param is more than two bits");
  signature$1 = new signature3(signature$1, enc);
  var n = this.n;
  var e = new import_bn12.default(msg);
  var r = signature$1.r;
  var s = signature$1.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r, s2);
};
EC3.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {
  signature$1 = new signature3(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_13 = createCommonjsModule3(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$13;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_13;
  elliptic.curves = curves_13;
  elliptic.ec = ec3;
  elliptic.eddsa = null;
});
var EC$13 = elliptic_13.ec;

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/signing-key/lib.esm/_version.js
init_define_process_env();
var version90 = "signing-key/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger107 = new Logger15(version90);

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/transactions/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/transactions/lib.esm/_version.js
init_define_process_env();
var version91 = "transactions/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/transactions/lib.esm/index.js
var logger108 = new Logger15(version91);
var TransactionTypes3;
(function(TransactionTypes5) {
  TransactionTypes5[TransactionTypes5["legacy"] = 0] = "legacy";
  TransactionTypes5[TransactionTypes5["eip2930"] = 1] = "eip2930";
  TransactionTypes5[TransactionTypes5["eip1559"] = 2] = "eip1559";
})(TransactionTypes3 || (TransactionTypes3 = {}));

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/id.js
init_define_process_env();
function id6(text) {
  return keccak2568(toUtf8Bytes7(text));
}

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/namehash.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/_version.js
init_define_process_env();
var version92 = "hash/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger109 = new Logger15(version92);
var Zeros6 = new Uint8Array(32);
Zeros6.fill(0);
var Partition6 = new RegExp("^((.*)\\.)?([^.]+)$");

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/message.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/typed-data.js
init_define_process_env();
var logger110 = new Logger15(version92);
var padding6 = new Uint8Array(32);
padding6.fill(0);
var NegativeOne22 = BigNumber10.from(-1);
var Zero22 = BigNumber10.from(0);
var One13 = BigNumber10.from(1);
var MaxUint25613 = BigNumber10.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var hexTrue6 = hexZeroPad10(One13.toHexString(), 32);
var hexFalse6 = hexZeroPad10(Zero22.toHexString(), 32);
function checkString6(key6) {
  return function(value) {
    if (typeof value !== "string") {
      logger110.throwArgumentError(`invalid domain value for ${JSON.stringify(key6)}`, `domain.${key6}`, value);
    }
    return value;
  };
}
var domainChecks6 = {
  name: checkString6("name"),
  version: checkString6("version"),
  chainId: function(value) {
    try {
      return BigNumber10.from(value).toString();
    } catch (error) {
    }
    return logger110.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress8(value).toLowerCase();
    } catch (error) {
    }
    return logger110.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify13(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify11(bytes);
    } catch (error) {
    }
    return logger110.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/lib.esm/_version.js
init_define_process_env();
var version93 = "wordlists/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist3 = false;
var logger111 = new Logger15(version93);
var Wordlist3 = class {
  constructor(locale) {
    logger111.checkAbstract(new.target, Wordlist3);
    defineReadOnly9(this, "locale", locale);
  }
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  join(words4) {
    return words4.join(" ");
  }
  static check(wordlist4) {
    const words4 = [];
    for (let i = 0; i < 2048; i++) {
      const word = wordlist4.getWord(i);
      if (i !== wordlist4.getWordIndex(word)) {
        return "0x";
      }
      words4.push(word);
    }
    return id6(words4.join("\n") + "\n");
  }
  static register(lang, name2) {
    if (!name2) {
      name2 = lang.locale;
    }
    if (exportWordlist3) {
      try {
        const anyGlobal4 = window;
        if (anyGlobal4._ethers && anyGlobal4._ethers.wordlists) {
          if (!anyGlobal4._ethers.wordlists[name2]) {
            defineReadOnly9(anyGlobal4._ethers.wordlists, name2, lang);
          }
        }
      } catch (error) {
      }
    }
  }
};

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
init_define_process_env();
var words3 = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
var wordlist3 = null;
function loadWords3(lang) {
  if (wordlist3 != null) {
    return;
  }
  wordlist3 = words3.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist3.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist3 = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var LangEn3 = class extends Wordlist3 {
  constructor() {
    super("en");
  }
  getWord(index) {
    loadWords3(this);
    return wordlist3[index];
  }
  getWordIndex(word) {
    loadWords3(this);
    return wordlist3.indexOf(word);
  }
};
var langEn3 = new LangEn3();
Wordlist3.register(langEn3);

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hdnode/lib.esm/_version.js
init_define_process_env();
var version94 = "hdnode/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hdnode/lib.esm/index.js
var logger112 = new Logger15(version94);
var N2 = BigNumber10.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var MasterSecret2 = toUtf8Bytes7("Bitcoin seed");

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/random/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/random/lib.esm/random.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/random/lib.esm/_version.js
init_define_process_env();
var version95 = "random/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/random/lib.esm/random.js
var logger113 = new Logger15(version95);
function getGlobal2() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal2 = getGlobal2();
var crypto2 = anyGlobal2.crypto || anyGlobal2.msCrypto;
if (!crypto2 || !crypto2.getRandomValues) {
  logger113.warn("WARNING: Missing strong random number source");
  crypto2 = {
    getRandomValues: function(buffer) {
      return logger113.throwError("no secure random source avaialble", Logger15.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}

// node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/random/lib.esm/shuffle.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
var logger114 = new Logger15(version89);

// node_modules/ethers/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha38 = __toESM(require_sha3());

// node_modules/ethers/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version96 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors15 = false;
var _censorErrors15 = false;
var LogLevels15 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel15 = LogLevels15["default"];
var _globalLogger15 = null;
function _checkNormalize15() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError15 = _checkNormalize15();
var LogLevel15;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel15 || (LogLevel15 = {}));
var ErrorCode15;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode15 || (ErrorCode15 = {}));
var HEX15 = "0123456789abcdef";
var Logger16 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels15[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel15 > LogLevels15[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger16.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger16.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger16.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors15) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger16.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX15[value[i] >> 4];
            hex += HEX15[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode15.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode15.CALL_EXCEPTION:
      case ErrorCode15.INSUFFICIENT_FUNDS:
      case ErrorCode15.MISSING_NEW:
      case ErrorCode15.NONCE_EXPIRED:
      case ErrorCode15.REPLACEMENT_UNDERPRICED:
      case ErrorCode15.TRANSACTION_REPLACED:
      case ErrorCode15.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger16.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError15) {
      this.throwError("platform missing String.prototype.normalize", Logger16.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError15
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger16.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger16.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger16.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger16.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger16.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger16.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger16.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger15) {
      _globalLogger15 = new Logger16(version96);
    }
    return _globalLogger15;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger16.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors15) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger16.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors15 = !!censorship;
    _permanentCensorErrors15 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels15[logLevel.toLowerCase()];
    if (level == null) {
      Logger16.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel15 = level;
  }
  static from(version134) {
    return new Logger16(version134);
  }
};
Logger16.errors = ErrorCode15;
Logger16.levels = LogLevel15;

// node_modules/ethers/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version97 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger115 = new Logger16(version97);
function isHexable13(value) {
  return !!value.toHexString;
}
function addSlice13(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice13(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger13(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes14(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger13(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger13(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify14(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger115.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice13(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable13(value)) {
    value = value.toHexString();
  }
  if (isHexString14(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger115.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice13(new Uint8Array(result));
  }
  if (isBytes14(value)) {
    return addSlice13(new Uint8Array(value));
  }
  return logger115.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString14(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

// node_modules/ethers/node_modules/@ethersproject/keccak256/lib.esm/index.js
function keccak2569(data) {
  return "0x" + import_js_sha38.default.keccak_256(arrayify14(data));
}

// node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/sha2.js
init_define_process_env();
var import_hash14 = __toESM(require_hash());

// node_modules/ethers/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/sha2/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/sha2/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version98 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/sha2/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors16 = false;
var _censorErrors16 = false;
var LogLevels16 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel16 = LogLevels16["default"];
var _globalLogger16 = null;
function _checkNormalize16() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError16 = _checkNormalize16();
var LogLevel16;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel16 || (LogLevel16 = {}));
var ErrorCode16;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode16 || (ErrorCode16 = {}));
var HEX16 = "0123456789abcdef";
var Logger17 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels16[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel16 > LogLevels16[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger17.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger17.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger17.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors16) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger17.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX16[value[i] >> 4];
            hex += HEX16[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode16.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode16.CALL_EXCEPTION:
      case ErrorCode16.INSUFFICIENT_FUNDS:
      case ErrorCode16.MISSING_NEW:
      case ErrorCode16.NONCE_EXPIRED:
      case ErrorCode16.REPLACEMENT_UNDERPRICED:
      case ErrorCode16.TRANSACTION_REPLACED:
      case ErrorCode16.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger17.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError16) {
      this.throwError("platform missing String.prototype.normalize", Logger17.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError16
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger17.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger17.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger17.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger17.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger17.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger17.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger17.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger16) {
      _globalLogger16 = new Logger17(version98);
    }
    return _globalLogger16;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger17.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors16) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger17.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors16 = !!censorship;
    _permanentCensorErrors16 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels16[logLevel.toLowerCase()];
    if (level == null) {
      Logger17.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel16 = level;
  }
  static from(version134) {
    return new Logger17(version134);
  }
};
Logger17.errors = ErrorCode16;
Logger17.levels = LogLevel16;

// node_modules/ethers/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version99 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger116 = new Logger17(version99);
function isHexable14(value) {
  return !!value.toHexString;
}
function addSlice14(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice14(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger14(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes15(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger14(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger14(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify15(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger116.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice14(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable14(value)) {
    value = value.toHexString();
  }
  if (isHexString15(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger116.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice14(new Uint8Array(result));
  }
  if (isBytes15(value)) {
    return addSlice14(new Uint8Array(value));
  }
  return logger116.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString15(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

// node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/types.js
init_define_process_env();
var SupportedAlgorithm4;
(function(SupportedAlgorithm5) {
  SupportedAlgorithm5["sha256"] = "sha256";
  SupportedAlgorithm5["sha512"] = "sha512";
})(SupportedAlgorithm4 || (SupportedAlgorithm4 = {}));

// node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/_version.js
init_define_process_env();
var version100 = "sha2/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/sha2/lib.esm/sha2.js
var logger117 = new Logger17(version100);
function ripemd1604(data) {
  return "0x" + import_hash14.default.ripemd160().update(arrayify15(data)).digest("hex");
}
function sha2565(data) {
  return "0x" + import_hash14.default.sha256().update(arrayify15(data)).digest("hex");
}
function sha5124(data) {
  return "0x" + import_hash14.default.sha512().update(arrayify15(data)).digest("hex");
}
function computeHmac4(algorithm, key6, data) {
  if (!SupportedAlgorithm4[algorithm]) {
    logger117.throwError("unsupported algorithm " + algorithm, Logger17.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + import_hash14.default.hmac(import_hash14.default[algorithm], arrayify15(key6)).update(arrayify15(data)).digest("hex");
}

// node_modules/@ethersproject/solidity/lib.esm/index.js
init_define_process_env();
init_lib3();
init_lib2();
init_lib5();
init_lib14();
init_lib7();
init_lib();

// node_modules/@ethersproject/solidity/lib.esm/_version.js
init_define_process_env();
var version101 = "solidity/5.5.0";

// node_modules/@ethersproject/solidity/lib.esm/index.js
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
var Zeros7 = "0000000000000000000000000000000000000000000000000000000000000000";
var logger118 = new Logger(version101);
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger118.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray) {
      size = 256;
    }
    value = BigNumber.from(value).toTwos(size);
    return zeroPad(value, size / 8);
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    if (String(size) !== match[1] || size === 0 || size > 32) {
      logger118.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size) {
      logger118.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray) {
      return arrayify((value + Zeros7).substring(0, 66));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    if (count != value.length) {
      logger118.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat(result);
  }
  return logger118.throwArgumentError("invalid type", "type", type);
}
function pack2(types, values) {
  if (types.length != values.length) {
    logger118.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function keccak25610(types, values) {
  return keccak256(pack2(types, values));
}
function sha2566(types, values) {
  return sha256(pack2(types, values));
}

// node_modules/ethers/node_modules/@ethersproject/random/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/random/lib.esm/random.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/random/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/random/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/random/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version102 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/random/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors17 = false;
var _censorErrors17 = false;
var LogLevels17 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel17 = LogLevels17["default"];
var _globalLogger17 = null;
function _checkNormalize17() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError17 = _checkNormalize17();
var LogLevel17;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel17 || (LogLevel17 = {}));
var ErrorCode17;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode17 || (ErrorCode17 = {}));
var HEX17 = "0123456789abcdef";
var Logger18 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels17[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel17 > LogLevels17[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger18.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger18.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger18.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors17) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger18.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX17[value[i] >> 4];
            hex += HEX17[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode17.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode17.CALL_EXCEPTION:
      case ErrorCode17.INSUFFICIENT_FUNDS:
      case ErrorCode17.MISSING_NEW:
      case ErrorCode17.NONCE_EXPIRED:
      case ErrorCode17.REPLACEMENT_UNDERPRICED:
      case ErrorCode17.TRANSACTION_REPLACED:
      case ErrorCode17.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger18.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError17) {
      this.throwError("platform missing String.prototype.normalize", Logger18.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError17
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger18.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger18.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger18.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger18.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger18.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger18.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger18.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger17) {
      _globalLogger17 = new Logger18(version102);
    }
    return _globalLogger17;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger18.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors17) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger18.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors17 = !!censorship;
    _permanentCensorErrors17 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels17[logLevel.toLowerCase()];
    if (level == null) {
      Logger18.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel17 = level;
  }
  static from(version134) {
    return new Logger18(version134);
  }
};
Logger18.errors = ErrorCode17;
Logger18.levels = LogLevel17;

// node_modules/ethers/node_modules/@ethersproject/random/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version103 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/random/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger119 = new Logger18(version103);
function isHexable15(value) {
  return !!value.toHexString;
}
function addSlice15(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice15(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger15(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes16(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger15(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger15(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify16(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger119.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice15(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable15(value)) {
    value = value.toHexString();
  }
  if (isHexString16(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger119.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice15(new Uint8Array(result));
  }
  if (isBytes16(value)) {
    return addSlice15(new Uint8Array(value));
  }
  return logger119.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString16(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

// node_modules/ethers/node_modules/@ethersproject/random/lib.esm/_version.js
init_define_process_env();
var version104 = "random/5.5.1";

// node_modules/ethers/node_modules/@ethersproject/random/lib.esm/random.js
var logger120 = new Logger18(version104);
function getGlobal3() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal3 = getGlobal3();
var crypto3 = anyGlobal3.crypto || anyGlobal3.msCrypto;
if (!crypto3 || !crypto3.getRandomValues) {
  logger120.warn("WARNING: Missing strong random number source");
  crypto3 = {
    getRandomValues: function(buffer) {
      return logger120.throwError("no secure random source avaialble", Logger18.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}
function randomBytes4(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger120.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto3.getRandomValues(result);
  return arrayify16(result);
}

// node_modules/ethers/node_modules/@ethersproject/random/lib.esm/shuffle.js
init_define_process_env();
function shuffled3(array) {
  array = array.slice();
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }
  return array;
}

// node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/properties/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/properties/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version105 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/properties/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors18 = false;
var _censorErrors18 = false;
var LogLevels18 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel18 = LogLevels18["default"];
var _globalLogger18 = null;
function _checkNormalize18() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError18 = _checkNormalize18();
var LogLevel18;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel18 || (LogLevel18 = {}));
var ErrorCode18;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode18 || (ErrorCode18 = {}));
var HEX18 = "0123456789abcdef";
var Logger19 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels18[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel18 > LogLevels18[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger19.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger19.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger19.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors18) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger19.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX18[value[i] >> 4];
            hex += HEX18[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode18.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode18.CALL_EXCEPTION:
      case ErrorCode18.INSUFFICIENT_FUNDS:
      case ErrorCode18.MISSING_NEW:
      case ErrorCode18.NONCE_EXPIRED:
      case ErrorCode18.REPLACEMENT_UNDERPRICED:
      case ErrorCode18.TRANSACTION_REPLACED:
      case ErrorCode18.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger19.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError18) {
      this.throwError("platform missing String.prototype.normalize", Logger19.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError18
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger19.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger19.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger19.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger19.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger19.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger19.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger19.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger18) {
      _globalLogger18 = new Logger19(version105);
    }
    return _globalLogger18;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger19.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors18) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger19.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors18 = !!censorship;
    _permanentCensorErrors18 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels18[logLevel.toLowerCase()];
    if (level == null) {
      Logger19.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel18 = level;
  }
  static from(version134) {
    return new Logger19(version134);
  }
};
Logger19.errors = ErrorCode18;
Logger19.levels = LogLevel18;

// node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version106 = "properties/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/properties/lib.esm/index.js
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger121 = new Logger19(version106);
function defineReadOnly10(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic4(ctor, key6) {
  for (let i = 0; i < 32; i++) {
    if (ctor[key6]) {
      return ctor[key6];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties4(object) {
  return __awaiter19(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key6) => {
      const value = object[key6];
      return Promise.resolve(value).then((v) => ({ key: key6, value: v }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties4(object, properties) {
  if (!object || typeof object !== "object") {
    logger121.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key6) => {
    if (!properties[key6]) {
      logger121.throwArgumentError("invalid object key - " + key6, "transaction:" + key6, object);
    }
  });
}
function shallowCopy9(object) {
  const result = {};
  for (const key6 in object) {
    result[key6] = object[key6];
  }
  return result;
}
var opaque4 = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen4(object) {
  if (object === void 0 || object === null || opaque4[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
      let value = null;
      try {
        value = object[keys[i]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen4(value)) {
        return false;
      }
    }
    return true;
  }
  return logger121.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy4(object) {
  if (_isFrozen4(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy8(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key6 in object) {
      const value = object[key6];
      if (value === void 0) {
        continue;
      }
      defineReadOnly10(result, key6, deepCopy8(value));
    }
    return result;
  }
  return logger121.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy8(object) {
  return _deepCopy4(object);
}

// node_modules/ethers/node_modules/@ethersproject/rlp/lib.esm/index.js
var lib_exports7 = {};
__export(lib_exports7, {
  decode: () => decode6,
  encode: () => encode13
});
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/rlp/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/rlp/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version107 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/rlp/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors19 = false;
var _censorErrors19 = false;
var LogLevels19 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel19 = LogLevels19["default"];
var _globalLogger19 = null;
function _checkNormalize19() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError19 = _checkNormalize19();
var LogLevel19;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel19 || (LogLevel19 = {}));
var ErrorCode19;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode19 || (ErrorCode19 = {}));
var HEX19 = "0123456789abcdef";
var Logger20 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels19[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel19 > LogLevels19[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger20.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger20.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger20.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors19) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger20.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX19[value[i] >> 4];
            hex += HEX19[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode19.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode19.CALL_EXCEPTION:
      case ErrorCode19.INSUFFICIENT_FUNDS:
      case ErrorCode19.MISSING_NEW:
      case ErrorCode19.NONCE_EXPIRED:
      case ErrorCode19.REPLACEMENT_UNDERPRICED:
      case ErrorCode19.TRANSACTION_REPLACED:
      case ErrorCode19.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger20.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError19) {
      this.throwError("platform missing String.prototype.normalize", Logger20.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError19
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger20.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger20.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger20.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger20.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger20.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger20.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger20.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger19) {
      _globalLogger19 = new Logger20(version107);
    }
    return _globalLogger19;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger20.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors19) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger20.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors19 = !!censorship;
    _permanentCensorErrors19 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels19[logLevel.toLowerCase()];
    if (level == null) {
      Logger20.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel19 = level;
  }
  static from(version134) {
    return new Logger20(version134);
  }
};
Logger20.errors = ErrorCode19;
Logger20.levels = LogLevel19;

// node_modules/ethers/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version108 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger122 = new Logger20(version108);
function isHexable16(value) {
  return !!value.toHexString;
}
function addSlice16(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice16(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike9(value) {
  return isHexString17(value) && !(value.length % 2) || isBytes17(value);
}
function isInteger16(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes17(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger16(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger16(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify17(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger122.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice16(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable16(value)) {
    value = value.toHexString();
  }
  if (isHexString17(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger122.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice16(new Uint8Array(result));
  }
  if (isBytes17(value)) {
    return addSlice16(new Uint8Array(value));
  }
  return logger122.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString17(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters11 = "0123456789abcdef";
function hexlify12(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger122.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters11[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable16(value)) {
    return value.toHexString();
  }
  if (isHexString17(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger122.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes17(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters11[(v & 240) >> 4] + HexCharacters11[v & 15];
    }
    return result;
  }
  return logger122.throwArgumentError("invalid hexlify value", "value", value);
}

// node_modules/ethers/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version109 = "rlp/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger123 = new Logger20(version109);
function arrayifyInteger3(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger2(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _encode6(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode6(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger3(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike9(object)) {
    logger123.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify17(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger3(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode13(object) {
  return hexlify12(_encode6(object));
}
function _decodeChildren2(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode2(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger123.throwError("child data too short", Logger20.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode2(data, offset) {
  if (data.length === 0) {
    logger123.throwError("data too short", Logger20.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger123.throwError("data short segment too short", Logger20.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger2(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger123.throwError("data long segment too short", Logger20.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren2(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger123.throwError("data array too short", Logger20.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren2(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger123.throwError("data array too short", Logger20.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger2(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger123.throwError("data array too short", Logger20.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify12(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger123.throwError("data too short", Logger20.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify12(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify12(data[offset]) };
}
function decode6(data) {
  const bytes = arrayify17(data);
  const decoded = _decode2(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger123.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}

// node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
init_define_process_env();
var import_bn13 = __toESM(require_bn());
var import_hash15 = __toESM(require_hash());
function createCommonjsModule4(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base6) {
      return commonjsRequire4(path, base6 === void 0 || base6 === null ? module.path : base6);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire4() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert4 = assert4;
function assert4(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert4.equal = function assertEqual4(l, r, msg) {
  if (l != r)
    throw new Error(msg || "Assertion failed: " + l + " != " + r);
};
var utils_14 = createCommonjsModule4(function(module, exports) {
  "use strict";
  var utils = exports;
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex13(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex13;
  utils.encode = function encode18(arr, enc) {
    if (enc === "hex")
      return toHex13(arr);
    else
      return arr;
  };
});
var utils_1$14 = createCommonjsModule4(function(module, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert4;
  utils.toArray = utils_14.toArray;
  utils.zero2 = utils_14.zero2;
  utils.toHex = utils_14.toHex;
  utils.encode = utils_14.encode;
  function getNAF6(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF6;
  function getJSF6(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF6;
  function cachedProperty(obj, name2, computer) {
    var key6 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key6] !== void 0 ? this[key6] : this[key6] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn13.default(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});
var getNAF4 = utils_1$14.getNAF;
var getJSF4 = utils_1$14.getJSF;
var assert$14 = utils_1$14.assert;
function BaseCurve4(type, conf) {
  this.type = type;
  this.p = new import_bn13.default(conf.p, 16);
  this.red = conf.prime ? import_bn13.default.red(conf.prime) : import_bn13.default.mont(this.p);
  this.zero = new import_bn13.default(0).toRed(this.red);
  this.one = new import_bn13.default(1).toRed(this.red);
  this.two = new import_bn13.default(2).toRed(this.red);
  this.n = conf.n && new import_bn13.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base4 = BaseCurve4;
BaseCurve4.prototype.point = function point7() {
  throw new Error("Not implemented");
};
BaseCurve4.prototype.validate = function validate13() {
  throw new Error("Not implemented");
};
BaseCurve4.prototype._fixedNafMul = function _fixedNafMul4(p, k) {
  assert$14(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF4(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};
BaseCurve4.prototype._wnafMul = function _wnafMul4(p, k) {
  var w = 4;
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF4(k, w, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);
    if (i < 0)
      break;
    var z = naf[i];
    assert$14(z !== 0);
    if (p.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p.type === "affine" ? acc.toP() : acc;
};
BaseCurve4.prototype._wnafMulAdd = function _wnafMulAdd4(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF4(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF4(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [
      points[a],
      null,
      null,
      points[b]
    ];
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF4(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;
    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][z - 1 >> 1];
      else if (z < 0)
        p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === "affine")
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  for (i = 0; i < len; i++)
    wnd[i] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint4(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve4.BasePoint = BasePoint4;
BasePoint4.prototype.eq = function eq10() {
  throw new Error("Not implemented");
};
BasePoint4.prototype.validate = function validate14() {
  return this.curve.validate(this);
};
BaseCurve4.prototype.decodePoint = function decodePoint4(bytes, enc) {
  bytes = utils_1$14.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$14(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$14(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint4.prototype.encodeCompressed = function encodeCompressed4(enc) {
  return this.encode(enc, true);
};
BasePoint4.prototype._encode = function _encode7(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x);
  return [4].concat(x, this.getY().toArray("be", len));
};
BasePoint4.prototype.encode = function encode14(enc, compact) {
  return utils_1$14.encode(this._encode(compact), enc);
};
BasePoint4.prototype.precompute = function precompute4(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint4.prototype._hasDoubles = function _hasDoubles4(k) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint4.prototype._getDoubles = function _getDoubles4(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint4.prototype._getNAFPoints = function _getNAFPoints4(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl11 = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl11);
  return {
    wnd,
    points: res
  };
};
BasePoint4.prototype._getBeta = function _getBeta7() {
  return null;
};
BasePoint4.prototype.dblp = function dblp7(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};
var inherits_browser4 = createCommonjsModule4(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$24 = utils_1$14.assert;
function ShortCurve4(conf) {
  base4.call(this, "short", conf);
  this.a = new import_bn13.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn13.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser4(ShortCurve4, base4);
var short_14 = ShortCurve4;
ShortCurve4.prototype._getEndomorphism = function _getEndomorphism4(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn13.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn13.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$24(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn13.default(vec.a, 16),
        b: new import_bn13.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve4.prototype._getEndoRoots = function _getEndoRoots4(num) {
  var red = num === this.p ? this.red : import_bn13.default.mont(num);
  var tinv = new import_bn13.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new import_bn13.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
};
ShortCurve4.prototype._getEndoBasis = function _getEndoBasis4(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u = lambda;
  var v = this.n.clone();
  var x1 = new import_bn13.default(1);
  var y1 = new import_bn13.default(0);
  var x2 = new import_bn13.default(0);
  var y2 = new import_bn13.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));
    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve4.prototype._endoSplit = function _endoSplit4(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1, k2 };
};
ShortCurve4.prototype.pointFromX = function pointFromX4(x, odd) {
  x = new import_bn13.default(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
};
ShortCurve4.prototype.validate = function validate15(point11) {
  if (point11.inf)
    return true;
  var x = point11.x;
  var y = point11.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve4.prototype._endoWnafMulAdd = function _endoWnafMulAdd4(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point4(curve, x, y, isRed) {
  base4.BasePoint.call(this, curve, "affine");
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn13.default(x, 16);
    this.y = new import_bn13.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser4(Point4, base4.BasePoint);
ShortCurve4.prototype.point = function point8(x, y, isRed) {
  return new Point4(this, x, y, isRed);
};
ShortCurve4.prototype.pointFromJSON = function pointFromJSON4(obj, red) {
  return Point4.fromJSON(this, obj, red);
};
Point4.prototype._getBeta = function _getBeta8() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point4.prototype.toJSON = function toJSON4() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point4.fromJSON = function fromJSON4(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point4.prototype.inspect = function inspect10() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point4.prototype.isInfinity = function isInfinity7() {
  return this.inf;
};
Point4.prototype.add = function add7(p) {
  if (this.inf)
    return p;
  if (p.inf)
    return this;
  if (this.eq(p))
    return this.dbl();
  if (this.neg().eq(p))
    return this.curve.point(null, null);
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point4.prototype.dbl = function dbl7() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point4.prototype.getX = function getX4() {
  return this.x.fromRed();
};
Point4.prototype.getY = function getY4() {
  return this.y.fromRed();
};
Point4.prototype.mul = function mul7(k) {
  k = new import_bn13.default(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k]);
  else
    return this.curve._wnafMul(this, k);
};
Point4.prototype.mulAdd = function mulAdd4(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point4.prototype.jmulAdd = function jmulAdd4(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point4.prototype.eq = function eq11(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point4.prototype.neg = function neg7(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point4.prototype.toJ = function toJ4() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint4(curve, x, y, z) {
  base4.BasePoint.call(this, curve, "jacobian");
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn13.default(0);
  } else {
    this.x = new import_bn13.default(x, 16);
    this.y = new import_bn13.default(y, 16);
    this.z = new import_bn13.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser4(JPoint4, base4.BasePoint);
ShortCurve4.prototype.jpoint = function jpoint4(x, y, z) {
  return new JPoint4(this, x, y, z);
};
JPoint4.prototype.toP = function toP4() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint4.prototype.neg = function neg8() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint4.prototype.add = function add8(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint4.prototype.mixedAdd = function mixedAdd4(p) {
  if (this.isInfinity())
    return p.toJ();
  if (p.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint4.prototype.dblp = function dblp8(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }
  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint4.prototype.dbl = function dbl8() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint4.prototype._zeroDbl = function _zeroDbl4() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx);
    var t = m.redSqr().redISub(s).redISub(s);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t;
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = b.redSqr();
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    var e = a.redAdd(a).redIAdd(a);
    var f = e.redSqr();
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f.redISub(d).redISub(d);
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint4.prototype._threeDbl = function _threeDbl4() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t = m.redSqr().redISub(s).redISub(s);
    nx = t;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint4.prototype._dbl = function _dbl4() {
  var a = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint4.prototype.trpl = function trpl4() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m = xx.redAdd(xx).redIAdd(xx);
  var mm = m.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee = e.redSqr();
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint4.prototype.mul = function mul8(k, kbase) {
  k = new import_bn13.default(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint4.prototype.eq = function eq12(p) {
  if (p.type === "affine")
    return this.eq(p.toJ());
  if (this === p)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint4.prototype.eqXToP = function eqXToP4(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint4.prototype.inspect = function inspect11() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint4.prototype.isInfinity = function isInfinity8() {
  return this.z.cmpn(0) === 0;
};
var curve_14 = createCommonjsModule4(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base4;
  curve.short = short_14;
  curve.mont = null;
  curve.edwards = null;
});
var curves_14 = createCommonjsModule4(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert6 = utils_1$14.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_14.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_14.edwards(options);
    else
      this.curve = new curve_14.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert6(this.g.validate(), "Invalid curve");
    assert6(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash15.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash15.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash15.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash15.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash15.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash15.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash15.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash15.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG4(options) {
  if (!(this instanceof HmacDRBG4))
    return new HmacDRBG4(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_14.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_14.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_14.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert4(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg4 = HmacDRBG4;
HmacDRBG4.prototype._init = function init4(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0;
    this.V[i] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG4.prototype._hmac = function hmac4() {
  return new import_hash15.default.hmac(this.hash, this.K);
};
HmacDRBG4.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG4.prototype.reseed = function reseed4(entropy, entropyEnc, add11, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add11;
    add11 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_14.toArray(entropy, entropyEnc);
  add11 = utils_14.toArray(add11, addEnc);
  minimalisticAssert4(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add11 || []));
  this._reseed = 1;
};
HmacDRBG4.prototype.generate = function generate4(len, enc, add11, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add11;
    add11 = enc;
    enc = null;
  }
  if (add11) {
    add11 = utils_14.toArray(add11, addEnc || "hex");
    this._update(add11);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add11);
  this._reseed++;
  return utils_14.encode(res, enc);
};
var assert$34 = utils_1$14.assert;
function KeyPair4(ec6, options) {
  this.ec = ec6;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key4 = KeyPair4;
KeyPair4.fromPublic = function fromPublic4(ec6, pub, enc) {
  if (pub instanceof KeyPair4)
    return pub;
  return new KeyPair4(ec6, {
    pub,
    pubEnc: enc
  });
};
KeyPair4.fromPrivate = function fromPrivate4(ec6, priv, enc) {
  if (priv instanceof KeyPair4)
    return priv;
  return new KeyPair4(ec6, {
    priv,
    privEnc: enc
  });
};
KeyPair4.prototype.validate = function validate16() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair4.prototype.getPublic = function getPublic4(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair4.prototype.getPrivate = function getPrivate4(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair4.prototype._importPrivate = function _importPrivate4(key6, enc) {
  this.priv = new import_bn13.default(key6, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair4.prototype._importPublic = function _importPublic4(key6, enc) {
  if (key6.x || key6.y) {
    if (this.ec.curve.type === "mont") {
      assert$34(key6.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$34(key6.x && key6.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key6.x, key6.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key6, enc);
};
KeyPair4.prototype.derive = function derive4(pub) {
  if (!pub.validate()) {
    assert$34(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair4.prototype.sign = function sign7(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair4.prototype.verify = function verify7(msg, signature6) {
  return this.ec.verify(msg, signature6, this);
};
KeyPair4.prototype.inspect = function inspect12() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$44 = utils_1$14.assert;
function Signature4(options, enc) {
  if (options instanceof Signature4)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$44(options.r && options.s, "Signature without r or s");
  this.r = new import_bn13.default(options.r, 16);
  this.s = new import_bn13.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature4 = Signature4;
function Position4() {
  this.place = 0;
}
function getLength4(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
function rmPadding4(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature4.prototype._importDER = function _importDER4(data, enc) {
  data = utils_1$14.toArray(data, enc);
  var p = new Position4();
  if (data[p.place++] !== 48) {
    return false;
  }
  var len = getLength4(data, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data.length) {
    return false;
  }
  if (data[p.place++] !== 2) {
    return false;
  }
  var rlen = getLength4(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 2) {
    return false;
  }
  var slen = getLength4(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 128) {
      r = r.slice(1);
    } else {
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 128) {
      s = s.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn13.default(r);
  this.s = new import_bn13.default(s);
  this.recoveryParam = null;
  return true;
};
function constructLength4(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature4.prototype.toDER = function toDER4(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();
  if (r[0] & 128)
    r = [0].concat(r);
  if (s[0] & 128)
    s = [0].concat(s);
  r = rmPadding4(r);
  s = rmPadding4(s);
  while (!s[0] && !(s[1] & 128)) {
    s = s.slice(1);
  }
  var arr = [2];
  constructLength4(arr, r.length);
  arr = arr.concat(r);
  arr.push(2);
  constructLength4(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [48];
  constructLength4(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$14.encode(res, enc);
};
var rand4 = function() {
  throw new Error("unsupported");
};
var assert$54 = utils_1$14.assert;
function EC4(options) {
  if (!(this instanceof EC4))
    return new EC4(options);
  if (typeof options === "string") {
    assert$54(Object.prototype.hasOwnProperty.call(curves_14, options), "Unknown curve " + options);
    options = curves_14[options];
  }
  if (options instanceof curves_14.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec4 = EC4;
EC4.prototype.keyPair = function keyPair4(options) {
  return new key4(this, options);
};
EC4.prototype.keyFromPrivate = function keyFromPrivate4(priv, enc) {
  return key4.fromPrivate(this, priv, enc);
};
EC4.prototype.keyFromPublic = function keyFromPublic4(pub, enc) {
  return key4.fromPublic(this, pub, enc);
};
EC4.prototype.genKeyPair = function genKeyPair4(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg4({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand4(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn13.default(2));
  for (; ; ) {
    var priv = new import_bn13.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC4.prototype._truncateToN = function _truncateToN4(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC4.prototype.sign = function sign8(msg, key6, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key6 = this.keyFromPrivate(key6, enc);
  msg = this._truncateToN(new import_bn13.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key6.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg4({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn13.default(1));
  for (var iter = 0; ; iter++) {
    var k = options.k ? options.k(iter) : new import_bn13.default(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;
    var s = k.invm(this.n).mul(r.mul(key6.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }
    return new signature4({ r, s, recoveryParam });
  }
};
EC4.prototype.verify = function verify8(msg, signature$1, key6, enc) {
  msg = this._truncateToN(new import_bn13.default(msg, 16));
  key6 = this.keyFromPublic(key6, enc);
  signature$1 = new signature4(signature$1, "hex");
  var r = signature$1.r;
  var s = signature$1.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;
  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key6.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  }
  p = this.g.jmulAdd(u1, key6.getPublic(), u2);
  if (p.isInfinity())
    return false;
  return p.eqXToP(r);
};
EC4.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$54((3 & j) === j, "The recovery param is more than two bits");
  signature$1 = new signature4(signature$1, enc);
  var n = this.n;
  var e = new import_bn13.default(msg);
  var r = signature$1.r;
  var s = signature$1.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r, s2);
};
EC4.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {
  signature$1 = new signature4(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_14 = createCommonjsModule4(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$14;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_14;
  elliptic.curves = curves_14;
  elliptic.ec = ec4;
  elliptic.eddsa = null;
});
var EC$14 = elliptic_14.ec;

// node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version110 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors20 = false;
var _censorErrors20 = false;
var LogLevels20 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel20 = LogLevels20["default"];
var _globalLogger20 = null;
function _checkNormalize20() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError20 = _checkNormalize20();
var LogLevel20;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel20 || (LogLevel20 = {}));
var ErrorCode20;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode20 || (ErrorCode20 = {}));
var HEX20 = "0123456789abcdef";
var Logger21 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels20[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel20 > LogLevels20[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger21.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger21.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger21.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors20) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger21.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX20[value[i] >> 4];
            hex += HEX20[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode20.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode20.CALL_EXCEPTION:
      case ErrorCode20.INSUFFICIENT_FUNDS:
      case ErrorCode20.MISSING_NEW:
      case ErrorCode20.NONCE_EXPIRED:
      case ErrorCode20.REPLACEMENT_UNDERPRICED:
      case ErrorCode20.TRANSACTION_REPLACED:
      case ErrorCode20.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger21.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError20) {
      this.throwError("platform missing String.prototype.normalize", Logger21.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError20
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger21.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger21.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger21.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger21.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger21.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger21.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger21.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger20) {
      _globalLogger20 = new Logger21(version110);
    }
    return _globalLogger20;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger21.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors20) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger21.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors20 = !!censorship;
    _permanentCensorErrors20 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels20[logLevel.toLowerCase()];
    if (level == null) {
      Logger21.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel20 = level;
  }
  static from(version134) {
    return new Logger21(version134);
  }
};
Logger21.errors = ErrorCode20;
Logger21.levels = LogLevel20;

// node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version111 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger124 = new Logger21(version111);
function isHexable17(value) {
  return !!value.toHexString;
}
function addSlice17(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice17(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike10(value) {
  return isHexString18(value) && !(value.length % 2) || isBytes18(value);
}
function isInteger17(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes18(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger17(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger17(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify18(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger124.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice17(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable17(value)) {
    value = value.toHexString();
  }
  if (isHexString18(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger124.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice17(new Uint8Array(result));
  }
  if (isBytes18(value)) {
    return addSlice17(new Uint8Array(value));
  }
  return logger124.throwArgumentError("invalid arrayify value", "value", value);
}
function zeroPad5(value, length) {
  value = arrayify18(value);
  if (value.length > length) {
    logger124.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice17(result);
}
function isHexString18(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters12 = "0123456789abcdef";
function hexlify13(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger124.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters12[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable17(value)) {
    return value.toHexString();
  }
  if (isHexString18(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger124.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes18(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters12[(v & 240) >> 4] + HexCharacters12[v & 15];
    }
    return result;
  }
  return logger124.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad11(value, length) {
  if (typeof value !== "string") {
    value = hexlify13(value);
  } else if (!isHexString18(value)) {
    logger124.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger124.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature5(signature6) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike10(signature6)) {
    let bytes = arrayify18(signature6);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify13(bytes.slice(0, 32));
      result.s = hexlify13(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify13(bytes.slice(0, 32));
      result.s = hexlify13(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger124.throwArgumentError("invalid signature string", "signature", signature6);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger124.throwArgumentError("signature invalid v byte", "signature", signature6);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify13(bytes.slice(32, 64));
  } else {
    result.r = signature6.r;
    result.s = signature6.s;
    result.v = signature6.v;
    result.recoveryParam = signature6.recoveryParam;
    result._vs = signature6._vs;
    if (result._vs != null) {
      const vs2 = zeroPad5(arrayify18(result._vs), 32);
      result._vs = hexlify13(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger124.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature6);
      }
      vs2[0] &= 127;
      const s = hexlify13(vs2);
      if (result.s == null) {
        result.s = s;
      } else if (result.s !== s) {
        logger124.throwArgumentError("signature v mismatch _vs", "signature", signature6);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger124.throwArgumentError("signature missing v and recoveryParam", "signature", signature6);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger124.throwArgumentError("signature recoveryParam mismatch v", "signature", signature6);
        }
      }
    }
    if (result.r == null || !isHexString18(result.r)) {
      logger124.throwArgumentError("signature missing or invalid r", "signature", signature6);
    } else {
      result.r = hexZeroPad11(result.r, 32);
    }
    if (result.s == null || !isHexString18(result.s)) {
      logger124.throwArgumentError("signature missing or invalid s", "signature", signature6);
    } else {
      result.s = hexZeroPad11(result.s, 32);
    }
    const vs = arrayify18(result.s);
    if (vs[0] >= 128) {
      logger124.throwArgumentError("signature s out of range", "signature", signature6);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify13(vs);
    if (result._vs) {
      if (!isHexString18(result._vs)) {
        logger124.throwArgumentError("signature invalid _vs", "signature", signature6);
      }
      result._vs = hexZeroPad11(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger124.throwArgumentError("signature _vs mismatch v and s", "signature", signature6);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version112 = "properties/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/properties/lib.esm/index.js
var logger125 = new Logger21(version112);
function defineReadOnly11(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/_version.js
init_define_process_env();
var version113 = "signing-key/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger126 = new Logger21(version113);
var _curve3 = null;
function getCurve3() {
  if (!_curve3) {
    _curve3 = new EC$14("secp256k1");
  }
  return _curve3;
}
var SigningKey5 = class {
  constructor(privateKey) {
    defineReadOnly11(this, "curve", "secp256k1");
    defineReadOnly11(this, "privateKey", hexlify13(privateKey));
    const keyPair6 = getCurve3().keyFromPrivate(arrayify18(this.privateKey));
    defineReadOnly11(this, "publicKey", "0x" + keyPair6.getPublic(false, "hex"));
    defineReadOnly11(this, "compressedPublicKey", "0x" + keyPair6.getPublic(true, "hex"));
    defineReadOnly11(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve3().keyFromPublic(arrayify18(this.publicKey));
    const p1 = getCurve3().keyFromPublic(arrayify18(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest) {
    const keyPair6 = getCurve3().keyFromPrivate(arrayify18(this.privateKey));
    const digestBytes = arrayify18(digest);
    if (digestBytes.length !== 32) {
      logger126.throwArgumentError("bad digest length", "digest", digest);
    }
    const signature6 = keyPair6.sign(digestBytes, { canonical: true });
    return splitSignature5({
      recoveryParam: signature6.recoveryParam,
      r: hexZeroPad11("0x" + signature6.r.toString(16), 32),
      s: hexZeroPad11("0x" + signature6.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair6 = getCurve3().keyFromPrivate(arrayify18(this.privateKey));
    const otherKeyPair = getCurve3().keyFromPublic(arrayify18(computePublicKey4(otherKey)));
    return hexZeroPad11("0x" + keyPair6.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
function recoverPublicKey4(digest, signature6) {
  const sig = splitSignature5(signature6);
  const rs = { r: arrayify18(sig.r), s: arrayify18(sig.s) };
  return "0x" + getCurve3().recoverPubKey(arrayify18(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey4(key6, compressed) {
  const bytes = arrayify18(key6);
  if (bytes.length === 32) {
    const signingKey = new SigningKey5(bytes);
    if (compressed) {
      return "0x" + getCurve3().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify13(bytes);
    }
    return "0x" + getCurve3().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify13(bytes);
    }
    return "0x" + getCurve3().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger126.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

// node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn14 = __toESM(require_bn());

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version114 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors21 = false;
var _censorErrors21 = false;
var LogLevels21 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel21 = LogLevels21["default"];
var _globalLogger21 = null;
function _checkNormalize21() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError21 = _checkNormalize21();
var LogLevel21;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel21 || (LogLevel21 = {}));
var ErrorCode21;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode21 || (ErrorCode21 = {}));
var HEX21 = "0123456789abcdef";
var Logger22 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels21[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel21 > LogLevels21[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger22.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger22.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger22.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors21) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger22.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX21[value[i] >> 4];
            hex += HEX21[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode21.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode21.CALL_EXCEPTION:
      case ErrorCode21.INSUFFICIENT_FUNDS:
      case ErrorCode21.MISSING_NEW:
      case ErrorCode21.NONCE_EXPIRED:
      case ErrorCode21.REPLACEMENT_UNDERPRICED:
      case ErrorCode21.TRANSACTION_REPLACED:
      case ErrorCode21.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger22.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError21) {
      this.throwError("platform missing String.prototype.normalize", Logger22.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError21
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger22.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger22.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger22.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger22.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger22.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger22.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger22.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger21) {
      _globalLogger21 = new Logger22(version114);
    }
    return _globalLogger21;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger22.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors21) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger22.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors21 = !!censorship;
    _permanentCensorErrors21 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels21[logLevel.toLowerCase()];
    if (level == null) {
      Logger22.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel21 = level;
  }
  static from(version134) {
    return new Logger22(version134);
  }
};
Logger22.errors = ErrorCode21;
Logger22.levels = LogLevel21;

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version115 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger127 = new Logger22(version115);
function isHexable18(value) {
  return !!value.toHexString;
}
function addSlice18(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice18(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger18(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes19(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger18(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger18(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify19(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger127.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice18(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable18(value)) {
    value = value.toHexString();
  }
  if (isHexString19(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger127.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice18(new Uint8Array(result));
  }
  if (isBytes19(value)) {
    return addSlice18(new Uint8Array(value));
  }
  return logger127.throwArgumentError("invalid arrayify value", "value", value);
}
function concat10(items) {
  const objects = items.map((item) => arrayify19(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice18(result);
}
function isHexString19(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters13 = "0123456789abcdef";
function hexlify14(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger127.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters13[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable18(value)) {
    return value.toHexString();
  }
  if (isHexString19(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger127.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes19(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters13[(v & 240) >> 4] + HexCharacters13[v & 15];
    }
    return result;
  }
  return logger127.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad12(value, length) {
  if (typeof value !== "string") {
    value = hexlify14(value);
  } else if (!isHexString19(value)) {
    logger127.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger127.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version116 = "bignumber/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN14 = import_bn14.default.BN;
var logger128 = new Logger22(version116);
var _constructorGuard22 = {};
var MAX_SAFE10 = 9007199254740991;
function isBigNumberish10(value) {
  return value != null && (BigNumber11.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString19(value) || typeof value === "bigint" || isBytes19(value));
}
var _warnedToStringRadix10 = false;
var BigNumber11 = class {
  constructor(constructorGuard, hex) {
    logger128.checkNew(new.target, BigNumber11);
    if (constructorGuard !== _constructorGuard22) {
      logger128.throwError("cannot call constructor directly; use BigNumber.from", Logger22.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber10(toBN10(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber10(toBN10(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber11.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber10(toBN10(this).add(toBN10(other)));
  }
  sub(other) {
    return toBigNumber10(toBN10(this).sub(toBN10(other)));
  }
  div(other) {
    const o = BigNumber11.from(other);
    if (o.isZero()) {
      throwFault19("division-by-zero", "div");
    }
    return toBigNumber10(toBN10(this).div(toBN10(other)));
  }
  mul(other) {
    return toBigNumber10(toBN10(this).mul(toBN10(other)));
  }
  mod(other) {
    const value = toBN10(other);
    if (value.isNeg()) {
      throwFault19("division-by-zero", "mod");
    }
    return toBigNumber10(toBN10(this).umod(value));
  }
  pow(other) {
    const value = toBN10(other);
    if (value.isNeg()) {
      throwFault19("negative-power", "pow");
    }
    return toBigNumber10(toBN10(this).pow(value));
  }
  and(other) {
    const value = toBN10(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault19("unbound-bitwise-result", "and");
    }
    return toBigNumber10(toBN10(this).and(value));
  }
  or(other) {
    const value = toBN10(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault19("unbound-bitwise-result", "or");
    }
    return toBigNumber10(toBN10(this).or(value));
  }
  xor(other) {
    const value = toBN10(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault19("unbound-bitwise-result", "xor");
    }
    return toBigNumber10(toBN10(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault19("negative-width", "mask");
    }
    return toBigNumber10(toBN10(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault19("negative-width", "shl");
    }
    return toBigNumber10(toBN10(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault19("negative-width", "shr");
    }
    return toBigNumber10(toBN10(this).shrn(value));
  }
  eq(other) {
    return toBN10(this).eq(toBN10(other));
  }
  lt(other) {
    return toBN10(this).lt(toBN10(other));
  }
  lte(other) {
    return toBN10(this).lte(toBN10(other));
  }
  gt(other) {
    return toBN10(this).gt(toBN10(other));
  }
  gte(other) {
    return toBN10(this).gte(toBN10(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN10(this).isZero();
  }
  toNumber() {
    try {
      return toBN10(this).toNumber();
    } catch (error) {
      throwFault19("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger128.throwError("this platform does not support BigInt", Logger22.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix10) {
          _warnedToStringRadix10 = true;
          logger128.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger128.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger22.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger128.throwError("BigNumber.toString does not accept parameters", Logger22.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN10(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber11) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber11(_constructorGuard22, toHex10(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber11(_constructorGuard22, toHex10(new BN14(value)));
      }
      return logger128.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault19("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE10 || value <= -MAX_SAFE10) {
        throwFault19("overflow", "BigNumber.from", value);
      }
      return BigNumber11.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber11.from(anyValue.toString());
    }
    if (isBytes19(anyValue)) {
      return BigNumber11.from(hexlify14(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber11.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString19(hex) || hex[0] === "-" && isHexString19(hex.substring(1))) {
            return BigNumber11.from(hex);
          }
        }
      }
    }
    return logger128.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex10(value) {
  if (typeof value !== "string") {
    return toHex10(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger128.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex10(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber10(value) {
  return BigNumber11.from(toHex10(value));
}
function toBN10(value) {
  const hex = BigNumber11.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN14("-" + hex.substring(3), 16);
  }
  return new BN14(hex.substring(2), 16);
}
function throwFault19(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger128.throwError(fault, Logger22.errors.NUMERIC_FAULT, params);
}

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger129 = new Logger22(version116);
var _constructorGuard23 = {};
var Zero23 = BigNumber11.from(0);
var NegativeOne23 = BigNumber11.from(-1);
function throwFault20(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger129.throwError(message, Logger22.errors.NUMERIC_FAULT, params);
}
var zeros10 = "0";
while (zeros10.length < 256) {
  zeros10 += zeros10;
}
function getMultiplier10(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber11.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros10.substring(0, decimals);
  }
  return logger129.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed11(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier10(decimals);
  value = BigNumber11.from(value);
  const negative = value.lt(Zero23);
  if (negative) {
    value = value.mul(NegativeOne23);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed11(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier10(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger129.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger129.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger129.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault20("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber11.from(whole);
  const fractionValue = BigNumber11.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne23);
  }
  return wei;
}
var FixedFormat10 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard23) {
      logger129.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger22.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier10(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat10) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger129.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger129.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger129.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger129.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat10(_constructorGuard23, signed, width, decimals);
  }
};
var FixedNumber10 = class {
  constructor(constructorGuard, hex, value, format) {
    logger129.checkNew(new.target, FixedNumber10);
    if (constructorGuard !== _constructorGuard23) {
      logger129.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger22.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger129.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed11(this._value, this.format.decimals);
    const b = parseFixed11(other._value, other.format.decimals);
    return FixedNumber10.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed11(this._value, this.format.decimals);
    const b = parseFixed11(other._value, other.format.decimals);
    return FixedNumber10.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed11(this._value, this.format.decimals);
    const b = parseFixed11(other._value, other.format.decimals);
    return FixedNumber10.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed11(this._value, this.format.decimals);
    const b = parseFixed11(other._value, other.format.decimals);
    return FixedNumber10.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber10.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE10.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber10.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE10.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger129.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber10.from("1" + zeros10.substring(0, decimals), this.format);
    const bump = BUMP10.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger129.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber11.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad12(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber10.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish10(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber10.fromString(formatFixed11(value, decimals), FixedFormat10.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat10.from(format);
    const numeric = parseFixed11(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero23)) {
      throwFault20("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad12(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed11(numeric, fixedFormat.decimals);
    return new FixedNumber10(_constructorGuard23, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat10.from(format);
    if (arrayify19(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber11.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed11(numeric, fixedFormat.decimals);
    return new FixedNumber10(_constructorGuard23, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber10.fromString(value, format);
    }
    if (isBytes19(value)) {
      return FixedNumber10.fromBytes(value, format);
    }
    try {
      return FixedNumber10.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger22.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger129.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE10 = FixedNumber10.from(1);
var BUMP10 = FixedNumber10.from("0.5");

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne24 = BigNumber11.from(-1);
var Zero24 = BigNumber11.from(0);
var One14 = BigNumber11.from(1);
var Two8 = BigNumber11.from(2);
var WeiPerEther8 = BigNumber11.from("1000000000000000000");
var MaxUint25614 = BigNumber11.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2568 = BigNumber11.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2568 = BigNumber11.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();
var HashZero8 = "0x0000000000000000000000000000000000000000000000000000000000000000";

// node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version117 = "strings/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger130 = new Logger22(version117);
var UnicodeNormalizationForm7;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm7 || (UnicodeNormalizationForm7 = {}));
var Utf8ErrorReason7;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason7 || (Utf8ErrorReason7 = {}));
function errorFunc7(reason, offset, bytes, output, badCodepoint) {
  return logger130.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc7(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason7.BAD_PREFIX || reason === Utf8ErrorReason7.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason7.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc7(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason7.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc7(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs7 = Object.freeze({
  error: errorFunc7,
  ignore: ignoreFunc7,
  replace: replaceFunc7
});
function getUtf8CodePoints4(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs7.error;
  }
  bytes = arrayify19(bytes);
  const result = [];
  let i = 0;
  while (i < bytes.length) {
    const c = bytes[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError(Utf8ErrorReason7.UNEXPECTED_CONTINUE, i - 1, bytes, result);
      } else {
        i += onError(Utf8ErrorReason7.BAD_PREFIX, i - 1, bytes, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes.length) {
      i += onError(Utf8ErrorReason7.OVERRUN, i - 1, bytes, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes[i];
      if ((nextChar & 192) != 128) {
        i += onError(Utf8ErrorReason7.MISSING_CONTINUE, i, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError(Utf8ErrorReason7.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError(Utf8ErrorReason7.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason7.OVERLONG, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes8(str, form = UnicodeNormalizationForm7.current) {
  if (form != UnicodeNormalizationForm7.current) {
    logger130.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify19(result);
}
function escapeChar(value) {
  const hex = "0000" + value.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String7(bytes, onError) {
  return '"' + getUtf8CodePoints4(bytes, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String7(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String7(bytes, onError) {
  return _toUtf8String7(getUtf8CodePoints4(bytes, onError));
}
function toUtf8CodePoints7(str, form = UnicodeNormalizationForm7.current) {
  return getUtf8CodePoints4(toUtf8Bytes8(str, form));
}

// node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/bytes32.js
function formatBytes32String7(text) {
  const bytes = toUtf8Bytes8(text);
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify14(concat10([bytes, HashZero8]).slice(0, 32));
}
function parseBytes32String7(bytes) {
  const data = arrayify19(bytes);
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String7(data.slice(0, length));
}

// node_modules/ethers/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes27(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable7(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable7(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap3(value, ranges) {
  let lo = 0;
  for (let i = 0; i < ranges.length; i++) {
    let range = ranges[i];
    lo += range.l;
    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range;
    }
  }
  return null;
}
var Table_A_1_ranges7 = createRangeTable7("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags7 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
var Table_B_2_ranges3 = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
var Table_B_2_lut_abs7 = createTable7("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel7 = createTable7("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex7 = createTable7("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes27);
var Table_C_ranges7 = createRangeTable7("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten3(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA13(codepoint) {
  return !!matchMap3(codepoint, Table_A_1_ranges7);
}
function _nameprepTableB23(codepoint) {
  let range = matchMap3(codepoint, Table_B_2_ranges3);
  if (range) {
    return [codepoint + range.s];
  }
  let codes = Table_B_2_lut_abs7[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel7[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex7[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC3(codepoint) {
  return !!matchMap3(codepoint, Table_C_ranges7);
}
function nameprep7(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints7(value);
  codes = flatten3(codes.map((code) => {
    if (Table_B_1_flags7.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 65024 && code <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB23(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code];
  }));
  codes = toUtf8CodePoints7(_toUtf8String7(codes), UnicodeNormalizationForm7.NFKC);
  codes.forEach((code) => {
    if (_nameprepTableC3(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code) => {
    if (_nameprepTableA13(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String7(codes);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  if (name2.length > 63) {
    throw new Error("too long");
  }
  return name2;
}

// node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version118 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors22 = false;
var _censorErrors22 = false;
var LogLevels22 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel22 = LogLevels22["default"];
var _globalLogger22 = null;
function _checkNormalize22() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError22 = _checkNormalize22();
var LogLevel22;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel22 || (LogLevel22 = {}));
var ErrorCode22;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode22 || (ErrorCode22 = {}));
var HEX22 = "0123456789abcdef";
var Logger23 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels22[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel22 > LogLevels22[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger23.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger23.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger23.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors22) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger23.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX22[value[i] >> 4];
            hex += HEX22[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode22.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode22.CALL_EXCEPTION:
      case ErrorCode22.INSUFFICIENT_FUNDS:
      case ErrorCode22.MISSING_NEW:
      case ErrorCode22.NONCE_EXPIRED:
      case ErrorCode22.REPLACEMENT_UNDERPRICED:
      case ErrorCode22.TRANSACTION_REPLACED:
      case ErrorCode22.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger23.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError22) {
      this.throwError("platform missing String.prototype.normalize", Logger23.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError22
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger23.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger23.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger23.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger23.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger23.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger23.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger23.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger22) {
      _globalLogger22 = new Logger23(version118);
    }
    return _globalLogger22;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger23.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors22) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger23.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors22 = !!censorship;
    _permanentCensorErrors22 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels22[logLevel.toLowerCase()];
    if (level == null) {
      Logger23.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel22 = level;
  }
  static from(version134) {
    return new Logger23(version134);
  }
};
Logger23.errors = ErrorCode22;
Logger23.levels = LogLevel22;

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version119 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger131 = new Logger23(version119);
function isHexable19(value) {
  return !!value.toHexString;
}
function addSlice19(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice19(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike11(value) {
  return isHexString20(value) && !(value.length % 2) || isBytes20(value);
}
function isInteger19(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes20(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger19(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger19(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify20(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger131.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice19(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable19(value)) {
    value = value.toHexString();
  }
  if (isHexString20(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger131.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice19(new Uint8Array(result));
  }
  if (isBytes20(value)) {
    return addSlice19(new Uint8Array(value));
  }
  return logger131.throwArgumentError("invalid arrayify value", "value", value);
}
function stripZeros9(value) {
  let result = arrayify20(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad6(value, length) {
  value = arrayify20(value);
  if (value.length > length) {
    logger131.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice19(result);
}
function isHexString20(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters14 = "0123456789abcdef";
function hexlify15(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger131.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters14[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable19(value)) {
    return value.toHexString();
  }
  if (isHexString20(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger131.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes20(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters14[(v & 240) >> 4] + HexCharacters14[v & 15];
    }
    return result;
  }
  return logger131.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength9(data) {
  if (typeof data !== "string") {
    data = hexlify15(data);
  } else if (!isHexString20(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice10(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify15(data);
  } else if (!isHexString20(data) || data.length % 2) {
    logger131.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat8(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify15(item).substring(2);
  });
  return result;
}
function hexZeroPad13(value, length) {
  if (typeof value !== "string") {
    value = hexlify15(value);
  } else if (!isHexString20(value)) {
    logger131.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger131.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature6(signature6) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike11(signature6)) {
    let bytes = arrayify20(signature6);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify15(bytes.slice(0, 32));
      result.s = hexlify15(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify15(bytes.slice(0, 32));
      result.s = hexlify15(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger131.throwArgumentError("invalid signature string", "signature", signature6);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger131.throwArgumentError("signature invalid v byte", "signature", signature6);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify15(bytes.slice(32, 64));
  } else {
    result.r = signature6.r;
    result.s = signature6.s;
    result.v = signature6.v;
    result.recoveryParam = signature6.recoveryParam;
    result._vs = signature6._vs;
    if (result._vs != null) {
      const vs2 = zeroPad6(arrayify20(result._vs), 32);
      result._vs = hexlify15(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger131.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature6);
      }
      vs2[0] &= 127;
      const s = hexlify15(vs2);
      if (result.s == null) {
        result.s = s;
      } else if (result.s !== s) {
        logger131.throwArgumentError("signature v mismatch _vs", "signature", signature6);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger131.throwArgumentError("signature missing v and recoveryParam", "signature", signature6);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger131.throwArgumentError("signature recoveryParam mismatch v", "signature", signature6);
        }
      }
    }
    if (result.r == null || !isHexString20(result.r)) {
      logger131.throwArgumentError("signature missing or invalid r", "signature", signature6);
    } else {
      result.r = hexZeroPad13(result.r, 32);
    }
    if (result.s == null || !isHexString20(result.s)) {
      logger131.throwArgumentError("signature missing or invalid s", "signature", signature6);
    } else {
      result.s = hexZeroPad13(result.s, 32);
    }
    const vs = arrayify20(result.s);
    if (vs[0] >= 128) {
      logger131.throwArgumentError("signature s out of range", "signature", signature6);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify15(vs);
    if (result._vs) {
      if (!isHexString20(result._vs)) {
        logger131.throwArgumentError("signature invalid _vs", "signature", signature6);
      }
      result._vs = hexZeroPad13(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger131.throwArgumentError("signature _vs mismatch v and s", "signature", signature6);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn15 = __toESM(require_bn());

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version120 = "bignumber/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN15 = import_bn15.default.BN;
var logger132 = new Logger23(version120);
var _constructorGuard24 = {};
var MAX_SAFE11 = 9007199254740991;
function isBigNumberish11(value) {
  return value != null && (BigNumber12.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString20(value) || typeof value === "bigint" || isBytes20(value));
}
var _warnedToStringRadix11 = false;
var BigNumber12 = class {
  constructor(constructorGuard, hex) {
    logger132.checkNew(new.target, BigNumber12);
    if (constructorGuard !== _constructorGuard24) {
      logger132.throwError("cannot call constructor directly; use BigNumber.from", Logger23.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber11(toBN11(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber11(toBN11(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber12.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber11(toBN11(this).add(toBN11(other)));
  }
  sub(other) {
    return toBigNumber11(toBN11(this).sub(toBN11(other)));
  }
  div(other) {
    const o = BigNumber12.from(other);
    if (o.isZero()) {
      throwFault21("division-by-zero", "div");
    }
    return toBigNumber11(toBN11(this).div(toBN11(other)));
  }
  mul(other) {
    return toBigNumber11(toBN11(this).mul(toBN11(other)));
  }
  mod(other) {
    const value = toBN11(other);
    if (value.isNeg()) {
      throwFault21("division-by-zero", "mod");
    }
    return toBigNumber11(toBN11(this).umod(value));
  }
  pow(other) {
    const value = toBN11(other);
    if (value.isNeg()) {
      throwFault21("negative-power", "pow");
    }
    return toBigNumber11(toBN11(this).pow(value));
  }
  and(other) {
    const value = toBN11(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault21("unbound-bitwise-result", "and");
    }
    return toBigNumber11(toBN11(this).and(value));
  }
  or(other) {
    const value = toBN11(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault21("unbound-bitwise-result", "or");
    }
    return toBigNumber11(toBN11(this).or(value));
  }
  xor(other) {
    const value = toBN11(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault21("unbound-bitwise-result", "xor");
    }
    return toBigNumber11(toBN11(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault21("negative-width", "mask");
    }
    return toBigNumber11(toBN11(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault21("negative-width", "shl");
    }
    return toBigNumber11(toBN11(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault21("negative-width", "shr");
    }
    return toBigNumber11(toBN11(this).shrn(value));
  }
  eq(other) {
    return toBN11(this).eq(toBN11(other));
  }
  lt(other) {
    return toBN11(this).lt(toBN11(other));
  }
  lte(other) {
    return toBN11(this).lte(toBN11(other));
  }
  gt(other) {
    return toBN11(this).gt(toBN11(other));
  }
  gte(other) {
    return toBN11(this).gte(toBN11(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN11(this).isZero();
  }
  toNumber() {
    try {
      return toBN11(this).toNumber();
    } catch (error) {
      throwFault21("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger132.throwError("this platform does not support BigInt", Logger23.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix11) {
          _warnedToStringRadix11 = true;
          logger132.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger132.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger23.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger132.throwError("BigNumber.toString does not accept parameters", Logger23.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN11(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber12) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber12(_constructorGuard24, toHex11(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber12(_constructorGuard24, toHex11(new BN15(value)));
      }
      return logger132.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault21("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE11 || value <= -MAX_SAFE11) {
        throwFault21("overflow", "BigNumber.from", value);
      }
      return BigNumber12.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber12.from(anyValue.toString());
    }
    if (isBytes20(anyValue)) {
      return BigNumber12.from(hexlify15(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber12.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString20(hex) || hex[0] === "-" && isHexString20(hex.substring(1))) {
            return BigNumber12.from(hex);
          }
        }
      }
    }
    return logger132.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex11(value) {
  if (typeof value !== "string") {
    return toHex11(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger132.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex11(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber11(value) {
  return BigNumber12.from(toHex11(value));
}
function toBN11(value) {
  const hex = BigNumber12.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN15("-" + hex.substring(3), 16);
  }
  return new BN15(hex.substring(2), 16);
}
function throwFault21(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger132.throwError(fault, Logger23.errors.NUMERIC_FAULT, params);
}
function _base36To1611(value) {
  return new BN15(value, 36).toString(16);
}

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger133 = new Logger23(version120);
var _constructorGuard25 = {};
var Zero25 = BigNumber12.from(0);
var NegativeOne25 = BigNumber12.from(-1);
function throwFault22(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger133.throwError(message, Logger23.errors.NUMERIC_FAULT, params);
}
var zeros11 = "0";
while (zeros11.length < 256) {
  zeros11 += zeros11;
}
function getMultiplier11(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber12.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros11.substring(0, decimals);
  }
  return logger133.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed12(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier11(decimals);
  value = BigNumber12.from(value);
  const negative = value.lt(Zero25);
  if (negative) {
    value = value.mul(NegativeOne25);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed12(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier11(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger133.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger133.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger133.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault22("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber12.from(whole);
  const fractionValue = BigNumber12.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne25);
  }
  return wei;
}
var FixedFormat11 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard25) {
      logger133.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger23.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier11(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat11) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger133.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger133.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger133.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger133.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat11(_constructorGuard25, signed, width, decimals);
  }
};
var FixedNumber11 = class {
  constructor(constructorGuard, hex, value, format) {
    logger133.checkNew(new.target, FixedNumber11);
    if (constructorGuard !== _constructorGuard25) {
      logger133.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger23.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger133.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed12(this._value, this.format.decimals);
    const b = parseFixed12(other._value, other.format.decimals);
    return FixedNumber11.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed12(this._value, this.format.decimals);
    const b = parseFixed12(other._value, other.format.decimals);
    return FixedNumber11.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed12(this._value, this.format.decimals);
    const b = parseFixed12(other._value, other.format.decimals);
    return FixedNumber11.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed12(this._value, this.format.decimals);
    const b = parseFixed12(other._value, other.format.decimals);
    return FixedNumber11.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber11.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE11.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber11.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE11.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger133.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber11.from("1" + zeros11.substring(0, decimals), this.format);
    const bump = BUMP11.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger133.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber12.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad13(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber11.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish11(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber11.fromString(formatFixed12(value, decimals), FixedFormat11.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat11.from(format);
    const numeric = parseFixed12(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero25)) {
      throwFault22("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad13(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed12(numeric, fixedFormat.decimals);
    return new FixedNumber11(_constructorGuard25, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat11.from(format);
    if (arrayify20(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber12.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed12(numeric, fixedFormat.decimals);
    return new FixedNumber11(_constructorGuard25, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber11.fromString(value, format);
    }
    if (isBytes20(value)) {
      return FixedNumber11.fromBytes(value, format);
    }
    try {
      return FixedNumber11.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger23.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger133.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE11 = FixedNumber11.from(1);
var BUMP11 = FixedNumber11.from("0.5");

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha39 = __toESM(require_sha3());
function keccak25611(data) {
  return "0x" + import_js_sha39.default.keccak_256(arrayify20(data));
}

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version121 = "rlp/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger134 = new Logger23(version121);
function arrayifyInteger4(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger3(data, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _encode8(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode8(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger4(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike11(object)) {
    logger134.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify20(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger4(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode15(object) {
  return hexlify15(_encode8(object));
}
function _decodeChildren3(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode3(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger134.throwError("child data too short", Logger23.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode3(data, offset) {
  if (data.length === 0) {
    logger134.throwError("data too short", Logger23.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger134.throwError("data short segment too short", Logger23.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger3(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger134.throwError("data long segment too short", Logger23.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren3(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger134.throwError("data array too short", Logger23.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren3(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger134.throwError("data array too short", Logger23.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger3(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger134.throwError("data array too short", Logger23.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify15(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger134.throwError("data too short", Logger23.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify15(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify15(data[offset]) };
}
function decode7(data) {
  const bytes = arrayify20(data);
  const decoded = _decode3(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger134.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version122 = "address/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/lib.esm/index.js
var logger135 = new Logger23(version122);
function getChecksumAddress8(address) {
  if (!isHexString20(address, 20)) {
    logger135.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify20(keccak25611(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER8 = 9007199254740991;
function log108(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
var ibanLookup8 = {};
for (let i = 0; i < 10; i++) {
  ibanLookup8[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
  ibanLookup8[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits8 = Math.floor(log108(MAX_SAFE_INTEGER8));
function ibanChecksum8(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup8[c];
  }).join("");
  while (expanded.length >= safeDigits8) {
    let block = expanded.substring(0, safeDigits8);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress9(address) {
  let result = null;
  if (typeof address !== "string") {
    logger135.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress8(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger135.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum8(address)) {
      logger135.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To1611(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress8("0x" + result);
  } else {
    logger135.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();
var NegativeOne26 = BigNumber12.from(-1);
var Zero26 = BigNumber12.from(0);
var One15 = BigNumber12.from(1);
var Two9 = BigNumber12.from(2);
var WeiPerEther9 = BigNumber12.from("1000000000000000000");
var MaxUint25615 = BigNumber12.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2569 = BigNumber12.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2569 = BigNumber12.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version123 = "properties/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/properties/lib.esm/index.js
var logger136 = new Logger23(version123);
function defineReadOnly12(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function checkProperties5(object, properties) {
  if (!object || typeof object !== "object") {
    logger136.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key6) => {
    if (!properties[key6]) {
      logger136.throwArgumentError("invalid object key - " + key6, "transaction:" + key6, object);
    }
  });
}

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
init_define_process_env();
var import_bn16 = __toESM(require_bn());
var import_hash16 = __toESM(require_hash());
function createCommonjsModule5(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base6) {
      return commonjsRequire5(path, base6 === void 0 || base6 === null ? module.path : base6);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire5() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert5 = assert5;
function assert5(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert5.equal = function assertEqual5(l, r, msg) {
  if (l != r)
    throw new Error(msg || "Assertion failed: " + l + " != " + r);
};
var utils_15 = createCommonjsModule5(function(module, exports) {
  "use strict";
  var utils = exports;
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex13(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex13;
  utils.encode = function encode18(arr, enc) {
    if (enc === "hex")
      return toHex13(arr);
    else
      return arr;
  };
});
var utils_1$15 = createCommonjsModule5(function(module, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert5;
  utils.toArray = utils_15.toArray;
  utils.zero2 = utils_15.zero2;
  utils.toHex = utils_15.toHex;
  utils.encode = utils_15.encode;
  function getNAF6(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF6;
  function getJSF6(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF6;
  function cachedProperty(obj, name2, computer) {
    var key6 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key6] !== void 0 ? this[key6] : this[key6] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn16.default(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});
var getNAF5 = utils_1$15.getNAF;
var getJSF5 = utils_1$15.getJSF;
var assert$15 = utils_1$15.assert;
function BaseCurve5(type, conf) {
  this.type = type;
  this.p = new import_bn16.default(conf.p, 16);
  this.red = conf.prime ? import_bn16.default.red(conf.prime) : import_bn16.default.mont(this.p);
  this.zero = new import_bn16.default(0).toRed(this.red);
  this.one = new import_bn16.default(1).toRed(this.red);
  this.two = new import_bn16.default(2).toRed(this.red);
  this.n = conf.n && new import_bn16.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base5 = BaseCurve5;
BaseCurve5.prototype.point = function point9() {
  throw new Error("Not implemented");
};
BaseCurve5.prototype.validate = function validate17() {
  throw new Error("Not implemented");
};
BaseCurve5.prototype._fixedNafMul = function _fixedNafMul5(p, k) {
  assert$15(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF5(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};
BaseCurve5.prototype._wnafMul = function _wnafMul5(p, k) {
  var w = 4;
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF5(k, w, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);
    if (i < 0)
      break;
    var z = naf[i];
    assert$15(z !== 0);
    if (p.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p.type === "affine" ? acc.toP() : acc;
};
BaseCurve5.prototype._wnafMulAdd = function _wnafMulAdd5(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF5(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF5(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [
      points[a],
      null,
      null,
      points[b]
    ];
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF5(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;
    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][z - 1 >> 1];
      else if (z < 0)
        p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === "affine")
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  for (i = 0; i < len; i++)
    wnd[i] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint5(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve5.BasePoint = BasePoint5;
BasePoint5.prototype.eq = function eq13() {
  throw new Error("Not implemented");
};
BasePoint5.prototype.validate = function validate18() {
  return this.curve.validate(this);
};
BaseCurve5.prototype.decodePoint = function decodePoint5(bytes, enc) {
  bytes = utils_1$15.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$15(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$15(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint5.prototype.encodeCompressed = function encodeCompressed5(enc) {
  return this.encode(enc, true);
};
BasePoint5.prototype._encode = function _encode9(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x);
  return [4].concat(x, this.getY().toArray("be", len));
};
BasePoint5.prototype.encode = function encode16(enc, compact) {
  return utils_1$15.encode(this._encode(compact), enc);
};
BasePoint5.prototype.precompute = function precompute5(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint5.prototype._hasDoubles = function _hasDoubles5(k) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint5.prototype._getDoubles = function _getDoubles5(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint5.prototype._getNAFPoints = function _getNAFPoints5(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl11 = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl11);
  return {
    wnd,
    points: res
  };
};
BasePoint5.prototype._getBeta = function _getBeta9() {
  return null;
};
BasePoint5.prototype.dblp = function dblp9(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};
var inherits_browser5 = createCommonjsModule5(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$25 = utils_1$15.assert;
function ShortCurve5(conf) {
  base5.call(this, "short", conf);
  this.a = new import_bn16.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn16.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser5(ShortCurve5, base5);
var short_15 = ShortCurve5;
ShortCurve5.prototype._getEndomorphism = function _getEndomorphism5(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn16.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn16.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$25(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn16.default(vec.a, 16),
        b: new import_bn16.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve5.prototype._getEndoRoots = function _getEndoRoots5(num) {
  var red = num === this.p ? this.red : import_bn16.default.mont(num);
  var tinv = new import_bn16.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new import_bn16.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
};
ShortCurve5.prototype._getEndoBasis = function _getEndoBasis5(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u = lambda;
  var v = this.n.clone();
  var x1 = new import_bn16.default(1);
  var y1 = new import_bn16.default(0);
  var x2 = new import_bn16.default(0);
  var y2 = new import_bn16.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));
    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve5.prototype._endoSplit = function _endoSplit5(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1, k2 };
};
ShortCurve5.prototype.pointFromX = function pointFromX5(x, odd) {
  x = new import_bn16.default(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
};
ShortCurve5.prototype.validate = function validate19(point11) {
  if (point11.inf)
    return true;
  var x = point11.x;
  var y = point11.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve5.prototype._endoWnafMulAdd = function _endoWnafMulAdd5(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point5(curve, x, y, isRed) {
  base5.BasePoint.call(this, curve, "affine");
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn16.default(x, 16);
    this.y = new import_bn16.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser5(Point5, base5.BasePoint);
ShortCurve5.prototype.point = function point10(x, y, isRed) {
  return new Point5(this, x, y, isRed);
};
ShortCurve5.prototype.pointFromJSON = function pointFromJSON5(obj, red) {
  return Point5.fromJSON(this, obj, red);
};
Point5.prototype._getBeta = function _getBeta10() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point5.prototype.toJSON = function toJSON5() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point5.fromJSON = function fromJSON5(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point5.prototype.inspect = function inspect13() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point5.prototype.isInfinity = function isInfinity9() {
  return this.inf;
};
Point5.prototype.add = function add9(p) {
  if (this.inf)
    return p;
  if (p.inf)
    return this;
  if (this.eq(p))
    return this.dbl();
  if (this.neg().eq(p))
    return this.curve.point(null, null);
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point5.prototype.dbl = function dbl9() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point5.prototype.getX = function getX5() {
  return this.x.fromRed();
};
Point5.prototype.getY = function getY5() {
  return this.y.fromRed();
};
Point5.prototype.mul = function mul9(k) {
  k = new import_bn16.default(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k]);
  else
    return this.curve._wnafMul(this, k);
};
Point5.prototype.mulAdd = function mulAdd5(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point5.prototype.jmulAdd = function jmulAdd5(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point5.prototype.eq = function eq14(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point5.prototype.neg = function neg9(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point5.prototype.toJ = function toJ5() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint5(curve, x, y, z) {
  base5.BasePoint.call(this, curve, "jacobian");
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn16.default(0);
  } else {
    this.x = new import_bn16.default(x, 16);
    this.y = new import_bn16.default(y, 16);
    this.z = new import_bn16.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser5(JPoint5, base5.BasePoint);
ShortCurve5.prototype.jpoint = function jpoint5(x, y, z) {
  return new JPoint5(this, x, y, z);
};
JPoint5.prototype.toP = function toP5() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint5.prototype.neg = function neg10() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint5.prototype.add = function add10(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint5.prototype.mixedAdd = function mixedAdd5(p) {
  if (this.isInfinity())
    return p.toJ();
  if (p.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint5.prototype.dblp = function dblp10(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }
  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint5.prototype.dbl = function dbl10() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint5.prototype._zeroDbl = function _zeroDbl5() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx);
    var t = m.redSqr().redISub(s).redISub(s);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t;
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = b.redSqr();
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    var e = a.redAdd(a).redIAdd(a);
    var f = e.redSqr();
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f.redISub(d).redISub(d);
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint5.prototype._threeDbl = function _threeDbl5() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t = m.redSqr().redISub(s).redISub(s);
    nx = t;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint5.prototype._dbl = function _dbl5() {
  var a = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint5.prototype.trpl = function trpl5() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m = xx.redAdd(xx).redIAdd(xx);
  var mm = m.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee = e.redSqr();
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint5.prototype.mul = function mul10(k, kbase) {
  k = new import_bn16.default(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint5.prototype.eq = function eq15(p) {
  if (p.type === "affine")
    return this.eq(p.toJ());
  if (this === p)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint5.prototype.eqXToP = function eqXToP5(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint5.prototype.inspect = function inspect14() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint5.prototype.isInfinity = function isInfinity10() {
  return this.z.cmpn(0) === 0;
};
var curve_15 = createCommonjsModule5(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base5;
  curve.short = short_15;
  curve.mont = null;
  curve.edwards = null;
});
var curves_15 = createCommonjsModule5(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert6 = utils_1$15.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_15.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_15.edwards(options);
    else
      this.curve = new curve_15.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert6(this.g.validate(), "Invalid curve");
    assert6(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash16.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash16.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash16.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash16.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash16.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash16.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash16.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash16.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG5(options) {
  if (!(this instanceof HmacDRBG5))
    return new HmacDRBG5(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_15.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_15.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_15.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert5(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg5 = HmacDRBG5;
HmacDRBG5.prototype._init = function init5(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0;
    this.V[i] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG5.prototype._hmac = function hmac5() {
  return new import_hash16.default.hmac(this.hash, this.K);
};
HmacDRBG5.prototype._update = function update5(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG5.prototype.reseed = function reseed5(entropy, entropyEnc, add11, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add11;
    add11 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_15.toArray(entropy, entropyEnc);
  add11 = utils_15.toArray(add11, addEnc);
  minimalisticAssert5(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add11 || []));
  this._reseed = 1;
};
HmacDRBG5.prototype.generate = function generate5(len, enc, add11, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add11;
    add11 = enc;
    enc = null;
  }
  if (add11) {
    add11 = utils_15.toArray(add11, addEnc || "hex");
    this._update(add11);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add11);
  this._reseed++;
  return utils_15.encode(res, enc);
};
var assert$35 = utils_1$15.assert;
function KeyPair5(ec6, options) {
  this.ec = ec6;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key5 = KeyPair5;
KeyPair5.fromPublic = function fromPublic5(ec6, pub, enc) {
  if (pub instanceof KeyPair5)
    return pub;
  return new KeyPair5(ec6, {
    pub,
    pubEnc: enc
  });
};
KeyPair5.fromPrivate = function fromPrivate5(ec6, priv, enc) {
  if (priv instanceof KeyPair5)
    return priv;
  return new KeyPair5(ec6, {
    priv,
    privEnc: enc
  });
};
KeyPair5.prototype.validate = function validate20() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair5.prototype.getPublic = function getPublic5(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair5.prototype.getPrivate = function getPrivate5(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair5.prototype._importPrivate = function _importPrivate5(key6, enc) {
  this.priv = new import_bn16.default(key6, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair5.prototype._importPublic = function _importPublic5(key6, enc) {
  if (key6.x || key6.y) {
    if (this.ec.curve.type === "mont") {
      assert$35(key6.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$35(key6.x && key6.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key6.x, key6.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key6, enc);
};
KeyPair5.prototype.derive = function derive5(pub) {
  if (!pub.validate()) {
    assert$35(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair5.prototype.sign = function sign9(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair5.prototype.verify = function verify9(msg, signature6) {
  return this.ec.verify(msg, signature6, this);
};
KeyPair5.prototype.inspect = function inspect15() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$45 = utils_1$15.assert;
function Signature5(options, enc) {
  if (options instanceof Signature5)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$45(options.r && options.s, "Signature without r or s");
  this.r = new import_bn16.default(options.r, 16);
  this.s = new import_bn16.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature5 = Signature5;
function Position5() {
  this.place = 0;
}
function getLength5(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
function rmPadding5(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature5.prototype._importDER = function _importDER5(data, enc) {
  data = utils_1$15.toArray(data, enc);
  var p = new Position5();
  if (data[p.place++] !== 48) {
    return false;
  }
  var len = getLength5(data, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data.length) {
    return false;
  }
  if (data[p.place++] !== 2) {
    return false;
  }
  var rlen = getLength5(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 2) {
    return false;
  }
  var slen = getLength5(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 128) {
      r = r.slice(1);
    } else {
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 128) {
      s = s.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn16.default(r);
  this.s = new import_bn16.default(s);
  this.recoveryParam = null;
  return true;
};
function constructLength5(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature5.prototype.toDER = function toDER5(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();
  if (r[0] & 128)
    r = [0].concat(r);
  if (s[0] & 128)
    s = [0].concat(s);
  r = rmPadding5(r);
  s = rmPadding5(s);
  while (!s[0] && !(s[1] & 128)) {
    s = s.slice(1);
  }
  var arr = [2];
  constructLength5(arr, r.length);
  arr = arr.concat(r);
  arr.push(2);
  constructLength5(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [48];
  constructLength5(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$15.encode(res, enc);
};
var rand5 = function() {
  throw new Error("unsupported");
};
var assert$55 = utils_1$15.assert;
function EC5(options) {
  if (!(this instanceof EC5))
    return new EC5(options);
  if (typeof options === "string") {
    assert$55(Object.prototype.hasOwnProperty.call(curves_15, options), "Unknown curve " + options);
    options = curves_15[options];
  }
  if (options instanceof curves_15.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec5 = EC5;
EC5.prototype.keyPair = function keyPair5(options) {
  return new key5(this, options);
};
EC5.prototype.keyFromPrivate = function keyFromPrivate5(priv, enc) {
  return key5.fromPrivate(this, priv, enc);
};
EC5.prototype.keyFromPublic = function keyFromPublic5(pub, enc) {
  return key5.fromPublic(this, pub, enc);
};
EC5.prototype.genKeyPair = function genKeyPair5(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg5({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand5(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn16.default(2));
  for (; ; ) {
    var priv = new import_bn16.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC5.prototype._truncateToN = function _truncateToN5(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC5.prototype.sign = function sign10(msg, key6, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key6 = this.keyFromPrivate(key6, enc);
  msg = this._truncateToN(new import_bn16.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key6.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg5({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn16.default(1));
  for (var iter = 0; ; iter++) {
    var k = options.k ? options.k(iter) : new import_bn16.default(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;
    var s = k.invm(this.n).mul(r.mul(key6.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }
    return new signature5({ r, s, recoveryParam });
  }
};
EC5.prototype.verify = function verify10(msg, signature$1, key6, enc) {
  msg = this._truncateToN(new import_bn16.default(msg, 16));
  key6 = this.keyFromPublic(key6, enc);
  signature$1 = new signature5(signature$1, "hex");
  var r = signature$1.r;
  var s = signature$1.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;
  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key6.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  }
  p = this.g.jmulAdd(u1, key6.getPublic(), u2);
  if (p.isInfinity())
    return false;
  return p.eqXToP(r);
};
EC5.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$55((3 & j) === j, "The recovery param is more than two bits");
  signature$1 = new signature5(signature$1, enc);
  var n = this.n;
  var e = new import_bn16.default(msg);
  var r = signature$1.r;
  var s = signature$1.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r, s2);
};
EC5.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {
  signature$1 = new signature5(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_15 = createCommonjsModule5(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$15;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_15;
  elliptic.curves = curves_15;
  elliptic.ec = ec5;
  elliptic.eddsa = null;
});
var EC$15 = elliptic_15.ec;

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/lib.esm/_version.js
init_define_process_env();
var version124 = "signing-key/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger137 = new Logger23(version124);
var _curve4 = null;
function getCurve4() {
  if (!_curve4) {
    _curve4 = new EC$15("secp256k1");
  }
  return _curve4;
}
var SigningKey6 = class {
  constructor(privateKey) {
    defineReadOnly12(this, "curve", "secp256k1");
    defineReadOnly12(this, "privateKey", hexlify15(privateKey));
    const keyPair6 = getCurve4().keyFromPrivate(arrayify20(this.privateKey));
    defineReadOnly12(this, "publicKey", "0x" + keyPair6.getPublic(false, "hex"));
    defineReadOnly12(this, "compressedPublicKey", "0x" + keyPair6.getPublic(true, "hex"));
    defineReadOnly12(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve4().keyFromPublic(arrayify20(this.publicKey));
    const p1 = getCurve4().keyFromPublic(arrayify20(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest) {
    const keyPair6 = getCurve4().keyFromPrivate(arrayify20(this.privateKey));
    const digestBytes = arrayify20(digest);
    if (digestBytes.length !== 32) {
      logger137.throwArgumentError("bad digest length", "digest", digest);
    }
    const signature6 = keyPair6.sign(digestBytes, { canonical: true });
    return splitSignature6({
      recoveryParam: signature6.recoveryParam,
      r: hexZeroPad13("0x" + signature6.r.toString(16), 32),
      s: hexZeroPad13("0x" + signature6.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair6 = getCurve4().keyFromPrivate(arrayify20(this.privateKey));
    const otherKeyPair = getCurve4().keyFromPublic(arrayify20(computePublicKey5(otherKey)));
    return hexZeroPad13("0x" + keyPair6.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
function recoverPublicKey5(digest, signature6) {
  const sig = splitSignature6(signature6);
  const rs = { r: arrayify20(sig.r), s: arrayify20(sig.s) };
  return "0x" + getCurve4().recoverPubKey(arrayify20(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey5(key6, compressed) {
  const bytes = arrayify20(key6);
  if (bytes.length === 32) {
    const signingKey = new SigningKey6(bytes);
    if (compressed) {
      return "0x" + getCurve4().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify15(bytes);
    }
    return "0x" + getCurve4().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify15(bytes);
    }
    return "0x" + getCurve4().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger137.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

// node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/_version.js
init_define_process_env();
var version125 = "transactions/5.5.0";

// node_modules/ethers/node_modules/@ethersproject/transactions/lib.esm/index.js
var logger138 = new Logger23(version125);
var TransactionTypes4;
(function(TransactionTypes5) {
  TransactionTypes5[TransactionTypes5["legacy"] = 0] = "legacy";
  TransactionTypes5[TransactionTypes5["eip2930"] = 1] = "eip2930";
  TransactionTypes5[TransactionTypes5["eip1559"] = 2] = "eip1559";
})(TransactionTypes4 || (TransactionTypes4 = {}));
function handleAddress2(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress9(value);
}
function handleNumber2(value) {
  if (value === "0x") {
    return Zero26;
  }
  return BigNumber12.from(value);
}
var transactionFields = [
  { name: "nonce", maxLength: 32, numeric: true },
  { name: "gasPrice", maxLength: 32, numeric: true },
  { name: "gasLimit", maxLength: 32, numeric: true },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: true },
  { name: "data" }
];
var allowedTransactionKeys5 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  type: true,
  value: true
};
function computeAddress5(key6) {
  const publicKey = computePublicKey5(key6);
  return getAddress9(hexDataSlice10(keccak25611(hexDataSlice10(publicKey, 1)), 12));
}
function recoverAddress3(digest, signature6) {
  return computeAddress5(recoverPublicKey5(arrayify20(digest), signature6));
}
function formatNumber2(value, name2) {
  const result = stripZeros9(BigNumber12.from(value).toHexString());
  if (result.length > 32) {
    logger138.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify2(addr, storageKeys) {
  return {
    address: getAddress9(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength9(storageKey) !== 32) {
        logger138.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify3(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger138.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
        }
        return accessSetify2(set[0], set[1]);
      }
      return accessSetify2(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify2(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b) => a.address.localeCompare(b.address));
  return result;
}
function formatAccessList2(value) {
  return accessListify3(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip15592(transaction, signature6) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber12.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber12.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger138.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber2(transaction.chainId || 0, "chainId"),
    formatNumber2(transaction.nonce || 0, "nonce"),
    formatNumber2(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber2(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber2(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress9(transaction.to) : "0x",
    formatNumber2(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList2(transaction.accessList || [])
  ];
  if (signature6) {
    const sig = splitSignature6(signature6);
    fields.push(formatNumber2(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros9(sig.r));
    fields.push(stripZeros9(sig.s));
  }
  return hexConcat8(["0x02", encode15(fields)]);
}
function _serializeEip29302(transaction, signature6) {
  const fields = [
    formatNumber2(transaction.chainId || 0, "chainId"),
    formatNumber2(transaction.nonce || 0, "nonce"),
    formatNumber2(transaction.gasPrice || 0, "gasPrice"),
    formatNumber2(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress9(transaction.to) : "0x",
    formatNumber2(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList2(transaction.accessList || [])
  ];
  if (signature6) {
    const sig = splitSignature6(signature6);
    fields.push(formatNumber2(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros9(sig.r));
    fields.push(stripZeros9(sig.s));
  }
  return hexConcat8(["0x01", encode15(fields)]);
}
function _serialize(transaction, signature6) {
  checkProperties5(transaction, allowedTransactionKeys5);
  const raw = [];
  transactionFields.forEach(function(fieldInfo) {
    let value = transaction[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value = arrayify20(hexlify15(value, options));
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger138.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    if (fieldInfo.maxLength) {
      value = stripZeros9(value);
      if (value.length > fieldInfo.maxLength) {
        logger138.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw.push(hexlify15(value));
  });
  let chainId = 0;
  if (transaction.chainId != null) {
    chainId = transaction.chainId;
    if (typeof chainId !== "number") {
      logger138.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature6 && !isBytesLike11(signature6) && signature6.v > 28) {
    chainId = Math.floor((signature6.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw.push(hexlify15(chainId));
    raw.push("0x");
    raw.push("0x");
  }
  if (!signature6) {
    return encode15(raw);
  }
  const sig = splitSignature6(signature6);
  let v = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v) {
      logger138.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature6);
    }
  } else if (sig.v !== v) {
    logger138.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature6);
  }
  raw.push(hexlify15(v));
  raw.push(stripZeros9(arrayify20(sig.r)));
  raw.push(stripZeros9(arrayify20(sig.s)));
  return encode15(raw);
}
function serialize3(transaction, signature6) {
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger138.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature6);
  }
  switch (transaction.type) {
    case 1:
      return _serializeEip29302(transaction, signature6);
    case 2:
      return _serializeEip15592(transaction, signature6);
    default:
      break;
  }
  return logger138.throwError(`unsupported transaction type: ${transaction.type}`, Logger23.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
function _parseEipSignature2(tx, fields, serialize4) {
  try {
    const recid = handleNumber2(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger138.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad13(fields[1], 32);
  tx.s = hexZeroPad13(fields[2], 32);
  try {
    const digest = keccak25611(serialize4(tx));
    tx.from = recoverAddress3(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
    console.log(error);
  }
}
function _parseEip15592(payload) {
  const transaction = decode7(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger138.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify15(payload));
  }
  const maxPriorityFeePerGas = handleNumber2(transaction[2]);
  const maxFeePerGas = handleNumber2(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber2(transaction[0]).toNumber(),
    nonce: handleNumber2(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber2(transaction[4]),
    to: handleAddress2(transaction[5]),
    value: handleNumber2(transaction[6]),
    data: transaction[7],
    accessList: accessListify3(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak25611(payload);
  _parseEipSignature2(tx, transaction.slice(9), _serializeEip15592);
  return tx;
}
function _parseEip29302(payload) {
  const transaction = decode7(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger138.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify15(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber2(transaction[0]).toNumber(),
    nonce: handleNumber2(transaction[1]).toNumber(),
    gasPrice: handleNumber2(transaction[2]),
    gasLimit: handleNumber2(transaction[3]),
    to: handleAddress2(transaction[4]),
    value: handleNumber2(transaction[5]),
    data: transaction[6],
    accessList: accessListify3(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak25611(payload);
  _parseEipSignature2(tx, transaction.slice(8), _serializeEip29302);
  return tx;
}
function _parse2(rawTransaction) {
  const transaction = decode7(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger138.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber2(transaction[0]).toNumber(),
    gasPrice: handleNumber2(transaction[1]),
    gasLimit: handleNumber2(transaction[2]),
    to: handleAddress2(transaction[3]),
    value: handleNumber2(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber12.from(transaction[6]).toNumber();
  } catch (error) {
    console.log(error);
    return tx;
  }
  tx.r = hexZeroPad13(transaction[7], 32);
  tx.s = hexZeroPad13(transaction[8], 32);
  if (BigNumber12.from(tx.r).isZero() && BigNumber12.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify15(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest = keccak25611(encode15(raw));
    try {
      tx.from = recoverAddress3(digest, { r: hexlify15(tx.r), s: hexlify15(tx.s), recoveryParam });
    } catch (error) {
      console.log(error);
    }
    tx.hash = keccak25611(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse2(rawTransaction) {
  const payload = arrayify20(rawTransaction);
  if (payload[0] > 127) {
    return _parse2(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip29302(payload);
    case 2:
      return _parseEip15592(payload);
    default:
      break;
  }
  return logger138.throwError(`unsupported transaction type: ${payload[0]}`, Logger23.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}

// node_modules/@ethersproject/units/lib.esm/index.js
init_define_process_env();
init_lib3();
init_lib();

// node_modules/@ethersproject/units/lib.esm/_version.js
init_define_process_env();
var version126 = "units/5.5.0";

// node_modules/@ethersproject/units/lib.esm/index.js
var logger139 = new Logger(version126);
var names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger139.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger139.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}

// node_modules/ethers/node_modules/@ethersproject/web/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/base64/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/base64/lib.esm/base64.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version127 = "logger/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors23 = false;
var _censorErrors23 = false;
var LogLevels23 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel23 = LogLevels23["default"];
var _globalLogger23 = null;
function _checkNormalize23() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError23 = _checkNormalize23();
var LogLevel23;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel23 || (LogLevel23 = {}));
var ErrorCode23;
(function(ErrorCode24) {
  ErrorCode24["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode24["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode24["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode24["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode24["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode24["TIMEOUT"] = "TIMEOUT";
  ErrorCode24["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode24["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode24["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode24["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode24["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode24["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode24["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode24["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode24["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode24["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode24["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode24["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode23 || (ErrorCode23 = {}));
var HEX23 = "0123456789abcdef";
var Logger24 = class {
  constructor(version134) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version134,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels23[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel23 > LogLevels23[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger24.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger24.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger24.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors23) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger24.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX23[value[i] >> 4];
            hex += HEX23[value[i] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode23.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode23.CALL_EXCEPTION:
      case ErrorCode23.INSUFFICIENT_FUNDS:
      case ErrorCode23.MISSING_NEW:
      case ErrorCode23.NONCE_EXPIRED:
      case ErrorCode23.REPLACEMENT_UNDERPRICED:
      case ErrorCode23.TRANSACTION_REPLACED:
      case ErrorCode23.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger24.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError23) {
      this.throwError("platform missing String.prototype.normalize", Logger24.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError23
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger24.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger24.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger24.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger24.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger24.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger24.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger24.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger23) {
      _globalLogger23 = new Logger24(version127);
    }
    return _globalLogger23;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger24.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors23) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger24.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors23 = !!censorship;
    _permanentCensorErrors23 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels23[logLevel.toLowerCase()];
    if (level == null) {
      Logger24.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel23 = level;
  }
  static from(version134) {
    return new Logger24(version134);
  }
};
Logger24.errors = ErrorCode23;
Logger24.levels = LogLevel23;

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version128 = "bytes/5.6.1";

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger140 = new Logger24(version128);
function isHexable20(value) {
  return !!value.toHexString;
}
function addSlice20(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice20(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike12(value) {
  return isHexString21(value) && !(value.length % 2) || isBytes21(value);
}
function isInteger20(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes21(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger20(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger20(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify21(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger140.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice20(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable20(value)) {
    value = value.toHexString();
  }
  if (isHexString21(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger140.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice20(new Uint8Array(result));
  }
  if (isBytes21(value)) {
    return addSlice20(new Uint8Array(value));
  }
  return logger140.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString21(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters15 = "0123456789abcdef";
function hexlify16(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger140.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters15[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable20(value)) {
    return value.toHexString();
  }
  if (isHexString21(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger140.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes21(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters15[(v & 240) >> 4] + HexCharacters15[v & 15];
    }
    return result;
  }
  return logger140.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad14(value, length) {
  if (typeof value !== "string") {
    value = hexlify16(value);
  } else if (!isHexString21(value)) {
    logger140.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger140.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/base64/lib.esm/base64.js
function decode8(textData) {
  textData = atob(textData);
  const data = [];
  for (let i = 0; i < textData.length; i++) {
    data.push(textData.charCodeAt(i));
  }
  return arrayify21(data);
}
function encode17(data) {
  data = arrayify21(data);
  let textData = "";
  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version129 = "properties/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/properties/lib.esm/index.js
var logger141 = new Logger24(version129);
function shallowCopy10(object) {
  const result = {};
  for (const key6 in object) {
    result[key6] = object[key6];
  }
  return result;
}

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn17 = __toESM(require_bn());

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version130 = "bignumber/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN17 = import_bn17.default.BN;
var logger142 = new Logger24(version130);
var _constructorGuard26 = {};
var MAX_SAFE12 = 9007199254740991;
function isBigNumberish12(value) {
  return value != null && (BigNumber13.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString21(value) || typeof value === "bigint" || isBytes21(value));
}
var _warnedToStringRadix12 = false;
var BigNumber13 = class {
  constructor(constructorGuard, hex) {
    logger142.checkNew(new.target, BigNumber13);
    if (constructorGuard !== _constructorGuard26) {
      logger142.throwError("cannot call constructor directly; use BigNumber.from", Logger24.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber12(toBN12(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber12(toBN12(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber13.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber12(toBN12(this).add(toBN12(other)));
  }
  sub(other) {
    return toBigNumber12(toBN12(this).sub(toBN12(other)));
  }
  div(other) {
    const o = BigNumber13.from(other);
    if (o.isZero()) {
      throwFault23("division-by-zero", "div");
    }
    return toBigNumber12(toBN12(this).div(toBN12(other)));
  }
  mul(other) {
    return toBigNumber12(toBN12(this).mul(toBN12(other)));
  }
  mod(other) {
    const value = toBN12(other);
    if (value.isNeg()) {
      throwFault23("division-by-zero", "mod");
    }
    return toBigNumber12(toBN12(this).umod(value));
  }
  pow(other) {
    const value = toBN12(other);
    if (value.isNeg()) {
      throwFault23("negative-power", "pow");
    }
    return toBigNumber12(toBN12(this).pow(value));
  }
  and(other) {
    const value = toBN12(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault23("unbound-bitwise-result", "and");
    }
    return toBigNumber12(toBN12(this).and(value));
  }
  or(other) {
    const value = toBN12(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault23("unbound-bitwise-result", "or");
    }
    return toBigNumber12(toBN12(this).or(value));
  }
  xor(other) {
    const value = toBN12(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault23("unbound-bitwise-result", "xor");
    }
    return toBigNumber12(toBN12(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault23("negative-width", "mask");
    }
    return toBigNumber12(toBN12(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault23("negative-width", "shl");
    }
    return toBigNumber12(toBN12(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault23("negative-width", "shr");
    }
    return toBigNumber12(toBN12(this).shrn(value));
  }
  eq(other) {
    return toBN12(this).eq(toBN12(other));
  }
  lt(other) {
    return toBN12(this).lt(toBN12(other));
  }
  lte(other) {
    return toBN12(this).lte(toBN12(other));
  }
  gt(other) {
    return toBN12(this).gt(toBN12(other));
  }
  gte(other) {
    return toBN12(this).gte(toBN12(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN12(this).isZero();
  }
  toNumber() {
    try {
      return toBN12(this).toNumber();
    } catch (error) {
      throwFault23("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger142.throwError("this platform does not support BigInt", Logger24.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix12) {
          _warnedToStringRadix12 = true;
          logger142.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger142.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger24.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger142.throwError("BigNumber.toString does not accept parameters", Logger24.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN12(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber13) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber13(_constructorGuard26, toHex12(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber13(_constructorGuard26, toHex12(new BN17(value)));
      }
      return logger142.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault23("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE12 || value <= -MAX_SAFE12) {
        throwFault23("overflow", "BigNumber.from", value);
      }
      return BigNumber13.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber13.from(anyValue.toString());
    }
    if (isBytes21(anyValue)) {
      return BigNumber13.from(hexlify16(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber13.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString21(hex) || hex[0] === "-" && isHexString21(hex.substring(1))) {
            return BigNumber13.from(hex);
          }
        }
      }
    }
    return logger142.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex12(value) {
  if (typeof value !== "string") {
    return toHex12(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger142.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex12(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber12(value) {
  return BigNumber13.from(toHex12(value));
}
function toBN12(value) {
  const hex = BigNumber13.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN17("-" + hex.substring(3), 16);
  }
  return new BN17(hex.substring(2), 16);
}
function throwFault23(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger142.throwError(fault, Logger24.errors.NUMERIC_FAULT, params);
}

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger143 = new Logger24(version130);
var _constructorGuard27 = {};
var Zero27 = BigNumber13.from(0);
var NegativeOne27 = BigNumber13.from(-1);
function throwFault24(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger143.throwError(message, Logger24.errors.NUMERIC_FAULT, params);
}
var zeros12 = "0";
while (zeros12.length < 256) {
  zeros12 += zeros12;
}
function getMultiplier12(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber13.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros12.substring(0, decimals);
  }
  return logger143.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed13(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier12(decimals);
  value = BigNumber13.from(value);
  const negative = value.lt(Zero27);
  if (negative) {
    value = value.mul(NegativeOne27);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed13(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier12(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger143.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger143.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger143.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault24("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber13.from(whole);
  const fractionValue = BigNumber13.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne27);
  }
  return wei;
}
var FixedFormat12 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard27) {
      logger143.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger24.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier12(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat12) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger143.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger143.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger143.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger143.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat12(_constructorGuard27, signed, width, decimals);
  }
};
var FixedNumber12 = class {
  constructor(constructorGuard, hex, value, format) {
    logger143.checkNew(new.target, FixedNumber12);
    if (constructorGuard !== _constructorGuard27) {
      logger143.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger24.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger143.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed13(this._value, this.format.decimals);
    const b = parseFixed13(other._value, other.format.decimals);
    return FixedNumber12.fromValue(a.add(b), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed13(this._value, this.format.decimals);
    const b = parseFixed13(other._value, other.format.decimals);
    return FixedNumber12.fromValue(a.sub(b), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed13(this._value, this.format.decimals);
    const b = parseFixed13(other._value, other.format.decimals);
    return FixedNumber12.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed13(this._value, this.format.decimals);
    const b = parseFixed13(other._value, other.format.decimals);
    return FixedNumber12.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber12.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE12.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber12.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE12.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger143.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber12.from("1" + zeros12.substring(0, decimals), this.format);
    const bump = BUMP12.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger143.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber13.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad14(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber12.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish12(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber12.fromString(formatFixed13(value, decimals), FixedFormat12.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat12.from(format);
    const numeric = parseFixed13(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero27)) {
      throwFault24("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad14(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed13(numeric, fixedFormat.decimals);
    return new FixedNumber12(_constructorGuard27, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat12.from(format);
    if (arrayify21(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber13.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed13(numeric, fixedFormat.decimals);
    return new FixedNumber12(_constructorGuard27, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber12.fromString(value, format);
    }
    if (isBytes21(value)) {
      return FixedNumber12.fromBytes(value, format);
    }
    try {
      return FixedNumber12.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger24.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger143.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE12 = FixedNumber12.from(1);
var BUMP12 = FixedNumber12.from("0.5");

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne28 = BigNumber13.from(-1);
var Zero28 = BigNumber13.from(0);
var One16 = BigNumber13.from(1);
var Two10 = BigNumber13.from(2);
var WeiPerEther10 = BigNumber13.from("1000000000000000000");
var MaxUint25616 = BigNumber13.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt25610 = BigNumber13.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt25610 = BigNumber13.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version131 = "strings/5.6.0";

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger144 = new Logger24(version131);
var UnicodeNormalizationForm8;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm8 || (UnicodeNormalizationForm8 = {}));
var Utf8ErrorReason8;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason8 || (Utf8ErrorReason8 = {}));
function errorFunc8(reason, offset, bytes, output, badCodepoint) {
  return logger144.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc8(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason8.BAD_PREFIX || reason === Utf8ErrorReason8.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason8.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc8(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason8.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc8(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs8 = Object.freeze({
  error: errorFunc8,
  ignore: ignoreFunc8,
  replace: replaceFunc8
});
function getUtf8CodePoints5(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs8.error;
  }
  bytes = arrayify21(bytes);
  const result = [];
  let i = 0;
  while (i < bytes.length) {
    const c = bytes[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError(Utf8ErrorReason8.UNEXPECTED_CONTINUE, i - 1, bytes, result);
      } else {
        i += onError(Utf8ErrorReason8.BAD_PREFIX, i - 1, bytes, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes.length) {
      i += onError(Utf8ErrorReason8.OVERRUN, i - 1, bytes, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes[i];
      if ((nextChar & 192) != 128) {
        i += onError(Utf8ErrorReason8.MISSING_CONTINUE, i, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError(Utf8ErrorReason8.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError(Utf8ErrorReason8.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason8.OVERLONG, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes9(str, form = UnicodeNormalizationForm8.current) {
  if (form != UnicodeNormalizationForm8.current) {
    logger144.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify21(result);
}
function _toUtf8String8(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String8(bytes, onError) {
  return _toUtf8String8(getUtf8CodePoints5(bytes, onError));
}

// node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes28(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable8(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable8(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges8 = createRangeTable8("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags8 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
var Table_B_2_lut_abs8 = createTable8("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel8 = createTable8("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex8 = createTable8("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes28);
var Table_C_ranges8 = createRangeTable8("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/ethers/node_modules/@ethersproject/web/lib.esm/_version.js
init_define_process_env();
var version132 = "web/5.5.1";

// node_modules/ethers/node_modules/@ethersproject/web/lib.esm/geturl.js
init_define_process_env();
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl2(href, options) {
  return __awaiter20(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    ;
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key6) => {
        headers[key6.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key6) => {
        headers[key6.toLowerCase()] = response.headers.get(key6);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify21(new Uint8Array(body))
    };
  });
}

// node_modules/ethers/node_modules/@ethersproject/web/lib.esm/index.js
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger145 = new Logger24(version132);
function staller2(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify2(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike12(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String8(value);
      } catch (error) {
      }
      ;
    }
    return hexlify16(value);
  }
  return value;
}
function _fetchData2(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger145.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger145.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger145.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key6 in connection.headers) {
        headers[key6.toLowerCase()] = { key: key6, value: String(connection.headers[key6]) };
        if (["if-none-match", "if-modified-since"].indexOf(key6.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger145.throwError("basic authentication requires a secure https url", Logger24.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode17(toUtf8Bytes9(authorization))
      };
    }
  }
  const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] },
        body: decode8(dataMatch[2])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger145.throwError("processing response error", Logger24.errors.SERVER_ERROR, {
        body: bodyify2(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key6) => {
    const header = headers[key6];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger145.makeError("timeout", Logger24.errors.TIMEOUT, {
            requestBody: bodyify2(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter21(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl2(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location = response.headers.location || "";
              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall3 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall3 = parseInt(retryAfter) * 1e3;
                } else {
                  stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller2(stall3);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger145.throwError("missing response", Logger24.errors.SERVER_ERROR, {
              requestBody: bodyify2(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (response.statusCode < 200 || response.statusCode >= 300) {
          runningTimeout.cancel();
          logger145.throwError("bad response", Logger24.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify2(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify2(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller2(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger145.throwError("processing response error", Logger24.errors.SERVER_ERROR, {
              body: bodyify2(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify2(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger145.throwError("failed response", Logger24.errors.SERVER_ERROR, {
        requestBody: bodyify2(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson2(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String8(value));
      } catch (error) {
        logger145.throwError("invalid JSON", Logger24.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes9(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy10(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k) => k.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy10(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData2(connection, body, processJsonFunc);
}
function poll2(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy10(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer2 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check, timeout);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}

// node_modules/ethers/lib.esm/_version.js
init_define_process_env();
var version133 = "ethers/5.5.4";

// node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber2,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer2,
  VoidSigner: () => VoidSigner2,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports,
  errors: () => ErrorCode6,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger146,
  providers: () => lib_exports3,
  utils: () => utils_exports,
  version: () => version133,
  wordlists: () => wordlists
});
init_define_process_env();
var logger146 = new Logger7(version133);

// node_modules/ethers/lib.esm/index.js
init_define_process_env();
try {
  const anyGlobal4 = window;
  if (anyGlobal4._ethers == null) {
    anyGlobal4._ethers = ethers_exports;
  }
} catch (error) {
}

export {
  BaseContract,
  Contract,
  ContractFactory,
  BigNumber2 as BigNumber,
  FixedNumber,
  Signer2 as Signer,
  VoidSigner2 as VoidSigner,
  Wallet,
  verifyMessage,
  verifyTypedData,
  lib_exports,
  getDefaultProvider,
  lib_exports3 as lib_exports2,
  Wordlist,
  wordlists,
  ErrorCode6 as ErrorCode,
  pack2 as pack,
  keccak25610 as keccak256,
  sha2566 as sha256,
  commify,
  formatUnits,
  parseUnits,
  formatEther,
  parseEther,
  utils_exports,
  version133 as version,
  logger146 as logger,
  ethers_exports
};
//# sourceMappingURL=chunk-AAFDKQNN.js.map
