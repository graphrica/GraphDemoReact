"use strict";
import {
  _fetchData,
  fetchJson,
  getDefaultProvider,
  init_lib as init_lib22,
  init_lib2 as init_lib23,
  init_lib3 as init_lib24,
  lib_exports as lib_exports3,
  lib_exports2 as lib_exports4,
  poll
} from "./chunk-MDRYO75J.js";
import {
  HDNode,
  Wordlist,
  decryptJsonWallet,
  decryptJsonWalletSync,
  defaultPath,
  encrypt,
  entropyToMnemonic,
  getAccountPath,
  getJsonWalletAddress,
  init_lib as init_lib18,
  init_lib2 as init_lib19,
  init_lib3 as init_lib21,
  isValidMnemonic,
  mnemonicToEntropy,
  mnemonicToSeed,
  wordlists
} from "./chunk-YSJ6UD5Q.js";
import {
  AbiCoder,
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  FormatTypes,
  Fragment,
  FunctionFragment,
  Indexed,
  Interface,
  LogDescription,
  ParamType,
  TransactionDescription,
  checkResultErrors,
  defaultAbiCoder,
  init_lib as init_lib11
} from "./chunk-WBSSQYQH.js";
import {
  Base58,
  Provider,
  Signer,
  SupportedAlgorithm,
  VoidSigner,
  computeHmac,
  init_lib as init_lib12,
  init_lib2 as init_lib13,
  init_lib3 as init_lib16,
  init_lib4 as init_lib17,
  init_lib5 as init_lib20,
  randomBytes,
  ripemd160,
  sha256,
  sha512,
  shuffled
} from "./chunk-GZNO4Y3K.js";
import "./chunk-77TI47IA.js";
import "./chunk-DJCW4LVW.js";
import {
  SigningKey,
  TransactionTypes,
  accessListify,
  computeAddress,
  computePublicKey,
  init_lib as init_lib14,
  init_lib2 as init_lib15,
  parse,
  recoverAddress,
  recoverPublicKey,
  serialize
} from "./chunk-VFG3R5NB.js";
import {
  BigNumber,
  ErrorCode,
  FixedNumber,
  Logger,
  TypedDataEncoder,
  UnicodeNormalizationForm,
  Utf8ErrorFuncs,
  Utf8ErrorReason,
  _toEscapedUtf8String,
  arrayify,
  checkProperties,
  concat,
  deepCopy,
  defineReadOnly,
  dnsEncode,
  formatBytes32String,
  formatFixed,
  getAddress,
  getContractAddress,
  getCreate2Address,
  getIcapAddress,
  getStatic,
  hashMessage,
  hexConcat,
  hexDataLength,
  hexDataSlice,
  hexStripZeros,
  hexValue,
  hexZeroPad,
  hexlify,
  id,
  init_lib,
  init_lib10,
  init_lib2,
  init_lib3,
  init_lib4,
  init_lib5,
  init_lib6,
  init_lib7,
  init_lib8,
  init_lib9,
  isAddress,
  isBytes,
  isBytesLike,
  isHexString,
  isValidName,
  joinSignature,
  keccak256,
  lib_exports,
  lib_exports2,
  namehash,
  nameprep,
  parseBytes32String,
  parseFixed,
  resolveProperties,
  shallowCopy,
  splitSignature,
  stripZeros,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String,
  zeroPad
} from "./chunk-QLJNFGTT.js";
import "./chunk-HEQAI6WE.js";
import "./chunk-QMSD3UEV.js";
import "./chunk-27CSTQIU.js";
import "./chunk-VIQ6GMKA.js";
import "./chunk-PX4IM7JA.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// node_modules/@gnosis.pm/safe-apps-sdk/dist/package.json
var require_package = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/package.json"(exports, module) {
    module.exports = {
      name: "@gnosis.pm/safe-apps-sdk",
      version: "6.3.0",
      description: "SDK developed to integrate third-party apps with Safe app.",
      main: "dist/src/index.js",
      typings: "dist/src/index.d.ts",
      _files: [
        "dist/**/*",
        "README.md"
      ],
      keywords: [
        "Gnosis",
        "sdk",
        "apps"
      ],
      scripts: {
        test: "jest",
        "format-dist": `sed -i 's/"files":/"_files":/' dist/package.json`,
        build: "yarn rimraf dist && tsc && yarn format-dist",
        lint: "tslint -p tsconfig.json"
      },
      author: "Gnosis (https://gnosis.io)",
      license: "MIT",
      dependencies: {
        "@gnosis.pm/safe-react-gateway-sdk": "^2.8.5",
        ethers: "^5.4.7"
      },
      devDependencies: {
        rimraf: "^3.0.2"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/gnosis/safe-apps-sdk.git"
      },
      bugs: {
        url: "https://github.com/gnosis/safe-apps-sdk/issues"
      },
      homepage: "https://github.com/gnosis/safe-apps-sdk#readme",
      publishConfig: {
        access: "public"
      }
    };
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/utils.js
var require_utils = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/utils.js"(exports) {
    "use strict";
    init_define_process_env();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSDKVersion = void 0;
    var package_json_1 = __importDefault(require_package());
    var getSDKVersion = () => package_json_1.default.version.slice(0, 5);
    exports.getSDKVersion = getSDKVersion;
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/communication/utils.js
var require_utils2 = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/communication/utils.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateRequestId = void 0;
    var dec2hex = (dec) => dec.toString(16).padStart(2, "0");
    var generateId = (len) => {
      const arr = new Uint8Array((len || 40) / 2);
      window.crypto.getRandomValues(arr);
      return Array.from(arr, dec2hex).join("");
    };
    var generateRequestId = () => {
      if (typeof window !== "undefined") {
        return generateId(10);
      }
      return new Date().getTime().toString(36);
    };
    exports.generateRequestId = generateRequestId;
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/communication/messageFormatter.js
var require_messageFormatter = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/communication/messageFormatter.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageFormatter = void 0;
    var utils_1 = require_utils();
    var utils_2 = require_utils2();
    var MessageFormatter = class {
    };
    exports.MessageFormatter = MessageFormatter;
    MessageFormatter.makeRequest = (method, params) => {
      const id2 = (0, utils_2.generateRequestId)();
      return {
        id: id2,
        method,
        params,
        env: {
          sdkVersion: (0, utils_1.getSDKVersion)()
        }
      };
    };
    MessageFormatter.makeResponse = (id2, data, version6) => ({
      id: id2,
      success: true,
      version: version6,
      data
    });
    MessageFormatter.makeErrorResponse = (id2, error, version6) => ({
      id: id2,
      success: false,
      error,
      version: version6
    });
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/communication/methods.js
var require_methods = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/communication/methods.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Methods = void 0;
    var Methods;
    (function(Methods2) {
      Methods2["sendTransactions"] = "sendTransactions";
      Methods2["rpcCall"] = "rpcCall";
      Methods2["getChainInfo"] = "getChainInfo";
      Methods2["getSafeInfo"] = "getSafeInfo";
      Methods2["getTxBySafeTxHash"] = "getTxBySafeTxHash";
      Methods2["getSafeBalances"] = "getSafeBalances";
      Methods2["signMessage"] = "signMessage";
    })(Methods = exports.Methods || (exports.Methods = {}));
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/communication/index.js
var require_communication = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/communication/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var messageFormatter_1 = require_messageFormatter();
    var PostMessageCommunicator = class {
      constructor(allowedOrigins = null, debugMode = false) {
        this.allowedOrigins = null;
        this.callbacks = /* @__PURE__ */ new Map();
        this.debugMode = false;
        this.isValidMessage = ({ origin, data, source }) => {
          const emptyOrMalformed = !data;
          const sentFromParentEl = source === window.parent;
          const majorVersionNumber = typeof data.version !== "undefined" && parseInt(data.version.split(".")[0]);
          const allowedSDKVersion = majorVersionNumber >= 1;
          let validOrigin = true;
          if (Array.isArray(this.allowedOrigins)) {
            validOrigin = this.allowedOrigins.find((regExp) => regExp.test(origin)) !== void 0;
          }
          return !emptyOrMalformed && sentFromParentEl && allowedSDKVersion && validOrigin;
        };
        this.logIncomingMessage = (msg) => {
          console.info(`Safe Apps SDK v1: A message was received from origin ${msg.origin}. `, msg.data);
        };
        this.onParentMessage = (msg) => {
          if (this.isValidMessage(msg)) {
            this.debugMode && this.logIncomingMessage(msg);
            this.handleIncomingMessage(msg.data);
          }
        };
        this.handleIncomingMessage = (payload) => {
          const { id: id2 } = payload;
          const cb = this.callbacks.get(id2);
          if (cb) {
            cb(payload);
            this.callbacks.delete(id2);
          }
        };
        this.send = (method, params) => {
          const request = messageFormatter_1.MessageFormatter.makeRequest(method, params);
          if (typeof window === "undefined") {
            throw new Error("Window doesn't exist");
          }
          window.parent.postMessage(request, "*");
          return new Promise((resolve, reject) => {
            this.callbacks.set(request.id, (response) => {
              if (!response.success) {
                reject(new Error(response.error));
                return;
              }
              resolve(response);
            });
          });
        };
        this.allowedOrigins = allowedOrigins;
        this.debugMode = debugMode;
        window.addEventListener("message", this.onParentMessage);
      }
    };
    exports.default = PostMessageCommunicator;
    __exportStar(require_methods(), exports);
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/txs/index.js
var require_txs = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/txs/index.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TXs = void 0;
    var methods_1 = require_methods();
    var TXs = class {
      constructor(communicator) {
        this.communicator = communicator;
      }
      async getBySafeTxHash(safeTxHash) {
        if (!safeTxHash) {
          throw new Error("Invalid safeTxHash");
        }
        const response = await this.communicator.send(methods_1.Methods.getTxBySafeTxHash, { safeTxHash });
        return response.data;
      }
      async signMessage(message) {
        const messagePayload = {
          message
        };
        const response = await this.communicator.send(methods_1.Methods.signMessage, messagePayload);
        return response.data;
      }
      async send({ txs, params }) {
        if (!txs || !txs.length) {
          throw new Error("No transactions were passed");
        }
        const messagePayload = {
          txs,
          params
        };
        const response = await this.communicator.send(methods_1.Methods.sendTransactions, messagePayload);
        return response.data;
      }
    };
    exports.TXs = TXs;
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/eth/constants.js
var require_constants = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/eth/constants.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RPC_CALLS = void 0;
    exports.RPC_CALLS = {
      eth_call: "eth_call",
      eth_gasPrice: "eth_gasPrice",
      eth_getLogs: "eth_getLogs",
      eth_getBalance: "eth_getBalance",
      eth_getCode: "eth_getCode",
      eth_getBlockByHash: "eth_getBlockByHash",
      eth_getBlockByNumber: "eth_getBlockByNumber",
      eth_getStorageAt: "eth_getStorageAt",
      eth_getTransactionByHash: "eth_getTransactionByHash",
      eth_getTransactionReceipt: "eth_getTransactionReceipt",
      eth_getTransactionCount: "eth_getTransactionCount",
      eth_estimateGas: "eth_estimateGas"
    };
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/eth/index.js
var require_eth = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/eth/index.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Eth = void 0;
    var constants_1 = require_constants();
    var methods_1 = require_methods();
    var inputFormatters = {
      defaultBlockParam: (arg = "latest") => arg,
      returnFullTxObjectParam: (arg = false) => arg,
      blockNumberToHex: (arg) => Number.isInteger(arg) ? `0x${arg.toString(16)}` : arg
    };
    var Eth = class {
      constructor(communicator) {
        this.communicator = communicator;
        this.call = this.buildRequest({
          call: constants_1.RPC_CALLS.eth_call,
          formatters: [null, inputFormatters.defaultBlockParam]
        });
        this.getBalance = this.buildRequest({
          call: constants_1.RPC_CALLS.eth_getBalance,
          formatters: [null, inputFormatters.defaultBlockParam]
        });
        this.getCode = this.buildRequest({
          call: constants_1.RPC_CALLS.eth_getCode,
          formatters: [null, inputFormatters.defaultBlockParam]
        });
        this.getStorageAt = this.buildRequest({
          call: constants_1.RPC_CALLS.eth_getStorageAt,
          formatters: [null, inputFormatters.blockNumberToHex, inputFormatters.defaultBlockParam]
        });
        this.getPastLogs = this.buildRequest({
          call: constants_1.RPC_CALLS.eth_getLogs
        });
        this.getBlockByHash = this.buildRequest({
          call: constants_1.RPC_CALLS.eth_getBlockByHash,
          formatters: [null, inputFormatters.returnFullTxObjectParam]
        });
        this.getBlockByNumber = this.buildRequest({
          call: constants_1.RPC_CALLS.eth_getBlockByNumber,
          formatters: [inputFormatters.blockNumberToHex, inputFormatters.returnFullTxObjectParam]
        });
        this.getTransactionByHash = this.buildRequest({
          call: constants_1.RPC_CALLS.eth_getTransactionByHash
        });
        this.getTransactionReceipt = this.buildRequest({
          call: constants_1.RPC_CALLS.eth_getTransactionReceipt
        });
        this.getTransactionCount = this.buildRequest({
          call: constants_1.RPC_CALLS.eth_getTransactionCount,
          formatters: [null, inputFormatters.defaultBlockParam]
        });
        this.getGasPrice = this.buildRequest({
          call: constants_1.RPC_CALLS.eth_gasPrice
        });
        this.getEstimateGas = (transaction) => this.buildRequest({
          call: constants_1.RPC_CALLS.eth_estimateGas
        })([transaction]);
      }
      buildRequest(args) {
        const { call, formatters } = args;
        return async (params) => {
          if (formatters && Array.isArray(params)) {
            formatters.forEach((formatter, i) => {
              if (formatter) {
                params[i] = formatter(params[i]);
              }
            });
          }
          const payload = {
            call,
            params: params || []
          };
          const response = await this.communicator.send(methods_1.Methods.rpcCall, payload);
          return response.data;
        };
      }
    };
    exports.Eth = Eth;
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/lib.esm/_version.js
var version;
var init_version = __esm({
  "node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/lib.esm/_version.js"() {
    init_define_process_env();
    version = "contracts/5.6.0";
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/lib.esm/index.js
function resolveName(resolver, nameOrPromise) {
  return __awaiter(this, void 0, void 0, function* () {
    const name = yield nameOrPromise;
    if (typeof name !== "string") {
      logger.throwArgumentError("invalid address or ENS name", "name", name);
    }
    try {
      return getAddress(name);
    } catch (error) {
    }
    if (!resolver) {
      logger.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name);
    if (address == null) {
      logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes = arrayify(data);
      for (let i = 0; i < bytes.length; i++) {
        intrinsic += 4;
        if (bytes[i]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key) => overrides[key] != null);
    if (leftovers.length) {
      logger.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }
  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
var __awaiter, logger, allowedTransactionKeys, RunningEvent, ErrorRunningEvent, FragmentRunningEvent, WildcardRunningEvent, BaseContract, Contract, ContractFactory;
var init_lib25 = __esm({
  "node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/lib.esm/index.js"() {
    "use strict";
    init_define_process_env();
    init_lib11();
    init_lib12();
    init_lib13();
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib4();
    init_lib15();
    init_lib();
    init_version();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger = new Logger(version);
    allowedTransactionKeys = {
      chainId: true,
      data: true,
      from: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      value: true,
      type: true,
      accessList: true,
      maxFeePerGas: true,
      maxPriorityFeePerGas: true,
      customData: true,
      ccipReadEnabled: true
    };
    RunningEvent = class {
      constructor(tag, filter) {
        defineReadOnly(this, "tag", tag);
        defineReadOnly(this, "filter", filter);
        this._listeners = [];
      }
      addListener(listener, once) {
        this._listeners.push({ listener, once });
      }
      removeListener(listener) {
        let done = false;
        this._listeners = this._listeners.filter((item) => {
          if (done || item.listener !== listener) {
            return true;
          }
          done = true;
          return false;
        });
      }
      removeAllListeners() {
        this._listeners = [];
      }
      listeners() {
        return this._listeners.map((i) => i.listener);
      }
      listenerCount() {
        return this._listeners.length;
      }
      run(args) {
        const listenerCount = this.listenerCount();
        this._listeners = this._listeners.filter((item) => {
          const argsCopy = args.slice();
          setTimeout(() => {
            item.listener.apply(this, argsCopy);
          }, 0);
          return !item.once;
        });
        return listenerCount;
      }
      prepareEvent(event) {
      }
      getEmit(event) {
        return [event];
      }
    };
    ErrorRunningEvent = class extends RunningEvent {
      constructor() {
        super("error", null);
      }
    };
    FragmentRunningEvent = class extends RunningEvent {
      constructor(address, contractInterface, fragment, topics) {
        const filter = {
          address
        };
        let topic = contractInterface.getEventTopic(fragment);
        if (topics) {
          if (topic !== topics[0]) {
            logger.throwArgumentError("topic mismatch", "topics", topics);
          }
          filter.topics = topics.slice();
        } else {
          filter.topics = [topic];
        }
        super(getEventTag(filter), filter);
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
        defineReadOnly(this, "fragment", fragment);
      }
      prepareEvent(event) {
        super.prepareEvent(event);
        event.event = this.fragment.name;
        event.eventSignature = this.fragment.format();
        event.decode = (data, topics) => {
          return this.interface.decodeEventLog(this.fragment, data, topics);
        };
        try {
          event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
        } catch (error) {
          event.args = null;
          event.decodeError = error;
        }
      }
      getEmit(event) {
        const errors = checkResultErrors(event.args);
        if (errors.length) {
          throw errors[0].error;
        }
        const args = (event.args || []).slice();
        args.push(event);
        return args;
      }
    };
    WildcardRunningEvent = class extends RunningEvent {
      constructor(address, contractInterface) {
        super("*", { address });
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
      }
      prepareEvent(event) {
        super.prepareEvent(event);
        try {
          const parsed = this.interface.parseLog(event);
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
          event.decode = (data, topics) => {
            return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.args = parsed.args;
        } catch (error) {
        }
      }
    };
    BaseContract = class {
      constructor(addressOrName, contractInterface, signerOrProvider) {
        logger.checkNew(new.target, Contract);
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
        if (signerOrProvider == null) {
          defineReadOnly(this, "provider", null);
          defineReadOnly(this, "signer", null);
        } else if (Signer.isSigner(signerOrProvider)) {
          defineReadOnly(this, "provider", signerOrProvider.provider || null);
          defineReadOnly(this, "signer", signerOrProvider);
        } else if (Provider.isProvider(signerOrProvider)) {
          defineReadOnly(this, "provider", signerOrProvider);
          defineReadOnly(this, "signer", null);
        } else {
          logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
        }
        defineReadOnly(this, "callStatic", {});
        defineReadOnly(this, "estimateGas", {});
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "populateTransaction", {});
        defineReadOnly(this, "filters", {});
        {
          const uniqueFilters = {};
          Object.keys(this.interface.events).forEach((eventSignature) => {
            const event = this.interface.events[eventSignature];
            defineReadOnly(this.filters, eventSignature, (...args) => {
              return {
                address: this.address,
                topics: this.interface.encodeFilterTopics(event, args)
              };
            });
            if (!uniqueFilters[event.name]) {
              uniqueFilters[event.name] = [];
            }
            uniqueFilters[event.name].push(eventSignature);
          });
          Object.keys(uniqueFilters).forEach((name) => {
            const filters = uniqueFilters[name];
            if (filters.length === 1) {
              defineReadOnly(this.filters, name, this.filters[filters[0]]);
            } else {
              logger.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
            }
          });
        }
        defineReadOnly(this, "_runningEvents", {});
        defineReadOnly(this, "_wrappedEmits", {});
        if (addressOrName == null) {
          logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
        }
        defineReadOnly(this, "address", addressOrName);
        if (this.provider) {
          defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
        } else {
          try {
            defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
          } catch (error) {
            logger.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "new Contract"
            });
          }
        }
        this.resolvedAddress.catch((e) => {
        });
        const uniqueNames = {};
        const uniqueSignatures = {};
        Object.keys(this.interface.functions).forEach((signature) => {
          const fragment = this.interface.functions[signature];
          if (uniqueSignatures[signature]) {
            logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
            return;
          }
          uniqueSignatures[signature] = true;
          {
            const name = fragment.name;
            if (!uniqueNames[`%${name}`]) {
              uniqueNames[`%${name}`] = [];
            }
            uniqueNames[`%${name}`].push(signature);
          }
          if (this[signature] == null) {
            defineReadOnly(this, signature, buildDefault(this, fragment, true));
          }
          if (this.functions[signature] == null) {
            defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));
          }
          if (this.callStatic[signature] == null) {
            defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));
          }
          if (this.populateTransaction[signature] == null) {
            defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));
          }
          if (this.estimateGas[signature] == null) {
            defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));
          }
        });
        Object.keys(uniqueNames).forEach((name) => {
          const signatures = uniqueNames[name];
          if (signatures.length > 1) {
            return;
          }
          name = name.substring(1);
          const signature = signatures[0];
          try {
            if (this[name] == null) {
              defineReadOnly(this, name, this[signature]);
            }
          } catch (e) {
          }
          if (this.functions[name] == null) {
            defineReadOnly(this.functions, name, this.functions[signature]);
          }
          if (this.callStatic[name] == null) {
            defineReadOnly(this.callStatic, name, this.callStatic[signature]);
          }
          if (this.populateTransaction[name] == null) {
            defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);
          }
          if (this.estimateGas[name] == null) {
            defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);
          }
        });
      }
      static getContractAddress(transaction) {
        return getContractAddress(transaction);
      }
      static getInterface(contractInterface) {
        if (Interface.isInterface(contractInterface)) {
          return contractInterface;
        }
        return new Interface(contractInterface);
      }
      deployed() {
        return this._deployed();
      }
      _deployed(blockTag) {
        if (!this._deployedPromise) {
          if (this.deployTransaction) {
            this._deployedPromise = this.deployTransaction.wait().then(() => {
              return this;
            });
          } else {
            this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
              if (code === "0x") {
                logger.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
                  contractAddress: this.address,
                  operation: "getDeployed"
                });
              }
              return this;
            });
          }
        }
        return this._deployedPromise;
      }
      fallback(overrides) {
        if (!this.signer) {
          logger.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
        }
        const tx = shallowCopy(overrides || {});
        ["from", "to"].forEach(function(key) {
          if (tx[key] == null) {
            return;
          }
          logger.throwError("cannot override " + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        tx.to = this.resolvedAddress;
        return this.deployed().then(() => {
          return this.signer.sendTransaction(tx);
        });
      }
      connect(signerOrProvider) {
        if (typeof signerOrProvider === "string") {
          signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
        }
        const contract = new this.constructor(this.address, this.interface, signerOrProvider);
        if (this.deployTransaction) {
          defineReadOnly(contract, "deployTransaction", this.deployTransaction);
        }
        return contract;
      }
      attach(addressOrName) {
        return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
      }
      static isIndexed(value) {
        return Indexed.isIndexed(value);
      }
      _normalizeRunningEvent(runningEvent) {
        if (this._runningEvents[runningEvent.tag]) {
          return this._runningEvents[runningEvent.tag];
        }
        return runningEvent;
      }
      _getRunningEvent(eventName) {
        if (typeof eventName === "string") {
          if (eventName === "error") {
            return this._normalizeRunningEvent(new ErrorRunningEvent());
          }
          if (eventName === "event") {
            return this._normalizeRunningEvent(new RunningEvent("event", null));
          }
          if (eventName === "*") {
            return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
          }
          const fragment = this.interface.getEvent(eventName);
          return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
        }
        if (eventName.topics && eventName.topics.length > 0) {
          try {
            const topic = eventName.topics[0];
            if (typeof topic !== "string") {
              throw new Error("invalid topic");
            }
            const fragment = this.interface.getEvent(topic);
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
          } catch (error) {
          }
          const filter = {
            address: this.address,
            topics: eventName.topics
          };
          return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      _checkRunningEvents(runningEvent) {
        if (runningEvent.listenerCount() === 0) {
          delete this._runningEvents[runningEvent.tag];
          const emit = this._wrappedEmits[runningEvent.tag];
          if (emit && runningEvent.filter) {
            this.provider.off(runningEvent.filter, emit);
            delete this._wrappedEmits[runningEvent.tag];
          }
        }
      }
      _wrapEvent(runningEvent, log, listener) {
        const event = deepCopy(log);
        event.removeListener = () => {
          if (!listener) {
            return;
          }
          runningEvent.removeListener(listener);
          this._checkRunningEvents(runningEvent);
        };
        event.getBlock = () => {
          return this.provider.getBlock(log.blockHash);
        };
        event.getTransaction = () => {
          return this.provider.getTransaction(log.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return this.provider.getTransactionReceipt(log.transactionHash);
        };
        runningEvent.prepareEvent(event);
        return event;
      }
      _addEventListener(runningEvent, listener, once) {
        if (!this.provider) {
          logger.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
        }
        runningEvent.addListener(listener, once);
        this._runningEvents[runningEvent.tag] = runningEvent;
        if (!this._wrappedEmits[runningEvent.tag]) {
          const wrappedEmit = (log) => {
            let event = this._wrapEvent(runningEvent, log, listener);
            if (event.decodeError == null) {
              try {
                const args = runningEvent.getEmit(event);
                this.emit(runningEvent.filter, ...args);
              } catch (error) {
                event.decodeError = error.error;
              }
            }
            if (runningEvent.filter != null) {
              this.emit("event", event);
            }
            if (event.decodeError != null) {
              this.emit("error", event.decodeError, event);
            }
          };
          this._wrappedEmits[runningEvent.tag] = wrappedEmit;
          if (runningEvent.filter != null) {
            this.provider.on(runningEvent.filter, wrappedEmit);
          }
        }
      }
      queryFilter(event, fromBlockOrBlockhash, toBlock) {
        const runningEvent = this._getRunningEvent(event);
        const filter = shallowCopy(runningEvent.filter);
        if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
          if (toBlock != null) {
            logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
          }
          filter.blockHash = fromBlockOrBlockhash;
        } else {
          filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
          filter.toBlock = toBlock != null ? toBlock : "latest";
        }
        return this.provider.getLogs(filter).then((logs) => {
          return logs.map((log) => this._wrapEvent(runningEvent, log, null));
        });
      }
      on(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, false);
        return this;
      }
      once(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, true);
        return this;
      }
      emit(eventName, ...args) {
        if (!this.provider) {
          return false;
        }
        const runningEvent = this._getRunningEvent(eventName);
        const result = runningEvent.run(args) > 0;
        this._checkRunningEvents(runningEvent);
        return result;
      }
      listenerCount(eventName) {
        if (!this.provider) {
          return 0;
        }
        if (eventName == null) {
          return Object.keys(this._runningEvents).reduce((accum, key) => {
            return accum + this._runningEvents[key].listenerCount();
          }, 0);
        }
        return this._getRunningEvent(eventName).listenerCount();
      }
      listeners(eventName) {
        if (!this.provider) {
          return [];
        }
        if (eventName == null) {
          const result = [];
          for (let tag in this._runningEvents) {
            this._runningEvents[tag].listeners().forEach((listener) => {
              result.push(listener);
            });
          }
          return result;
        }
        return this._getRunningEvent(eventName).listeners();
      }
      removeAllListeners(eventName) {
        if (!this.provider) {
          return this;
        }
        if (eventName == null) {
          for (const tag in this._runningEvents) {
            const runningEvent2 = this._runningEvents[tag];
            runningEvent2.removeAllListeners();
            this._checkRunningEvents(runningEvent2);
          }
          return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
        return this;
      }
      off(eventName, listener) {
        if (!this.provider) {
          return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
        return this;
      }
      removeListener(eventName, listener) {
        return this.off(eventName, listener);
      }
    };
    Contract = class extends BaseContract {
    };
    ContractFactory = class {
      constructor(contractInterface, bytecode, signer) {
        let bytecodeHex = null;
        if (typeof bytecode === "string") {
          bytecodeHex = bytecode;
        } else if (isBytes(bytecode)) {
          bytecodeHex = hexlify(bytecode);
        } else if (bytecode && typeof bytecode.object === "string") {
          bytecodeHex = bytecode.object;
        } else {
          bytecodeHex = "!";
        }
        if (bytecodeHex.substring(0, 2) !== "0x") {
          bytecodeHex = "0x" + bytecodeHex;
        }
        if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
          logger.throwArgumentError("invalid bytecode", "bytecode", bytecode);
        }
        if (signer && !Signer.isSigner(signer)) {
          logger.throwArgumentError("invalid signer", "signer", signer);
        }
        defineReadOnly(this, "bytecode", bytecodeHex);
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
        defineReadOnly(this, "signer", signer || null);
      }
      getDeployTransaction(...args) {
        let tx = {};
        if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
          tx = shallowCopy(args.pop());
          for (const key in tx) {
            if (!allowedTransactionKeys[key]) {
              throw new Error("unknown transaction override " + key);
            }
          }
        }
        ["data", "from", "to"].forEach((key) => {
          if (tx[key] == null) {
            return;
          }
          logger.throwError("cannot override " + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        if (tx.value) {
          const value = BigNumber.from(tx.value);
          if (!value.isZero() && !this.interface.deploy.payable) {
            logger.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.value",
              value: tx.value
            });
          }
        }
        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        tx.data = hexlify(concat([
          this.bytecode,
          this.interface.encodeDeploy(args)
        ]));
        return tx;
      }
      deploy(...args) {
        return __awaiter(this, void 0, void 0, function* () {
          let overrides = {};
          if (args.length === this.interface.deploy.inputs.length + 1) {
            overrides = args.pop();
          }
          logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
          const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
          params.push(overrides);
          const unsignedTx = this.getDeployTransaction(...params);
          const tx = yield this.signer.sendTransaction(unsignedTx);
          const address = getStatic(this.constructor, "getContractAddress")(tx);
          const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
          addContractWait(contract, tx);
          defineReadOnly(contract, "deployTransaction", tx);
          return contract;
        });
      }
      attach(address) {
        return this.constructor.getContract(address, this.interface, this.signer);
      }
      connect(signer) {
        return new this.constructor(this.interface, this.bytecode, signer);
      }
      static fromSolidity(compilerOutput, signer) {
        if (compilerOutput == null) {
          logger.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
        }
        if (typeof compilerOutput === "string") {
          compilerOutput = JSON.parse(compilerOutput);
        }
        const abi = compilerOutput.abi;
        let bytecode = null;
        if (compilerOutput.bytecode) {
          bytecode = compilerOutput.bytecode;
        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
          bytecode = compilerOutput.evm.bytecode;
        }
        return new this(abi, bytecode, signer);
      }
      static getInterface(contractInterface) {
        return Contract.getInterface(contractInterface);
      }
      static getContractAddress(tx) {
        return getContractAddress(tx);
      }
      static getContract(address, contractInterface, signer) {
        return new Contract(address, contractInterface, signer);
      }
    };
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/lib.esm/_version.js
var version2;
var init_version2 = __esm({
  "node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/lib.esm/_version.js"() {
    init_define_process_env();
    version2 = "wallet/5.6.0";
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/lib.esm/index.js
function isAccount(value) {
  return value != null && isHexString(value.privateKey, 32) && value.address != null;
}
function hasMnemonic(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
function verifyMessage(message, signature) {
  return recoverAddress(hashMessage(message), signature);
}
function verifyTypedData(domain, types, value, signature) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);
}
var __awaiter2, logger2, Wallet;
var init_lib26 = __esm({
  "node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/lib.esm/index.js"() {
    "use strict";
    init_define_process_env();
    init_lib7();
    init_lib12();
    init_lib13();
    init_lib2();
    init_lib10();
    init_lib19();
    init_lib5();
    init_lib4();
    init_lib20();
    init_lib14();
    init_lib21();
    init_lib15();
    init_lib();
    init_version2();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger2 = new Logger(version2);
    Wallet = class extends Signer {
      constructor(privateKey, provider) {
        logger2.checkNew(new.target, Wallet);
        super();
        if (isAccount(privateKey)) {
          const signingKey = new SigningKey(privateKey.privateKey);
          defineReadOnly(this, "_signingKey", () => signingKey);
          defineReadOnly(this, "address", computeAddress(this.publicKey));
          if (this.address !== getAddress(privateKey.address)) {
            logger2.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
          }
          if (hasMnemonic(privateKey)) {
            const srcMnemonic = privateKey.mnemonic;
            defineReadOnly(this, "_mnemonic", () => ({
              phrase: srcMnemonic.phrase,
              path: srcMnemonic.path || defaultPath,
              locale: srcMnemonic.locale || "en"
            }));
            const mnemonic = this.mnemonic;
            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
            if (computeAddress(node.privateKey) !== this.address) {
              logger2.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
            }
          } else {
            defineReadOnly(this, "_mnemonic", () => null);
          }
        } else {
          if (SigningKey.isSigningKey(privateKey)) {
            if (privateKey.curve !== "secp256k1") {
              logger2.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
            }
            defineReadOnly(this, "_signingKey", () => privateKey);
          } else {
            if (typeof privateKey === "string") {
              if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                privateKey = "0x" + privateKey;
              }
            }
            const signingKey = new SigningKey(privateKey);
            defineReadOnly(this, "_signingKey", () => signingKey);
          }
          defineReadOnly(this, "_mnemonic", () => null);
          defineReadOnly(this, "address", computeAddress(this.publicKey));
        }
        if (provider && !Provider.isProvider(provider)) {
          logger2.throwArgumentError("invalid provider", "provider", provider);
        }
        defineReadOnly(this, "provider", provider || null);
      }
      get mnemonic() {
        return this._mnemonic();
      }
      get privateKey() {
        return this._signingKey().privateKey;
      }
      get publicKey() {
        return this._signingKey().publicKey;
      }
      getAddress() {
        return Promise.resolve(this.address);
      }
      connect(provider) {
        return new Wallet(this, provider);
      }
      signTransaction(transaction) {
        return resolveProperties(transaction).then((tx) => {
          if (tx.from != null) {
            if (getAddress(tx.from) !== this.address) {
              logger2.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
            }
            delete tx.from;
          }
          const signature = this._signingKey().signDigest(keccak256(serialize(tx)));
          return serialize(tx, signature);
        });
      }
      signMessage(message) {
        return __awaiter2(this, void 0, void 0, function* () {
          return joinSignature(this._signingKey().signDigest(hashMessage(message)));
        });
      }
      _signTypedData(domain, types, value) {
        return __awaiter2(this, void 0, void 0, function* () {
          const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name) => {
            if (this.provider == null) {
              logger2.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName",
                value: name
              });
            }
            return this.provider.resolveName(name);
          });
          return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
        });
      }
      encrypt(password, options, progressCallback) {
        if (typeof options === "function" && !progressCallback) {
          progressCallback = options;
          options = {};
        }
        if (progressCallback && typeof progressCallback !== "function") {
          throw new Error("invalid callback");
        }
        if (!options) {
          options = {};
        }
        return encrypt(this, password, options, progressCallback);
      }
      static createRandom(options) {
        let entropy = randomBytes(16);
        if (!options) {
          options = {};
        }
        if (options.extraEntropy) {
          entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));
        }
        const mnemonic = entropyToMnemonic(entropy, options.locale);
        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
      }
      static fromEncryptedJson(json, password, progressCallback) {
        return decryptJsonWallet(json, password, progressCallback).then((account) => {
          return new Wallet(account);
        });
      }
      static fromEncryptedJsonSync(json, password) {
        return new Wallet(decryptJsonWalletSync(json, password));
      }
      static fromMnemonic(mnemonic, path, wordlist) {
        if (!path) {
          path = defaultPath;
        }
        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));
      }
    };
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/lib.esm/_version.js
var version3;
var init_version3 = __esm({
  "node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/lib.esm/_version.js"() {
    init_define_process_env();
    version3 = "solidity/5.6.0";
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/lib.esm/index.js
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger3.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray) {
      size = 256;
    }
    value = BigNumber.from(value).toTwos(size);
    return zeroPad(value, size / 8);
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    if (String(size) !== match[1] || size === 0 || size > 32) {
      logger3.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size) {
      logger3.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray) {
      return arrayify((value + Zeros).substring(0, 66));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    if (count != value.length) {
      logger3.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat(result);
  }
  return logger3.throwArgumentError("invalid type", "type", type);
}
function pack(types, values) {
  if (types.length != values.length) {
    logger3.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function keccak2562(types, values) {
  return keccak256(pack(types, values));
}
function sha2562(types, values) {
  return sha256(pack(types, values));
}
var regexBytes, regexNumber, regexArray, Zeros, logger3;
var init_lib27 = __esm({
  "node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/lib.esm/index.js"() {
    "use strict";
    init_define_process_env();
    init_lib3();
    init_lib2();
    init_lib5();
    init_lib17();
    init_lib9();
    init_lib();
    init_version3();
    regexBytes = new RegExp("^bytes([0-9]+)$");
    regexNumber = new RegExp("^(u?int)([0-9]*)$");
    regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
    Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
    logger3 = new Logger(version3);
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/lib.esm/_version.js
var version4;
var init_version4 = __esm({
  "node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/lib.esm/_version.js"() {
    init_define_process_env();
    version4 = "units/5.6.0";
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/lib.esm/index.js
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger4.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger4.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
var logger4, names;
var init_lib28 = __esm({
  "node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/lib.esm/index.js"() {
    "use strict";
    init_define_process_env();
    init_lib3();
    init_lib();
    init_version4();
    logger4 = new Logger(version4);
    names = [
      "wei",
      "kwei",
      "mwei",
      "gwei",
      "szabo",
      "finney",
      "ether"
    ];
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  Logger: () => Logger,
  ParamType: () => ParamType,
  RLP: () => lib_exports,
  SigningKey: () => SigningKey,
  SupportedAlgorithm: () => SupportedAlgorithm,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _TypedDataEncoder: () => TypedDataEncoder,
  _fetchData: () => _fetchData,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  accessListify: () => accessListify,
  arrayify: () => arrayify,
  base58: () => Base58,
  base64: () => lib_exports3,
  checkProperties: () => checkProperties,
  checkResultErrors: () => checkResultErrors,
  commify: () => commify,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  computePublicKey: () => computePublicKey,
  concat: () => concat,
  deepCopy: () => deepCopy,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath,
  defineReadOnly: () => defineReadOnly,
  dnsEncode: () => dnsEncode,
  entropyToMnemonic: () => entropyToMnemonic,
  fetchJson: () => fetchJson,
  formatBytes32String: () => formatBytes32String,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic,
  hashMessage: () => hashMessage,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName,
  joinSignature: () => joinSignature,
  keccak256: () => keccak256,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  parseEther: () => parseEther,
  parseTransaction: () => parse,
  parseUnits: () => parseUnits,
  poll: () => poll,
  randomBytes: () => randomBytes,
  recoverAddress: () => recoverAddress,
  recoverPublicKey: () => recoverPublicKey,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd160,
  serializeTransaction: () => serialize,
  sha256: () => sha256,
  sha512: () => sha512,
  shallowCopy: () => shallowCopy,
  shuffled: () => shuffled,
  solidityKeccak256: () => keccak2562,
  solidityPack: () => pack,
  soliditySha256: () => sha2562,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad
});
var init_utils = __esm({
  "node_modules/@gnosis.pm/safe-apps-sdk/node_modules/ethers/lib.esm/utils.js"() {
    "use strict";
    init_define_process_env();
    init_lib11();
    init_lib7();
    init_lib22();
    init_lib16();
    init_lib2();
    init_lib10();
    init_lib19();
    init_lib21();
    init_lib5();
    init_lib();
    init_lib17();
    init_lib27();
    init_lib20();
    init_lib4();
    init_lib6();
    init_lib14();
    init_lib9();
    init_lib15();
    init_lib28();
    init_lib26();
    init_lib23();
    init_lib17();
    init_lib9();
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/node_modules/ethers/lib.esm/_version.js
var version5;
var init_version5 = __esm({
  "node_modules/@gnosis.pm/safe-apps-sdk/node_modules/ethers/lib.esm/_version.js"() {
    init_define_process_env();
    version5 = "ethers/5.6.2";
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports2,
  errors: () => ErrorCode,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger5,
  providers: () => lib_exports4,
  utils: () => utils_exports,
  version: () => version5,
  wordlists: () => wordlists
});
var logger5;
var init_ethers = __esm({
  "node_modules/@gnosis.pm/safe-apps-sdk/node_modules/ethers/lib.esm/ethers.js"() {
    "use strict";
    init_define_process_env();
    init_lib25();
    init_lib3();
    init_lib13();
    init_lib26();
    init_lib8();
    init_lib24();
    init_lib24();
    init_lib18();
    init_utils();
    init_lib();
    init_version5();
    logger5 = new Logger(version5);
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/node_modules/ethers/lib.esm/index.js
var lib_exports5 = {};
__export(lib_exports5, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports2,
  errors: () => ErrorCode,
  ethers: () => ethers_exports,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger5,
  providers: () => lib_exports4,
  utils: () => utils_exports,
  version: () => version5,
  wordlists: () => wordlists
});
var init_lib29 = __esm({
  "node_modules/@gnosis.pm/safe-apps-sdk/node_modules/ethers/lib.esm/index.js"() {
    "use strict";
    init_define_process_env();
    init_ethers();
    init_ethers();
    try {
      const anyGlobal = window;
      if (anyGlobal._ethers == null) {
        anyGlobal._ethers = ethers_exports;
      }
    } catch (error) {
    }
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/safe/signatures.js
var require_signatures = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/safe/signatures.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MAGIC_VALUE_BYTES = exports.MAGIC_VALUE = exports.EIP_1271_BYTES_INTERFACE = exports.EIP_1271_INTERFACE = void 0;
    var ethers_1 = (init_lib29(), __toCommonJS(lib_exports5));
    var MAGIC_VALUE = "0x1626ba7e";
    exports.MAGIC_VALUE = MAGIC_VALUE;
    var MAGIC_VALUE_BYTES = "0x20c13b0b";
    exports.MAGIC_VALUE_BYTES = MAGIC_VALUE_BYTES;
    var EIP_1271_INTERFACE = new ethers_1.ethers.utils.Interface([
      "function isValidSignature(bytes32 _dataHash, bytes calldata _signature) external view"
    ]);
    exports.EIP_1271_INTERFACE = EIP_1271_INTERFACE;
    var EIP_1271_BYTES_INTERFACE = new ethers_1.ethers.utils.Interface([
      "function isValidSignature(bytes calldata _data, bytes calldata _signature) public view"
    ]);
    exports.EIP_1271_BYTES_INTERFACE = EIP_1271_BYTES_INTERFACE;
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/safe/index.js
var require_safe = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/safe/index.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Safe = void 0;
    var ethers_1 = (init_lib29(), __toCommonJS(lib_exports5));
    var signatures_1 = require_signatures();
    var methods_1 = require_methods();
    var constants_1 = require_constants();
    var Safe = class {
      constructor(communicator) {
        this.communicator = communicator;
      }
      async getChainInfo() {
        const response = await this.communicator.send(methods_1.Methods.getChainInfo, void 0);
        return response.data;
      }
      async getInfo() {
        const response = await this.communicator.send(methods_1.Methods.getSafeInfo, void 0);
        return response.data;
      }
      async experimental_getBalances({ currency = "usd" } = {}) {
        const response = await this.communicator.send(methods_1.Methods.getSafeBalances, {
          currency
        });
        return response.data;
      }
      async check1271Signature(messageHash, signature = "0x") {
        const safeInfo = await this.getInfo();
        const encodedIsValidSignatureCall = signatures_1.EIP_1271_INTERFACE.encodeFunctionData("isValidSignature", [
          messageHash,
          signature
        ]);
        const payload = {
          call: constants_1.RPC_CALLS.eth_call,
          params: [
            {
              to: safeInfo.safeAddress,
              data: encodedIsValidSignatureCall
            },
            "latest"
          ]
        };
        try {
          const response = await this.communicator.send(methods_1.Methods.rpcCall, payload);
          return response.data.slice(0, 10).toLowerCase() === signatures_1.MAGIC_VALUE;
        } catch (err) {
          return false;
        }
      }
      async check1271SignatureBytes(messageHash, signature = "0x") {
        const safeInfo = await this.getInfo();
        const msgBytes = ethers_1.ethers.utils.arrayify(messageHash);
        const encodedIsValidSignatureCall = signatures_1.EIP_1271_BYTES_INTERFACE.encodeFunctionData("isValidSignature", [
          msgBytes,
          signature
        ]);
        const payload = {
          call: constants_1.RPC_CALLS.eth_call,
          params: [
            {
              to: safeInfo.safeAddress,
              data: encodedIsValidSignatureCall
            },
            "latest"
          ]
        };
        try {
          const response = await this.communicator.send(methods_1.Methods.rpcCall, payload);
          return response.data.slice(0, 10).toLowerCase() === signatures_1.MAGIC_VALUE_BYTES;
        } catch (err) {
          return false;
        }
      }
      calculateMessageHash(message) {
        return ethers_1.ethers.utils.hashMessage(message);
      }
      async isMessageSigned(message, signature = "0x") {
        const messageHash = this.calculateMessageHash(message);
        const messageHashSigned = await this.isMessageHashSigned(messageHash, signature);
        return messageHashSigned;
      }
      async isMessageHashSigned(messageHash, signature = "0x") {
        const checks = [this.check1271Signature.bind(this), this.check1271SignatureBytes.bind(this)];
        for (const check of checks) {
          const isValid = await check(messageHash, signature);
          if (isValid) {
            return true;
          }
        }
        return false;
      }
    };
    exports.Safe = Safe;
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/sdk.js
var require_sdk = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/sdk.js"(exports) {
    "use strict";
    init_define_process_env();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var communication_1 = __importDefault(require_communication());
    var txs_1 = require_txs();
    var eth_1 = require_eth();
    var safe_1 = require_safe();
    var SafeAppsSDK = class {
      constructor(opts = {}) {
        const { whitelistedDomains = null, debug = false } = opts;
        this.communicator = new communication_1.default(whitelistedDomains, debug);
        this.eth = new eth_1.Eth(this.communicator);
        this.txs = new txs_1.TXs(this.communicator);
        this.safe = new safe_1.Safe(this.communicator);
      }
    };
    exports.default = SafeAppsSDK;
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/types/sdk.js
var require_sdk2 = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/types/sdk.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/types/rpc.js
var require_rpc = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/types/rpc.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@gnosis.pm/safe-react-gateway-sdk/dist/index.min.js
var require_index_min = __commonJS({
  "node_modules/@gnosis.pm/safe-react-gateway-sdk/dist/index.min.js"(exports, module) {
    init_define_process_env();
    !function(t, e) {
      typeof exports == "object" && typeof module == "object" ? module.exports = e() : typeof define == "function" && define.amd ? define([], e) : typeof exports == "object" ? exports['"@gnosis.pm/safe-react-gateway-sdk"'] = e() : t['"@gnosis.pm/safe-react-gateway-sdk"'] = e();
    }(exports, function() {
      return (() => {
        var t = { 98: function(t2, e2) {
          var r2 = typeof self != "undefined" ? self : this, n2 = function() {
            function t3() {
              this.fetch = false, this.DOMException = r2.DOMException;
            }
            return t3.prototype = r2, new t3();
          }();
          !function(t3) {
            !function(e3) {
              var r3 = "URLSearchParams" in t3, n3 = "Symbol" in t3 && "iterator" in Symbol, o2 = "FileReader" in t3 && "Blob" in t3 && function() {
                try {
                  return new Blob(), true;
                } catch (t4) {
                  return false;
                }
              }(), i = "FormData" in t3, s = "ArrayBuffer" in t3;
              if (s)
                var a = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], c = ArrayBuffer.isView || function(t4) {
                  return t4 && a.indexOf(Object.prototype.toString.call(t4)) > -1;
                };
              function u(t4) {
                if (typeof t4 != "string" && (t4 = String(t4)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t4))
                  throw new TypeError("Invalid character in header field name");
                return t4.toLowerCase();
              }
              function f(t4) {
                return typeof t4 != "string" && (t4 = String(t4)), t4;
              }
              function d(t4) {
                var e4 = { next: function() {
                  var e5 = t4.shift();
                  return { done: e5 === void 0, value: e5 };
                } };
                return n3 && (e4[Symbol.iterator] = function() {
                  return e4;
                }), e4;
              }
              function h(t4) {
                this.map = {}, t4 instanceof h ? t4.forEach(function(t5, e4) {
                  this.append(e4, t5);
                }, this) : Array.isArray(t4) ? t4.forEach(function(t5) {
                  this.append(t5[0], t5[1]);
                }, this) : t4 && Object.getOwnPropertyNames(t4).forEach(function(e4) {
                  this.append(e4, t4[e4]);
                }, this);
              }
              function p(t4) {
                if (t4.bodyUsed)
                  return Promise.reject(new TypeError("Already read"));
                t4.bodyUsed = true;
              }
              function l(t4) {
                return new Promise(function(e4, r4) {
                  t4.onload = function() {
                    e4(t4.result);
                  }, t4.onerror = function() {
                    r4(t4.error);
                  };
                });
              }
              function y(t4) {
                var e4 = new FileReader(), r4 = l(e4);
                return e4.readAsArrayBuffer(t4), r4;
              }
              function b(t4) {
                if (t4.slice)
                  return t4.slice(0);
                var e4 = new Uint8Array(t4.byteLength);
                return e4.set(new Uint8Array(t4)), e4.buffer;
              }
              function E() {
                return this.bodyUsed = false, this._initBody = function(t4) {
                  var e4;
                  this._bodyInit = t4, t4 ? typeof t4 == "string" ? this._bodyText = t4 : o2 && Blob.prototype.isPrototypeOf(t4) ? this._bodyBlob = t4 : i && FormData.prototype.isPrototypeOf(t4) ? this._bodyFormData = t4 : r3 && URLSearchParams.prototype.isPrototypeOf(t4) ? this._bodyText = t4.toString() : s && o2 && (e4 = t4) && DataView.prototype.isPrototypeOf(e4) ? (this._bodyArrayBuffer = b(t4.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : s && (ArrayBuffer.prototype.isPrototypeOf(t4) || c(t4)) ? this._bodyArrayBuffer = b(t4) : this._bodyText = t4 = Object.prototype.toString.call(t4) : this._bodyText = "", this.headers.get("content-type") || (typeof t4 == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : r3 && URLSearchParams.prototype.isPrototypeOf(t4) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
                }, o2 && (this.blob = function() {
                  var t4 = p(this);
                  if (t4)
                    return t4;
                  if (this._bodyBlob)
                    return Promise.resolve(this._bodyBlob);
                  if (this._bodyArrayBuffer)
                    return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                  if (this._bodyFormData)
                    throw new Error("could not read FormData body as blob");
                  return Promise.resolve(new Blob([this._bodyText]));
                }, this.arrayBuffer = function() {
                  return this._bodyArrayBuffer ? p(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(y);
                }), this.text = function() {
                  var t4, e4, r4, n4 = p(this);
                  if (n4)
                    return n4;
                  if (this._bodyBlob)
                    return t4 = this._bodyBlob, r4 = l(e4 = new FileReader()), e4.readAsText(t4), r4;
                  if (this._bodyArrayBuffer)
                    return Promise.resolve(function(t5) {
                      for (var e5 = new Uint8Array(t5), r5 = new Array(e5.length), n5 = 0; n5 < e5.length; n5++)
                        r5[n5] = String.fromCharCode(e5[n5]);
                      return r5.join("");
                    }(this._bodyArrayBuffer));
                  if (this._bodyFormData)
                    throw new Error("could not read FormData body as text");
                  return Promise.resolve(this._bodyText);
                }, i && (this.formData = function() {
                  return this.text().then(T);
                }), this.json = function() {
                  return this.text().then(JSON.parse);
                }, this;
              }
              h.prototype.append = function(t4, e4) {
                t4 = u(t4), e4 = f(e4);
                var r4 = this.map[t4];
                this.map[t4] = r4 ? r4 + ", " + e4 : e4;
              }, h.prototype.delete = function(t4) {
                delete this.map[u(t4)];
              }, h.prototype.get = function(t4) {
                return t4 = u(t4), this.has(t4) ? this.map[t4] : null;
              }, h.prototype.has = function(t4) {
                return this.map.hasOwnProperty(u(t4));
              }, h.prototype.set = function(t4, e4) {
                this.map[u(t4)] = f(e4);
              }, h.prototype.forEach = function(t4, e4) {
                for (var r4 in this.map)
                  this.map.hasOwnProperty(r4) && t4.call(e4, this.map[r4], r4, this);
              }, h.prototype.keys = function() {
                var t4 = [];
                return this.forEach(function(e4, r4) {
                  t4.push(r4);
                }), d(t4);
              }, h.prototype.values = function() {
                var t4 = [];
                return this.forEach(function(e4) {
                  t4.push(e4);
                }), d(t4);
              }, h.prototype.entries = function() {
                var t4 = [];
                return this.forEach(function(e4, r4) {
                  t4.push([r4, e4]);
                }), d(t4);
              }, n3 && (h.prototype[Symbol.iterator] = h.prototype.entries);
              var I = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
              function A(t4, e4) {
                var r4, n4, o3 = (e4 = e4 || {}).body;
                if (t4 instanceof A) {
                  if (t4.bodyUsed)
                    throw new TypeError("Already read");
                  this.url = t4.url, this.credentials = t4.credentials, e4.headers || (this.headers = new h(t4.headers)), this.method = t4.method, this.mode = t4.mode, this.signal = t4.signal, o3 || t4._bodyInit == null || (o3 = t4._bodyInit, t4.bodyUsed = true);
                } else
                  this.url = String(t4);
                if (this.credentials = e4.credentials || this.credentials || "same-origin", !e4.headers && this.headers || (this.headers = new h(e4.headers)), this.method = (n4 = (r4 = e4.method || this.method || "GET").toUpperCase(), I.indexOf(n4) > -1 ? n4 : r4), this.mode = e4.mode || this.mode || null, this.signal = e4.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && o3)
                  throw new TypeError("Body not allowed for GET or HEAD requests");
                this._initBody(o3);
              }
              function T(t4) {
                var e4 = new FormData();
                return t4.trim().split("&").forEach(function(t5) {
                  if (t5) {
                    var r4 = t5.split("="), n4 = r4.shift().replace(/\+/g, " "), o3 = r4.join("=").replace(/\+/g, " ");
                    e4.append(decodeURIComponent(n4), decodeURIComponent(o3));
                  }
                }), e4;
              }
              function v(t4, e4) {
                e4 || (e4 = {}), this.type = "default", this.status = e4.status === void 0 ? 200 : e4.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in e4 ? e4.statusText : "OK", this.headers = new h(e4.headers), this.url = e4.url || "", this._initBody(t4);
              }
              A.prototype.clone = function() {
                return new A(this, { body: this._bodyInit });
              }, E.call(A.prototype), E.call(v.prototype), v.prototype.clone = function() {
                return new v(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new h(this.headers), url: this.url });
              }, v.error = function() {
                var t4 = new v(null, { status: 0, statusText: "" });
                return t4.type = "error", t4;
              };
              var O = [301, 302, 303, 307, 308];
              v.redirect = function(t4, e4) {
                if (O.indexOf(e4) === -1)
                  throw new RangeError("Invalid status code");
                return new v(null, { status: e4, headers: { location: t4 } });
              }, e3.DOMException = t3.DOMException;
              try {
                new e3.DOMException();
              } catch (t4) {
                e3.DOMException = function(t5, e4) {
                  this.message = t5, this.name = e4;
                  var r4 = Error(t5);
                  this.stack = r4.stack;
                }, e3.DOMException.prototype = Object.create(Error.prototype), e3.DOMException.prototype.constructor = e3.DOMException;
              }
              function _(t4, r4) {
                return new Promise(function(n4, i2) {
                  var s2 = new A(t4, r4);
                  if (s2.signal && s2.signal.aborted)
                    return i2(new e3.DOMException("Aborted", "AbortError"));
                  var a2 = new XMLHttpRequest();
                  function c2() {
                    a2.abort();
                  }
                  a2.onload = function() {
                    var t5, e4, r5 = { status: a2.status, statusText: a2.statusText, headers: (t5 = a2.getAllResponseHeaders() || "", e4 = new h(), t5.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function(t6) {
                      var r6 = t6.split(":"), n5 = r6.shift().trim();
                      if (n5) {
                        var o4 = r6.join(":").trim();
                        e4.append(n5, o4);
                      }
                    }), e4) };
                    r5.url = "responseURL" in a2 ? a2.responseURL : r5.headers.get("X-Request-URL");
                    var o3 = "response" in a2 ? a2.response : a2.responseText;
                    n4(new v(o3, r5));
                  }, a2.onerror = function() {
                    i2(new TypeError("Network request failed"));
                  }, a2.ontimeout = function() {
                    i2(new TypeError("Network request failed"));
                  }, a2.onabort = function() {
                    i2(new e3.DOMException("Aborted", "AbortError"));
                  }, a2.open(s2.method, s2.url, true), s2.credentials === "include" ? a2.withCredentials = true : s2.credentials === "omit" && (a2.withCredentials = false), "responseType" in a2 && o2 && (a2.responseType = "blob"), s2.headers.forEach(function(t5, e4) {
                    a2.setRequestHeader(e4, t5);
                  }), s2.signal && (s2.signal.addEventListener("abort", c2), a2.onreadystatechange = function() {
                    a2.readyState === 4 && s2.signal.removeEventListener("abort", c2);
                  }), a2.send(s2._bodyInit === void 0 ? null : s2._bodyInit);
                });
              }
              _.polyfill = true, t3.fetch || (t3.fetch = _, t3.Headers = h, t3.Request = A, t3.Response = v), e3.Headers = h, e3.Request = A, e3.Response = v, e3.fetch = _, Object.defineProperty(e3, "__esModule", { value: true });
            }({});
          }(n2), n2.fetch.ponyfill = true, delete n2.fetch.polyfill;
          var o = n2;
          (e2 = o.fetch).default = o.fetch, e2.fetch = o.fetch, e2.Headers = o.Headers, e2.Request = o.Request, e2.Response = o.Response, t2.exports = e2;
        } }, e = {};
        function r(n2) {
          var o = e[n2];
          if (o !== void 0)
            return o.exports;
          var i = e[n2] = { exports: {} };
          return t[n2].call(i.exports, i, i.exports, r), i.exports;
        }
        r.n = (t2) => {
          var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
          return r.d(e2, { a: e2 }), e2;
        }, r.d = (t2, e2) => {
          for (var n2 in e2)
            r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
        }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
          typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        };
        var n = {};
        return (() => {
          "use strict";
          r.r(n), r.d(n, { FEATURES: () => f, GAS_PRICE_TYPE: () => u, LabelValue: () => a, Operation: () => e2, RPC_AUTHENTICATION: () => c, SafeAppAccessPolicyTypes: () => t2, TokenType: () => d, TransactionStatus: () => o, TransactionTokenType: () => s, TransferDirection: () => i, getBalances: () => E, getChainConfig: () => g, getChainsConfig: () => w, getCollectibles: () => T, getDecodedData: () => x, getFiatCurrencies: () => I, getMasterCopies: () => S, getOwnedSafes: () => A, getSafeApps: () => C, getSafeInfo: () => b, getTransactionDetails: () => _, getTransactionHistory: () => v, getTransactionQueue: () => O, postSafeGasEstimation: () => m, proposeTransaction: () => N });
          var t2, e2, o, i, s, a, c, u, f, d, h = r(98), p = r.n(h);
          function l(t3, e3) {
            return r2 = this, n2 = void 0, i2 = function() {
              var r3, n3, o3, i3, s2;
              return function(t4, e4) {
                var r4, n4, o4, i4, s3 = { label: 0, sent: function() {
                  if (1 & o4[0])
                    throw o4[1];
                  return o4[1];
                }, trys: [], ops: [] };
                return i4 = { next: a2(0), throw: a2(1), return: a2(2) }, typeof Symbol == "function" && (i4[Symbol.iterator] = function() {
                  return this;
                }), i4;
                function a2(i5) {
                  return function(a3) {
                    return function(i6) {
                      if (r4)
                        throw new TypeError("Generator is already executing.");
                      for (; s3; )
                        try {
                          if (r4 = 1, n4 && (o4 = 2 & i6[0] ? n4.return : i6[0] ? n4.throw || ((o4 = n4.return) && o4.call(n4), 0) : n4.next) && !(o4 = o4.call(n4, i6[1])).done)
                            return o4;
                          switch (n4 = 0, o4 && (i6 = [2 & i6[0], o4.value]), i6[0]) {
                            case 0:
                            case 1:
                              o4 = i6;
                              break;
                            case 4:
                              return s3.label++, { value: i6[1], done: false };
                            case 5:
                              s3.label++, n4 = i6[1], i6 = [0];
                              continue;
                            case 7:
                              i6 = s3.ops.pop(), s3.trys.pop();
                              continue;
                            default:
                              if (!((o4 = (o4 = s3.trys).length > 0 && o4[o4.length - 1]) || i6[0] !== 6 && i6[0] !== 2)) {
                                s3 = 0;
                                continue;
                              }
                              if (i6[0] === 3 && (!o4 || i6[1] > o4[0] && i6[1] < o4[3])) {
                                s3.label = i6[1];
                                break;
                              }
                              if (i6[0] === 6 && s3.label < o4[1]) {
                                s3.label = o4[1], o4 = i6;
                                break;
                              }
                              if (o4 && s3.label < o4[2]) {
                                s3.label = o4[2], s3.ops.push(i6);
                                break;
                              }
                              o4[2] && s3.ops.pop(), s3.trys.pop();
                              continue;
                          }
                          i6 = e4.call(t4, s3);
                        } catch (t5) {
                          i6 = [6, t5], n4 = 0;
                        } finally {
                          r4 = o4 = 0;
                        }
                      if (5 & i6[0])
                        throw i6[1];
                      return { value: i6[0] ? i6[1] : void 0, done: true };
                    }([i5, a3]);
                  };
                }
              }(this, function(a2) {
                switch (a2.label) {
                  case 0:
                    return e3 != null && (r3 = { method: "POST", body: typeof e3 == "string" ? e3 : JSON.stringify(e3), headers: { "Content-Type": "application/json" } }), [4, p()(t3, r3)];
                  case 1:
                    return [4, (n3 = a2.sent()).json()];
                  case 2:
                    if (o3 = a2.sent(), !n3.ok) {
                      i3 = "";
                      try {
                        i3 = (s2 = o3).code + ": " + s2.message;
                      } catch (t4) {
                        i3 = n3.statusText;
                      }
                      throw new Error(i3);
                    }
                    return [2, o3];
                }
              });
            }, new ((o2 = void 0) || (o2 = Promise))(function(t4, e4) {
              function s2(t5) {
                try {
                  c2(i2.next(t5));
                } catch (t6) {
                  e4(t6);
                }
              }
              function a2(t5) {
                try {
                  c2(i2.throw(t5));
                } catch (t6) {
                  e4(t6);
                }
              }
              function c2(e5) {
                var r3;
                e5.done ? t4(e5.value) : (r3 = e5.value, r3 instanceof o2 ? r3 : new o2(function(t5) {
                  t5(r3);
                })).then(s2, a2);
              }
              c2((i2 = i2.apply(r2, n2 || [])).next());
            });
            var r2, n2, o2, i2;
          }
          function y(t3, e3, r2, n2) {
            if (n2)
              return l(n2);
            var o2 = r2;
            return l("" + t3 + function(t4, e4) {
              return e4 ? Object.keys(e4).reduce(function(t5, r3) {
                return function(t6, e5, r4) {
                  return t6.replace(new RegExp("\\{" + e5 + "\\}", "g"), r4);
                }(t5, r3, String(e4[r3]));
              }, t4) : t4;
            }(e3, o2 == null ? void 0 : o2.path) + function(t4) {
              if (!t4)
                return "";
              var e4 = new URLSearchParams();
              Object.keys(t4).forEach(function(r4) {
                t4[r4] != null && e4.append(r4, String(t4[r4]));
              });
              var r3 = e4.toString();
              return r3 ? "?" + r3 : "";
            }(o2 == null ? void 0 : o2.query), o2 == null ? void 0 : o2.body);
          }
          function b(t3, e3, r2) {
            return y(t3, "/v1/chains/{chainId}/safes/{address}", { path: { chainId: e3, address: r2 } });
          }
          function E(t3, e3, r2, n2, o2) {
            return n2 === void 0 && (n2 = "usd"), o2 === void 0 && (o2 = {}), y(t3, "/v1/chains/{chainId}/safes/{address}/balances/{currency}", { path: { chainId: e3, address: r2, currency: n2 }, query: o2 });
          }
          function I(t3) {
            return y(t3, "/v1/balances/supported-fiat-codes");
          }
          function A(t3, e3, r2) {
            return y(t3, "/v1/chains/{chainId}/owners/{address}/safes", { path: { chainId: e3, address: r2 } });
          }
          function T(t3, e3, r2, n2) {
            return n2 === void 0 && (n2 = {}), y(t3, "/v1/chains/{chainId}/safes/{address}/collectibles", { path: { chainId: e3, address: r2 }, query: n2 });
          }
          function v(t3, e3, r2, n2) {
            return y(t3, "/v1/chains/{chainId}/safes/{safe_address}/transactions/history", { path: { chainId: e3, safe_address: r2 }, query: {} }, n2);
          }
          function O(t3, e3, r2, n2) {
            return y(t3, "/v1/chains/{chainId}/safes/{safe_address}/transactions/queued", { path: { chainId: e3, safe_address: r2 }, query: {} }, n2);
          }
          function _(t3, e3, r2) {
            return y(t3, "/v1/chains/{chainId}/transactions/{transactionId}", { path: { chainId: e3, transactionId: r2 } });
          }
          function m(t3, e3, r2, n2) {
            return y(t3, "/v2/chains/{chainId}/safes/{safe_address}/multisig-transactions/estimations", { path: { chainId: e3, safe_address: r2 }, body: n2 });
          }
          function N(t3, e3, r2, n2) {
            return y(t3, "/v1/chains/{chainId}/transactions/{safe_address}/propose", { path: { chainId: e3, safe_address: r2 }, body: n2 });
          }
          function w(t3, e3) {
            return y(t3, "/v1/chains", { query: e3 });
          }
          function g(t3, e3) {
            return y(t3, "/v1/chains/{chainId}", { path: { chainId: e3 } });
          }
          function C(t3, e3, r2) {
            return r2 === void 0 && (r2 = {}), y(t3, "/v1/chains/{chainId}/safe-apps", { path: { chainId: e3 }, query: r2 });
          }
          function S(t3, e3) {
            return y(t3, "/v1/chains/{chainId}/about/master-copies", { path: { chainId: e3 } });
          }
          function x(t3, e3, r2) {
            return y(t3, "/v1/chains/{chainId}/data-decoder", { path: { chainId: e3 }, body: { data: r2 } });
          }
          !function(t3) {
            t3.NoRestrictions = "NO_RESTRICTIONS", t3.DomainAllowlist = "DOMAIN_ALLOWLIST";
          }(t2 || (t2 = {})), function(t3) {
            t3[t3.CALL = 0] = "CALL", t3[t3.DELEGATE = 1] = "DELEGATE";
          }(e2 || (e2 = {})), function(t3) {
            t3.AWAITING_CONFIRMATIONS = "AWAITING_CONFIRMATIONS", t3.AWAITING_EXECUTION = "AWAITING_EXECUTION", t3.CANCELLED = "CANCELLED", t3.FAILED = "FAILED", t3.SUCCESS = "SUCCESS", t3.PENDING = "PENDING", t3.WILL_BE_REPLACED = "WILL_BE_REPLACED";
          }(o || (o = {})), function(t3) {
            t3.INCOMING = "INCOMING", t3.OUTGOING = "OUTGOING", t3.UNKNOWN = "UNKNOWN";
          }(i || (i = {})), function(t3) {
            t3.ERC20 = "ERC20", t3.ERC721 = "ERC721", t3.NATIVE_COIN = "NATIVE_COIN";
          }(s || (s = {})), function(t3) {
            t3.Queued = "Queued", t3.Next = "Next";
          }(a || (a = {})), function(t3) {
            t3.API_KEY_PATH = "API_KEY_PATH", t3.NO_AUTHENTICATION = "NO_AUTHENTICATION", t3.UNKNOWN = "UNKNOWN";
          }(c || (c = {})), function(t3) {
            t3.ORACLE = "ORACLE", t3.FIXED = "FIXED", t3.UNKNOWN = "UNKNOWN";
          }(u || (u = {})), function(t3) {
            t3.ERC721 = "ERC721", t3.SAFE_APPS = "SAFE_APPS", t3.CONTRACT_INTERACTION = "CONTRACT_INTERACTION", t3.DOMAIN_LOOKUP = "DOMAIN_LOOKUP", t3.SPENDING_LIMIT = "SPENDING_LIMIT", t3.EIP1559 = "EIP1559", t3.SAFE_TX_GAS_OPTIONAL = "SAFE_TX_GAS_OPTIONAL";
          }(f || (f = {})), function(t3) {
            t3.ERC20 = "ERC20", t3.ERC721 = "ERC721", t3.NATIVE_TOKEN = "NATIVE_TOKEN";
          }(d || (d = {}));
        })(), n;
      })();
    });
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/types/gateway.js
var require_gateway = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/types/gateway.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransferDirection = exports.TransactionStatus = exports.TokenType = exports.Operation = void 0;
    var safe_react_gateway_sdk_1 = require_index_min();
    Object.defineProperty(exports, "Operation", { enumerable: true, get: function() {
      return safe_react_gateway_sdk_1.Operation;
    } });
    Object.defineProperty(exports, "TokenType", { enumerable: true, get: function() {
      return safe_react_gateway_sdk_1.TokenType;
    } });
    Object.defineProperty(exports, "TransactionStatus", { enumerable: true, get: function() {
      return safe_react_gateway_sdk_1.TransactionStatus;
    } });
    Object.defineProperty(exports, "TransferDirection", { enumerable: true, get: function() {
      return safe_react_gateway_sdk_1.TransferDirection;
    } });
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/types/messaging.js
var require_messaging = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/types/messaging.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    var methods_1 = require_methods();
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/types/index.js
var require_types = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/types/index.js"(exports) {
    "use strict";
    init_define_process_env();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_sdk2(), exports);
    __exportStar(require_rpc(), exports);
    __exportStar(require_gateway(), exports);
    __exportStar(require_messaging(), exports);
  }
});

// node_modules/@gnosis.pm/safe-apps-sdk/dist/src/index.js
var require_src = __commonJS({
  "node_modules/@gnosis.pm/safe-apps-sdk/dist/src/index.js"(exports) {
    init_define_process_env();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSDKVersion = void 0;
    var sdk_1 = __importDefault(require_sdk());
    exports.default = sdk_1.default;
    __exportStar(require_sdk(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_methods(), exports);
    __exportStar(require_messageFormatter(), exports);
    var utils_1 = require_utils();
    Object.defineProperty(exports, "getSDKVersion", { enumerable: true, get: function() {
      return utils_1.getSDKVersion;
    } });
  }
});
"use strict";
export default require_src();
//# sourceMappingURL=src-EYAWUDCX.js.map
