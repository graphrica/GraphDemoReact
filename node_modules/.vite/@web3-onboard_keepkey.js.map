{
  "version": 3,
  "sources": ["dep:@web3-onboard_keepkey", "../@web3-onboard/keepkey/dist/index.js"],
  "sourcesContent": ["import d from \"./node_modules/@web3-onboard/keepkey/dist/index.js\";export default d;", "const DEFAULT_PATH = `m/44'/60'/0'/0/0`;\nconst DEFAULT_BASE_PATHS = [\n    {\n        label: 'Ethereum Mainnet',\n        value: DEFAULT_PATH\n    }\n];\nconst assets = [\n    {\n        label: 'ETH'\n    }\n];\nconst ERROR_BUSY = 'busy';\nconst ERROR_PAIRING = 'pairing';\nconst errorMessages = {\n    [ERROR_BUSY]: `Your KeepKey is currently connected to another application.\n  Please close any other browser tabs or applications that may be connected to your device and try again.`,\n    [ERROR_PAIRING]: 'There was an error pairing the device. Please disconnect and reconnect the device and try again.'\n};\nfunction keepkey() {\n    const getIcon = async () => (await import('./icon.js')).default;\n    return () => {\n        let accounts;\n        return {\n            label: 'KeepKey',\n            getIcon,\n            getInterface: async ({ EventEmitter, chains }) => {\n                const { WebUSBKeepKeyAdapter } = await import('@shapeshiftoss/hdwallet-keepkey-webusb');\n                const { Keyring, Events, bip32ToAddressNList, addressNListToBIP32, HDWalletErrorType } = await import('@shapeshiftoss/hdwallet-core');\n                const { accountSelect, createEIP1193Provider, ProviderRpcError, entryModal } = await import('@web3-onboard/common');\n                const { StaticJsonRpcProvider } = await import('@ethersproject/providers');\n                const ethUtil = await import('ethereumjs-util');\n                const keyring = new Keyring();\n                const keepKeyAdapter = WebUSBKeepKeyAdapter.useKeyring(keyring);\n                const eventEmitter = new EventEmitter();\n                let keepKeyWallet;\n                let currentChain = chains[0];\n                keyring.on(['*', '*', Events.DISCONNECT], async () => {\n                    eventEmitter.emit('accountsChanged', []);\n                });\n                // If the wallet asks for a PIN, open the PIN modal\n                keyring.on(['*', '*', Events.PIN_REQUEST], () => {\n                    entryModal('pin', val => keepKeyWallet.sendPin(val), () => keepKeyWallet.cancel());\n                });\n                // If the wallet asks for a PIN, open the PIN modal\n                keyring.on(['*', '*', Events.PASSPHRASE_REQUEST], () => {\n                    entryModal('passphrase', val => keepKeyWallet.sendPassphrase(val), () => keepKeyWallet.cancel());\n                });\n                const getAccountIdx = (derivationPath) => {\n                    // Get the account index from the derivation path\n                    const { accountIdx } = keepKeyWallet.describePath({\n                        path: bip32ToAddressNList(derivationPath),\n                        coin: 'Ethereum'\n                    });\n                    if (accountIdx === undefined)\n                        throw new Error(`Could not derive account from path: ${derivationPath}`);\n                    return accountIdx;\n                };\n                const getPaths = (accountIdx) => {\n                    // Retrieve the array form of the derivation path for a given account index\n                    const [paths] = keepKeyWallet.ethGetAccountPaths({\n                        coin: 'Ethereum',\n                        accountIdx\n                    });\n                    return paths;\n                };\n                const getAccount = async ({ accountIdx, provider, asset }) => {\n                    const paths = getPaths(accountIdx);\n                    // Retrieve the address associated with the given account index\n                    const address = await keepKeyWallet.ethGetAddress({\n                        addressNList: paths.addressNList,\n                        showDisplay: false\n                    });\n                    const balance = await provider.getBalance(address);\n                    return {\n                        derivationPath: addressNListToBIP32(paths.addressNList),\n                        address,\n                        balance: {\n                            asset: asset.label,\n                            value: balance\n                        }\n                    };\n                };\n                const getAllAccounts = async ({ derivationPath, asset, provider }) => {\n                    let index = getAccountIdx(derivationPath);\n                    let zeroBalanceAccounts = 0;\n                    const accounts = [];\n                    // Iterates until a 0 balance account is found\n                    // Then adds 4 more 0 balance accounts to the array\n                    while (zeroBalanceAccounts < 5) {\n                        const acc = await getAccount({\n                            accountIdx: index,\n                            provider,\n                            asset\n                        });\n                        if (acc &&\n                            acc.balance &&\n                            acc.balance.value &&\n                            acc.balance.value.isZero()) {\n                            zeroBalanceAccounts++;\n                            accounts.push(acc);\n                        }\n                        else {\n                            accounts.push(acc);\n                            // Reset the number of 0 balance accounts\n                            zeroBalanceAccounts = 0;\n                        }\n                        index++;\n                    }\n                    return accounts;\n                };\n                const scanAccounts = async ({ derivationPath, chainId, asset }) => {\n                    if (!keepKeyWallet)\n                        throw new Error('Device must be connected before scanning accounts');\n                    currentChain = chains.find(({ id }) => id === chainId) || currentChain;\n                    const provider = new StaticJsonRpcProvider(currentChain.rpcUrl);\n                    // Checks to see if this is a custom derivation path\n                    // If it is then just return the single account\n                    if (!DEFAULT_BASE_PATHS.find(({ value }) => value === derivationPath)) {\n                        try {\n                            const accountIdx = getAccountIdx(derivationPath);\n                            const account = await getAccount({ accountIdx, provider, asset });\n                            return [account];\n                        }\n                        catch (error) {\n                            throw new Error('Invalid derivation path');\n                        }\n                    }\n                    return getAllAccounts({ derivationPath, asset, provider });\n                };\n                const getAccounts = async () => {\n                    accounts = await accountSelect({\n                        basePaths: DEFAULT_BASE_PATHS,\n                        assets,\n                        chains,\n                        scanAccounts\n                    });\n                    if (!accounts)\n                        throw new Error('No accounts were found');\n                    if (accounts.length) {\n                        eventEmitter.emit('accountsChanged', [accounts[0].address]);\n                    }\n                    return accounts;\n                };\n                const request = async ({ method, params }) => {\n                    const response = await fetch(currentChain.rpcUrl, {\n                        method: 'POST',\n                        body: JSON.stringify({\n                            id: '42',\n                            method,\n                            params\n                        })\n                    }).then(res => res.json());\n                    if (response.result) {\n                        return response.result;\n                    }\n                    else {\n                        throw response.error;\n                    }\n                };\n                const keepKeyProvider = { request };\n                const provider = createEIP1193Provider(keepKeyProvider, {\n                    eth_requestAccounts: async () => {\n                        if (keepKeyWallet && typeof keepKeyWallet.cancel === 'function') {\n                            // cancel any current actions on device\n                            keepKeyWallet.cancel();\n                        }\n                        try {\n                            keepKeyWallet =\n                                (await keepKeyAdapter.pairDevice());\n                        }\n                        catch (error) {\n                            const { name } = error;\n                            // This error indicates that the keepkey is paired with another app\n                            if (name === HDWalletErrorType.ConflictingApp) {\n                                throw new ProviderRpcError({\n                                    code: 4001,\n                                    message: errorMessages[ERROR_BUSY]\n                                });\n                                // This error indicates that for some reason we can't claim the usb device\n                            }\n                            else if (name === HDWalletErrorType.WebUSBCouldNotPair) {\n                                throw new ProviderRpcError({\n                                    code: 4001,\n                                    message: errorMessages[ERROR_PAIRING]\n                                });\n                            }\n                        }\n                        // Triggers the account select modal if no accounts have been selected\n                        const accounts = await getAccounts();\n                        if (!accounts || !Array.isArray(accounts)) {\n                            throw new Error('No accounts were returned from Keepkey device');\n                        }\n                        if (!accounts.length) {\n                            throw new ProviderRpcError({\n                                code: 4001,\n                                message: 'User rejected the request.'\n                            });\n                        }\n                        if (!accounts[0].hasOwnProperty('address')) {\n                            throw new Error('The account returned does not have a required address field');\n                        }\n                        return [accounts[0].address];\n                    },\n                    eth_selectAccounts: async () => {\n                        const accounts = await getAccounts();\n                        return accounts.map(({ address }) => address);\n                    },\n                    eth_accounts: async () => {\n                        if (!accounts || !Array.isArray(accounts)) {\n                            throw new Error('No accounts were returned from Keepkey device');\n                        }\n                        return accounts[0].hasOwnProperty('address')\n                            ? [accounts[0].address]\n                            : [];\n                    },\n                    eth_chainId: async () => {\n                        return currentChain && currentChain.id != undefined\n                            ? currentChain.id\n                            : '0x0';\n                    },\n                    eth_signTransaction: async ({ params: [transactionObject] }) => {\n                        if (!accounts || !Array.isArray(accounts) || !accounts.length)\n                            throw new Error('No account selected. Must call eth_requestAccounts first.');\n                        const account = !transactionObject || !transactionObject.hasOwnProperty('from')\n                            ? accounts[0]\n                            : accounts.find(account => account.address === transactionObject.from);\n                        const { derivationPath } = account || accounts[0];\n                        const addressNList = bip32ToAddressNList(derivationPath);\n                        const { nonce, gasPrice, gas, gasLimit, to, value, data, maxFeePerGas, maxPriorityFeePerGas } = transactionObject;\n                        const { serialized } = await keepKeyWallet.ethSignTx({\n                            addressNList,\n                            nonce: nonce || '0x0',\n                            gasPrice,\n                            gasLimit: gasLimit || gas || '0x5208',\n                            to,\n                            value: value || '0x0',\n                            data: data || '',\n                            maxFeePerGas,\n                            maxPriorityFeePerGas,\n                            chainId: parseInt(currentChain.id)\n                        });\n                        return serialized;\n                    },\n                    eth_sendTransaction: async ({ baseRequest, params }) => {\n                        const signedTx = await provider.request({\n                            method: 'eth_signTransaction',\n                            params\n                        });\n                        const transactionHash = await baseRequest({\n                            method: 'eth_sendRawTransaction',\n                            params: [signedTx]\n                        });\n                        return transactionHash;\n                    },\n                    eth_sign: async ({ params: [address, message] }) => {\n                        if (!accounts ||\n                            !Array.isArray(accounts) ||\n                            !(accounts.length && accounts.length > 0))\n                            throw new Error('No account selected. Must call eth_requestAccounts first.');\n                        const account = accounts.find(account => account.address === address) ||\n                            accounts[0];\n                        const { derivationPath } = account;\n                        const accountIdx = getAccountIdx(derivationPath);\n                        const { addressNList } = getPaths(accountIdx);\n                        const { signature } = await keepKeyWallet.ethSignMessage({\n                            addressNList,\n                            message: message.slice(0, 2) === '0x'\n                                ? // @ts-ignore - commonjs weirdness\n                                    (ethUtil.default || ethUtil)\n                                        .toBuffer(message)\n                                        .toString('utf8')\n                                : message\n                        });\n                        return signature;\n                    },\n                    eth_signTypedData: null,\n                    wallet_switchEthereumChain: async ({ params: [{ chainId }] }) => {\n                        currentChain =\n                            chains.find(({ id }) => id === chainId) || currentChain;\n                        if (!currentChain)\n                            throw new Error('chain must be set before switching');\n                        eventEmitter.emit('chainChanged', currentChain.id);\n                        return null;\n                    },\n                    wallet_addEthereumChain: null\n                });\n                provider.on = eventEmitter.on.bind(eventEmitter);\n                return {\n                    provider,\n                    instance: {\n                        selectAccount: getAccounts\n                    }\n                };\n            }\n        };\n    };\n}\nexport default keepkey;\n"],
  "mappings": "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",
  "names": []
}
