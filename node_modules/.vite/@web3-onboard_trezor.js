import {
  require_buffer
} from "./chunk-557FO4FU.js";
import "./chunk-S5NSXQRL.js";
import {
  __spreadProps,
  __spreadValues,
  __toESM,
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// dep:@web3-onboard_trezor
init_define_process_env();

// node_modules/@web3-onboard/trezor/dist/index.js
init_define_process_env();
var import_buffer = __toESM(require_buffer(), 1);
var TREZOR_DEFAULT_PATH = "m/44'/60'/0'/0";
var assets = [
  {
    label: "ETH"
  }
];
var DEFAULT_BASE_PATHS = [
  {
    label: "Ethereum Mainnet",
    value: TREZOR_DEFAULT_PATH
  }
];
var getAccount = async ({ publicKey, chainCode, path }, asset, index, provider) => {
  const { default: HDKey } = await import("./hdkey-JVIHWFGX.js");
  const ethUtil = await import("./dist-JPBCCQ4F.js");
  const { publicToAddress, toChecksumAddress } = ethUtil.default || ethUtil;
  const hdk = new HDKey();
  hdk.publicKey = import_buffer.Buffer.from(publicKey, "hex");
  hdk.chainCode = import_buffer.Buffer.from(chainCode, "hex");
  const dkey = hdk.deriveChild(index);
  const address = toChecksumAddress(`0x${publicToAddress(dkey.publicKey, true).toString("hex")}`);
  return {
    derivationPath: `${path}/${index}`,
    address,
    balance: {
      asset: asset.label,
      value: await provider.getBalance(address)
    }
  };
};
var getAddresses = async (account, asset, provider) => {
  const accounts = [];
  let index = 0;
  let zeroBalanceAccounts = 0;
  while (zeroBalanceAccounts < 5) {
    const acc = await getAccount(account, asset, index, provider);
    if (acc && acc.hasOwnProperty("balance") && acc.balance.hasOwnProperty("value") && acc.balance.value.isZero()) {
      zeroBalanceAccounts++;
      accounts.push(acc);
    } else {
      accounts.push(acc);
      zeroBalanceAccounts = 0;
    }
    index++;
  }
  return accounts;
};
function trezor(options) {
  const getIcon = async () => (await import("./icon-NJYXE2P7.js")).default;
  return () => {
    let accounts;
    return {
      label: "Trezor",
      getIcon,
      getInterface: async ({ EventEmitter, chains }) => {
        const { default: Trezor } = await import("./lib-7ATQJVKV.js");
        const { Transaction } = await import("./dist-LOC4KPXA.js");
        const { default: Common, Hardfork } = await import("./dist-4XGLEIV5.js");
        const { accountSelect, createEIP1193Provider, ProviderRpcError } = await import("./dist-3LUD4YRJ.js");
        const ethUtil = await import("./dist-JPBCCQ4F.js");
        const { compress } = (await import("./es-JKBPI3ST.js")).publicKey;
        const { StaticJsonRpcProvider } = await import("./lib-5NF7NHOH.js");
        if (!options || !options.email || !options.appUrl) {
          throw new Error("Email and AppUrl required in Trezor options for Trezor Wallet Connection");
        }
        const { email, appUrl, customNetwork } = options;
        const TrezorConnect = Trezor.default || Trezor;
        TrezorConnect.manifest({
          email,
          appUrl
        });
        const eventEmitter = new EventEmitter();
        let currentChain = chains[0];
        let account;
        const scanAccounts = async ({ derivationPath, chainId, asset }) => {
          currentChain = chains.find(({ id }) => id === chainId) || currentChain;
          const provider2 = new StaticJsonRpcProvider(currentChain.rpcUrl);
          const { publicKey, chainCode, path } = await getPublicKey(derivationPath);
          if (derivationPath !== TREZOR_DEFAULT_PATH) {
            const address = await getAddress(path);
            return [
              {
                derivationPath,
                address,
                balance: {
                  asset: asset.label,
                  value: await provider2.getBalance(address)
                }
              }
            ];
          }
          return getAddresses({
            publicKey: compress(publicKey),
            chainCode: chainCode || "",
            path: derivationPath
          }, asset, provider2);
        };
        const getAccountFromAccountSelect = async () => {
          accounts = await accountSelect({
            basePaths: DEFAULT_BASE_PATHS,
            assets,
            chains,
            scanAccounts
          });
          if (Array.isArray(accounts) && accounts.length && accounts[0].hasOwnProperty("address")) {
            eventEmitter.emit("accountsChanged", [accounts[0].address]);
          }
          return accounts;
        };
        async function getAddress(path) {
          const errorMsg = `Unable to derive address from path ${path}`;
          try {
            const result = await TrezorConnect.ethereumGetAddress({
              path,
              showOnTrezor: true
            });
            if (!result.success) {
              throw new Error(errorMsg);
            }
            return result.payload.address;
          } catch (error) {
            throw new Error(errorMsg);
          }
        }
        async function getPublicKey(dPath) {
          if (!dPath) {
            throw new Error("a derivation path is needed to get the public key");
          }
          try {
            const result = await TrezorConnect.getPublicKey({
              path: dPath,
              coin: "ETH"
            });
            if (!result.success) {
              throw new Error(result.payload.error);
            }
            account = {
              publicKey: result.payload.publicKey,
              chainCode: result.payload.chainCode,
              path: result.payload.serializedPath
            };
            return account;
          } catch (error) {
            throw new Error(`There was an error accessing your Trezor accounts - Error: ${error}`);
          }
        }
        function createTrezorTransactionObject(transactionData) {
          if (!transactionData || !transactionData.hasOwnProperty("gasLimit") && !transactionData.hasOwnProperty("gas")) {
            throw new Error("There was no Transaction Object or both the gasLimit and gas property are missing");
          }
          const gasLimit = transactionData.gasLimit || transactionData.gas;
          if (transactionData.maxFeePerGas || transactionData.maxPriorityFeePerGas) {
            return {
              to: transactionData.to,
              value: transactionData.value,
              gasLimit,
              maxFeePerGas: transactionData.maxFeePerGas,
              maxPriorityFeePerGas: transactionData.maxPriorityFeePerGas,
              nonce: transactionData.nonce,
              chainId: parseInt(currentChain.id),
              data: transactionData.hasOwnProperty("data") ? transactionData.data : ""
            };
          }
          return {
            to: transactionData.to,
            value: transactionData.value,
            gasPrice: transactionData.gasPrice,
            gasLimit,
            nonce: transactionData.nonce,
            chainId: parseInt(currentChain.id),
            data: transactionData.hasOwnProperty("data") ? transactionData.data : ""
          };
        }
        function trezorSignTransaction(path, transactionData) {
          try {
            return TrezorConnect.ethereumSignTransaction({
              path,
              transaction: transactionData
            });
          } catch (error) {
            throw new Error(`There was an error signing transaction - Error: ${error}`);
          }
        }
        async function signTransaction(transactionObject) {
          if (!Array.isArray(accounts) || !accounts.length)
            throw new Error("No account selected. Must call eth_requestAccounts first.");
          let signingAccount;
          if (transactionObject.hasOwnProperty("from")) {
            signingAccount = accounts.find((account2) => account2.address === transactionObject.from);
          }
          signingAccount = signingAccount ? signingAccount : accounts[0];
          const { derivationPath } = signingAccount;
          const transactionData = createTrezorTransactionObject(transactionObject);
          const CommonConstructor = Common.default || Common;
          const common = new CommonConstructor({
            chain: customNetwork || Number.parseInt(currentChain.id) || 1,
            hardfork: Hardfork.Berlin,
            eips: [1559]
          });
          const trezorResult = await trezorSignTransaction(derivationPath, transactionData);
          if (!trezorResult.success) {
            const message = trezorResult.payload.error === "Unknown message" ? "This type of transactions is not supported on this device" : trezorResult.payload.error;
            throw new Error(message);
          }
          const { r, s } = trezorResult.payload;
          let v = trezorResult.payload.v;
          const rv = parseInt(v, 16);
          let cv = parseInt(currentChain.id) * 2 + 35;
          if (rv !== cv && (rv & cv) !== rv) {
            cv += 1;
          }
          v = cv.toString(16);
          const signedTx = Transaction.fromTxData(__spreadProps(__spreadValues({}, transactionData), {
            v: `0x${v}`,
            r,
            s
          }), { common });
          return signedTx ? `0x${signedTx.serialize().toString("hex")}` : "";
        }
        async function signMessage(address, message) {
          if (!Array.isArray(accounts) || !accounts.length)
            throw new Error("No account selected. Must call eth_requestAccounts first.");
          const accountToSign = accounts.find((account2) => account2.address === address) || accounts[0];
          return new Promise((resolve, reject) => {
            TrezorConnect.ethereumSignMessage({
              path: accountToSign.derivationPath,
              message: ethUtil.stripHexPrefix(message.data),
              hex: true
            }).then((response) => {
              if (response.success) {
                if (response.payload.address !== ethUtil.toChecksumAddress(address)) {
                  reject(new Error("signature doesnt match the right address"));
                }
                const signature = `0x${response.payload.signature}`;
                resolve(signature);
              } else {
                reject(new Error(response.payload && response.payload.error || "There was an error signing a message"));
              }
            });
          });
        }
        const request = async ({ method, params }) => {
          const response = await fetch(currentChain.rpcUrl, {
            method: "POST",
            body: JSON.stringify({
              id: "42",
              method,
              params
            })
          }).then((res) => res.json());
          if (response.result) {
            return response.result;
          } else {
            throw response.error;
          }
        };
        const trezorProvider = { request };
        const provider = createEIP1193Provider(trezorProvider, {
          eth_requestAccounts: async () => {
            const accounts2 = await getAccountFromAccountSelect();
            if (!Array.isArray(accounts2))
              throw new Error("No account selected. Must call eth_requestAccounts first.");
            if (accounts2.length === 0) {
              throw new ProviderRpcError({
                code: 4001,
                message: "User rejected the request."
              });
            }
            if (!accounts2[0].hasOwnProperty("address"))
              throw new Error("No address property associated with the selected account");
            return [accounts2[0].address];
          },
          eth_selectAccounts: async () => {
            const accounts2 = await getAccountFromAccountSelect();
            return accounts2.map(({ address }) => address);
          },
          eth_accounts: async () => {
            return Array.isArray(accounts) && accounts.length && accounts[0].hasOwnProperty("address") ? [accounts[0].address] : [];
          },
          eth_chainId: async () => {
            return currentChain.hasOwnProperty("id") ? currentChain.id : "";
          },
          eth_signTransaction: async ({ params: [transactionObject] }) => {
            return signTransaction(transactionObject);
          },
          eth_sendTransaction: async ({ baseRequest, params }) => {
            const signedTx = await provider.request({
              method: "eth_signTransaction",
              params
            });
            const transactionHash = await baseRequest({
              method: "eth_sendRawTransaction",
              params: [signedTx]
            });
            return transactionHash;
          },
          eth_sign: async ({ params: [address, message] }) => {
            let messageData = { data: message };
            return signMessage(address, messageData);
          },
          wallet_switchEthereumChain: async ({ params: [{ chainId }] }) => {
            currentChain = chains.find(({ id }) => id === chainId) || currentChain;
            if (!currentChain)
              throw new Error("chain must be set before switching");
            eventEmitter.emit("chainChanged", currentChain.id);
            return null;
          },
          eth_signTypedData: null,
          wallet_addEthereumChain: null
        });
        provider.on = eventEmitter.on.bind(eventEmitter);
        return {
          provider
        };
      }
    };
  };
}
var dist_default = trezor;

// dep:@web3-onboard_trezor
var web3_onboard_trezor_default = dist_default;
export {
  web3_onboard_trezor_default as default
};
//# sourceMappingURL=@web3-onboard_trezor.js.map
