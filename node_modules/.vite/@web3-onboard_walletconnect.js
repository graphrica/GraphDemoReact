import {
  StaticJsonRpcProvider,
  init_lib3 as init_lib
} from "./chunk-MDRYO75J.js";
import {
  ProviderRpcError,
  ProviderRpcErrorCode
} from "./chunk-QLIZTXI5.js";
import "./chunk-BRDLAWJG.js";
import "./chunk-AAFDKQNN.js";
import "./chunk-YSJ6UD5Q.js";
import "./chunk-WBSSQYQH.js";
import "./chunk-GZNO4Y3K.js";
import "./chunk-77TI47IA.js";
import "./chunk-DJCW4LVW.js";
import "./chunk-VFG3R5NB.js";
import "./chunk-QLJNFGTT.js";
import "./chunk-HEQAI6WE.js";
import "./chunk-QMSD3UEV.js";
import "./chunk-27CSTQIU.js";
import "./chunk-VIQ6GMKA.js";
import "./chunk-PX4IM7JA.js";
import {
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// dep:@web3-onboard_walletconnect
init_define_process_env();

// node_modules/@web3-onboard/walletconnect/dist/index.js
init_define_process_env();
init_lib();
function walletConnect(options) {
  const { bridge = "https://bridge.walletconnect.org", qrcodeModalOptions } = options || {};
  return () => {
    return {
      label: "WalletConnect",
      getIcon: async () => (await import("./icon-GVHFMAZU.js")).default,
      getInterface: async ({ chains, EventEmitter }) => {
        const { default: WalletConnect } = await import("./esm-VYMMAIGO.js");
        const { default: QRCodeModal } = await import("./cjs-OLOWFVIF.js");
        const { Subject, fromEvent } = await import("./esm5-EENXUBBZ.js");
        const { takeUntil, take } = await import("./operators-U2L4BPSR.js");
        const connector = new WalletConnect({
          bridge
        });
        const emitter = new EventEmitter();
        class EthProvider {
          constructor({ connector: connector2, chains: chains2 }) {
            this.emit = emitter.emit.bind(emitter);
            this.on = emitter.on.bind(emitter);
            this.removeListener = emitter.removeListener.bind(emitter);
            this.connector = connector2;
            this.chains = chains2;
            this.disconnected$ = new Subject();
            this.providers = {};
            fromEvent(this.connector, "session_update", (error, payload) => {
              if (error) {
                throw error;
              }
              return payload;
            }).pipe(takeUntil(this.disconnected$)).subscribe({
              next: ({ params }) => {
                const [{ accounts, chainId }] = params;
                this.emit("accountsChanged", accounts);
                this.emit("chainChanged", `0x${chainId.toString(16)}`);
              },
              error: console.warn
            });
            fromEvent(this.connector, "disconnect", (error, payload) => {
              if (error) {
                throw error;
              }
              return payload;
            }).pipe(takeUntil(this.disconnected$)).subscribe({
              next: () => {
                this.emit("accountsChanged", []);
                this.disconnected$.next(true);
                typeof localStorage !== "undefined" && localStorage.removeItem("walletconnect");
              },
              error: console.warn
            });
            this.disconnect = () => this.connector.killSession();
            this.request = async ({ method, params }) => {
              if (method === "eth_chainId") {
                return `0x${this.connector.chainId.toString(16)}`;
              }
              if (method === "eth_requestAccounts") {
                return new Promise((resolve, reject) => {
                  if (!this.connector.connected) {
                    this.connector.createSession().then(() => {
                      QRCodeModal.open(this.connector.uri, () => reject(new ProviderRpcError({
                        code: 4001,
                        message: "User rejected the request."
                      })), qrcodeModalOptions);
                    });
                  } else {
                    const { accounts, chainId: chainId2 } = this.connector.session;
                    this.emit("chainChanged", `0x${chainId2.toString(16)}`);
                    return resolve(accounts);
                  }
                  fromEvent(this.connector, "connect", (error, payload) => {
                    if (error) {
                      throw error;
                    }
                    return payload;
                  }).pipe(take(1)).subscribe({
                    next: ({ params: params2 }) => {
                      const [{ accounts, chainId: chainId2 }] = params2;
                      this.emit("accountsChanged", accounts);
                      this.emit("chainChanged", `0x${chainId2.toString(16)}`);
                      QRCodeModal.close();
                      resolve(accounts);
                    },
                    error: reject
                  });
                });
              }
              if (method === "wallet_switchEthereumChain" || method === "eth_selectAccounts") {
                throw new ProviderRpcError({
                  code: ProviderRpcErrorCode.UNSUPPORTED_METHOD,
                  message: `The Provider does not support the requested method: ${method}`
                });
              }
              if (method === "eth_sendTransaction") {
                return this.connector.sendTransaction(params[0]);
              }
              if (method === "eth_signTransaction") {
                return this.connector.signTransaction(params[0]);
              }
              if (method === "personal_sign") {
                return this.connector.signPersonalMessage(params);
              }
              if (method === "eth_sign") {
                return this.connector.signMessage(params);
              }
              if (method === "eth_signTypedData") {
                return this.connector.signTypedData(params);
              }
              if (method === "eth_accounts") {
                return this.connector.sendCustomRequest({
                  id: 1337,
                  jsonrpc: "2.0",
                  method,
                  params
                });
              }
              const chainId = await this.request({ method: "eth_chainId" });
              if (!this.providers[chainId]) {
                const currentChain = chains2.find(({ id }) => id === chainId);
                if (!currentChain) {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.CHAIN_NOT_ADDED,
                    message: `The Provider does not have a rpcUrl to make a request for the requested method: ${method}`
                  });
                }
                this.providers[chainId] = new StaticJsonRpcProvider(currentChain.rpcUrl);
              }
              return this.providers[chainId].send(method, params);
            };
          }
        }
        return {
          provider: new EthProvider({ chains, connector })
        };
      }
    };
  };
}
var dist_default = walletConnect;

// dep:@web3-onboard_walletconnect
var web3_onboard_walletconnect_default = dist_default;
export {
  web3_onboard_walletconnect_default as default
};
//# sourceMappingURL=@web3-onboard_walletconnect.js.map
