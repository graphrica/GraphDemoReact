import {
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// dep:@web3-onboard_torus
init_define_process_env();

// node_modules/@web3-onboard/torus/dist/index.js
init_define_process_env();
function torus(options) {
  const { buttonPosition, modalZIndex, apiKey, buildEnv, enableLogging, loginConfig, showTorusButton, integrity, whiteLabel, skipTKey, useLocalStorage } = options || {};
  return () => {
    return {
      label: "Torus",
      getIcon: async () => (await import("./icon-2GJEHDT2.js")).default,
      getInterface: async ({ chains }) => {
        const { default: Torus } = await import("./torus.esm-5H36E6AV.js");
        const { createEIP1193Provider, ProviderRpcErrorCode, ProviderRpcError } = await import("./dist-3LUD4YRJ.js");
        const [chain] = chains;
        let instance = new Torus({
          buttonPosition,
          modalZIndex,
          apiKey
        });
        await instance.init({
          buildEnv,
          enableLogging,
          network: {
            host: chain.rpcUrl,
            chainId: parseInt(chain.id),
            networkName: chain.label
          },
          showTorusButton,
          loginConfig,
          integrity,
          whiteLabel,
          skipTKey,
          useLocalStorage
        });
        const torusProvider = instance.provider;
        const on = torusProvider.on.bind(torusProvider);
        torusProvider.on = (event, listener) => {
          on(event, (val) => {
            if (event === "chainChanged") {
              listener(`0x${val.toString(16)}`);
              return;
            }
            listener(val);
          });
          return torusProvider;
        };
        const provider = createEIP1193Provider(torusProvider, {
          eth_requestAccounts: async () => {
            try {
              const accounts = await instance.login();
              return accounts;
            } catch (error) {
              throw new ProviderRpcError({
                code: ProviderRpcErrorCode.ACCOUNT_ACCESS_REJECTED,
                message: "Account access rejected"
              });
            }
          },
          eth_selectAccounts: null,
          wallet_switchEthereumChain: async ({ params }) => {
            const chain2 = chains.find(({ id }) => id === params[0].chainId);
            if (!chain2)
              throw new Error("chain must be set before switching");
            await instance.setProvider({
              host: chain2.rpcUrl,
              chainId: parseInt(chain2.id),
              networkName: chain2.label
            });
            return null;
          },
          eth_chainId: async ({ baseRequest }) => {
            const chainId = await baseRequest({ method: "eth_chainId" });
            return `0x${parseInt(chainId).toString(16)}`;
          }
        });
        provider.disconnect = () => instance.cleanUp();
        return {
          provider,
          instance
        };
      }
    };
  };
}
var dist_default = torus;

// dep:@web3-onboard_torus
var web3_onboard_torus_default = dist_default;
export {
  web3_onboard_torus_default as default
};
//# sourceMappingURL=@web3-onboard_torus.js.map
