{
  "version": 3,
  "sources": ["dep:@web3-onboard_magic", "../@web3-onboard/magic/dist/index.js"],
  "sourcesContent": ["import d from \"./node_modules/@web3-onboard/magic/dist/index.js\";export default d;", "function magic(options) {\n    const { apiKey } = options;\n    const walletName = 'Magic Wallet';\n    return () => {\n        return {\n            label: walletName,\n            getIcon: async () => (await import('./icon-87babf0a.js')).default,\n            getInterface: async ({ EventEmitter, BigNumber, chains }) => {\n                const { Magic, RPCErrorCode } = await import('magic-sdk');\n                const loginModal = (await import('./login-modal-59f258c3.js')).default;\n                const brandingHTML = (await import('./branding-111ba967.js')).default;\n                let loggedIn = false;\n                const { createEIP1193Provider, ProviderRpcErrorCode, ProviderRpcError } = await import('@web3-onboard/common');\n                const emitter = new EventEmitter();\n                if (!chains.length)\n                    throw new Error('Atleast one Chain must be passed to onboard in order to connect');\n                let currentChain = chains[0];\n                let customNodeOptions = {\n                    chainId: parseInt(currentChain.id),\n                    rpcUrl: currentChain.rpcUrl\n                };\n                let magicInstance = new Magic(apiKey, {\n                    network: customNodeOptions\n                });\n                const loginWithEmail = async (emailAddress) => {\n                    try {\n                        await magicInstance.auth.loginWithMagicLink({ email: emailAddress });\n                        return await magicInstance.user.isLoggedIn();\n                    }\n                    catch (err) {\n                        throw new Error(`An error occurred while connecting your Magic wallet, please try again: ${err}`);\n                    }\n                };\n                const handleLogin = async () => {\n                    loggedIn = await loginModal({\n                        walletName: walletName,\n                        brandingHTMLString: brandingHTML,\n                        emailLoginFunction: loginWithEmail\n                    });\n                };\n                let magicProvider = magicInstance.rpcProvider;\n                let provider;\n                let activeAddress;\n                function patchProvider() {\n                    const patchedProvider = createEIP1193Provider(magicProvider, {\n                        eth_requestAccounts: async ({ baseRequest }) => {\n                            try {\n                                if (!loggedIn)\n                                    await handleLogin();\n                                const accounts = await baseRequest({ method: 'eth_accounts' });\n                                activeAddress = accounts[0];\n                                return accounts;\n                            }\n                            catch (error) {\n                                const { code } = error;\n                                if (code === RPCErrorCode.InternalError) {\n                                    throw new ProviderRpcError({\n                                        code: ProviderRpcErrorCode.ACCOUNT_ACCESS_REJECTED,\n                                        message: 'Account access rejected'\n                                    });\n                                }\n                                return [];\n                            }\n                        },\n                        eth_selectAccounts: null,\n                        eth_getBalance: async ({ baseRequest }) => {\n                            const balance = await baseRequest({\n                                method: 'eth_getBalance',\n                                params: [activeAddress, 'latest']\n                            });\n                            return balance\n                                ? BigNumber.from(balance).mul('1000000000000000000').toString()\n                                : '0';\n                        },\n                        wallet_switchEthereumChain: async ({ params }) => {\n                            const chain = chains.find(({ id }) => id === params[0].chainId);\n                            if (!chain)\n                                throw new Error('Chain must be set before switching');\n                            currentChain = chain;\n                            // re-instantiate instance with new network\n                            customNodeOptions = {\n                                chainId: parseInt(currentChain.id),\n                                rpcUrl: currentChain.rpcUrl\n                            };\n                            magicInstance = new Magic(apiKey, {\n                                network: customNodeOptions\n                            });\n                            magicProvider = magicInstance.rpcProvider;\n                            emitter.emit('chainChanged', currentChain.id);\n                            patchProvider();\n                            return null;\n                        },\n                        eth_sign: async ({ params }) => {\n                            const receipt = await magicProvider.send('eth_sign', params);\n                            return receipt &&\n                                receipt.hasOwnProperty('tx') &&\n                                receipt.tx.hasOwnProperty('hash')\n                                ? receipt.tx.hash\n                                : '';\n                        },\n                        eth_signTypedData: async ({ params }) => {\n                            const receipt = await magicProvider.send('eth_sign', params);\n                            return receipt &&\n                                receipt.hasOwnProperty('tx') &&\n                                receipt.tx.hasOwnProperty('hash')\n                                ? receipt.tx.hash\n                                : '';\n                        },\n                        eth_chainId: async () => currentChain && currentChain.hasOwnProperty('id')\n                            ? currentChain.id\n                            : '0x1',\n                        eth_signTransaction: async ({ params: [transactionObject] }) => {\n                            let destination;\n                            if (transactionObject.hasOwnProperty('to')) {\n                                destination = transactionObject.to;\n                            }\n                            const receipt = await magicProvider.send('eth_signTransaction', [\n                                {\n                                    ...transactionObject,\n                                    nonce: transactionObject.hasOwnProperty('nonce') &&\n                                        typeof transactionObject.nonce === 'number'\n                                        ? parseInt(transactionObject.nonce)\n                                        : '',\n                                    from: activeAddress,\n                                    to: destination\n                                }\n                            ]);\n                            return receipt &&\n                                receipt.hasOwnProperty('tx') &&\n                                receipt.tx.hasOwnProperty('hash')\n                                ? receipt.tx.hash\n                                : '';\n                        }\n                    });\n                    if (!provider) {\n                        patchedProvider.on = emitter.on.bind(emitter);\n                        patchedProvider.disconnect = () => magicInstance.user.logout();\n                        return patchedProvider;\n                    }\n                    else {\n                        provider.request = patchedProvider.request.bind(patchedProvider);\n                        // @ts-ignore - bind old methods for backwards compat\n                        provider.send = patchedProvider.send.bind(patchedProvider);\n                        // @ts-ignore - bind old methods for backwards compat\n                        provider.sendAsync = patchedProvider.sendAsync.bind(patchedProvider);\n                        return provider;\n                    }\n                }\n                provider = patchProvider();\n                return {\n                    provider,\n                    instance: magicInstance\n                };\n            }\n        };\n    };\n}\n\nexport { magic as default };\n"],
  "mappings": "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",
  "names": []
}
