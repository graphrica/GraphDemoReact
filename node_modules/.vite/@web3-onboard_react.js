import {
  require_lodash
} from "./chunk-NJCSFN6D.js";
import {
  ProviderRpcErrorCode,
  SofiaProRegular,
  require_joi_browser_min
} from "./chunk-QLIZTXI5.js";
import {
  __assign,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __extends,
  __generator,
  __read,
  __spreadArray,
  __values
} from "./chunk-BRDLAWJG.js";
import {
  require_react
} from "./chunk-M6NHTCMH.js";
import "./chunk-RFCOJ5N5.js";
import {
  BaseContract,
  Contract,
  ContractFactory,
  Wallet,
  commify,
  formatEther,
  formatUnits,
  keccak256,
  pack,
  parseEther,
  parseUnits,
  sha256,
  verifyMessage,
  verifyTypedData
} from "./chunk-AAFDKQNN.js";
import {
  require_aes_js
} from "./chunk-YSJ6UD5Q.js";
import "./chunk-WBSSQYQH.js";
import "./chunk-GZNO4Y3K.js";
import {
  require_bech32
} from "./chunk-77TI47IA.js";
import {
  require_scrypt
} from "./chunk-DJCW4LVW.js";
import "./chunk-VFG3R5NB.js";
import "./chunk-QLJNFGTT.js";
import {
  require_sha3
} from "./chunk-HEQAI6WE.js";
import {
  require_hash
} from "./chunk-QMSD3UEV.js";
import "./chunk-27CSTQIU.js";
import {
  require_bn
} from "./chunk-VIQ6GMKA.js";
import "./chunk-PX4IM7JA.js";
import {
  __commonJS,
  __export,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toESM,
  init_define_process_env
} from "./chunk-KJE66DWM.js";

// node_modules/lodash.partition/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.partition/index.js"(exports, module) {
    init_define_process_env();
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER9 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key6) {
      return function(object) {
        return object == null ? void 0 : object[key6];
      };
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key6) {
      return object == null ? void 0 : object[key6];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key6) {
        result[++index] = [key6, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto2 = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto2.hasOwnProperty;
    var objectToString = objectProto2.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key6) {
      return this.has(key6) && delete this.__data__[key6];
    }
    function hashGet(key6) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key6];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key6) ? data[key6] : void 0;
    }
    function hashHas(key6) {
      var data = this.__data__;
      return nativeCreate ? data[key6] !== void 0 : hasOwnProperty.call(data, key6);
    }
    function hashSet(key6, value) {
      var data = this.__data__;
      data[key6] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key6) {
      var data = this.__data__, index = assocIndexOf(data, key6);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key6) {
      var data = this.__data__, index = assocIndexOf(data, key6);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key6) {
      return assocIndexOf(this.__data__, key6) > -1;
    }
    function listCacheSet(key6, value) {
      var data = this.__data__, index = assocIndexOf(data, key6);
      if (index < 0) {
        data.push([key6, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key6) {
      return getMapData(this, key6)["delete"](key6);
    }
    function mapCacheGet(key6) {
      return getMapData(this, key6).get(key6);
    }
    function mapCacheHas(key6) {
      return getMapData(this, key6).has(key6);
    }
    function mapCacheSet(key6, value) {
      getMapData(this, key6).set(key6, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key6) {
      return this.__data__["delete"](key6);
    }
    function stackGet(key6) {
      return this.__data__.get(key6);
    }
    function stackHas(key6) {
      return this.__data__.has(key6);
    }
    function stackSet(key6, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs2 = cache.__data__;
        if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
          pairs2.push([key6, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs2);
      }
      cache.set(key6, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray4(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key6 in value) {
        if ((inherited || hasOwnProperty.call(value, key6)) && !(skipIndexes && (key6 == "length" || isIndex(key6, length)))) {
          result.push(key6);
        }
      }
      return result;
    }
    function assocIndexOf(array, key6) {
      var length = array.length;
      while (length--) {
        if (eq16(array[length][0], key6)) {
          return length;
        }
      }
      return -1;
    }
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key6, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key6) {
      return object != null && key6 in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray4(object), othIsArr = isArray4(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key6 = data[0], objValue = object[key6], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key6 in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key6, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity3;
      }
      if (typeof value == "object") {
        return isArray4(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key6 in Object(object)) {
        if (hasOwnProperty.call(object, key6) && key6 != "constructor") {
          result.push(key6);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get2(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray4(value) ? value : stringToPath(value);
    }
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray4(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
      };
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike2(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key6 = props[fromRight ? length : ++index];
          if (iteratee(iterable[key6], key6, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq16(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key6 = objProps[index];
        if (!(isPartial ? key6 in other : hasOwnProperty.call(other, key6))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key6 = objProps[index];
        var objValue = object[key6], othValue = other[key6];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key6, other, object, stack) : customizer(objValue, othValue, key6, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key6 == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map2, key6) {
      var data = map2.__data__;
      return isKeyable(key6) ? data[typeof key6 == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key6 = result[length], value = object[key6];
        result[length] = [key6, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key6) {
      var value = getValue(object, key6);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key6 = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key6))) {
          break;
        }
        object = object[key6];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key6, length) && (isArray4(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER9 : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray4(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key6, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key6] === srcValue && (srcValue !== void 0 || key6 in Object(object));
      };
    }
    var stringToPath = memoize2(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var partition4 = createAggregator(function(result, value, key6) {
      result[key6 ? 0 : 1].push(value);
    }, function() {
      return [[], []];
    });
    function memoize2(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key6 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key6)) {
          return cache.get(key6);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key6, result);
        return result;
      };
      memoized.cache = new (memoize2.Cache || MapCache)();
      return memoized;
    }
    memoize2.Cache = MapCache;
    function eq16(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray4 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike2(value);
    }
    function isFunction2(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER9;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get2(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity3(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module.exports = partition4;
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element2) {
        return cloneUnlessOtherwiseSpecified(element2, options);
      });
    }
    function getMergeFunction(key6, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key6);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_2) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key6) {
      return propertyIsOnObject(target, key6) && !(Object.hasOwnProperty.call(target, key6) && Object.propertyIsEnumerable.call(target, key6));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key6) {
          destination[key6] = cloneUnlessOtherwiseSpecified(target[key6], options);
        });
      }
      getKeys(source).forEach(function(key6) {
        if (propertyIsUnsafe(target, key6)) {
          return;
        }
        if (propertyIsOnObject(target, key6) && options.isMergeableObject(source[key6])) {
          destination[key6] = getMergeFunction(key6, options)(target[key6], source[key6], options);
        } else {
          destination[key6] = cloneUnlessOtherwiseSpecified(source[key6], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// node_modules/@web3-onboard/core/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@web3-onboard/core/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    init_define_process_env();
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context2, once) {
      this.fn = fn;
      this.context = context2;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context2, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0)
        return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2))
          names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
        ee2[i2] = handlers[i2].fn;
      }
      return ee2;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once)
            this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                  args[j2 - 1] = arguments[j2];
                }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context2) {
      return addListener(this, event, fn, context2, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context2) {
      return addListener(this, event, fn, context2, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
            events.push(listeners[i2]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if (typeof module !== "undefined") {
      module.exports = EventEmitter2;
    }
  }
});

// dep:@web3-onboard_react
init_define_process_env();

// node_modules/@web3-onboard/react/dist/index.js
init_define_process_env();
var import_react = __toESM(require_react(), 1);

// node_modules/@web3-onboard/core/dist/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Observable.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Subscriber.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isFunction.js
init_define_process_env();
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Subscription.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
init_define_process_env();
function createErrorClass(createImpl) {
  var _super = function(instance2) {
    Error.call(instance2);
    instance2.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
init_define_process_env();
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a2, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return))
                _a2.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a2;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty3 = new Subscription2();
    empty3.closed = true;
    return empty3;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/config.js
init_define_process_env();
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
init_define_process_env();
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/noop.js
init_define_process_env();
function noop() {
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
init_define_process_env();
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/errorContext.js
init_define_process_env();
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a2 = context, errorThrown = _a2.errorThrown, error = _a2.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/symbol/observable.js
init_define_process_env();
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/pipe.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/identity.js
init_define_process_env();
function identity(x2) {
  return x2;
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe3) {
    if (subscribe3) {
      this._subscribe = subscribe3;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a2 = _this, operator = _a2.operator, source = _a2.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a2;
    return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe3) {
    return new Observable2(subscribe3);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a2;
  return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/refCount.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/lift.js
init_define_process_env();
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init8) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init8(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
init_define_process_env();
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a2;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a2 = this.onFinalize) === null || _a2 === void 0 ? void 0 : _a2.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
init_define_process_env();
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
init_define_process_env();
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  var schedule = animationFrameProvider.schedule;
  return new Observable(function(subscriber) {
    var subscription = new Subscription();
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var run3 = function(timestamp2) {
      var now3 = provider.now();
      subscriber.next({
        timestamp: timestampProvider ? now3 : timestamp2,
        elapsed: now3 - start
      });
      if (!subscriber.closed) {
        subscription.add(schedule(run3));
      }
    };
    subscription.add(schedule(run3));
    return subscription;
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Subject.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
init_define_process_env();
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a2;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return))
              _a2.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a2;
      return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b === void 0 ? void 0 : _b.call(_a2, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b === void 0 ? void 0 : _b.call(_a2, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b === void 0 ? void 0 : _b.call(_a2);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a2, _b;
    return (_b = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
init_define_process_env();
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, _value = _a2._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
init_define_process_env();
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a2 = this, isStopped = _a2.isStopped, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow, _timestampProvider = _a2._timestampProvider, _windowTime = _a2._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a2 = this, _infiniteTimeWindow = _a2._infiniteTimeWindow, _buffer = _a2._buffer;
    var copy = _buffer.slice();
    for (var i2 = 0; i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i2]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a2 = this, _bufferSize = _a2._bufferSize, _timestampProvider = _a2._timestampProvider, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now3 = _timestampProvider.now();
      var last3 = 0;
      for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now3; i2 += 2) {
        last3 = i2;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
init_define_process_env();
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a2 = this, hasError = _a2.hasError, _hasValue = _a2._hasValue, _value = _a2._value, thrownError = _a2.thrownError, isStopped = _a2.isStopped, _isComplete = _a2._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a2 = this, _hasValue = _a2._hasValue, _value = _a2._value, _isComplete = _a2._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
init_define_process_env();
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
init_define_process_env();
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state2;
    var id7 = this.id;
    var scheduler = this.scheduler;
    if (id7 != null) {
      this.id = this.recycleAsyncId(scheduler, id7, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id7, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id7;
    }
    intervalProvider.clearInterval(id7);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state2, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state2, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state2, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state2);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a2 = this, id7 = _a2.id, scheduler = _a2.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id7 != null) {
        this.id = this.recycleAsyncId(scheduler, id7, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/Immediate.js
init_define_process_env();
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id7, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id7, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id7, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id7, delay2);
    }
    if (!scheduler.actions.some(function(action) {
      return action.id === id7;
    })) {
      immediateProvider.clearImmediate(id7);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Scheduler.js
init_define_process_env();
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now3) {
    if (now3 === void 0) {
      now3 = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now3;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state2, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now3) {
    if (now3 === void 0) {
      now3 = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now3) || this;
    _this.actions = [];
    _this._active = false;
    _this._scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/async.js
init_define_process_env();
var asyncScheduler = new AsyncScheduler(AsyncAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
init_define_process_env();
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state2, delay2);
    }
    this.delay = delay2;
    this.state = state2;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state2, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay2) : this._execute(state2, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id7, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id7, delay2);
    }
    return scheduler.flush(this);
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
init_define_process_env();
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
init_define_process_env();
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id7, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id7, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id7, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id7, delay2);
    }
    if (!scheduler.actions.some(function(action) {
      return action.id === id7;
    })) {
      animationFrameProvider.cancelAnimationFrame(id7);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
init_define_process_env();
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
init_define_process_env();
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state2, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state2, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id7, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return true;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id7, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state2, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state2, delay2);
    }
  };
  VirtualAction2.sortActions = function(a2, b2) {
    if (a2.delay === b2.delay) {
      if (a2.index === b2.index) {
        return 0;
      } else if (a2.index > b2.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a2.delay > b2.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Notification.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/empty.js
init_define_process_env();
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/of.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/args.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
init_define_process_env();
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/from.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
init_define_process_env();
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isPromise.js
init_define_process_env();
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
init_define_process_env();
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
init_define_process_env();
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
init_define_process_env();
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isIterable.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
init_define_process_env();
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
init_define_process_env();
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a2, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a2 = _b.sent(), value = _a2.value, done = _a2.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise2) {
  return new Observable(function(subscriber) {
    promise2.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a2;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a2 = iterable_1.return))
          _a2.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a2;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a2.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
init_define_process_env();
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
init_define_process_env();
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
init_define_process_env();
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
init_define_process_env();
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i2 = 0;
    return scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
init_define_process_env();
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a2;
        var value;
        var done;
        try {
          _a2 = iterator2.next(), value = _a2.value, done = _a2.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
init_define_process_env();
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
init_define_process_env();
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/throwError.js
init_define_process_env();
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init8 = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init8, 0, subscriber);
  } : init8);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a2 = this, kind = _a2.kind, value = _a2.value, error = _a2.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a2;
    return isFunction((_a2 = nextOrObserver) === null || _a2 === void 0 ? void 0 : _a2.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a2 = this, kind = _a2.kind, value = _a2.value, error = _a2.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a2, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a2 = observer.next) === null || _a2 === void 0 ? void 0 : _a2.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isObservable.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
init_define_process_env();
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
init_define_process_env();
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
init_define_process_env();
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
init_define_process_env();
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
init_define_process_env();
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/timeout.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/isDate.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/bindCallback.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/bindCallbackInternals.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/map.js
init_define_process_env();
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/bindNodeCallback.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
init_define_process_env();
var isArray2 = Array.isArray;
var objectProto = Object.prototype;

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/createObject.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/concat.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/connectable.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/defer.js
init_define_process_env();
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/fromEventPattern.js
init_define_process_env();
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e[_i] = arguments[_i];
      }
      return subscriber.next(e.length === 1 ? e[0] : e);
    };
    var retValue = addHandler(handler);
    return isFunction(removeHandler) ? function() {
      return removeHandler(handler, retValue);
    } : void 0;
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/generate.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/iif.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/interval.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/timer.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/merge.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/never.js
init_define_process_env();
var NEVER = new Observable(noop);

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/onErrorResumeNext.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/onErrorResumeNext.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
init_define_process_env();
var isArray3 = Array.isArray;

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/pairs.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/partition.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/util/not.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/filter.js
init_define_process_env();
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/race.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/range.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/using.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/zip.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/types.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/audit.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/auditTime.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/buffer.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/bufferTime.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/bufferToggle.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/bufferWhen.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/catchError.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/combineAll.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/combineLatestAll.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/joinAllInternals.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/toArray.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/reduce.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/concatMapTo.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/concatWith.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/concat.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/connect.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/observable/fromSubscribable.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/count.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/debounce.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/delay.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/delayWhen.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/take.js
init_define_process_env();
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mapTo.js
init_define_process_env();
function mapTo(value) {
  return map(function() {
    return value;
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/dematerialize.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/distinct.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
init_define_process_env();
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a2, b2) {
  return a2 === b2;
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js
init_define_process_env();
function distinctUntilKeyChanged(key6, compare) {
  return distinctUntilChanged(function(x2, y) {
    return compare ? compare(x2[key6], y[key6]) : x2[key6] === y[key6];
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/elementAt.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/endWith.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/every.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/exhaust.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/exhaustAll.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/exhaustMap.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/expand.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/finalize.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/find.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/findIndex.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/first.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/groupBy.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/isEmpty.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/last.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/takeLast.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/materialize.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/max.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/flatMap.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mergeMapTo.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mergeScan.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/merge.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/min.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/multicast.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/pairwise.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/pluck.js
init_define_process_env();
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return map(function(x2) {
    var currentProp = x2;
    for (var i2 = 0; i2 < length; i2++) {
      var p2 = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i2]];
      if (typeof p2 !== "undefined") {
        currentProp = p2;
      } else {
        return void 0;
      }
    }
    return currentProp;
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/publish.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/publishBehavior.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/publishLast.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/publishReplay.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/raceWith.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/repeat.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/repeatWhen.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/retry.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/retryWhen.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/sample.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/sampleTime.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/scan.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/sequenceEqual.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/share.js
init_define_process_env();
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.connector, connector = _a2 === void 0 ? function() {
    return new Subject();
  } : _a2, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection = null;
    var resetConnection = null;
    var subject = null;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = null;
    };
    var reset = function() {
      cancelReset();
      connection = subject = null;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        from(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return null;
  }
  if (on === false) {
    return null;
  }
  return on.apply(void 0, __spreadArray([], __read(args))).pipe(take(1)).subscribe(function() {
    return reset();
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
init_define_process_env();
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a2, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a2 = configOrBufferSize.bufferSize, bufferSize = _a2 === void 0 ? Infinity : _a2, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/single.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/skip.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/skipLast.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/skipUntil.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/skipWhile.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/startWith.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/switchAll.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
init_define_process_env();
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/switchMapTo.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/switchScan.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
init_define_process_env();
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/tap.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/throttle.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/throttleTime.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/timeInterval.js
init_define_process_env();
var TimeInterval = function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/timeoutWith.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/timestamp.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/window.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/windowCount.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/windowTime.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/windowToggle.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/windowWhen.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js
init_define_process_env();
function withLatestFrom() {
  var inputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputs[_i] = arguments[_i];
  }
  var project = popResultSelector(inputs);
  return operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i3) {
      innerFrom(inputs[i3]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        otherValues[i3] = value;
        if (!ready && !hasValue[i3]) {
          hasValue[i3] = true;
          (ready = hasValue.every(identity)) && (hasValue = null);
        }
      }, noop));
    };
    for (var i2 = 0; i2 < len; i2++) {
      _loop_1(i2);
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (ready) {
        var values = __spreadArray([value], __read(otherValues));
        subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
      }
    }));
  });
}

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/zipAll.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/zipWith.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/zip.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/operators/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/partition.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/rxjs/dist/esm5/internal/operators/race.js
init_define_process_env();

// node_modules/bowser/src/bowser.js
init_define_process_env();

// node_modules/bowser/src/parser.js
init_define_process_env();

// node_modules/bowser/src/parser-browsers.js
init_define_process_env();

// node_modules/bowser/src/utils.js
init_define_process_env();

// node_modules/bowser/src/constants.js
init_define_process_env();
var BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
var BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
var PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
var OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
var ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};

// node_modules/bowser/src/utils.js
var Utils = class {
  static getFirstMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 0 && match[1] || "";
  }
  static getSecondMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 1 && match[2] || "";
  }
  static matchAndReturnConst(regexp, ua, _const) {
    if (regexp.test(ua)) {
      return _const;
    }
    return void 0;
  }
  static getWindowsVersionName(version130) {
    switch (version130) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return void 0;
    }
  }
  static getMacOSVersionName(version130) {
    const v2 = version130.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v2.push(0);
    if (v2[0] !== 10)
      return void 0;
    switch (v2[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return void 0;
    }
  }
  static getAndroidVersionName(version130) {
    const v2 = version130.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v2.push(0);
    if (v2[0] === 1 && v2[1] < 5)
      return void 0;
    if (v2[0] === 1 && v2[1] < 6)
      return "Cupcake";
    if (v2[0] === 1 && v2[1] >= 6)
      return "Donut";
    if (v2[0] === 2 && v2[1] < 2)
      return "Eclair";
    if (v2[0] === 2 && v2[1] === 2)
      return "Froyo";
    if (v2[0] === 2 && v2[1] > 2)
      return "Gingerbread";
    if (v2[0] === 3)
      return "Honeycomb";
    if (v2[0] === 4 && v2[1] < 1)
      return "Ice Cream Sandwich";
    if (v2[0] === 4 && v2[1] < 4)
      return "Jelly Bean";
    if (v2[0] === 4 && v2[1] >= 4)
      return "KitKat";
    if (v2[0] === 5)
      return "Lollipop";
    if (v2[0] === 6)
      return "Marshmallow";
    if (v2[0] === 7)
      return "Nougat";
    if (v2[0] === 8)
      return "Oreo";
    if (v2[0] === 9)
      return "Pie";
    return void 0;
  }
  static getVersionPrecision(version130) {
    return version130.split(".").length;
  }
  static compareVersions(versionA, versionB, isLoose = false) {
    const versionAPrecision = Utils.getVersionPrecision(versionA);
    const versionBPrecision = Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision);
    let lastPrecision = 0;
    const chunks = Utils.map([versionA, versionB], (version130) => {
      const delta = precision - Utils.getVersionPrecision(version130);
      const _version = version130 + new Array(delta + 1).join(".0");
      return Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    if (isLoose) {
      lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
    }
    precision -= 1;
    while (precision >= lastPrecision) {
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision) {
          return 0;
        }
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision]) {
        return -1;
      }
    }
    return void 0;
  }
  static map(arr, iterator2) {
    const result = [];
    let i2;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator2);
    }
    for (i2 = 0; i2 < arr.length; i2 += 1) {
      result.push(iterator2(arr[i2]));
    }
    return result;
  }
  static find(arr, predicate) {
    let i2;
    let l2;
    if (Array.prototype.find) {
      return Array.prototype.find.call(arr, predicate);
    }
    for (i2 = 0, l2 = arr.length; i2 < l2; i2 += 1) {
      const value = arr[i2];
      if (predicate(value, i2)) {
        return value;
      }
    }
    return void 0;
  }
  static assign(obj, ...assigners) {
    const result = obj;
    let i2;
    let l2;
    if (Object.assign) {
      return Object.assign(obj, ...assigners);
    }
    for (i2 = 0, l2 = assigners.length; i2 < l2; i2 += 1) {
      const assigner = assigners[i2];
      if (typeof assigner === "object" && assigner !== null) {
        const keys = Object.keys(assigner);
        keys.forEach((key6) => {
          result[key6] = assigner[key6];
        });
      }
    }
    return obj;
  }
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
};

// node_modules/bowser/src/parser-browsers.js
var commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
var browsersList = [
  {
    test: [/googlebot/i],
    describe(ua) {
      const browser = {
        name: "Googlebot"
      };
      const version130 = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/opera/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/opr\/|opios/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version130 = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua) {
      const browser = {
        name: "Samsung Internet for Android"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/Whale/i],
    describe(ua) {
      const browser = {
        name: "NAVER Whale Browser"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua) {
      const browser = {
        name: "MZ Browser"
      };
      const version130 = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/focus/i],
    describe(ua) {
      const browser = {
        name: "Focus"
      };
      const version130 = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/swing/i],
    describe(ua) {
      const browser = {
        name: "Swing"
      };
      const version130 = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/coast/i],
    describe(ua) {
      const browser = {
        name: "Opera Coast"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua) {
      const browser = {
        name: "Opera Touch"
      };
      const version130 = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua) {
      const browser = {
        name: "Yandex Browser"
      };
      const version130 = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua) {
      const browser = {
        name: "UC Browser"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua) {
      const browser = {
        name: "Maxthon"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua) {
      const browser = {
        name: "Epiphany"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/puffin/i],
    describe(ua) {
      const browser = {
        name: "Puffin"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua) {
      const browser = {
        name: "Sleipnir"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua) {
      const browser = {
        name: "K-Meleon"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua) {
      const browser = {
        name: "WeChat"
      };
      const version130 = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua) {
      const browser = {
        name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
      };
      const version130 = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua) {
      const browser = {
        name: "Internet Explorer"
      };
      const version130 = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version130 = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version130 = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua) {
      const browser = {
        name: "Vivaldi"
      };
      const version130 = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua) {
      const browser = {
        name: "SeaMonkey"
      };
      const version130 = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua) {
      const browser = {
        name: "Sailfish"
      };
      const version130 = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/silk/i],
    describe(ua) {
      const browser = {
        name: "Amazon Silk"
      };
      const version130 = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/phantom/i],
    describe(ua) {
      const browser = {
        name: "PhantomJS"
      };
      const version130 = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua) {
      const browser = {
        name: "SlimerJS"
      };
      const version130 = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const browser = {
        name: "BlackBerry"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const browser = {
        name: "WebOS Browser"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const browser = {
        name: "Bada"
      };
      const version130 = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const browser = {
        name: "Tizen"
      };
      const version130 = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua) {
      const browser = {
        name: "QupZilla"
      };
      const version130 = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua) {
      const browser = {
        name: "Firefox"
      };
      const version130 = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/electron/i],
    describe(ua) {
      const browser = {
        name: "Electron"
      };
      const version130 = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua) {
      const browser = {
        name: "Miui"
      };
      const version130 = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/chromium/i],
    describe(ua) {
      const browser = {
        name: "Chromium"
      };
      const version130 = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua) {
      const browser = {
        name: "Chrome"
      };
      const version130 = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/GSA/i],
    describe(ua) {
      const browser = {
        name: "Google Search"
      };
      const version130 = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const browser = {
        name: "Android Browser"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/playstation 4/i],
    describe(ua) {
      const browser = {
        name: "PlayStation 4"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/safari|applewebkit/i],
    describe(ua) {
      const browser = {
        name: "Safari"
      };
      const version130 = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version130) {
        browser.version = version130;
      }
      return browser;
    }
  },
  {
    test: [/.*/i],
    describe(ua) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
      const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
      const hasDeviceSpec = ua.search("\\(") !== -1;
      const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua),
        version: Utils.getSecondMatch(regexp, ua)
      };
    }
  }
];
var parser_browsers_default = browsersList;

// node_modules/bowser/src/parser-os.js
init_define_process_env();
var parser_os_default = [
  {
    test: [/Roku\/DVP/],
    describe(ua) {
      const version130 = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
      return {
        name: OS_MAP.Roku,
        version: version130
      };
    }
  },
  {
    test: [/windows phone/i],
    describe(ua) {
      const version130 = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.WindowsPhone,
        version: version130
      };
    }
  },
  {
    test: [/windows /i],
    describe(ua) {
      const version130 = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua);
      const versionName = Utils.getWindowsVersionName(version130);
      return {
        name: OS_MAP.Windows,
        version: version130,
        versionName
      };
    }
  },
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua) {
      const result = {
        name: OS_MAP.iOS
      };
      const version130 = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
      if (version130) {
        result.version = version130;
      }
      return result;
    }
  },
  {
    test: [/macintosh/i],
    describe(ua) {
      const version130 = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, ".");
      const versionName = Utils.getMacOSVersionName(version130);
      const os = {
        name: OS_MAP.MacOS,
        version: version130
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua) {
      const version130 = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version: version130
      };
    }
  },
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const version130 = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua);
      const versionName = Utils.getAndroidVersionName(version130);
      const os = {
        name: OS_MAP.Android,
        version: version130
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const version130 = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua);
      const os = {
        name: OS_MAP.WebOS
      };
      if (version130 && version130.length) {
        os.version = version130;
      }
      return os;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const version130 = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils.getFirstMatch(/\bbb(\d+)/i, ua);
      return {
        name: OS_MAP.BlackBerry,
        version: version130
      };
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const version130 = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Bada,
        version: version130
      };
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const version130 = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Tizen,
        version: version130
      };
    }
  },
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  {
    test: [/PlayStation 4/],
    describe(ua) {
      const version130 = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.PlayStation4,
        version: version130
      };
    }
  }
];

// node_modules/bowser/src/parser-platforms.js
init_define_process_env();
var parser_platforms_default = [
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  {
    test: [/huawei/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua) && "Nova";
      const platform = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      if (model) {
        platform.model = model;
      }
      return platform;
    }
  },
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  {
    test(parser) {
      const iDevice = parser.test(/ipod|iphone/i);
      const likeIDevice = parser.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser) {
      return parser.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  {
    test(parser) {
      return parser.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser) {
      return parser.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  {
    test(parser) {
      const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
      return parser.getOSName(true) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
];

// node_modules/bowser/src/parser-engines.js
init_define_process_env();
var parser_engines_default = [
  {
    test(parser) {
      return parser.getBrowserName(true) === "microsoft edge";
    },
    describe(ua) {
      const isBlinkBased = /\sedg\//i.test(ua);
      if (isBlinkBased) {
        return {
          name: ENGINE_MAP.Blink
        };
      }
      const version130 = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version: version130
      };
    }
  },
  {
    test: [/trident/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Trident
      };
      const version130 = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        engine.version = version130;
      }
      return engine;
    }
  },
  {
    test(parser) {
      return parser.test(/presto/i);
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Presto
      };
      const version130 = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        engine.version = version130;
      }
      return engine;
    }
  },
  {
    test(parser) {
      const isGecko = parser.test(/gecko/i);
      const likeGecko = parser.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Gecko
      };
      const version130 = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        engine.version = version130;
      }
      return engine;
    }
  },
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  {
    test: [/(apple)?webkit/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.WebKit
      };
      const version130 = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
      if (version130) {
        engine.version = version130;
      }
      return engine;
    }
  }
];

// node_modules/bowser/src/parser.js
var Parser = class {
  constructor(UA, skipParsing = false) {
    if (UA === void 0 || UA === null || UA === "") {
      throw new Error("UserAgent parameter can't be empty");
    }
    this._ua = UA;
    this.parsedResult = {};
    if (skipParsing !== true) {
      this.parse();
    }
  }
  getUA() {
    return this._ua;
  }
  test(regex) {
    return regex.test(this._ua);
  }
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(parser_browsers_default, (_browser) => {
      if (typeof _browser.test === "function") {
        return _browser.test(this);
      }
      if (_browser.test instanceof Array) {
        return _browser.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (browserDescriptor) {
      this.parsedResult.browser = browserDescriptor.describe(this.getUA());
    }
    return this.parsedResult.browser;
  }
  getBrowser() {
    if (this.parsedResult.browser) {
      return this.parsedResult.browser;
    }
    return this.parseBrowser();
  }
  getBrowserName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getBrowser().name).toLowerCase() || "";
    }
    return this.getBrowser().name || "";
  }
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  getOS() {
    if (this.parsedResult.os) {
      return this.parsedResult.os;
    }
    return this.parseOS();
  }
  parseOS() {
    this.parsedResult.os = {};
    const os = Utils.find(parser_os_default, (_os) => {
      if (typeof _os.test === "function") {
        return _os.test(this);
      }
      if (_os.test instanceof Array) {
        return _os.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (os) {
      this.parsedResult.os = os.describe(this.getUA());
    }
    return this.parsedResult.os;
  }
  getOSName(toLowerCase) {
    const { name: name2 } = this.getOS();
    if (toLowerCase) {
      return String(name2).toLowerCase() || "";
    }
    return name2 || "";
  }
  getOSVersion() {
    return this.getOS().version;
  }
  getPlatform() {
    if (this.parsedResult.platform) {
      return this.parsedResult.platform;
    }
    return this.parsePlatform();
  }
  getPlatformType(toLowerCase = false) {
    const { type } = this.getPlatform();
    if (toLowerCase) {
      return String(type).toLowerCase() || "";
    }
    return type || "";
  }
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform = Utils.find(parser_platforms_default, (_platform) => {
      if (typeof _platform.test === "function") {
        return _platform.test(this);
      }
      if (_platform.test instanceof Array) {
        return _platform.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (platform) {
      this.parsedResult.platform = platform.describe(this.getUA());
    }
    return this.parsedResult.platform;
  }
  getEngine() {
    if (this.parsedResult.engine) {
      return this.parsedResult.engine;
    }
    return this.parseEngine();
  }
  getEngineName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getEngine().name).toLowerCase() || "";
    }
    return this.getEngine().name || "";
  }
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(parser_engines_default, (_engine) => {
      if (typeof _engine.test === "function") {
        return _engine.test(this);
      }
      if (_engine.test instanceof Array) {
        return _engine.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (engine) {
      this.parsedResult.engine = engine.describe(this.getUA());
    }
    return this.parsedResult.engine;
  }
  parse() {
    this.parseBrowser();
    this.parseOS();
    this.parsePlatform();
    this.parseEngine();
    return this;
  }
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    const allDefinitions = Object.keys(checkTree);
    allDefinitions.forEach((key6) => {
      const currentDefinition = checkTree[key6];
      if (typeof currentDefinition === "string") {
        browsers[key6] = currentDefinition;
        browsersCounter += 1;
      } else if (typeof currentDefinition === "object") {
        platformsAndOSes[key6] = currentDefinition;
        platformsAndOSCounter += 1;
      }
    });
    if (platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes);
      const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name2) => this.isOS(name2));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0) {
          return osResult;
        }
      }
      const platformMatchingDefinition = Utils.find(platformsAndOSNames, (name2) => this.isPlatform(name2));
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0) {
          return platformResult;
        }
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers);
      const matchingDefinition = Utils.find(browserNames, (name2) => this.isBrowser(name2, true));
      if (matchingDefinition !== void 0) {
        return this.compareVersion(browsers[matchingDefinition]);
      }
    }
    return void 0;
  }
  isBrowser(browserName, includingAlias = false) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    if (includingAlias && alias) {
      browserNameLower = alias.toLowerCase();
    }
    return browserNameLower === defaultBrowserName;
  }
  compareVersion(version130) {
    let expectedResults = [0];
    let comparableVersion = version130;
    let isLoose = false;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion !== "string") {
      return void 0;
    }
    if (version130[0] === ">" || version130[0] === "<") {
      comparableVersion = version130.substr(1);
      if (version130[1] === "=") {
        isLoose = true;
        comparableVersion = version130.substr(2);
      } else {
        expectedResults = [];
      }
      if (version130[0] === ">") {
        expectedResults.push(1);
      } else {
        expectedResults.push(-1);
      }
    } else if (version130[0] === "=") {
      comparableVersion = version130.substr(1);
    } else if (version130[0] === "~") {
      isLoose = true;
      comparableVersion = version130.substr(1);
    }
    return expectedResults.indexOf(Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)) > -1;
  }
  isOS(osName) {
    return this.getOSName(true) === String(osName).toLowerCase();
  }
  isPlatform(platformType) {
    return this.getPlatformType(true) === String(platformType).toLowerCase();
  }
  isEngine(engineName) {
    return this.getEngineName(true) === String(engineName).toLowerCase();
  }
  is(anything, includingAlias = false) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
};
var parser_default = Parser;

// node_modules/bowser/src/bowser.js
var Bowser = class {
  static getParser(UA, skipParsing = false) {
    if (typeof UA !== "string") {
      throw new Error("UserAgent should be a string");
    }
    return new parser_default(UA, skipParsing);
  }
  static parse(UA) {
    return new parser_default(UA).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
};
var bowser_default = Bowser;

// node_modules/@web3-onboard/core/dist/index.js
var import_joi = __toESM(require_joi_browser_min());
var import_lodash = __toESM(require_lodash2());

// node_modules/@web3-onboard/core/node_modules/ethers/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports,
  errors: () => ErrorCode15,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger142,
  providers: () => lib_exports3,
  utils: () => utils_exports,
  version: () => version129,
  wordlists: () => wordlists
});
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn = __toESM(require_bn());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX[value[i2] >> 4];
            hex += HEX[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version130) {
    return new Logger(version130);
  }
};
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version2 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger = new Logger(version2);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version3 = "bignumber/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN = import_bn.default.BN;
var logger2 = new Logger(version3);
var _constructorGuard = {};
var MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
var _warnedToStringRadix = false;
var BigNumber = class {
  constructor(constructorGuard, hex) {
    logger2.checkNew(new.target, BigNumber);
    if (constructorGuard !== _constructorGuard) {
      logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o = BigNumber.from(other);
    if (o.isZero()) {
      throwFault("division by zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("cannot modulo negative values", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("cannot raise to negative values", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'and' negative values", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'or' negative values", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("cannot 'xor' negative values", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot mask negative values", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot shift negative values", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("cannot shift negative values", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard, toHex(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard, toHex(new BN(value)));
      }
      return logger2.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger2.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger2.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger3 = new Logger(version3);
var _constructorGuard2 = {};
var Zero = BigNumber.from(0);
var NegativeOne = BigNumber.from(-1);
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
var zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger3.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger3.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger3.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var FixedFormat = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard2) {
      logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger3.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger3.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard2, signed, width, decimals);
  }
};
var FixedNumber = class {
  constructor(constructorGuard, hex, value, format) {
    logger3.checkNew(new.target, FixedNumber);
    if (constructorGuard !== _constructorGuard2) {
      logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger3.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero)) {
      throwFault2("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }
    if (isBytes(value)) {
      return FixedNumber.fromBytes(value, format);
    }
    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE = FixedNumber.from(1);
var BUMP = FixedNumber.from("0.5");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abstract-signer/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version4 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors2 = false;
var _censorErrors2 = false;
var LogLevels2 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel2 = LogLevels2["default"];
var _globalLogger2 = null;
function _checkNormalize2() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError2 = _checkNormalize2();
var LogLevel2;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel2 || (LogLevel2 = {}));
var ErrorCode2;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode2 || (ErrorCode2 = {}));
var HEX2 = "0123456789abcdef";
var Logger2 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels2[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel2 > LogLevels2[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger2.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger2.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger2.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors2) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger2.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX2[value[i2] >> 4];
            hex += HEX2[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode2.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode2.CALL_EXCEPTION:
      case ErrorCode2.INSUFFICIENT_FUNDS:
      case ErrorCode2.MISSING_NEW:
      case ErrorCode2.NONCE_EXPIRED:
      case ErrorCode2.REPLACEMENT_UNDERPRICED:
      case ErrorCode2.TRANSACTION_REPLACED:
      case ErrorCode2.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger2.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError2) {
      this.throwError("platform missing String.prototype.normalize", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError2
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger2.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger2.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger2.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger2) {
      _globalLogger2 = new Logger2(version4);
    }
    return _globalLogger2;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors2) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors2 = !!censorship;
    _permanentCensorErrors2 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels2[logLevel.toLowerCase()];
    if (level == null) {
      Logger2.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel2 = level;
  }
  static from(version130) {
    return new Logger2(version130);
  }
};
Logger2.errors = ErrorCode2;
Logger2.levels = LogLevel2;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version5 = "properties/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/properties/lib.esm/index.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger4 = new Logger2(version5);
function defineReadOnly(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function resolveProperties(object) {
  return __awaiter2(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key6) => {
      const value = object[key6];
      return Promise.resolve(value).then((v2) => ({ key: key6, value: v2 }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function shallowCopy(object) {
  const result = {};
  for (const key6 in object) {
    result[key6] = object[key6];
  }
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
init_define_process_env();
var version6 = "abstract-signer/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abstract-signer/lib.esm/index.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger5 = new Logger2(version6);
var allowedTransactionKeys = [
  "accessList",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
var forwardErrors = [
  Logger2.errors.INSUFFICIENT_FUNDS,
  Logger2.errors.NONCE_EXPIRED,
  Logger2.errors.REPLACEMENT_UNDERPRICED
];
var Signer = class {
  constructor() {
    logger5.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  getBalance(blockTag) {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  estimateGas(transaction) {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  call(transaction, blockTag) {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  sendTransaction(transaction) {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter3(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  checkTransaction(transaction) {
    for (const key6 in transaction) {
      if (allowedTransactionKeys.indexOf(key6) === -1) {
        logger5.throwArgumentError("invalid transaction key: " + key6, "transaction", transaction);
      }
    }
    const tx = shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger5.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  populateTransaction(transaction) {
    return __awaiter3(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter3(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger5.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger5.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger5.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger5.throwError("network does not support EIP-1559", Logger2.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger5.throwError("failed to get consistent fee data", Logger2.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger5.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger2.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger5.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  _checkProvider(operation) {
    if (!this.provider) {
      logger5.throwError("missing provider", Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
};
var VoidSigner = class extends Signer {
  constructor(address, provider) {
    logger5.checkNew(new.target, VoidSigner);
    super();
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "provider", provider || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger5.throwError(message, Logger2.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain, types, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  AddressZero: () => AddressZero,
  EtherSymbol: () => EtherSymbol,
  HashZero: () => HashZero,
  MaxInt256: () => MaxInt256,
  MaxUint256: () => MaxUint256,
  MinInt256: () => MinInt256,
  NegativeOne: () => NegativeOne3,
  One: () => One,
  Two: () => Two,
  WeiPerEther: () => WeiPerEther,
  Zero: () => Zero3
});
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();
var AddressZero = "0x0000000000000000000000000000000000000000";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn2 = __toESM(require_bn());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version7 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors3 = false;
var _censorErrors3 = false;
var LogLevels3 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel3 = LogLevels3["default"];
var _globalLogger3 = null;
function _checkNormalize3() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError3 = _checkNormalize3();
var LogLevel3;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel3 || (LogLevel3 = {}));
var ErrorCode3;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode3 || (ErrorCode3 = {}));
var HEX3 = "0123456789abcdef";
var Logger3 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels3[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel3 > LogLevels3[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger3.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger3.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger3.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors3) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger3.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX3[value[i2] >> 4];
            hex += HEX3[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode3.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode3.CALL_EXCEPTION:
      case ErrorCode3.INSUFFICIENT_FUNDS:
      case ErrorCode3.MISSING_NEW:
      case ErrorCode3.NONCE_EXPIRED:
      case ErrorCode3.REPLACEMENT_UNDERPRICED:
      case ErrorCode3.TRANSACTION_REPLACED:
      case ErrorCode3.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger3.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError3) {
      this.throwError("platform missing String.prototype.normalize", Logger3.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError3
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger3.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger3.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger3.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger3.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger3.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger3.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger3.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger3) {
      _globalLogger3 = new Logger3(version7);
    }
    return _globalLogger3;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger3.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors3) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger3.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors3 = !!censorship;
    _permanentCensorErrors3 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels3[logLevel.toLowerCase()];
    if (level == null) {
      Logger3.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel3 = level;
  }
  static from(version130) {
    return new Logger3(version130);
  }
};
Logger3.errors = ErrorCode3;
Logger3.levels = LogLevel3;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version8 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger6 = new Logger3(version8);
function isHexable2(value) {
  return !!value.toHexString;
}
function addSlice2(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice2(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger2(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes2(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger2(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger2(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify2(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger6.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice2(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable2(value)) {
    value = value.toHexString();
  }
  if (isHexString2(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger6.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice2(new Uint8Array(result));
  }
  if (isBytes2(value)) {
    return addSlice2(new Uint8Array(value));
  }
  return logger6.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString2(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters2 = "0123456789abcdef";
function hexlify2(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger6.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters2[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable2(value)) {
    return value.toHexString();
  }
  if (isHexString2(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger6.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes2(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters2[(v2 & 240) >> 4] + HexCharacters2[v2 & 15];
    }
    return result;
  }
  return logger6.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad2(value, length) {
  if (typeof value !== "string") {
    value = hexlify2(value);
  } else if (!isHexString2(value)) {
    logger6.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger6.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version9 = "bignumber/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN2 = import_bn2.default.BN;
var logger7 = new Logger3(version9);
var _constructorGuard3 = {};
var MAX_SAFE2 = 9007199254740991;
function isBigNumberish2(value) {
  return value != null && (BigNumber2.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString2(value) || typeof value === "bigint" || isBytes2(value));
}
var _warnedToStringRadix2 = false;
var BigNumber2 = class {
  constructor(constructorGuard, hex) {
    logger7.checkNew(new.target, BigNumber2);
    if (constructorGuard !== _constructorGuard3) {
      logger7.throwError("cannot call constructor directly; use BigNumber.from", Logger3.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber2(toBN2(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber2(toBN2(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber2.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber2(toBN2(this).add(toBN2(other)));
  }
  sub(other) {
    return toBigNumber2(toBN2(this).sub(toBN2(other)));
  }
  div(other) {
    const o = BigNumber2.from(other);
    if (o.isZero()) {
      throwFault3("division-by-zero", "div");
    }
    return toBigNumber2(toBN2(this).div(toBN2(other)));
  }
  mul(other) {
    return toBigNumber2(toBN2(this).mul(toBN2(other)));
  }
  mod(other) {
    const value = toBN2(other);
    if (value.isNeg()) {
      throwFault3("division-by-zero", "mod");
    }
    return toBigNumber2(toBN2(this).umod(value));
  }
  pow(other) {
    const value = toBN2(other);
    if (value.isNeg()) {
      throwFault3("negative-power", "pow");
    }
    return toBigNumber2(toBN2(this).pow(value));
  }
  and(other) {
    const value = toBN2(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault3("unbound-bitwise-result", "and");
    }
    return toBigNumber2(toBN2(this).and(value));
  }
  or(other) {
    const value = toBN2(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault3("unbound-bitwise-result", "or");
    }
    return toBigNumber2(toBN2(this).or(value));
  }
  xor(other) {
    const value = toBN2(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault3("unbound-bitwise-result", "xor");
    }
    return toBigNumber2(toBN2(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault3("negative-width", "mask");
    }
    return toBigNumber2(toBN2(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault3("negative-width", "shl");
    }
    return toBigNumber2(toBN2(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault3("negative-width", "shr");
    }
    return toBigNumber2(toBN2(this).shrn(value));
  }
  eq(other) {
    return toBN2(this).eq(toBN2(other));
  }
  lt(other) {
    return toBN2(this).lt(toBN2(other));
  }
  lte(other) {
    return toBN2(this).lte(toBN2(other));
  }
  gt(other) {
    return toBN2(this).gt(toBN2(other));
  }
  gte(other) {
    return toBN2(this).gte(toBN2(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN2(this).isZero();
  }
  toNumber() {
    try {
      return toBN2(this).toNumber();
    } catch (error) {
      throwFault3("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger7.throwError("this platform does not support BigInt", Logger3.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix2) {
          _warnedToStringRadix2 = true;
          logger7.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger7.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger3.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger7.throwError("BigNumber.toString does not accept parameters", Logger3.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN2(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber2) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber2(_constructorGuard3, toHex2(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber2(_constructorGuard3, toHex2(new BN2(value)));
      }
      return logger7.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault3("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE2 || value <= -MAX_SAFE2) {
        throwFault3("overflow", "BigNumber.from", value);
      }
      return BigNumber2.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber2.from(anyValue.toString());
    }
    if (isBytes2(anyValue)) {
      return BigNumber2.from(hexlify2(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber2.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString2(hex) || hex[0] === "-" && isHexString2(hex.substring(1))) {
            return BigNumber2.from(hex);
          }
        }
      }
    }
    return logger7.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex2(value) {
  if (typeof value !== "string") {
    return toHex2(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger7.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex2(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber2(value) {
  return BigNumber2.from(toHex2(value));
}
function toBN2(value) {
  const hex = BigNumber2.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN2("-" + hex.substring(3), 16);
  }
  return new BN2(hex.substring(2), 16);
}
function throwFault3(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger7.throwError(fault, Logger3.errors.NUMERIC_FAULT, params);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger8 = new Logger3(version9);
var _constructorGuard4 = {};
var Zero2 = BigNumber2.from(0);
var NegativeOne2 = BigNumber2.from(-1);
function throwFault4(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger8.throwError(message, Logger3.errors.NUMERIC_FAULT, params);
}
var zeros2 = "0";
while (zeros2.length < 256) {
  zeros2 += zeros2;
}
function getMultiplier2(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber2.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros2.substring(0, decimals);
  }
  return logger8.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed2(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier2(decimals);
  value = BigNumber2.from(value);
  const negative = value.lt(Zero2);
  if (negative) {
    value = value.mul(NegativeOne2);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed2(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier2(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger8.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger8.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger8.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault4("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber2.from(whole);
  const fractionValue = BigNumber2.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne2);
  }
  return wei;
}
var FixedFormat2 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard4) {
      logger8.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger3.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier2(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat2) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger8.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger8.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger8.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger8.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat2(_constructorGuard4, signed, width, decimals);
  }
};
var FixedNumber2 = class {
  constructor(constructorGuard, hex, value, format) {
    logger8.checkNew(new.target, FixedNumber2);
    if (constructorGuard !== _constructorGuard4) {
      logger8.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger3.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger8.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed2(this._value, this.format.decimals);
    const b2 = parseFixed2(other._value, other.format.decimals);
    return FixedNumber2.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed2(this._value, this.format.decimals);
    const b2 = parseFixed2(other._value, other.format.decimals);
    return FixedNumber2.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed2(this._value, this.format.decimals);
    const b2 = parseFixed2(other._value, other.format.decimals);
    return FixedNumber2.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed2(this._value, this.format.decimals);
    const b2 = parseFixed2(other._value, other.format.decimals);
    return FixedNumber2.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber2.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE2.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber2.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE2.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger8.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber2.from("1" + zeros2.substring(0, decimals), this.format);
    const bump = BUMP2.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger8.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber2.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad2(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber2.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish2(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber2.fromString(formatFixed2(value, decimals), FixedFormat2.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat2.from(format);
    const numeric = parseFixed2(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero2)) {
      throwFault4("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad2(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed2(numeric, fixedFormat.decimals);
    return new FixedNumber2(_constructorGuard4, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat2.from(format);
    if (arrayify2(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber2.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed2(numeric, fixedFormat.decimals);
    return new FixedNumber2(_constructorGuard4, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber2.fromString(value, format);
    }
    if (isBytes2(value)) {
      return FixedNumber2.fromBytes(value, format);
    }
    try {
      return FixedNumber2.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger3.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger8.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE2 = FixedNumber2.from(1);
var BUMP2 = FixedNumber2.from("0.5");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne3 = BigNumber2.from(-1);
var Zero3 = BigNumber2.from(0);
var One = BigNumber2.from(1);
var Two = BigNumber2.from(2);
var WeiPerEther = BigNumber2.from("1000000000000000000");
var MaxUint256 = BigNumber2.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigNumber2.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt256 = BigNumber2.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();
var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();
var EtherSymbol = "\u039E";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  AlchemyProvider: () => AlchemyProvider,
  AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
  BaseProvider: () => BaseProvider,
  CloudflareProvider: () => CloudflareProvider,
  EtherscanProvider: () => EtherscanProvider,
  FallbackProvider: () => FallbackProvider,
  Formatter: () => Formatter,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  IpcProvider: () => IpcProvider,
  JsonRpcBatchProvider: () => JsonRpcBatchProvider,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcSigner: () => JsonRpcSigner,
  NodesmithProvider: () => NodesmithProvider,
  PocketProvider: () => PocketProvider,
  Provider: () => Provider,
  Resolver: () => Resolver,
  StaticJsonRpcProvider: () => StaticJsonRpcProvider,
  UrlJsonRpcProvider: () => UrlJsonRpcProvider,
  Web3Provider: () => Web3Provider,
  WebSocketProvider: () => WebSocketProvider,
  getDefaultProvider: () => getDefaultProvider,
  getNetwork: () => getNetwork,
  isCommunityResourcable: () => isCommunityResourcable,
  isCommunityResource: () => isCommunityResource,
  showThrottleMessage: () => showThrottleMessage
});
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-provider/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn3 = __toESM(require_bn());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version10 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors4 = false;
var _censorErrors4 = false;
var LogLevels4 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel4 = LogLevels4["default"];
var _globalLogger4 = null;
function _checkNormalize4() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError4 = _checkNormalize4();
var LogLevel4;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel4 || (LogLevel4 = {}));
var ErrorCode4;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode4 || (ErrorCode4 = {}));
var HEX4 = "0123456789abcdef";
var Logger4 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels4[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel4 > LogLevels4[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger4.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger4.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger4.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors4) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger4.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX4[value[i2] >> 4];
            hex += HEX4[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode4.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode4.CALL_EXCEPTION:
      case ErrorCode4.INSUFFICIENT_FUNDS:
      case ErrorCode4.MISSING_NEW:
      case ErrorCode4.NONCE_EXPIRED:
      case ErrorCode4.REPLACEMENT_UNDERPRICED:
      case ErrorCode4.TRANSACTION_REPLACED:
      case ErrorCode4.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger4.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError4) {
      this.throwError("platform missing String.prototype.normalize", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError4
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger4.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger4.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger4.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger4.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger4.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger4.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger4.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger4) {
      _globalLogger4 = new Logger4(version10);
    }
    return _globalLogger4;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors4) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors4 = !!censorship;
    _permanentCensorErrors4 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels4[logLevel.toLowerCase()];
    if (level == null) {
      Logger4.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel4 = level;
  }
  static from(version130) {
    return new Logger4(version130);
  }
};
Logger4.errors = ErrorCode4;
Logger4.levels = LogLevel4;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version11 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger9 = new Logger4(version11);
function isHexable3(value) {
  return !!value.toHexString;
}
function addSlice3(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice3(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString3(value) && !(value.length % 2) || isBytes3(value);
}
function isInteger3(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes3(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger3(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger3(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify3(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger9.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice3(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable3(value)) {
    value = value.toHexString();
  }
  if (isHexString3(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger9.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice3(new Uint8Array(result));
  }
  if (isBytes3(value)) {
    return addSlice3(new Uint8Array(value));
  }
  return logger9.throwArgumentError("invalid arrayify value", "value", value);
}
function concat3(items) {
  const objects = items.map((item) => arrayify3(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice3(result);
}
function stripZeros(value) {
  let result = arrayify3(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify3(value);
  if (value.length > length) {
    logger9.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice3(result);
}
function isHexString3(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters3 = "0123456789abcdef";
function hexlify3(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger9.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters3[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable3(value)) {
    return value.toHexString();
  }
  if (isHexString3(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger9.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes3(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters3[(v2 & 240) >> 4] + HexCharacters3[v2 & 15];
    }
    return result;
  }
  return logger9.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify3(data);
  } else if (!isHexString3(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify3(data);
  } else if (!isHexString3(data) || data.length % 2) {
    logger9.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify3(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify3(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify3(value);
  }
  if (!isHexString3(value)) {
    logger9.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad3(value, length) {
  if (typeof value !== "string") {
    value = hexlify3(value);
  } else if (!isHexString3(value)) {
    logger9.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger9.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature6) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature6)) {
    let bytes = arrayify3(signature6);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify3(bytes.slice(0, 32));
      result.s = hexlify3(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify3(bytes.slice(0, 32));
      result.s = hexlify3(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger9.throwArgumentError("invalid signature string", "signature", signature6);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger9.throwArgumentError("signature invalid v byte", "signature", signature6);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify3(bytes.slice(32, 64));
  } else {
    result.r = signature6.r;
    result.s = signature6.s;
    result.v = signature6.v;
    result.recoveryParam = signature6.recoveryParam;
    result._vs = signature6._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify3(result._vs), 32);
      result._vs = hexlify3(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger9.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature6);
      }
      vs2[0] &= 127;
      const s2 = hexlify3(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger9.throwArgumentError("signature v mismatch _vs", "signature", signature6);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger9.throwArgumentError("signature missing v and recoveryParam", "signature", signature6);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger9.throwArgumentError("signature recoveryParam mismatch v", "signature", signature6);
        }
      }
    }
    if (result.r == null || !isHexString3(result.r)) {
      logger9.throwArgumentError("signature missing or invalid r", "signature", signature6);
    } else {
      result.r = hexZeroPad3(result.r, 32);
    }
    if (result.s == null || !isHexString3(result.s)) {
      logger9.throwArgumentError("signature missing or invalid s", "signature", signature6);
    } else {
      result.s = hexZeroPad3(result.s, 32);
    }
    const vs = arrayify3(result.s);
    if (vs[0] >= 128) {
      logger9.throwArgumentError("signature s out of range", "signature", signature6);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify3(vs);
    if (result._vs) {
      if (!isHexString3(result._vs)) {
        logger9.throwArgumentError("signature invalid _vs", "signature", signature6);
      }
      result._vs = hexZeroPad3(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger9.throwArgumentError("signature _vs mismatch v and s", "signature", signature6);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version12 = "bignumber/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN3 = import_bn3.default.BN;
var logger10 = new Logger4(version12);
var _constructorGuard5 = {};
var MAX_SAFE3 = 9007199254740991;
function isBigNumberish3(value) {
  return value != null && (BigNumber3.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString3(value) || typeof value === "bigint" || isBytes3(value));
}
var _warnedToStringRadix3 = false;
var BigNumber3 = class {
  constructor(constructorGuard, hex) {
    logger10.checkNew(new.target, BigNumber3);
    if (constructorGuard !== _constructorGuard5) {
      logger10.throwError("cannot call constructor directly; use BigNumber.from", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber3(toBN3(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber3(toBN3(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber3.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber3(toBN3(this).add(toBN3(other)));
  }
  sub(other) {
    return toBigNumber3(toBN3(this).sub(toBN3(other)));
  }
  div(other) {
    const o = BigNumber3.from(other);
    if (o.isZero()) {
      throwFault5("division-by-zero", "div");
    }
    return toBigNumber3(toBN3(this).div(toBN3(other)));
  }
  mul(other) {
    return toBigNumber3(toBN3(this).mul(toBN3(other)));
  }
  mod(other) {
    const value = toBN3(other);
    if (value.isNeg()) {
      throwFault5("division-by-zero", "mod");
    }
    return toBigNumber3(toBN3(this).umod(value));
  }
  pow(other) {
    const value = toBN3(other);
    if (value.isNeg()) {
      throwFault5("negative-power", "pow");
    }
    return toBigNumber3(toBN3(this).pow(value));
  }
  and(other) {
    const value = toBN3(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault5("unbound-bitwise-result", "and");
    }
    return toBigNumber3(toBN3(this).and(value));
  }
  or(other) {
    const value = toBN3(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault5("unbound-bitwise-result", "or");
    }
    return toBigNumber3(toBN3(this).or(value));
  }
  xor(other) {
    const value = toBN3(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault5("unbound-bitwise-result", "xor");
    }
    return toBigNumber3(toBN3(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault5("negative-width", "mask");
    }
    return toBigNumber3(toBN3(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault5("negative-width", "shl");
    }
    return toBigNumber3(toBN3(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault5("negative-width", "shr");
    }
    return toBigNumber3(toBN3(this).shrn(value));
  }
  eq(other) {
    return toBN3(this).eq(toBN3(other));
  }
  lt(other) {
    return toBN3(this).lt(toBN3(other));
  }
  lte(other) {
    return toBN3(this).lte(toBN3(other));
  }
  gt(other) {
    return toBN3(this).gt(toBN3(other));
  }
  gte(other) {
    return toBN3(this).gte(toBN3(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN3(this).isZero();
  }
  toNumber() {
    try {
      return toBN3(this).toNumber();
    } catch (error) {
      throwFault5("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger10.throwError("this platform does not support BigInt", Logger4.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix3) {
          _warnedToStringRadix3 = true;
          logger10.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger10.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger4.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger10.throwError("BigNumber.toString does not accept parameters", Logger4.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN3(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber3) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber3(_constructorGuard5, toHex3(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber3(_constructorGuard5, toHex3(new BN3(value)));
      }
      return logger10.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault5("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE3 || value <= -MAX_SAFE3) {
        throwFault5("overflow", "BigNumber.from", value);
      }
      return BigNumber3.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber3.from(anyValue.toString());
    }
    if (isBytes3(anyValue)) {
      return BigNumber3.from(hexlify3(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber3.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString3(hex) || hex[0] === "-" && isHexString3(hex.substring(1))) {
            return BigNumber3.from(hex);
          }
        }
      }
    }
    return logger10.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex3(value) {
  if (typeof value !== "string") {
    return toHex3(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger10.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex3(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber3(value) {
  return BigNumber3.from(toHex3(value));
}
function toBN3(value) {
  const hex = BigNumber3.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN3("-" + hex.substring(3), 16);
  }
  return new BN3(hex.substring(2), 16);
}
function throwFault5(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger10.throwError(fault, Logger4.errors.NUMERIC_FAULT, params);
}
function _base36To163(value) {
  return new BN3(value, 36).toString(16);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger11 = new Logger4(version12);
var _constructorGuard6 = {};
var Zero4 = BigNumber3.from(0);
var NegativeOne4 = BigNumber3.from(-1);
function throwFault6(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger11.throwError(message, Logger4.errors.NUMERIC_FAULT, params);
}
var zeros3 = "0";
while (zeros3.length < 256) {
  zeros3 += zeros3;
}
function getMultiplier3(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber3.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros3.substring(0, decimals);
  }
  return logger11.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed3(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier3(decimals);
  value = BigNumber3.from(value);
  const negative = value.lt(Zero4);
  if (negative) {
    value = value.mul(NegativeOne4);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed3(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier3(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger11.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger11.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger11.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault6("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber3.from(whole);
  const fractionValue = BigNumber3.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne4);
  }
  return wei;
}
var FixedFormat3 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard6) {
      logger11.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier3(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat3) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger11.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger11.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger11.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger11.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat3(_constructorGuard6, signed, width, decimals);
  }
};
var FixedNumber3 = class {
  constructor(constructorGuard, hex, value, format) {
    logger11.checkNew(new.target, FixedNumber3);
    if (constructorGuard !== _constructorGuard6) {
      logger11.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger11.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed3(this._value, this.format.decimals);
    const b2 = parseFixed3(other._value, other.format.decimals);
    return FixedNumber3.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed3(this._value, this.format.decimals);
    const b2 = parseFixed3(other._value, other.format.decimals);
    return FixedNumber3.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed3(this._value, this.format.decimals);
    const b2 = parseFixed3(other._value, other.format.decimals);
    return FixedNumber3.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed3(this._value, this.format.decimals);
    const b2 = parseFixed3(other._value, other.format.decimals);
    return FixedNumber3.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber3.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE3.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber3.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE3.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger11.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber3.from("1" + zeros3.substring(0, decimals), this.format);
    const bump = BUMP3.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger11.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber3.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad3(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber3.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish3(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber3.fromString(formatFixed3(value, decimals), FixedFormat3.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat3.from(format);
    const numeric = parseFixed3(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero4)) {
      throwFault6("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad3(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed3(numeric, fixedFormat.decimals);
    return new FixedNumber3(_constructorGuard6, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat3.from(format);
    if (arrayify3(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber3.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed3(numeric, fixedFormat.decimals);
    return new FixedNumber3(_constructorGuard6, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber3.fromString(value, format);
    }
    if (isBytes3(value)) {
      return FixedNumber3.fromBytes(value, format);
    }
    try {
      return FixedNumber3.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger4.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger11.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE3 = FixedNumber3.from(1);
var BUMP3 = FixedNumber3.from("0.5");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version13 = "properties/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/properties/lib.esm/index.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger12 = new Logger4(version13);
function defineReadOnly2(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key6) {
  for (let i2 = 0; i2 < 32; i2++) {
    if (ctor[key6]) {
      return ctor[key6];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties2(object) {
  return __awaiter4(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key6) => {
      const value = object[key6];
      return Promise.resolve(value).then((v2) => ({ key: key6, value: v2 }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger12.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key6) => {
    if (!properties[key6]) {
      logger12.throwArgumentError("invalid object key - " + key6, "transaction:" + key6, object);
    }
  });
}
function shallowCopy2(object) {
  const result = {};
  for (const key6 in object) {
    result[key6] = object[key6];
  }
  return result;
}
var opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i2 = 0; i2 < keys.length; i2++) {
      let value = null;
      try {
        value = object[keys[i2]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger12.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key6 in object) {
      const value = object[key6];
      if (value === void 0) {
        continue;
      }
      defineReadOnly2(result, key6, deepCopy(value));
    }
    return result;
  }
  return logger12.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
var Description = class {
  constructor(info) {
    for (const key6 in info) {
      this[key6] = deepCopy(info[key6]);
    }
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
init_define_process_env();
var version14 = "abstract-provider/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-provider/lib.esm/index.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger13 = new Logger4(version14);
var ForkEvent = class extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
};
var Provider = class {
  constructor() {
    logger13.checkAbstract(new.target, Provider);
    defineReadOnly2(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter5(this, void 0, void 0, function* () {
      const { block, gasPrice } = yield resolveProperties2({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = BigNumber3.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/networks/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/networks/lib.esm/_version.js
init_define_process_env();
var version15 = "networks/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/networks/lib.esm/index.js
var logger14 = new Logger4(version15);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip2 = ["goerli", "ropsten", "rinkeby"];
      try {
        const provider = new providers.PocketProvider(network);
        if (provider.network && skip2.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        providerList.push(new providers.AnkrProvider(network, options.ankr));
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
var homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
var ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
var classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
var networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: { chainId: 137, name: "matic" },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: { chainId: 10, name: "optimism" },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name2 in networks) {
      const standard2 = networks[name2];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger14.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger14.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/base-provider.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/basex/lib.esm/index.js
init_define_process_env();
var BaseX = class {
  constructor(alphabet) {
    defineReadOnly2(this, "alphabet", alphabet);
    defineReadOnly2(this, "base", alphabet.length);
    defineReadOnly2(this, "_alphabetMap", {});
    defineReadOnly2(this, "_leader", alphabet.charAt(0));
    for (let i2 = 0; i2 < alphabet.length; i2++) {
      this._alphabetMap[alphabet.charAt(i2)] = i2;
    }
  }
  encode(value) {
    let source = arrayify3(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i2 = 0; i2 < source.length; ++i2) {
      let carry = source[i2];
      for (let j2 = 0; j2 < digits.length; ++j2) {
        carry += digits[j2] << 8;
        digits[j2] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k2 = 0; source[k2] === 0 && k2 < source.length - 1; ++k2) {
      string += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string += this.alphabet[digits[q2]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i2 = 0; i2 < value.length; i2++) {
      let byte = this._alphabetMap[value[i2]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j2 = 0; j2 < bytes.length; ++j2) {
        carry += bytes[j2] * this.base;
        bytes[j2] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k2 = 0; value[k2] === this._leader && k2 < value.length - 1; ++k2) {
      bytes.push(0);
    }
    return arrayify3(new Uint8Array(bytes.reverse()));
  }
};
var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
var Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();
var AddressZero2 = "0x0000000000000000000000000000000000000000";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();
var NegativeOne5 = BigNumber3.from(-1);
var Zero5 = BigNumber3.from(0);
var One2 = BigNumber3.from(1);
var Two2 = BigNumber3.from(2);
var WeiPerEther2 = BigNumber3.from("1000000000000000000");
var MaxUint2562 = BigNumber3.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2562 = BigNumber3.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2562 = BigNumber3.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();
var HashZero2 = "0x0000000000000000000000000000000000000000000000000000000000000000";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/id.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha3 = __toESM(require_sha3());
function keccak2562(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify3(data));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version16 = "strings/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger15 = new Logger4(version16);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger15.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify3(bytes);
  const result = [];
  let i2 = 0;
  while (i2 < bytes.length) {
    const c2 = bytes[i2++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i2 - 1, bytes, result);
      } else {
        i2 += onError(Utf8ErrorReason.BAD_PREFIX, i2 - 1, bytes, result);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes.length) {
      i2 += onError(Utf8ErrorReason.OVERRUN, i2 - 1, bytes, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError(Utf8ErrorReason.MISSING_CONTINUE, i2, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError(Utf8ErrorReason.OUT_OF_RANGE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError(Utf8ErrorReason.UTF16_SURROGATE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError(Utf8ErrorReason.OVERLONG, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger15.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify3(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data.length; i2 += 4) {
    result.push(parseInt(data.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let range2 = ranges[i2];
    lo += range2.l;
    if (value >= lo && value <= lo + range2.h && (value - lo) % (range2.d || 1) === 0) {
      if (range2.e && range2.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range2;
    }
  }
  return null;
}
var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
var Table_B_2_ranges = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range2 = matchMap(codepoint, Table_B_2_ranges);
  if (range2) {
    return [codepoint + range2.s];
  }
  let codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints(value);
  codes = flatten(codes.map((code) => {
    if (Table_B_1_flags.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 65024 && code <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code];
  }));
  codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
  codes.forEach((code) => {
    if (_nameprepTableC(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code) => {
    if (_nameprepTableA1(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String(codes);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  if (name2.length > 63) {
    throw new Error("too long");
  }
  return name2;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/id.js
function id(text2) {
  return keccak2562(toUtf8Bytes(text2));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/namehash.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/_version.js
init_define_process_env();
var version17 = "hash/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger16 = new Logger4(version17);
var Zeros = new Uint8Array(32);
Zeros.fill(0);
var Partition = new RegExp("^((.*)\\.)?([^.]+)$");
function namehash(name2) {
  if (typeof name2 !== "string") {
    logger16.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let current = name2;
  let result = Zeros;
  while (current.length) {
    const partition4 = current.match(Partition);
    if (partition4 == null || partition4[2] === "") {
      logger16.throwArgumentError("invalid ENS address; missing component", "name", name2);
    }
    const label = toUtf8Bytes(nameprep(partition4[3]));
    result = keccak2562(concat3([result, keccak2562(label)]));
    current = partition4[2] || "";
  }
  return hexlify3(result);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/message.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/typed-data.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version18 = "rlp/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger17 = new Logger4(version18);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i2 = 0; i2 < length; i2++) {
    result = result * 256 + data[offset + i2];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger17.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify3(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode(object) {
  return hexlify3(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger17.throwError("child data too short", Logger4.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  if (data.length === 0) {
    logger17.throwError("data too short", Logger4.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger17.throwError("data short segment too short", Logger4.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger17.throwError("data long segment too short", Logger4.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger17.throwError("data array too short", Logger4.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger17.throwError("data array too short", Logger4.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger17.throwError("data array too short", Logger4.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify3(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger17.throwError("data too short", Logger4.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify3(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify3(data[offset]) };
}
function decode(data) {
  const bytes = arrayify3(data);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger17.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version19 = "address/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/address/lib.esm/index.js
var logger18 = new Logger4(version19);
function getChecksumAddress(address) {
  if (!isHexString3(address, 20)) {
    logger18.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify3(keccak2562(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function log10(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
var ibanLookup = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup[String.fromCharCode(65 + i2)] = String(10 + i2);
}
var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger18.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger18.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger18.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To163(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger18.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function getContractAddress(transaction) {
  let from2 = null;
  try {
    from2 = getAddress(transaction.from);
  } catch (error) {
    logger18.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify3(BigNumber3.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak2562(encode([from2, nonce])), 12));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/hash/lib.esm/typed-data.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger19 = new Logger4(version17);
var padding = new Uint8Array(32);
padding.fill(0);
var NegativeOne6 = BigNumber3.from(-1);
var Zero6 = BigNumber3.from(0);
var One3 = BigNumber3.from(1);
var MaxUint2563 = BigNumber3.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes = arrayify3(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }
  return hexlify3(bytes);
}
var hexTrue = hexZeroPad3(One3.toHexString(), 32);
var hexFalse = hexZeroPad3(Zero6.toHexString(), 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key6) {
  return function(value) {
    if (typeof value !== "string") {
      logger19.throwArgumentError(`invalid domain value for ${JSON.stringify(key6)}`, `domain.${key6}`, value);
    }
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber3.from(value).toString();
    } catch (error) {
    }
    return logger19.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    return logger19.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify3(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify3(bytes);
    } catch (error) {
    }
    return logger19.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger19.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint2563.mask(signed ? width - 1 : width);
      const boundsLower = signed ? boundsUpper.add(One3).mul(NegativeOne6) : Zero6;
      return function(value) {
        const v2 = BigNumber3.from(value);
        if (v2.lt(boundsLower) || v2.gt(boundsUpper)) {
          logger19.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad3(v2.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger19.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes = arrayify3(value);
        if (bytes.length !== width) {
          logger19.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad3(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak2562(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
var TypedDataEncoder = class {
  constructor(types) {
    defineReadOnly2(this, "types", Object.freeze(deepCopy(types)));
    defineReadOnly2(this, "_encoderCache", {});
    defineReadOnly2(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types).forEach((type) => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name2 in types) {
      const uniqueNames = {};
      types[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger19.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger19.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        }
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger19.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n) => parents[n].length === 0);
    if (primaryTypes.length === 0) {
      logger19.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger19.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types);
    }
    defineReadOnly2(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger19.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
      }
      found[type] = true;
      Object.keys(links[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st = Object.keys(subtypes[name2]);
      st.sort();
      this._types[name2] = encodeType(name2, types[name2]) + st.map((t2) => encodeType(t2, types[t2])).join("");
    }
  }
  getEncoder(type) {
    let encoder = this._encoderCache[type];
    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder;
  }
  _getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return (value) => {
        if (length >= 0 && value.length !== length) {
          logger19.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak2562);
        }
        return keccak2562(hexConcat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this._types[type]);
      return (value) => {
        const values = fields.map(({ name: name2, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name2]);
          if (this._types[type2]) {
            return keccak2562(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger19.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger19.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name2, value) {
    return keccak2562(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);
      if (length >= 0 && value.length !== length) {
        logger19.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v2) => this._visit(subtype, v2, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type2 }) => {
        accum[name2] = this._visit(type2, value[name2], callback);
        return accum;
      }, {});
    }
    return logger19.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types) {
    return new TypedDataEncoder(types);
  }
  static getPrimaryType(types) {
    return TypedDataEncoder.from(types).primaryType;
  }
  static hashStruct(name2, types, value) {
    return TypedDataEncoder.from(types).hashStruct(name2, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name2 in domain) {
      const type = domainFieldTypes[name2];
      if (!type) {
        logger19.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain);
      }
      domainFields.push({ name: name2, type });
    }
    domainFields.sort((a2, b2) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b2.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types, value) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types).hash(value)
    ]);
  }
  static hash(domain, types, value) {
    return keccak2562(TypedDataEncoder.encode(domain, types, value));
  }
  static resolveNames(domain, types, value, resolveName) {
    return __awaiter6(this, void 0, void 0, function* () {
      domain = shallowCopy2(domain);
      const ensCache = {};
      if (domain.verifyingContract && !isHexString3(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder.from(types);
      encoder.visit(value, (type, value2) => {
        if (type === "address" && !isHexString3(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName(name2);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder.visit(value, (type, value2) => {
        if (type === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    });
  }
  static getPayload(domain, types, value) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value2 = domain[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
    });
    const encoder = TypedDataEncoder.from(types);
    const typesWithDomain = shallowCopy2(types);
    if (typesWithDomain.EIP712Domain) {
      logger19.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify3(arrayify3(value2));
        }
        if (type.match(/^u?int/)) {
          return BigNumber3.from(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger19.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger19.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/sha2/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/sha2/lib.esm/sha2.js
init_define_process_env();
var import_hash = __toESM(require_hash());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/sha2/lib.esm/types.js
init_define_process_env();
var SupportedAlgorithm;
(function(SupportedAlgorithm5) {
  SupportedAlgorithm5["sha256"] = "sha256";
  SupportedAlgorithm5["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/sha2/lib.esm/_version.js
init_define_process_env();
var version20 = "sha2/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/sha2/lib.esm/sha2.js
var logger20 = new Logger4(version20);
function sha2562(data) {
  return "0x" + import_hash.default.sha256().update(arrayify3(data)).digest("hex");
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/web/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/base64/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/base64/lib.esm/base64.js
init_define_process_env();
function decode2(textData) {
  textData = atob(textData);
  const data = [];
  for (let i2 = 0; i2 < textData.length; i2++) {
    data.push(textData.charCodeAt(i2));
  }
  return arrayify3(data);
}
function encode2(data) {
  data = arrayify3(data);
  let textData = "";
  for (let i2 = 0; i2 < data.length; i2++) {
    textData += String.fromCharCode(data[i2]);
  }
  return btoa(textData);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/web/lib.esm/_version.js
init_define_process_env();
var version21 = "web/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/web/lib.esm/geturl.js
init_define_process_env();
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter7(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    ;
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key6) => {
        headers[key6.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key6) => {
        headers[key6.toLowerCase()] = response.headers.get(key6);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify3(new Uint8Array(body))
    };
  });
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/web/lib.esm/index.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger21 = new Logger4(version21);
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
      ;
    }
    return hexlify3(value);
  }
  return value;
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger21.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger21.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout2 = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger21.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout2 = connection.timeout;
    }
    if (connection.headers) {
      for (const key6 in connection.headers) {
        headers[key6.toLowerCase()] = { key: key6, value: String(connection.headers[key6]) };
        if (["if-none-match", "if-modified-since"].indexOf(key6.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger21.throwError("basic authentication requires a secure https url", Logger4.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode2(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
  }
  const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] },
        body: decode2(dataMatch[2])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger21.throwError("processing response error", Logger4.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key6) => {
    const header = headers[key6];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer3 = null;
    const promise2 = new Promise(function(resolve, reject) {
      if (timeout2) {
        timer3 = setTimeout(() => {
          if (timer3 == null) {
            return;
          }
          timer3 = null;
          reject(logger21.makeError("timeout", Logger4.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout: timeout2,
            url
          }));
        }, timeout2);
      }
    });
    const cancel = function() {
      if (timer3 == null) {
        return;
      }
      clearTimeout(timer3);
      timer3 = null;
    };
    return { promise: promise2, cancel };
  }();
  const runningFetch = function() {
    return __awaiter8(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location = response.headers.location || "";
              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall3 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall3 = parseInt(retryAfter) * 1e3;
                } else {
                  stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall3);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger21.throwError("missing response", Logger4.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger21.throwError("bad response", Logger4.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout3);
                continue;
              }
            }
            runningTimeout.cancel();
            logger21.throwError("processing response error", Logger4.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger21.throwError("failed response", Logger4.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger21.throwError("invalid JSON", Logger4.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy2(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k2) => k2.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy2(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy2(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer3 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer3) {
        clearTimeout(timer3);
      }
      return true;
    };
    if (options.timeout) {
      timer3 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout2 = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout2 < options.floor) {
            timeout2 = options.floor;
          }
          if (timeout2 > options.ceiling) {
            timeout2 = options.ceiling;
          }
          setTimeout(check, timeout2);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/base-provider.js
var import_bech32 = __toESM(require_bech32());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/_version.js
init_define_process_env();
var version22 = "providers/5.5.2";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/formatter.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/transactions/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/signing-key/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
init_define_process_env();
var import_bn4 = __toESM(require_bn());
var import_hash2 = __toESM(require_hash());
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base6) {
      return commonjsRequire(path, base6 === void 0 || base6 === null ? module.path : base6);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var utils = exports;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray2;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex13(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero2(msg[i2].toString(16));
    return res;
  }
  utils.toHex = toHex13;
  utils.encode = function encode18(arr, enc) {
    if (enc === "hex")
      return toHex13(arr);
    else
      return arr;
  };
});
var utils_1$1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert;
  utils.toArray = utils_1.toArray;
  utils.zero2 = utils_1.zero2;
  utils.toHex = utils_1.toHex;
  utils.encode = utils_1.encode;
  function getNAF6(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i2 = 0; i2 < naf.length; i2++) {
      var z;
      var mod = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k2.isubn(z);
      } else {
        z = 0;
      }
      naf[i2] = z;
      k2.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF6;
  function getJSF6(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF6;
  function cachedProperty(obj, name2, computer) {
    var key6 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key6] !== void 0 ? this[key6] : this[key6] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn4.default(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new import_bn4.default(conf.p, 16);
  this.red = conf.prime ? import_bn4.default.red(conf.prime) : import_bn4.default.mont(this.p);
  this.zero = new import_bn4.default(0).toRed(this.red);
  this.one = new import_bn4.default(1).toRed(this.red);
  this.two = new import_bn4.default(2).toRed(this.red);
  this.n = conf.n && new import_bn4.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k2) {
  assert$1(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i2 = I2; i2 > 0; i2--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i2)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i2)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p2, k2) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i2 = naf.length - 1; i2 >= 0; i2--) {
    for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
      l2++;
    if (i2 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i2 < 0)
      break;
    var z = naf[i2];
    assert$1(z !== 0);
    if (p2.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i2;
  var j2;
  var p2;
  for (i2 = 0; i2 < len; i2++) {
    p2 = points[i2];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i2] = nafPoints.wnd;
    wnd[i2] = nafPoints.points;
  }
  for (i2 = len - 1; i2 >= 1; i2 -= 2) {
    var a2 = i2 - 1;
    var b2 = i2;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
      max2 = Math.max(naf[a2].length, max2);
      max2 = Math.max(naf[b2].length, max2);
      continue;
    }
    var comb = [
      points[a2],
      null,
      null,
      points[b2]
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF(coeffs[a2], coeffs[b2]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a2] = new Array(max2);
    naf[b2] = new Array(max2);
    for (j2 = 0; j2 < max2; j2++) {
      var ja = jsf[0][j2] | 0;
      var jb = jsf[1][j2] | 0;
      naf[a2][j2] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i2 = max2; i2 >= 0; i2--) {
    var k2 = 0;
    while (i2 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len; j2++) {
        tmp[j2] = naf[j2][i2] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i2--;
    }
    if (i2 >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i2 < 0)
      break;
    for (j2 = 0; j2 < len; j2++) {
      var z = tmp[j2];
      p2;
      if (z === 0)
        continue;
      else if (z > 0)
        p2 = wnd[j2][z - 1 >> 1];
      else if (z < 0)
        p2 = wnd[j2][-z - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i2 = 0; i2 < len; i2++)
    wnd[i2] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$1(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$1(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode2(compact) {
  var len = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode3(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i2 = 0; i2 < power; i2 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl11 = max2 === 1 ? null : this.dbl();
  for (var i2 = 1; i2 < max2; i2++)
    res[i2] = res[i2 - 1].add(dbl11);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k2) {
  var r2 = this;
  for (var i2 = 0; i2 < k2; i2++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new import_bn4.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn4.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn4.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn4.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn4.default(vec.a, 16),
        b: new import_bn4.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : import_bn4.default.mont(num);
  var tinv = new import_bn4.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new import_bn4.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new import_bn4.default(1);
  var y1 = new import_bn4.default(0);
  var x2 = new import_bn4.default(0);
  var y2 = new import_bn4.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i2 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r2 = v2.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i2 === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y;
  }
  a2 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x2, odd) {
  x2 = new import_bn4.default(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x2, y);
};
ShortCurve.prototype.validate = function validate3(point11) {
  if (point11.inf)
    return true;
  var x2 = point11.x;
  var y = point11.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i2 = 0; i2 < points.length; i2++) {
    var split = this._endoSplit(coeffs[i2]);
    var p2 = points[i2];
    var beta = p2._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i2 * 2] = p2;
    npoints[i2 * 2 + 1] = beta;
    ncoeffs[i2 * 2] = split.k1;
    ncoeffs[i2 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
  for (var j2 = 0; j2 < i2 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point(curve, x2, y, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x2 === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn4.default(x2, 16);
    this.y = new import_bn4.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function point2(x2, y, isRed) {
  return new Point(this, x2, y, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p2) {
      return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul(k2) {
  k2 = new import_bn4.default(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq2(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x2, y, z) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn4.default(0);
  } else {
    this.x = new import_bn4.default(x2, 16);
    this.y = new import_bn4.default(y, 16);
    this.z = new import_bn4.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x2, y, z) {
  return new JPoint(this, x2, y, z);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add2(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i2;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i2 = 0; i2 < pow; i2++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i2 = 0; i2 < pow; i2++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i2 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e = a2.redAdd(a2).redIAdd(a2);
    var f2 = e.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee2 = e.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e).redSqr().redISub(mm).redISub(ee2).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k2, kbase) {
  k2 = new import_bn4.default(k2, kbase);
  return this.curve._wnafMul(this, k2);
};
JPoint.prototype.eq = function eq3(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base;
  curve.short = short_1;
  curve.mont = null;
  curve.edwards = null;
});
var curves_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert6 = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert6(this.g.validate(), "Invalid curve");
    assert6(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash2.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash2.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash2.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac() {
  return new import_hash2.default.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add11, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add11;
    add11 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add11 = utils_1.toArray(add11, addEnc);
  minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add11 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate2(len, enc, add11, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add11;
    add11 = enc;
    enc = null;
  }
  if (add11) {
    add11 = utils_1.toArray(add11, addEnc || "hex");
    this._update(add11);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add11);
  this._reseed++;
  return utils_1.encode(res, enc);
};
var assert$3 = utils_1$1.assert;
function KeyPair(ec6, options) {
  this.ec = ec6;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec6, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec6, {
    pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec6, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec6, {
    priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate4() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key6, enc) {
  this.priv = new import_bn4.default(key6, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key6, enc) {
  if (key6.x || key6.y) {
    if (this.ec.curve.type === "mont") {
      assert$3(key6.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3(key6.x && key6.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key6.x, key6.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key6, enc);
};
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature6) {
  return this.ec.verify(msg, signature6, this);
};
KeyPair.prototype.inspect = function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new import_bn4.default(options.r, 16);
  this.s = new import_bn4.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding(buf) {
  var i2 = 0;
  var len = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p2 = new Position();
  if (data[p2.place++] !== 48) {
    return false;
  }
  var len = getLength(data, p2);
  if (len === false) {
    return false;
  }
  if (len + p2.place !== data.length) {
    return false;
  }
  if (data[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength(data, p2);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p2.place) {
    return false;
  }
  var s2 = data.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn4.default(r2);
  this.s = new import_bn4.default(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding(r2);
  s2 = rmPadding(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};
var rand = function() {
  throw new Error("unsupported");
};
var assert$5 = utils_1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options), "Unknown curve " + options);
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn4.default(2));
  for (; ; ) {
    var priv = new import_bn4.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign2(msg, key6, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key6 = this.keyFromPrivate(key6, enc);
  msg = this._truncateToN(new import_bn4.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key6.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn4.default(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new import_bn4.default(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k2.invm(this.n).mul(r2.mul(key6.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature({ r: r2, s: s2, recoveryParam });
  }
};
EC.prototype.verify = function verify2(msg, signature$1, key6, enc) {
  msg = this._truncateToN(new import_bn4.default(msg, 16));
  key6 = this.keyFromPublic(key6, enc);
  signature$1 = new signature(signature$1, "hex");
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key6.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key6.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j2, enc) {
  assert$5((3 & j2) === j2, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n = this.n;
  var e = new import_bn4.default(msg);
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s22 = s2.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r2, s22);
};
EC.prototype.getKeyRecoveryParam = function(e, signature$1, Q2, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i2 = 0; i2 < 4; i2++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i2);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i2;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec;
  elliptic.eddsa = null;
});
var EC$1 = elliptic_1.ec;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/signing-key/lib.esm/_version.js
init_define_process_env();
var version23 = "signing-key/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger22 = new Logger4(version23);
var _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
var SigningKey = class {
  constructor(privateKey) {
    defineReadOnly2(this, "curve", "secp256k1");
    defineReadOnly2(this, "privateKey", hexlify3(privateKey));
    const keyPair6 = getCurve().keyFromPrivate(arrayify3(this.privateKey));
    defineReadOnly2(this, "publicKey", "0x" + keyPair6.getPublic(false, "hex"));
    defineReadOnly2(this, "compressedPublicKey", "0x" + keyPair6.getPublic(true, "hex"));
    defineReadOnly2(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify3(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify3(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest) {
    const keyPair6 = getCurve().keyFromPrivate(arrayify3(this.privateKey));
    const digestBytes = arrayify3(digest);
    if (digestBytes.length !== 32) {
      logger22.throwArgumentError("bad digest length", "digest", digest);
    }
    const signature6 = keyPair6.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature6.recoveryParam,
      r: hexZeroPad3("0x" + signature6.r.toString(16), 32),
      s: hexZeroPad3("0x" + signature6.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair6 = getCurve().keyFromPrivate(arrayify3(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify3(computePublicKey(otherKey)));
    return hexZeroPad3("0x" + keyPair6.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
function recoverPublicKey(digest, signature6) {
  const sig = splitSignature(signature6);
  const rs = { r: arrayify3(sig.r), s: arrayify3(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify3(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key6, compressed) {
  const bytes = arrayify3(key6);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify3(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify3(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger22.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/transactions/lib.esm/_version.js
init_define_process_env();
var version24 = "transactions/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/transactions/lib.esm/index.js
var logger23 = new Logger4(version24);
var TransactionTypes;
(function(TransactionTypes5) {
  TransactionTypes5[TransactionTypes5["legacy"] = 0] = "legacy";
  TransactionTypes5[TransactionTypes5["eip2930"] = 1] = "eip2930";
  TransactionTypes5[TransactionTypes5["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero5;
  }
  return BigNumber3.from(value);
}
function computeAddress(key6) {
  const publicKey = computePublicKey(key6);
  return getAddress(hexDataSlice(keccak2562(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest, signature6) {
  return computeAddress(recoverPublicKey(arrayify3(digest), signature6));
}
function formatNumber(value, name2) {
  const result = stripZeros(BigNumber3.from(value).toHexString());
  if (result.length > 32) {
    logger23.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength(storageKey) !== 32) {
        logger23.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger23.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
        }
        return accessSetify(set[0], set[1]);
      }
      return accessSetify(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature6) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber3.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber3.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger23.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature6) {
    const sig = splitSignature(signature6);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode(fields)]);
}
function _serializeEip2930(transaction, signature6) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature6) {
    const sig = splitSignature(signature6);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode(fields)]);
}
function _parseEipSignature(tx, fields, serialize3) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger23.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad3(fields[1], 32);
  tx.s = hexZeroPad3(fields[2], 32);
  try {
    const digest = keccak2562(serialize3(tx));
    tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
    console.log(error);
  }
}
function _parseEip1559(payload) {
  const transaction = decode(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger23.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify3(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak2562(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger23.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify3(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak2562(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger23.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber3.from(transaction[6]).toNumber();
  } catch (error) {
    console.log(error);
    return tx;
  }
  tx.r = hexZeroPad3(transaction[7], 32);
  tx.s = hexZeroPad3(transaction[8], 32);
  if (BigNumber3.from(tx.r).isZero() && BigNumber3.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify3(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest = keccak2562(encode(raw));
    try {
      tx.from = recoverAddress(digest, { r: hexlify3(tx.r), s: hexlify3(tx.s), recoveryParam });
    } catch (error) {
      console.log(error);
    }
    tx.hash = keccak2562(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse(rawTransaction) {
  const payload = arrayify3(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
    default:
      break;
  }
  return logger23.throwError(`unsupported transaction type: ${payload[0]}`, Logger4.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/formatter.js
var logger24 = new Logger4(version22);
var Formatter = class {
  constructor() {
    logger24.checkNew(new.target, Formatter);
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash11 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v2) => {
      return this.data(v2, true);
    };
    formats.transaction = {
      hash: hash11,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash11, null),
      blockNumber: Formatter.allowNull(number, null),
      transactionIndex: Formatter.allowNull(number, null),
      confirmations: Formatter.allowNull(number, null),
      from: address,
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number,
      data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash11,
      address,
      topics: Formatter.arrayOf(hash11),
      data,
      logIndex: number,
      blockHash: hash11
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number,
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash11,
      transactionHash: hash11,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number),
      type
    };
    formats.block = {
      hash: hash11,
      parentHash: hash11,
      number,
      timestamp: number,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: address,
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash11)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy2(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash11, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number),
      blockHash: Formatter.allowNull(hash11),
      transactionIndex: number,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash11),
      transactionHash: hash11,
      logIndex: number
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  number(number) {
    if (number === "0x") {
      return 0;
    }
    return BigNumber3.from(number).toNumber();
  }
  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }
    return BigNumber3.from(number).toNumber();
  }
  bigNumber(value) {
    return BigNumber3.from(value);
  }
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString3(value)) {
        return value.toLowerCase();
      }
    }
    return logger24.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString3(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero2 ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    if (blockTag === "latest" || blockTag === "pending") {
      return blockTag;
    }
    if (typeof blockTag === "number" || isHexString3(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger24.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v2 = BigNumber3.from(value);
    try {
      return v2.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString3(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad3(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber3.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber3.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId2 = transaction.chainId;
      if (isHexString3(chainId2)) {
        chainId2 = BigNumber3.from(chainId2).toNumber();
      }
      result.chainId = chainId2;
    } else {
      let chainId2 = transaction.networkId;
      if (chainId2 == null && result.v == null) {
        chainId2 = transaction.chainId;
      }
      if (isHexString3(chainId2)) {
        chainId2 = BigNumber3.from(chainId2).toNumber();
      }
      if (typeof chainId2 !== "number" && result.v != null) {
        chainId2 = (result.v - 35) / 2;
        if (chainId2 < 0) {
          chainId2 = 0;
        }
        chainId2 = parseInt(chainId2);
      }
      if (typeof chainId2 !== "number") {
        chainId2 = 0;
      }
      result.chainId = chainId2;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber3.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger24.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger24.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger24.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v2) => this.topics(v2));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object) {
    const result = {};
    for (const key6 in format) {
      try {
        const value = format[key6](object[key6]);
        if (value !== void 0) {
          result[key6] = value;
        }
      } catch (error) {
        error.checkKey = key6;
        error.checkValue = object[key6];
        throw error;
      }
    }
    return result;
  }
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  static arrayOf(format) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
};
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
var throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/base-provider.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger25 = new Logger4(version22);
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger25.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger25.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return new Date().getTime();
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
var PollableEvents = ["block", "network", "pending", "poll"];
var Event = class {
  constructor(tag, listener, once) {
    defineReadOnly2(this, "tag", tag);
    defineReadOnly2(this, "listener", listener);
    defineReadOnly2(this, "once", once);
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter2 = {};
    if (topics.length > 0) {
      filter2.topics = topics;
    }
    if (address && address !== "*") {
      filter2.address = address;
    }
    return filter2;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
var coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad3(BigNumber3.from(value).toHexString(), 32);
}
function base58Encode(data) {
  return Base58.encode(concat3([data, hexDataSlice(sha2562(sha2562(data)), 0, 4)]));
}
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result) {
  try {
    return toUtf8String(_parseBytes(result));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber3.from(hexDataSlice(result, 0, 32)).toNumber();
  const length = BigNumber3.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length);
}
function getIpfsLink(link) {
  return `https://gateway.ipfs.io/ipfs/${link.substring(7)}`;
}
var Resolver = class {
  constructor(provider, address, name2, resolvedAddress) {
    defineReadOnly2(this, "provider", provider);
    defineReadOnly2(this, "name", name2);
    defineReadOnly2(this, "address", provider.formatter.address(address));
    defineReadOnly2(this, "_resolvedAddress", resolvedAddress);
  }
  _fetchBytes(selector, parameters) {
    return __awaiter9(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      try {
        return _parseBytes(yield this.provider.call(tx));
      } catch (error) {
        if (error.code === Logger4.errors.CALL_EXCEPTION) {
          return null;
        }
        return null;
      }
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger25.throwError(`unsupported coin type: ${coinType}`, Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = arrayify3(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat3([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat3([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length = bytes[1];
      let version130 = bytes[0];
      if (version130 === 0) {
        if (length !== 20 && length !== 32) {
          version130 = -1;
        }
      } else {
        version130 = -1;
      }
      if (version130 >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
        const words4 = import_bech32.default.toWords(bytes.slice(2));
        words4.unshift(version130);
        return import_bech32.default.encode(coinInfo.prefix, words4);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const transaction = {
            to: this.address,
            data: "0x3b3b57de" + namehash(this.name).substring(2)
          };
          const hexBytes2 = yield this.provider.call(transaction);
          if (hexBytes2 === "0x" || hexBytes2 === HashZero2) {
            return null;
          }
          return this.provider.formatter.callAddress(hexBytes2);
        } catch (error) {
          if (error.code === Logger4.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger25.throwError(`invalid or unsupported coin data`, Logger4.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter9(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i2 = 0; i2 < matchers.length; i2++) {
          const match = avatar.match(matchers[i2]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad3(BigNumber3.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance2 = BigNumber3.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad3(owner, 32), tokenId])
                }));
                if (balance2.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance2.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx));
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter9(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      return logger25.throwError(`invalid or unsupported content hash data`, Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key6) {
    return __awaiter9(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key6);
      keyBytes = concat3([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat3([keyBytes, hexZeroPad3("0x", 32 - key6.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify3(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
};
var defaultFormatter = null;
var nextPollId = 1;
var BaseProvider = class extends Provider {
  constructor(network) {
    logger25.checkNew(new.target, Provider);
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.formatter = new.target.getFormatter();
    defineReadOnly2(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly2(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger25.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter9(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger25.throwError("no network detected", Logger4.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly2(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger4.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  _getInternalBlockNumber(maxAge) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties2({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber3.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter9(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger25.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger25.makeError("network block skew detected", Logger4.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i2 = this._emitted.block + 1; i2 <= blockNumber; i2++) {
          this.emit("block", i2);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key6) => {
          if (key6 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key6];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key6];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash11 = event.hash;
            let runner = this.getTransactionReceipt(hash11).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash11] = receipt.blockNumber;
              this.emit(hash11, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            const filter2 = event.filter;
            filter2.fromBlock = this._lastBlockNumber + 1;
            filter2.toBlock = blockNumber;
            const runner = this.getLogs(filter2).then((logs) => {
              if (logs.length === 0) {
                return;
              }
              logs.forEach((log) => {
                this._emitted["b:" + log.blockHash] = log.blockNumber;
                this._emitted["t:" + log.transactionHash] = log.blockNumber;
                this.emit(filter2, log);
              });
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return __awaiter9(this, void 0, void 0, function* () {
      return logger25.throwError("provider does not support network detection", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter9(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger25.makeError("underlying network changed", Logger4.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now3 = getTime();
    if (now3 - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now3;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout2) {
    return __awaiter9(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout2 || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout2, replaceable) {
    return __awaiter9(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter9(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter9(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger25.makeError("transaction was replaced", Logger4.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout2 === "number" && timeout2 > 0) {
          const timer3 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger25.makeError("timeout exceeded", Logger4.errors.TIMEOUT, { timeout: timeout2 }));
          }, timeout2);
          if (timer3.unref) {
            timer3.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer3);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter9(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber3.from(result);
      } catch (error) {
        return logger25.throwError("bad result from backend", Logger4.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties2({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber3.from(result);
      } catch (error) {
        return logger25.throwError("bad result from backend", Logger4.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties2({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber3.from(result).toNumber();
      } catch (error) {
        return logger25.throwError("bad result from backend", Logger4.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties2({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify3(result);
      } catch (error) {
        return logger25.throwError("bad result from backend", Logger4.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties2({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p2) => hexValue(p2))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify3(result);
      } catch (error) {
        return logger25.throwError("bad result from backend", Logger4.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  _wrapTransaction(tx, hash11, startBlock) {
    if (hash11 != null && hexDataLength(hash11) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash11 != null && tx.hash !== hash11) {
      logger25.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger4.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash11 });
    }
    result.wait = (confirms, timeout2) => __awaiter9(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout2 == null) {
        timeout2 = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout2, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger25.throwError("transaction failed", Logger4.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t2) => hexlify3(t2));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash11 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash11, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter9(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key6) => {
        if (values[key6] == null) {
          return;
        }
        tx[key6] = Promise.resolve(values[key6]).then((v2) => v2 ? this._getAddress(v2) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key6) => {
        if (values[key6] == null) {
          return;
        }
        tx[key6] = Promise.resolve(values[key6]).then((v2) => v2 ? BigNumber3.from(v2) : null);
      });
      ["type"].forEach((key6) => {
        if (values[key6] == null) {
          return;
        }
        tx[key6] = Promise.resolve(values[key6]).then((v2) => v2 != null ? v2 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key6) => {
        if (values[key6] == null) {
          return;
        }
        tx[key6] = Promise.resolve(values[key6]).then((v2) => v2 ? hexlify3(v2) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties2(tx));
    });
  }
  _getFilter(filter2) {
    return __awaiter9(this, void 0, void 0, function* () {
      filter2 = yield filter2;
      const result = {};
      if (filter2.address != null) {
        result.address = this._getAddress(filter2.address);
      }
      ["blockHash", "topics"].forEach((key6) => {
        if (filter2[key6] == null) {
          return;
        }
        result[key6] = filter2[key6];
      });
      ["fromBlock", "toBlock"].forEach((key6) => {
        if (filter2[key6] == null) {
          return;
        }
        result[key6] = this._getBlockTag(filter2[key6]);
      });
      return this.formatter.filter(yield resolveProperties2(result));
    });
  }
  call(transaction, blockTag) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties2({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("call", params);
      try {
        return hexlify3(result);
      } catch (error) {
        return logger25.throwError("bad result from backend", Logger4.errors.SERVER_ERROR, {
          method: "call",
          params,
          result,
          error
        });
      }
    });
  }
  estimateGas(transaction) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties2({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber3.from(result);
      } catch (error) {
        return logger25.throwError("bad result from backend", Logger4.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter9(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger25.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger25.throwError("ENS name not configured", Logger4.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString3(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString3(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger25.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter9(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i2 = 0; i2 < block.transactions.length; i2++) {
            const tx = block.transactions[i2];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter9(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter9(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter2) {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties2({ filter: this._getFilter(filter2) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter9(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter9(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger25.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter9(this, void 0, void 0, function* () {
      try {
        const address = yield this._getResolver(name2);
        if (address == null) {
          return null;
        }
        return new Resolver(this, address, name2);
      } catch (error) {
        if (error.code === Logger4.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _getResolver(name2) {
    return __awaiter9(this, void 0, void 0, function* () {
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger25.throwError("network does not support ENS", Logger4.errors.UNSUPPORTED_OPERATION, { operation: "ENS", network: network.name });
      }
      const transaction = {
        to: network.ensAddress,
        data: "0x0178b8bf" + namehash(name2).substring(2)
      };
      try {
        return this.formatter.callAddress(yield this.call(transaction));
      } catch (error) {
        if (error.code === Logger4.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  resolveName(name2) {
    return __awaiter9(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error) {
        if (isHexString3(name2)) {
          throw error;
        }
      }
      if (typeof name2 !== "string") {
        logger25.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter9(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddress = yield this._getResolver(reverseName);
      if (!resolverAddress) {
        return null;
      }
      let bytes = arrayify3(yield this.call({
        to: resolverAddress,
        data: "0x691f3431" + namehash(reverseName).substring(2)
      }));
      if (bytes.length < 32 || !BigNumber3.from(bytes.slice(0, 32)).eq(32)) {
        return null;
      }
      bytes = bytes.slice(32);
      if (bytes.length < 32) {
        return null;
      }
      const length = BigNumber3.from(bytes.slice(0, 32)).toNumber();
      bytes = bytes.slice(32);
      if (length > bytes.length) {
        return null;
      }
      const name2 = toUtf8String(bytes.slice(0, length));
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter9(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString3(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(reverseName);
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, "_", address);
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger25.throwError(method + " not implemented", Logger4.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e) => e.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e) => e.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event(getEventTag(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-signer/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
init_define_process_env();
var version25 = "abstract-signer/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/abstract-signer/lib.esm/index.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger26 = new Logger4(version25);
var allowedTransactionKeys2 = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
var forwardErrors2 = [
  Logger4.errors.INSUFFICIENT_FUNDS,
  Logger4.errors.NONCE_EXPIRED,
  Logger4.errors.REPLACEMENT_UNDERPRICED
];
var Signer2 = class {
  constructor() {
    logger26.checkAbstract(new.target, Signer2);
    defineReadOnly2(this, "_isSigner", true);
  }
  getBalance(blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  estimateGas(transaction) {
    return __awaiter10(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties2(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  call(transaction, blockTag) {
    return __awaiter10(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties2(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  sendTransaction(transaction) {
    return __awaiter10(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter10(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter10(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter10(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter10(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  checkTransaction(transaction) {
    for (const key6 in transaction) {
      if (allowedTransactionKeys2.indexOf(key6) === -1) {
        logger26.throwArgumentError("invalid transaction key: " + key6, "transaction", transaction);
      }
    }
    const tx = shallowCopy2(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger26.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  populateTransaction(transaction) {
    return __awaiter10(this, void 0, void 0, function* () {
      const tx = yield resolveProperties2(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter10(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger26.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger26.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger26.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger26.throwError("network does not support EIP-1559", Logger4.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger26.throwError("failed to get consistent fee data", Logger4.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors2.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger26.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger4.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger26.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties2(tx);
    });
  }
  _checkProvider(operation) {
    if (!this.provider) {
      logger26.throwError("missing provider", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger27 = new Logger4(version22);
var errorGas = ["call", "estimateGas"];
function checkError(method, error, params) {
  if (method === "call" && error.code === Logger4.errors.SERVER_ERROR) {
    const e = error.error;
    if (e && e.message.match("reverted") && isHexString3(e.data)) {
      return e.data;
    }
    logger27.throwError("missing revert data in call exception", Logger4.errors.CALL_EXCEPTION, {
      error,
      data: "0x"
    });
  }
  let message = error.message;
  if (error.code === Logger4.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  const transaction = params.transaction || params.signedTransaction;
  if (message.match(/insufficient funds|base fee exceeds gas limit/)) {
    logger27.throwError("insufficient funds for intrinsic transaction cost", Logger4.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce too low/)) {
    logger27.throwError("nonce has already been used", Logger4.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced/)) {
    logger27.throwError("replacement fee too low", Logger4.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/)) {
    logger27.throwError("legacy pre-eip-155 transactions not supported", Logger4.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
    logger27.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger4.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer2(timeout2) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout2);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
var _constructorGuard7 = {};
var JsonRpcSigner = class extends Signer2 {
  constructor(constructorGuard, provider, addressOrIndex) {
    logger27.checkNew(new.target, JsonRpcSigner);
    super();
    if (constructorGuard !== _constructorGuard7) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly2(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly2(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly2(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly2(this, "_index", addressOrIndex);
      defineReadOnly2(this, "_address", null);
    } else {
      logger27.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger27.throwError("cannot alter JSON-RPC Signer connection", Logger4.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard7, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts2) => {
      if (accounts2.length <= this._index) {
        logger27.throwError("unknown account #" + this._index, Logger4.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts2[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy2(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy2(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter11(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger27.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties2({
      tx: resolveProperties2(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger27.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash11) => {
        return hash11;
      }, (error) => {
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger27.throwError("signing transactions is unsupported", Logger4.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter11(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash11 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter11(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash11);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash11, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash11;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter11(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("personal_sign", [hexlify3(data), address.toLowerCase()]);
    });
  }
  _legacySignMessage(message) {
    return __awaiter11(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify3(data)]);
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter11(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      return yield this.provider.send("eth_signTypedData_v4", [
        address.toLowerCase(),
        JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
      ]);
    });
  }
  unlock(password) {
    return __awaiter11(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
};
var UncheckedJsonRpcSigner = class extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash11) => {
      return {
        hash: hash11,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash11, confirmations);
        }
      };
    });
  }
};
var allowedTransactionKeys3 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
var JsonRpcProvider = class extends BaseProvider {
  constructor(url, network) {
    logger27.checkNew(new.target, JsonRpcProvider);
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly2(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly2(this, "connection", Object.freeze(shallowCopy2(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter11(this, void 0, void 0, function* () {
      yield timer2(0);
      let chainId2 = null;
      try {
        chainId2 = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId2 = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId2 != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber3.from(chainId2).toNumber());
        } catch (error) {
          return logger27.throwError("could not detect network", Logger4.errors.NETWORK_ERROR, {
            chainId: chainId2,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger27.throwError("could not detect network", Logger4.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard7, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts2) => {
      return accounts2.map((a2) => this.formatter.address(a2));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
      default:
        break;
    }
    return null;
  }
  perform(method, params) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber3.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy2(params);
              params.transaction = shallowCopy2(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger27.throwError(method + " not implemented", Logger4.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll3() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash11) {
            self2._emitted["t:" + hash11.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash11).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer2(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll3();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll3();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy2(allowedTransactionKeys3);
    if (allowExtra) {
      for (const key6 in allowExtra) {
        if (allowExtra[key6]) {
          allowed[key6] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key6) {
      if (transaction[key6] == null) {
        return;
      }
      const value = hexValue(transaction[key6]);
      if (key6 === "gasLimit") {
        key6 = "gas";
      }
      result[key6] = value;
    });
    ["from", "to", "data"].forEach(function(key6) {
      if (transaction[key6] == null) {
        return;
      }
      result[key6] = hexlify3(transaction[key6]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/ws.js
init_define_process_env();
var WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger143 = new Logger4(version22);
  WS = function() {
    logger143.throwError("WebSockets not supported in this environment", Logger4.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger28 = new Logger4(version22);
var NextId = 1;
var WebSocketProvider = class extends JsonRpcProvider {
  constructor(url, network) {
    if (network === "any") {
      logger28.throwError("WebSocketProvider does not support 'any' network yet", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    super(url, network);
    this._pollingInterval = -1;
    this._wsReady = false;
    defineReadOnly2(this, "_websocket", new WS(this.connection.url));
    defineReadOnly2(this, "_requests", {});
    defineReadOnly2(this, "_subs", {});
    defineReadOnly2(this, "_subIds", {});
    defineReadOnly2(this, "_detectNetwork", super.detectNetwork());
    this._websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id7) => {
        this._websocket.send(this._requests[id7].payload);
      });
    };
    this._websocket.onmessage = (messageEvent) => {
      const data = messageEvent.data;
      const result = JSON.parse(data);
      if (result.id != null) {
        const id7 = String(result.id);
        const request = this._requests[id7];
        delete this._requests[id7];
        if (result.result !== void 0) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            defineReadOnly2(error, "code", result.error.code || null);
            defineReadOnly2(error, "response", data);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, void 0);
          this.emit("debug", {
            action: "response",
            error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger28.throwError("cannot reset events block on WebSocketProvider", Logger4.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger28.throwError("cannot set polling interval on WebSocketProvider", Logger4.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter12(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger28.throwError("cannot set polling on WebSocketProvider", Logger4.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this._websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter12(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = BigNumber3.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = (event2) => {
          const hash11 = event2.hash;
          this.getTransactionReceipt(hash11).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash11, receipt);
          });
        };
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e) => e.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e) => e.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter12(this, void 0, void 0, function* () {
      if (this._websocket.readyState === WS.CONNECTING) {
        yield new Promise((resolve) => {
          this._websocket.onopen = function() {
            resolve(true);
          };
          this._websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this._websocket.close(1e3);
    });
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
init_define_process_env();
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger29 = new Logger4(version22);
var StaticJsonRpcProvider = class extends JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter13(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger29.throwError("no network detected", Logger4.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          defineReadOnly2(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
};
var UrlJsonRpcProvider = class extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger29.checkAbstract(new.target, UrlJsonRpcProvider);
    network = getStatic(new.target, "getNetwork")(network);
    apiKey = getStatic(new.target, "getApiKey")(apiKey);
    const connection = getStatic(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      defineReadOnly2(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key6) => {
        defineReadOnly2(this, key6, apiKey[key6]);
      });
    }
  }
  _startPending() {
    logger29.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger29.throwError("API provider does not support signing", Logger4.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  static getApiKey(apiKey) {
    return apiKey;
  }
  static getUrl(network, apiKey) {
    return logger29.throwError("not implemented; sub-classes must override getUrl", Logger4.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var logger30 = new Logger4(version22);
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
var AlchemyWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new AlchemyProvider(network, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    defineReadOnly2(this, "apiKey", provider.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};
var AlchemyProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger30.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "ropsten":
        host = "eth-ropsten.alchemyapi.io/v2/";
        break;
      case "rinkeby":
        host = "eth-rinkeby.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.alchemyapi.io/v2/";
        break;
      case "kovan":
        host = "eth-kovan.alchemyapi.io/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-rinkeby":
        host = "arb-rinkeby.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-kovan":
        host = "opt-kovan.g.alchemy.com/v2/";
        break;
      default:
        logger30.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https://" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
init_define_process_env();
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger31 = new Logger4(version22);
var CloudflareProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger31.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger31.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter14(this, void 0, void 0, function* () {
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
        return block.number;
      }
      return _super.perform.call(this, method, params);
    });
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
init_define_process_env();
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger32 = new Logger4(version22);
function getTransactionPostData(transaction) {
  const result = {};
  for (let key6 in transaction) {
    if (transaction[key6] == null) {
      continue;
    }
    let value = transaction[key6];
    if (key6 === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key6]) {
      value = hexValue(hexlify3(value));
    } else if (key6 === "accessList") {
      value = "[" + accessListify(value).map((set) => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify3(value);
    }
    result[key6] = value;
  }
  return result;
}
function getResult2(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || result.message != "OK") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
var defaultApiKey2 = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";
function checkError2(method, error, transaction) {
  if (method === "call" && error.code === Logger4.errors.SERVER_ERROR) {
    const e = error.error;
    if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
      let data = e.data;
      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }
      if (isHexString3(data)) {
        return data;
      }
      logger32.throwError("missing revert data in call exception", Logger4.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === Logger4.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger32.throwError("insufficient funds for intrinsic transaction cost", Logger4.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger32.throwError("nonce has already been used", Logger4.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger32.throwError("replacement fee too low", Logger4.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger32.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger4.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
var EtherscanProvider = class extends BaseProvider {
  constructor(network, apiKey) {
    logger32.checkNew(new.target, EtherscanProvider);
    super(network);
    defineReadOnly2(this, "baseUrl", this.getBaseUrl());
    defineReadOnly2(this, "apiKey", apiKey || defaultApiKey2);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "ropsten":
        return "https://api-ropsten.etherscan.io";
      case "rinkeby":
        return "https://api-rinkeby.etherscan.io";
      case "kovan":
        return "https://api-kovan.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      default:
    }
    return logger32.throwArgumentError("unsupported network", "network", name);
  }
  getUrl(module, params) {
    const query = Object.keys(params).reduce((accum, key6) => {
      const value = params[key6];
      if (value != null) {
        accum += `&${key6}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module, params, post) {
    return __awaiter15(this, void 0, void 0, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module, params);
      const payload = post ? this.getPostData(module, params) : null;
      const procFunc = module === "proxy" ? getJsonResult : getResult2;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url,
        throttleSlotInterval: 1e3,
        throttleCallback: (attempt, url2) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
        payloadStr = Object.keys(payload).map((key6) => {
          return `${key6}=${payload[key6]}`;
        }).join("&");
      }
      const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: deepCopy(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter15(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter15(this, void 0, void 0, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch((error) => {
            return checkError2("sendTransaction", error, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call": {
          if (params.blockTag !== "latest") {
            throw new Error("EtherscanProvider does not support blockTag for call");
          }
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_call";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("call", error, params.transaction);
          }
        }
        case "estimateGas": {
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("estimateGas", error, params.transaction);
          }
        }
        case "getLogs": {
          const args = { action: "getLogs" };
          if (params.filter.fromBlock) {
            args.fromBlock = checkLogTag(params.filter.fromBlock);
          }
          if (params.filter.toBlock) {
            args.toBlock = checkLogTag(params.filter.toBlock);
          }
          if (params.filter.address) {
            args.address = params.filter.address;
          }
          if (params.filter.topics && params.filter.topics.length > 0) {
            if (params.filter.topics.length > 1) {
              logger32.throwError("unsupported topic count", Logger4.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
            }
            if (params.filter.topics.length === 1) {
              const topic0 = params.filter.topics[0];
              if (typeof topic0 !== "string" || topic0.length !== 66) {
                logger32.throwError("unsupported topic format", Logger4.errors.UNSUPPORTED_OPERATION, { topic0 });
              }
              args.topic0 = topic0;
            }
          }
          const logs = yield this.fetch("logs", args);
          let blocks = {};
          for (let i2 = 0; i2 < logs.length; i2++) {
            const log = logs[i2];
            if (log.blockHash != null) {
              continue;
            }
            if (blocks[log.blockNumber] == null) {
              const block = yield this.getBlock(log.blockNumber);
              if (block) {
                blocks[log.blockNumber] = block.hash;
              }
            }
            log.blockHash = blocks[log.blockNumber];
          }
          return logs;
        }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0;
          }
          return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
        default:
          break;
      }
      return _super.perform.call(this, method, params);
    });
  }
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter15(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map((tx) => {
        ["contractAddress", "to"].forEach(function(key6) {
          if (tx[key6] == "") {
            delete tx[key6];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/random/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/random/lib.esm/random.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/random/lib.esm/_version.js
init_define_process_env();
var version26 = "random/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/random/lib.esm/random.js
var logger33 = new Logger4(version26);
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal = getGlobal();
var crypto = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto || !crypto.getRandomValues) {
  logger33.warn("WARNING: Missing strong random number source");
  crypto = {
    getRandomValues: function(buffer2) {
      return logger33.throwError("no secure random source avaialble", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/node_modules/@ethersproject/random/lib.esm/shuffle.js
init_define_process_env();
function shuffled(array) {
  array = array.slice();
  for (let i2 = array.length - 1; i2 > 0; i2--) {
    const j2 = Math.floor(Math.random() * (i2 + 1));
    const tmp = array[i2];
    array[i2] = array[j2];
    array[j2] = tmp;
  }
  return array;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger34 = new Logger4(version22);
function now() {
  return new Date().getTime();
}
function checkNetworks(networks2) {
  let result = null;
  for (let i2 = 0; i2 < networks2.length; i2++) {
    const network = networks2[i2];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger34.throwArgumentError("provider mismatch", "networks", networks2);
      }
    } else {
      result = network;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a2 = values[middle - 1], b2 = values[middle];
  if (maxDelta != null && Math.abs(a2 - b2) > maxDelta) {
    return null;
  }
  return (a2 + b2) / 2;
}
function serialize(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber3.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i2) => serialize(i2)));
  } else if (typeof value === "object") {
    const keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map((key6) => {
      let v2 = value[key6];
      if (typeof v2 === "function") {
        v2 = "[function]";
      } else {
        v2 = serialize(v2);
      }
      return JSON.stringify(key6) + ":" + v2;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
var nextRid = 1;
function stall2(duration) {
  let cancel = null;
  let timer3 = null;
  let promise2 = new Promise((resolve) => {
    cancel = function() {
      if (timer3) {
        clearTimeout(timer3);
        timer3 = null;
      }
      resolve();
    };
    timer3 = setTimeout(cancel, duration);
  });
  const wait2 = (func) => {
    promise2 = promise2.then(func);
    return promise2;
  };
  function getPromise() {
    return promise2;
  }
  return { cancel, getPromise, wait: wait2 };
}
var ForwardErrors = [
  Logger4.errors.CALL_EXCEPTION,
  Logger4.errors.INSUFFICIENT_FUNDS,
  Logger4.errors.NONCE_EXPIRED,
  Logger4.errors.REPLACEMENT_UNDERPRICED,
  Logger4.errors.UNPREDICTABLE_GAS_LIMIT
];
var ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(config2, now3) {
  const result = {
    weight: config2.weight
  };
  Object.defineProperty(result, "provider", { get: () => config2.provider });
  if (config2.start) {
    result.start = config2.start;
  }
  if (now3) {
    result.duration = now3 - config2.start;
  }
  if (config2.done) {
    if (config2.error) {
      result.error = config2.error;
    } else {
      result.result = config2.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c2) => {
      const value = normalize(c2.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c2.result };
      }
      tally[value].count++;
    });
    const keys = Object.keys(tally);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const check = tally[keys[i2]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider, method, params) {
  let normalize = serialize;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c2) => c2.result);
        let blockNumber = median(configs.map((c2) => c2.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c2) => c2.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c2) => c2.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy2(tx);
        tx.confirmations = -1;
        return serialize(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy2(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy2(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize(block);
        };
      } else {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          return serialize(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize, provider.quorum);
}
function waitForSync(config2, blockNumber) {
  return __awaiter16(this, void 0, void 0, function* () {
    const provider = config2.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          if (config2.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider });
  });
}
function getRunner(config2, currentBlockNumber, method, params) {
  return __awaiter16(this, void 0, void 0, function* () {
    let provider = config2.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString3(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString3(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString3(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString3(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs": {
        let filter2 = params.filter;
        if (filter2.fromBlock && isHexString3(filter2.fromBlock) || filter2.toBlock && isHexString3(filter2.toBlock)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getLogs(filter2);
      }
    }
    return logger34.throwError("unknown method error", Logger4.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
var FallbackProvider = class extends BaseProvider {
  constructor(providers, quorum) {
    logger34.checkNew(new.target, FallbackProvider);
    if (providers.length === 0) {
      logger34.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index) => {
      if (Provider.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config2 = shallowCopy2(configOrProvider);
      if (config2.priority == null) {
        config2.priority = 1;
      }
      if (config2.stallTimeout == null) {
        config2.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
      }
      if (config2.weight == null) {
        config2.weight = 1;
      }
      const weight = config2.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger34.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
      }
      return Object.freeze(config2);
    });
    const total = providerConfigs.reduce((accum, c2) => accum + c2.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger34.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c2) => c2.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    defineReadOnly2(this, "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly2(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter16(this, void 0, void 0, function* () {
      const networks2 = yield Promise.all(this.providerConfigs.map((c2) => c2.provider.getNetwork()));
      return checkNetworks(networks2);
    });
  }
  perform(method, params) {
    return __awaiter16(this, void 0, void 0, function* () {
      if (method === "sendTransaction") {
        const results = yield Promise.all(this.providerConfigs.map((c2) => {
          return c2.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error) => {
            return error;
          });
        }));
        for (let i3 = 0; i3 < results.length; i3++) {
          const result = results[i3];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results[0];
      }
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      const configs = shuffled(this.providerConfigs.map(shallowCopy2));
      configs.sort((a2, b2) => a2.priority - b2.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i2 = 0;
      let first2 = true;
      while (true) {
        const t0 = now();
        let inflightWeight = configs.filter((c2) => c2.runner && t0 - c2.start < c2.stallTimeout).reduce((accum, c2) => accum + c2.weight, 0);
        while (inflightWeight < this.quorum && i2 < configs.length) {
          const config2 = configs[i2++];
          const rid = nextRid++;
          config2.start = now();
          config2.staller = stall2(config2.stallTimeout);
          config2.staller.wait(() => {
            config2.staller = null;
          });
          config2.runner = getRunner(config2, currentBlockNumber, method, params).then((result) => {
            config2.done = true;
            config2.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          }, (error) => {
            config2.done = true;
            config2.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config2, null),
              request: { method, params: deepCopy(params) },
              provider: this
            });
          }
          inflightWeight += config2.weight;
        }
        const waiting = [];
        configs.forEach((c2) => {
          if (c2.done || !c2.runner) {
            return;
          }
          waiting.push(c2.runner);
          if (c2.staller) {
            waiting.push(c2.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results = configs.filter((c2) => c2.done && c2.error == null);
        if (results.length >= this.quorum) {
          const result = processFunc(results);
          if (result !== void 0) {
            configs.forEach((c2) => {
              if (c2.staller) {
                c2.staller.cancel();
              }
              c2.cancelled = true;
            });
            return result;
          }
          if (!first2) {
            yield stall2(100).getPromise();
          }
          first2 = false;
        }
        const errors = configs.reduce((accum, c2) => {
          if (!c2.done || c2.error == null) {
            return accum;
          }
          const code = c2.error.code;
          if (ForwardErrors.indexOf(code) >= 0) {
            if (!accum[code]) {
              accum[code] = { error: c2.error, weight: 0 };
            }
            accum[code].weight += c2.weight;
          }
          return accum;
        }, {});
        Object.keys(errors).forEach((errorCode) => {
          const tally = errors[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c2) => {
            if (c2.staller) {
              c2.staller.cancel();
            }
            c2.cancelled = true;
          });
          const e = tally.error;
          const props = {};
          ForwardProperties.forEach((name2) => {
            if (e[name2] == null) {
              return;
            }
            props[name2] = e[name2];
          });
          logger34.throwError(e.reason || e.message, errorCode, props);
        });
        if (configs.filter((c2) => !c2.done).length === 0) {
          break;
        }
      }
      configs.forEach((c2) => {
        if (c2.staller) {
          c2.staller.cancel();
        }
        c2.cancelled = true;
      });
      return logger34.throwError("failed to meet quorum", Logger4.errors.SERVER_ERROR, {
        method,
        params,
        results: configs.map((c2) => exposeDebugConfig(c2)),
        provider: this
      });
    });
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
init_define_process_env();
var IpcProvider = null;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/infura-provider.js
init_define_process_env();
var logger35 = new Logger4(version22);
var defaultProjectId = "84842078b09946638c03157f83405213";
var InfuraWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger35.throwError("INFURA WebSocket project secrets unsupported", Logger4.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    defineReadOnly2(this, "apiKey", provider.projectId);
    defineReadOnly2(this, "projectId", provider.projectId);
    defineReadOnly2(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};
var InfuraProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger35.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger35.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "ropsten":
        host = "ropsten.infura.io";
        break;
      case "rinkeby":
        host = "rinkeby.infura.io";
        break;
      case "kovan":
        host = "kovan.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-kovan":
        host = "optimism-kovan.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-rinkeby":
        host = "arbitrum-rinkeby.infura.io";
        break;
      default:
        logger35.throwError("unsupported network", Logger4.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
init_define_process_env();
var JsonRpcBatchProvider = class extends JsonRpcProvider {
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = { request, resolve: null, reject: null };
    const promise2 = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        const request2 = batch.map((inflight) => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: deepCopy(request2),
          provider: this
        });
        return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
          this.emit("debug", {
            action: "response",
            request: request2,
            response: result,
            provider: this
          });
          batch.forEach((inflightRequest2, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest2.reject(error);
            } else {
              inflightRequest2.resolve(payload.result);
            }
          });
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request: request2,
            provider: this
          });
          batch.forEach((inflightRequest2) => {
            inflightRequest2.reject(error);
          });
        });
      }, 10);
    }
    return promise2;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
init_define_process_env();
var logger36 = new Logger4(version22);
var defaultApiKey3 = "ETHERS_JS_SHARED";
var NodesmithProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger36.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey3;
  }
  static getUrl(network, apiKey) {
    logger36.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger36.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
init_define_process_env();
var logger37 = new Logger4(version22);
var defaultApplicationIds = {
  homestead: "6004bcd10040261633ade990",
  ropsten: "6004bd4d0040261633ade991",
  rinkeby: "6004bda20040261633ade994",
  goerli: "6004bd860040261633ade992"
};
var PocketProvider = class extends UrlJsonRpcProvider {
  constructor(network, apiKey) {
    if (apiKey == null) {
      const n = getStatic(new.target, "getNetwork")(network);
      if (n) {
        const applicationId = defaultApplicationIds[n.name];
        if (applicationId) {
          apiKey = {
            applicationId,
            loadBalancer: true
          };
        }
      }
      if (apiKey == null) {
        logger37.throwError("unsupported network", Logger4.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
      }
    }
    super(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      logger37.throwArgumentError("PocketProvider.getApiKey does not support null apiKey", "apiKey", apiKey);
    }
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: false,
      applicationSecretKey: null
    };
    if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      logger37.assertArgument(typeof apiKey.applicationId === "string", "applicationSecretKey requires an applicationId", "applicationId", apiKey.applicationId);
      logger37.assertArgument(typeof apiKey.applicationSecretKey === "string", "invalid applicationSecretKey", "applicationSecretKey", "[REDACTED]");
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
      apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
    } else if (apiKey.applicationId) {
      logger37.assertArgument(typeof apiKey.applicationId === "string", "apiKey.applicationId must be a string", "apiKey.applicationId", apiKey.applicationId);
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
    } else {
      logger37.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      default:
        logger37.throwError("unsupported network", Logger4.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    let url = null;
    if (apiKey.loadBalancer) {
      url = `https://${host}/v1/lb/${apiKey.applicationId}`;
    } else {
      url = `https://${host}/v1/${apiKey.applicationId}`;
    }
    const connection = { url };
    connection.headers = {};
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationIds[this.network.name];
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/web3-provider.js
init_define_process_env();
var logger38 = new Logger4(version22);
var _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
var Web3Provider = class extends JsonRpcProvider {
  constructor(provider, network) {
    logger38.checkNew(new.target, Web3Provider);
    if (provider == null) {
      logger38.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger38.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly2(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly2(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/providers/lib.esm/index.js
var logger39 = new Logger4(version22);
function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1]) {
        case "http":
          return new JsonRpcProvider(network);
        case "ws":
          return new WebSocketProvider(network);
        default:
          logger39.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n = getNetwork(network);
  if (!n || !n._defaultProvider) {
    logger39.throwError("unsupported getDefaultProvider network", Logger4.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/id.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha32 = __toESM(require_sha3());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version27 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors5 = false;
var _censorErrors5 = false;
var LogLevels5 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel5 = LogLevels5["default"];
var _globalLogger5 = null;
function _checkNormalize5() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError5 = _checkNormalize5();
var LogLevel5;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel5 || (LogLevel5 = {}));
var ErrorCode5;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode5 || (ErrorCode5 = {}));
var HEX5 = "0123456789abcdef";
var Logger5 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels5[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel5 > LogLevels5[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger5.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger5.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger5.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors5) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger5.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX5[value[i2] >> 4];
            hex += HEX5[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode5.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode5.CALL_EXCEPTION:
      case ErrorCode5.INSUFFICIENT_FUNDS:
      case ErrorCode5.MISSING_NEW:
      case ErrorCode5.NONCE_EXPIRED:
      case ErrorCode5.REPLACEMENT_UNDERPRICED:
      case ErrorCode5.TRANSACTION_REPLACED:
      case ErrorCode5.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger5.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError5) {
      this.throwError("platform missing String.prototype.normalize", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError5
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger5.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger5.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger5.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger5.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger5.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger5.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger5.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger5) {
      _globalLogger5 = new Logger5(version27);
    }
    return _globalLogger5;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors5) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors5 = !!censorship;
    _permanentCensorErrors5 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels5[logLevel.toLowerCase()];
    if (level == null) {
      Logger5.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel5 = level;
  }
  static from(version130) {
    return new Logger5(version130);
  }
};
Logger5.errors = ErrorCode5;
Logger5.levels = LogLevel5;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version28 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger40 = new Logger5(version28);
function isHexable4(value) {
  return !!value.toHexString;
}
function addSlice4(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice4(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger4(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes4(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger4(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger4(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify4(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger40.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice4(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable4(value)) {
    value = value.toHexString();
  }
  if (isHexString4(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger40.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice4(new Uint8Array(result));
  }
  if (isBytes4(value)) {
    return addSlice4(new Uint8Array(value));
  }
  return logger40.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString4(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters4 = "0123456789abcdef";
function hexlify4(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger40.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters4[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable4(value)) {
    return value.toHexString();
  }
  if (isHexString4(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger40.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes4(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters4[(v2 & 240) >> 4] + HexCharacters4[v2 & 15];
    }
    return result;
  }
  return logger40.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad4(value, length) {
  if (typeof value !== "string") {
    value = hexlify4(value);
  } else if (!isHexString4(value)) {
    logger40.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger40.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/keccak256/lib.esm/index.js
function keccak2563(data) {
  return "0x" + import_js_sha32.default.keccak_256(arrayify4(data));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn5 = __toESM(require_bn());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version29 = "bignumber/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN5 = import_bn5.default.BN;
var logger41 = new Logger5(version29);
var _constructorGuard8 = {};
var MAX_SAFE4 = 9007199254740991;
function isBigNumberish4(value) {
  return value != null && (BigNumber4.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString4(value) || typeof value === "bigint" || isBytes4(value));
}
var _warnedToStringRadix4 = false;
var BigNumber4 = class {
  constructor(constructorGuard, hex) {
    logger41.checkNew(new.target, BigNumber4);
    if (constructorGuard !== _constructorGuard8) {
      logger41.throwError("cannot call constructor directly; use BigNumber.from", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber4(toBN4(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber4(toBN4(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber4.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber4(toBN4(this).add(toBN4(other)));
  }
  sub(other) {
    return toBigNumber4(toBN4(this).sub(toBN4(other)));
  }
  div(other) {
    const o = BigNumber4.from(other);
    if (o.isZero()) {
      throwFault7("division-by-zero", "div");
    }
    return toBigNumber4(toBN4(this).div(toBN4(other)));
  }
  mul(other) {
    return toBigNumber4(toBN4(this).mul(toBN4(other)));
  }
  mod(other) {
    const value = toBN4(other);
    if (value.isNeg()) {
      throwFault7("division-by-zero", "mod");
    }
    return toBigNumber4(toBN4(this).umod(value));
  }
  pow(other) {
    const value = toBN4(other);
    if (value.isNeg()) {
      throwFault7("negative-power", "pow");
    }
    return toBigNumber4(toBN4(this).pow(value));
  }
  and(other) {
    const value = toBN4(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault7("unbound-bitwise-result", "and");
    }
    return toBigNumber4(toBN4(this).and(value));
  }
  or(other) {
    const value = toBN4(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault7("unbound-bitwise-result", "or");
    }
    return toBigNumber4(toBN4(this).or(value));
  }
  xor(other) {
    const value = toBN4(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault7("unbound-bitwise-result", "xor");
    }
    return toBigNumber4(toBN4(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault7("negative-width", "mask");
    }
    return toBigNumber4(toBN4(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault7("negative-width", "shl");
    }
    return toBigNumber4(toBN4(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault7("negative-width", "shr");
    }
    return toBigNumber4(toBN4(this).shrn(value));
  }
  eq(other) {
    return toBN4(this).eq(toBN4(other));
  }
  lt(other) {
    return toBN4(this).lt(toBN4(other));
  }
  lte(other) {
    return toBN4(this).lte(toBN4(other));
  }
  gt(other) {
    return toBN4(this).gt(toBN4(other));
  }
  gte(other) {
    return toBN4(this).gte(toBN4(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN4(this).isZero();
  }
  toNumber() {
    try {
      return toBN4(this).toNumber();
    } catch (error) {
      throwFault7("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger41.throwError("this platform does not support BigInt", Logger5.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix4) {
          _warnedToStringRadix4 = true;
          logger41.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger41.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger5.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger41.throwError("BigNumber.toString does not accept parameters", Logger5.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN4(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber4) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber4(_constructorGuard8, toHex4(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber4(_constructorGuard8, toHex4(new BN5(value)));
      }
      return logger41.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault7("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE4 || value <= -MAX_SAFE4) {
        throwFault7("overflow", "BigNumber.from", value);
      }
      return BigNumber4.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber4.from(anyValue.toString());
    }
    if (isBytes4(anyValue)) {
      return BigNumber4.from(hexlify4(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber4.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString4(hex) || hex[0] === "-" && isHexString4(hex.substring(1))) {
            return BigNumber4.from(hex);
          }
        }
      }
    }
    return logger41.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex4(value) {
  if (typeof value !== "string") {
    return toHex4(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger41.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex4(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber4(value) {
  return BigNumber4.from(toHex4(value));
}
function toBN4(value) {
  const hex = BigNumber4.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN5("-" + hex.substring(3), 16);
  }
  return new BN5(hex.substring(2), 16);
}
function throwFault7(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger41.throwError(fault, Logger5.errors.NUMERIC_FAULT, params);
}
function _base36To164(value) {
  return new BN5(value, 36).toString(16);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger42 = new Logger5(version29);
var _constructorGuard9 = {};
var Zero7 = BigNumber4.from(0);
var NegativeOne7 = BigNumber4.from(-1);
function throwFault8(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger42.throwError(message, Logger5.errors.NUMERIC_FAULT, params);
}
var zeros4 = "0";
while (zeros4.length < 256) {
  zeros4 += zeros4;
}
function getMultiplier4(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber4.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros4.substring(0, decimals);
  }
  return logger42.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed4(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier4(decimals);
  value = BigNumber4.from(value);
  const negative = value.lt(Zero7);
  if (negative) {
    value = value.mul(NegativeOne7);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed4(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier4(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger42.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger42.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger42.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault8("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber4.from(whole);
  const fractionValue = BigNumber4.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne7);
  }
  return wei;
}
var FixedFormat4 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard9) {
      logger42.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier4(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat4) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger42.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger42.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger42.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger42.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat4(_constructorGuard9, signed, width, decimals);
  }
};
var FixedNumber4 = class {
  constructor(constructorGuard, hex, value, format) {
    logger42.checkNew(new.target, FixedNumber4);
    if (constructorGuard !== _constructorGuard9) {
      logger42.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger5.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger42.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed4(this._value, this.format.decimals);
    const b2 = parseFixed4(other._value, other.format.decimals);
    return FixedNumber4.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed4(this._value, this.format.decimals);
    const b2 = parseFixed4(other._value, other.format.decimals);
    return FixedNumber4.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed4(this._value, this.format.decimals);
    const b2 = parseFixed4(other._value, other.format.decimals);
    return FixedNumber4.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed4(this._value, this.format.decimals);
    const b2 = parseFixed4(other._value, other.format.decimals);
    return FixedNumber4.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber4.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE4.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber4.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE4.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger42.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber4.from("1" + zeros4.substring(0, decimals), this.format);
    const bump = BUMP4.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger42.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber4.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad4(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber4.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish4(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber4.fromString(formatFixed4(value, decimals), FixedFormat4.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat4.from(format);
    const numeric = parseFixed4(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero7)) {
      throwFault8("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad4(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed4(numeric, fixedFormat.decimals);
    return new FixedNumber4(_constructorGuard9, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat4.from(format);
    if (arrayify4(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber4.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed4(numeric, fixedFormat.decimals);
    return new FixedNumber4(_constructorGuard9, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber4.fromString(value, format);
    }
    if (isBytes4(value)) {
      return FixedNumber4.fromBytes(value, format);
    }
    try {
      return FixedNumber4.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger5.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger42.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE4 = FixedNumber4.from(1);
var BUMP4 = FixedNumber4.from("0.5");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne8 = BigNumber4.from(-1);
var Zero8 = BigNumber4.from(0);
var One4 = BigNumber4.from(1);
var Two3 = BigNumber4.from(2);
var WeiPerEther3 = BigNumber4.from("1000000000000000000");
var MaxUint2564 = BigNumber4.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2563 = BigNumber4.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2563 = BigNumber4.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version30 = "strings/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger43 = new Logger5(version30);
var UnicodeNormalizationForm2;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm2 || (UnicodeNormalizationForm2 = {}));
var Utf8ErrorReason2;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason2 || (Utf8ErrorReason2 = {}));
function errorFunc2(reason, offset, bytes, output, badCodepoint) {
  return logger43.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc2(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason2.BAD_PREFIX || reason === Utf8ErrorReason2.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason2.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc2(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason2.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc2(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs2 = Object.freeze({
  error: errorFunc2,
  ignore: ignoreFunc2,
  replace: replaceFunc2
});
function toUtf8Bytes2(str, form = UnicodeNormalizationForm2.current) {
  if (form != UnicodeNormalizationForm2.current) {
    logger43.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify4(result);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes22(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data.length; i2 += 4) {
    result.push(parseInt(data.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable2(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable2(data) {
  let hi = 0;
  return data.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges2 = createRangeTable2("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags2 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
var Table_B_2_lut_abs2 = createTable2("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel2 = createTable2("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex2 = createTable2("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes22);
var Table_C_ranges2 = createRangeTable2("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/id.js
function id2(text2) {
  return keccak2563(toUtf8Bytes2(text2));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/namehash.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/_version.js
init_define_process_env();
var version31 = "hash/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger44 = new Logger5(version31);
var Zeros2 = new Uint8Array(32);
Zeros2.fill(0);
var Partition2 = new RegExp("^((.*)\\.)?([^.]+)$");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/message.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/typed-data.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version32 = "rlp/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger45 = new Logger5(version32);

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version33 = "address/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/address/lib.esm/index.js
var logger46 = new Logger5(version33);
function getChecksumAddress2(address) {
  if (!isHexString4(address, 20)) {
    logger46.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify4(keccak2563(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER2 = 9007199254740991;
function log102(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
var ibanLookup2 = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup2[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup2[String.fromCharCode(65 + i2)] = String(10 + i2);
}
var safeDigits2 = Math.floor(log102(MAX_SAFE_INTEGER2));
function ibanChecksum2(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup2[c2];
  }).join("");
  while (expanded.length >= safeDigits2) {
    let block = expanded.substring(0, safeDigits2);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress2(address) {
  let result = null;
  if (typeof address !== "string") {
    logger46.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress2(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger46.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum2(address)) {
      logger46.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To164(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress2("0x" + result);
  } else {
    logger46.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version34 = "properties/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/properties/lib.esm/index.js
var logger47 = new Logger5(version34);
function defineReadOnly3(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/lib.esm/typed-data.js
var logger48 = new Logger5(version31);
var padding2 = new Uint8Array(32);
padding2.fill(0);
var NegativeOne9 = BigNumber4.from(-1);
var Zero9 = BigNumber4.from(0);
var One5 = BigNumber4.from(1);
var MaxUint2565 = BigNumber4.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var hexTrue2 = hexZeroPad4(One5.toHexString(), 32);
var hexFalse2 = hexZeroPad4(Zero9.toHexString(), 32);
function checkString2(key6) {
  return function(value) {
    if (typeof value !== "string") {
      logger48.throwArgumentError(`invalid domain value for ${JSON.stringify(key6)}`, `domain.${key6}`, value);
    }
    return value;
  };
}
var domainChecks2 = {
  name: checkString2("name"),
  version: checkString2("version"),
  chainId: function(value) {
    try {
      return BigNumber4.from(value).toString();
    } catch (error) {
    }
    return logger48.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress2(value).toLowerCase();
    } catch (error) {
    }
    return logger48.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify4(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify4(bytes);
    } catch (error) {
    }
    return logger48.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/lib.esm/_version.js
init_define_process_env();
var version35 = "wordlists/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist = false;
var logger49 = new Logger5(version35);
var Wordlist = class {
  constructor(locale) {
    logger49.checkAbstract(new.target, Wordlist);
    defineReadOnly3(this, "locale", locale);
  }
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  join(words4) {
    return words4.join(" ");
  }
  static check(wordlist4) {
    const words4 = [];
    for (let i2 = 0; i2 < 2048; i2++) {
      const word = wordlist4.getWord(i2);
      if (i2 !== wordlist4.getWordIndex(word)) {
        return "0x";
      }
      words4.push(word);
    }
    return id2(words4.join("\n") + "\n");
  }
  static register(lang, name2) {
    if (!name2) {
      name2 = lang.locale;
    }
    if (exportWordlist) {
      try {
        const anyGlobal4 = window;
        if (anyGlobal4._ethers && anyGlobal4._ethers.wordlists) {
          if (!anyGlobal4._ethers.wordlists[name2]) {
            defineReadOnly3(anyGlobal4._ethers.wordlists, name2, lang);
          }
        }
      } catch (error) {
      }
    }
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
init_define_process_env();
var words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
var wordlist = null;
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var LangEn = class extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(index) {
    loadWords(this);
    return wordlist[index];
  }
  getWordIndex(word) {
    loadWords(this);
    return wordlist.indexOf(word);
  }
};
var langEn = new LangEn();
Wordlist.register(langEn);

// node_modules/@web3-onboard/core/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
var wordlists = {
  en: langEn
};

// node_modules/@web3-onboard/core/node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  Logger: () => Logger15,
  ParamType: () => ParamType,
  RLP: () => lib_exports7,
  SigningKey: () => SigningKey4,
  SupportedAlgorithm: () => SupportedAlgorithm4,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes4,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm7,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs7,
  Utf8ErrorReason: () => Utf8ErrorReason7,
  _TypedDataEncoder: () => TypedDataEncoder4,
  _fetchData: () => _fetchData2,
  _toEscapedUtf8String: () => _toEscapedUtf8String7,
  accessListify: () => accessListify2,
  arrayify: () => arrayify9,
  base58: () => Base582,
  base64: () => lib_exports4,
  checkProperties: () => checkProperties4,
  checkResultErrors: () => checkResultErrors,
  commify: () => commify,
  computeAddress: () => computeAddress4,
  computeHmac: () => computeHmac4,
  computePublicKey: () => computePublicKey4,
  concat: () => concat7,
  deepCopy: () => deepCopy7,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath,
  defineReadOnly: () => defineReadOnly9,
  entropyToMnemonic: () => entropyToMnemonic,
  fetchJson: () => fetchJson2,
  formatBytes32String: () => formatBytes32String7,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress4,
  getContractAddress: () => getContractAddress2,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic3,
  hashMessage: () => hashMessage4,
  hexConcat: () => hexConcat4,
  hexDataLength: () => hexDataLength5,
  hexDataSlice: () => hexDataSlice5,
  hexStripZeros: () => hexStripZeros2,
  hexValue: () => hexValue2,
  hexZeroPad: () => hexZeroPad7,
  hexlify: () => hexlify7,
  id: () => id4,
  isAddress: () => isAddress,
  isBytes: () => isBytes9,
  isBytesLike: () => isBytesLike5,
  isHexString: () => isHexString9,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName4,
  joinSignature: () => joinSignature,
  keccak256: () => keccak2569,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash4,
  nameprep: () => nameprep7,
  parseBytes32String: () => parseBytes32String7,
  parseEther: () => parseEther,
  parseTransaction: () => parse2,
  parseUnits: () => parseUnits,
  poll: () => poll2,
  randomBytes: () => randomBytes3,
  recoverAddress: () => recoverAddress2,
  recoverPublicKey: () => recoverPublicKey4,
  resolveProperties: () => resolveProperties3,
  ripemd160: () => ripemd1604,
  serializeTransaction: () => serialize2,
  sha256: () => sha2565,
  sha512: () => sha5124,
  shallowCopy: () => shallowCopy8,
  shuffled: () => shuffled3,
  solidityKeccak256: () => keccak256,
  solidityPack: () => pack,
  soliditySha256: () => sha256,
  splitSignature: () => splitSignature2,
  stripZeros: () => stripZeros5,
  toUtf8Bytes: () => toUtf8Bytes7,
  toUtf8CodePoints: () => toUtf8CodePoints7,
  toUtf8String: () => toUtf8String7,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad2
});
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/fragments.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn6 = __toESM(require_bn());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version36 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors6 = false;
var _censorErrors6 = false;
var LogLevels6 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel6 = LogLevels6["default"];
var _globalLogger6 = null;
function _checkNormalize6() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError6 = _checkNormalize6();
var LogLevel6;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel6 || (LogLevel6 = {}));
var ErrorCode6;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode6 || (ErrorCode6 = {}));
var HEX6 = "0123456789abcdef";
var Logger6 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels6[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel6 > LogLevels6[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger6.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger6.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger6.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors6) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger6.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX6[value[i2] >> 4];
            hex += HEX6[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode6.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode6.CALL_EXCEPTION:
      case ErrorCode6.INSUFFICIENT_FUNDS:
      case ErrorCode6.MISSING_NEW:
      case ErrorCode6.NONCE_EXPIRED:
      case ErrorCode6.REPLACEMENT_UNDERPRICED:
      case ErrorCode6.TRANSACTION_REPLACED:
      case ErrorCode6.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger6.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError6) {
      this.throwError("platform missing String.prototype.normalize", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError6
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger6.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger6.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger6.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger6.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger6.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger6.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger6.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger6) {
      _globalLogger6 = new Logger6(version36);
    }
    return _globalLogger6;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors6) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors6 = !!censorship;
    _permanentCensorErrors6 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels6[logLevel.toLowerCase()];
    if (level == null) {
      Logger6.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel6 = level;
  }
  static from(version130) {
    return new Logger6(version130);
  }
};
Logger6.errors = ErrorCode6;
Logger6.levels = LogLevel6;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version37 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger50 = new Logger6(version37);
function isHexable5(value) {
  return !!value.toHexString;
}
function addSlice5(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice5(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger5(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes5(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger5(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger5(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify5(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger50.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice5(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable5(value)) {
    value = value.toHexString();
  }
  if (isHexString5(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger50.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice5(new Uint8Array(result));
  }
  if (isBytes5(value)) {
    return addSlice5(new Uint8Array(value));
  }
  return logger50.throwArgumentError("invalid arrayify value", "value", value);
}
function concat5(items) {
  const objects = items.map((item) => arrayify5(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice5(result);
}
function isHexString5(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters5 = "0123456789abcdef";
function hexlify5(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger50.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters5[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable5(value)) {
    return value.toHexString();
  }
  if (isHexString5(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger50.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes5(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters5[(v2 & 240) >> 4] + HexCharacters5[v2 & 15];
    }
    return result;
  }
  return logger50.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataSlice3(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify5(data);
  } else if (!isHexString5(data) || data.length % 2) {
    logger50.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat3(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify5(item).substring(2);
  });
  return result;
}
function hexZeroPad5(value, length) {
  if (typeof value !== "string") {
    value = hexlify5(value);
  } else if (!isHexString5(value)) {
    logger50.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger50.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version38 = "bignumber/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN6 = import_bn6.default.BN;
var logger51 = new Logger6(version38);
var _constructorGuard10 = {};
var MAX_SAFE5 = 9007199254740991;
function isBigNumberish5(value) {
  return value != null && (BigNumber5.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString5(value) || typeof value === "bigint" || isBytes5(value));
}
var _warnedToStringRadix5 = false;
var BigNumber5 = class {
  constructor(constructorGuard, hex) {
    logger51.checkNew(new.target, BigNumber5);
    if (constructorGuard !== _constructorGuard10) {
      logger51.throwError("cannot call constructor directly; use BigNumber.from", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber5(toBN5(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber5(toBN5(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber5.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber5(toBN5(this).add(toBN5(other)));
  }
  sub(other) {
    return toBigNumber5(toBN5(this).sub(toBN5(other)));
  }
  div(other) {
    const o = BigNumber5.from(other);
    if (o.isZero()) {
      throwFault9("division-by-zero", "div");
    }
    return toBigNumber5(toBN5(this).div(toBN5(other)));
  }
  mul(other) {
    return toBigNumber5(toBN5(this).mul(toBN5(other)));
  }
  mod(other) {
    const value = toBN5(other);
    if (value.isNeg()) {
      throwFault9("division-by-zero", "mod");
    }
    return toBigNumber5(toBN5(this).umod(value));
  }
  pow(other) {
    const value = toBN5(other);
    if (value.isNeg()) {
      throwFault9("negative-power", "pow");
    }
    return toBigNumber5(toBN5(this).pow(value));
  }
  and(other) {
    const value = toBN5(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault9("unbound-bitwise-result", "and");
    }
    return toBigNumber5(toBN5(this).and(value));
  }
  or(other) {
    const value = toBN5(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault9("unbound-bitwise-result", "or");
    }
    return toBigNumber5(toBN5(this).or(value));
  }
  xor(other) {
    const value = toBN5(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault9("unbound-bitwise-result", "xor");
    }
    return toBigNumber5(toBN5(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault9("negative-width", "mask");
    }
    return toBigNumber5(toBN5(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault9("negative-width", "shl");
    }
    return toBigNumber5(toBN5(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault9("negative-width", "shr");
    }
    return toBigNumber5(toBN5(this).shrn(value));
  }
  eq(other) {
    return toBN5(this).eq(toBN5(other));
  }
  lt(other) {
    return toBN5(this).lt(toBN5(other));
  }
  lte(other) {
    return toBN5(this).lte(toBN5(other));
  }
  gt(other) {
    return toBN5(this).gt(toBN5(other));
  }
  gte(other) {
    return toBN5(this).gte(toBN5(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN5(this).isZero();
  }
  toNumber() {
    try {
      return toBN5(this).toNumber();
    } catch (error) {
      throwFault9("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger51.throwError("this platform does not support BigInt", Logger6.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix5) {
          _warnedToStringRadix5 = true;
          logger51.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger51.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger6.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger51.throwError("BigNumber.toString does not accept parameters", Logger6.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN5(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber5) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber5(_constructorGuard10, toHex5(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber5(_constructorGuard10, toHex5(new BN6(value)));
      }
      return logger51.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault9("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE5 || value <= -MAX_SAFE5) {
        throwFault9("overflow", "BigNumber.from", value);
      }
      return BigNumber5.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber5.from(anyValue.toString());
    }
    if (isBytes5(anyValue)) {
      return BigNumber5.from(hexlify5(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber5.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString5(hex) || hex[0] === "-" && isHexString5(hex.substring(1))) {
            return BigNumber5.from(hex);
          }
        }
      }
    }
    return logger51.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex5(value) {
  if (typeof value !== "string") {
    return toHex5(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger51.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex5(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber5(value) {
  return BigNumber5.from(toHex5(value));
}
function toBN5(value) {
  const hex = BigNumber5.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN6("-" + hex.substring(3), 16);
  }
  return new BN6(hex.substring(2), 16);
}
function throwFault9(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger51.throwError(fault, Logger6.errors.NUMERIC_FAULT, params);
}
function _base36To165(value) {
  return new BN6(value, 36).toString(16);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger52 = new Logger6(version38);
var _constructorGuard11 = {};
var Zero10 = BigNumber5.from(0);
var NegativeOne10 = BigNumber5.from(-1);
function throwFault10(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger52.throwError(message, Logger6.errors.NUMERIC_FAULT, params);
}
var zeros5 = "0";
while (zeros5.length < 256) {
  zeros5 += zeros5;
}
function getMultiplier5(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber5.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros5.substring(0, decimals);
  }
  return logger52.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed5(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier5(decimals);
  value = BigNumber5.from(value);
  const negative = value.lt(Zero10);
  if (negative) {
    value = value.mul(NegativeOne10);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed5(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier5(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger52.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger52.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger52.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault10("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber5.from(whole);
  const fractionValue = BigNumber5.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne10);
  }
  return wei;
}
var FixedFormat5 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard11) {
      logger52.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier5(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat5) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger52.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger52.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger52.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger52.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat5(_constructorGuard11, signed, width, decimals);
  }
};
var FixedNumber5 = class {
  constructor(constructorGuard, hex, value, format) {
    logger52.checkNew(new.target, FixedNumber5);
    if (constructorGuard !== _constructorGuard11) {
      logger52.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger52.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed5(this._value, this.format.decimals);
    const b2 = parseFixed5(other._value, other.format.decimals);
    return FixedNumber5.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed5(this._value, this.format.decimals);
    const b2 = parseFixed5(other._value, other.format.decimals);
    return FixedNumber5.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed5(this._value, this.format.decimals);
    const b2 = parseFixed5(other._value, other.format.decimals);
    return FixedNumber5.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed5(this._value, this.format.decimals);
    const b2 = parseFixed5(other._value, other.format.decimals);
    return FixedNumber5.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber5.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE5.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber5.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE5.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger52.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber5.from("1" + zeros5.substring(0, decimals), this.format);
    const bump = BUMP5.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger52.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber5.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad5(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber5.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish5(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber5.fromString(formatFixed5(value, decimals), FixedFormat5.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat5.from(format);
    const numeric = parseFixed5(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero10)) {
      throwFault10("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad5(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed5(numeric, fixedFormat.decimals);
    return new FixedNumber5(_constructorGuard11, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat5.from(format);
    if (arrayify5(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber5.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed5(numeric, fixedFormat.decimals);
    return new FixedNumber5(_constructorGuard11, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber5.fromString(value, format);
    }
    if (isBytes5(value)) {
      return FixedNumber5.fromBytes(value, format);
    }
    try {
      return FixedNumber5.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger6.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger52.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE5 = FixedNumber5.from(1);
var BUMP5 = FixedNumber5.from("0.5");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version39 = "properties/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/lib.esm/index.js
var logger53 = new Logger6(version39);
function defineReadOnly4(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic2(ctor, key6) {
  for (let i2 = 0; i2 < 32; i2++) {
    if (ctor[key6]) {
      return ctor[key6];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
var opaque2 = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen2(object) {
  if (object === void 0 || object === null || opaque2[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i2 = 0; i2 < keys.length; i2++) {
      let value = null;
      try {
        value = object[keys[i2]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen2(value)) {
        return false;
      }
    }
    return true;
  }
  return logger53.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy2(object) {
  if (_isFrozen2(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy3(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key6 in object) {
      const value = object[key6];
      if (value === void 0) {
        continue;
      }
      defineReadOnly4(result, key6, deepCopy3(value));
    }
    return result;
  }
  return logger53.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy3(object) {
  return _deepCopy2(object);
}
var Description2 = class {
  constructor(info) {
    for (const key6 in info) {
      this[key6] = deepCopy3(info[key6]);
    }
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/_version.js
init_define_process_env();
var version40 = "abi/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/fragments.js
var logger54 = new Logger6(version40);
var _constructorGuard12 = {};
var ModifiersBytes = { calldata: true, memory: true, storage: true };
var ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name2) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger54.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError2(i2) {
    logger54.throwArgumentError(`unexpected character at position ${i2}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i2 = 0; i2 < param.length; i2++) {
    let c2 = param[i2];
    switch (c2) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError2(i2);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i2);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError2(i2);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i2);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError2(i2);
              }
              if (node.indexed) {
                throwError2(i2);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError2(i2);
        }
        node.type += c2;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError2(i2);
        }
        node.type += c2;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c2;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c2;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c2;
        } else {
          throwError2(i2);
        }
    }
  }
  if (node.parent) {
    logger54.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError2(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError2(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key6 in params) {
    defineReadOnly4(object, key6, params[key6]);
  }
}
var FormatTypes = Object.freeze({
  sighash: "sighash",
  minimal: "minimal",
  full: "full",
  json: "json"
});
var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
var ParamType = class {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard12) {
      logger54.throwError("use fromString", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger54.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard12, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node) {
      return ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
};
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
var Fragment = class {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard12) {
      logger54.throwError("use a static from method", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger54.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger54.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
};
var EventFragment = class extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger54.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger54.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard12, params);
  }
  static fromString(value) {
    let match = value.match(regexParen);
    if (!match) {
      logger54.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger54.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
};
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger54.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger54.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber5.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger54.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger54.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger54.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger54.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger54.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
var ConstructorFragment = class extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger54.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    if (format === FormatTypes.sighash) {
      logger54.throwError("cannot format a constructor for sighash", Logger6.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger54.throwArgumentError("invalid constructor object", "value", value);
    }
    let state2 = verifyState(value);
    if (state2.constant) {
      logger54.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber5.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard12, params);
  }
  static fromString(value) {
    let params = { type: "constructor" };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger54.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
};
var FunctionFragment = class extends ConstructorFragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger54.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
        outputs: this.outputs.map((output) => JSON.parse(output.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger54.throwArgumentError("invalid function object", "value", value);
    }
    let state2 = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state2.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value.gas ? BigNumber5.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard12, params);
  }
  static fromString(value) {
    let params = { type: "function" };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger54.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger54.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger54.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
};
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger54.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
var ErrorFragment = class extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger54.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger54.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard12, params));
  }
  static fromString(value) {
    let params = { type: "error" };
    let parens = value.match(regexParen);
    if (!parens) {
      logger54.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
};
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger54.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c2 = value[offset];
    if (c2 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c2;
      if (c2 === "(") {
        depth++;
      } else if (c2 === ")") {
        depth--;
        if (depth === -1) {
          logger54.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/abi-coder.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
init_define_process_env();
var logger55 = new Logger6(version40);
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key6 in object) {
      const childPath = path.slice();
      childPath.push(key6);
      try {
        checkErrors(childPath, object[key6]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
var Coder = class {
  constructor(name2, type, localName, dynamic) {
    this.name = name2;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger55.throwArgumentError(message, this.localName, value);
  }
};
var Writer = class {
  constructor(wordSize) {
    defineReadOnly4(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat3(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this._writeData(concat5(writer._data));
  }
  writeBytes(value) {
    let bytes = arrayify5(value);
    const paddingOffset = bytes.length % this.wordSize;
    if (paddingOffset) {
      bytes = concat5([bytes, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes);
  }
  _getValue(value) {
    let bytes = arrayify5(BigNumber5.from(value));
    if (bytes.length > this.wordSize) {
      logger55.throwError("value out-of-bounds", Logger6.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes.length
      });
    }
    if (bytes.length % this.wordSize) {
      bytes = concat5([this._padding.slice(bytes.length % this.wordSize), bytes]);
    }
    return bytes;
  }
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset] = this._getValue(value);
    };
  }
};
var Reader = class {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    defineReadOnly4(this, "_data", arrayify5(data));
    defineReadOnly4(this, "wordSize", wordSize || 32);
    defineReadOnly4(this, "_coerceFunc", coerceFunc);
    defineReadOnly4(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify5(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(name2, value) {
    let match = name2.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name2, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name2, value);
    }
    return Reader.coerce(name2, value);
  }
  _peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger55.throwError("data out-of-bounds", Logger6.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length, loose) {
    let bytes = this._peekBytes(0, length, !!loose);
    this._offset += bytes.length;
    return bytes.slice(0, length);
  }
  readValue() {
    return BigNumber5.from(this.readBytes(this.wordSize));
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/address.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha33 = __toESM(require_sha3());
function keccak2564(data) {
  return "0x" + import_js_sha33.default.keccak_256(arrayify5(data));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version41 = "rlp/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger56 = new Logger6(version41);

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version42 = "address/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/lib.esm/index.js
var logger57 = new Logger6(version42);
function getChecksumAddress3(address) {
  if (!isHexString5(address, 20)) {
    logger57.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify5(keccak2564(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER3 = 9007199254740991;
function log103(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
var ibanLookup3 = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup3[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup3[String.fromCharCode(65 + i2)] = String(10 + i2);
}
var safeDigits3 = Math.floor(log103(MAX_SAFE_INTEGER3));
function ibanChecksum3(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup3[c2];
  }).join("");
  while (expanded.length >= safeDigits3) {
    let block = expanded.substring(0, safeDigits3);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress3(address) {
  let result = null;
  if (typeof address !== "string") {
    logger57.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress3(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger57.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum3(address)) {
      logger57.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To165(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress3("0x" + result);
  } else {
    logger57.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/address.js
var AddressCoder = class extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress3(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress3(hexZeroPad5(reader.readValue().toHexString(), 20));
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/array.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
init_define_process_env();
var AnonymousCoder = class extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/array.js
var logger58 = new Logger6(version40);
function pack2(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger58.throwError("cannot encode object for signature with missing names", Logger6.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name2]) {
        logger58.throwError("cannot encode object for signature with duplicate names", Logger6.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name2] = true;
      return values[name2];
    });
  } else {
    logger58.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger58.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger6.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger6.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name2] = value;
    }
  });
  for (let i2 = 0; i2 < values.length; i2++) {
    const value = values[i2];
    if (value instanceof Error) {
      Object.defineProperty(values, i2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
var ArrayCoder = class extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i2 = 0; i2 < this.length; i2++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count2 = this.length;
    if (count2 === -1) {
      count2 = value.length;
      writer.writeValue(value.length);
    }
    logger58.checkArgumentCount(value.length, count2, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i2 = 0; i2 < value.length; i2++) {
      coders.push(this.coder);
    }
    return pack2(writer, coders, value);
  }
  decode(reader) {
    let count2 = this.length;
    if (count2 === -1) {
      count2 = reader.readValue().toNumber();
      if (count2 * 32 > reader._data.length) {
        logger58.throwError("insufficient data length", Logger6.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count: count2
        });
      }
    }
    let coders = [];
    for (let i2 = 0; i2 < count2; i2++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
init_define_process_env();
var BooleanCoder = class extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
init_define_process_env();
var DynamicBytesCoder = class extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify5(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
};
var BytesCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify5(super.decode(reader)));
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
init_define_process_env();
var FixedBytesCoder = class extends Coder {
  constructor(size, localName) {
    let name2 = "bytes" + String(size);
    super(name2, name2, localName, false);
    this.size = size;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data = arrayify5(value);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify5(reader.readBytes(this.size)));
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/null.js
init_define_process_env();
var NullCoder = class extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/number.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();
var NegativeOne11 = BigNumber5.from(-1);
var Zero11 = BigNumber5.from(0);
var One6 = BigNumber5.from(1);
var Two4 = BigNumber5.from(2);
var WeiPerEther4 = BigNumber5.from("1000000000000000000");
var MaxUint2566 = BigNumber5.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2564 = BigNumber5.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2564 = BigNumber5.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/number.js
var NumberCoder = class extends Coder {
  constructor(size, signed, localName) {
    const name2 = (signed ? "int" : "uint") + size * 8;
    super(name2, name2, localName, false);
    this.size = size;
    this.signed = signed;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v2 = BigNumber5.from(value);
    let maxUintValue = MaxUint2566.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v2.gt(bounds) || v2.lt(bounds.add(One6).mul(NegativeOne11))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v2.lt(Zero11) || v2.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v2 = v2.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v2 = v2.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v2);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/string.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version43 = "strings/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger59 = new Logger6(version43);
var UnicodeNormalizationForm3;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm3 || (UnicodeNormalizationForm3 = {}));
var Utf8ErrorReason3;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason3 || (Utf8ErrorReason3 = {}));
function errorFunc3(reason, offset, bytes, output, badCodepoint) {
  return logger59.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc3(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason3.BAD_PREFIX || reason === Utf8ErrorReason3.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason3.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc3(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason3.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc3(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs3 = Object.freeze({
  error: errorFunc3,
  ignore: ignoreFunc3,
  replace: replaceFunc3
});
function getUtf8CodePoints2(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs3.error;
  }
  bytes = arrayify5(bytes);
  const result = [];
  let i2 = 0;
  while (i2 < bytes.length) {
    const c2 = bytes[i2++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError(Utf8ErrorReason3.UNEXPECTED_CONTINUE, i2 - 1, bytes, result);
      } else {
        i2 += onError(Utf8ErrorReason3.BAD_PREFIX, i2 - 1, bytes, result);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes.length) {
      i2 += onError(Utf8ErrorReason3.OVERRUN, i2 - 1, bytes, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError(Utf8ErrorReason3.MISSING_CONTINUE, i2, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError(Utf8ErrorReason3.OUT_OF_RANGE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError(Utf8ErrorReason3.UTF16_SURROGATE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError(Utf8ErrorReason3.OVERLONG, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes3(str, form = UnicodeNormalizationForm3.current) {
  if (form != UnicodeNormalizationForm3.current) {
    logger59.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify5(result);
}
function _toUtf8String3(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String3(bytes, onError) {
  return _toUtf8String3(getUtf8CodePoints2(bytes, onError));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes23(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data.length; i2 += 4) {
    result.push(parseInt(data.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable3(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable3(data) {
  let hi = 0;
  return data.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges3 = createRangeTable3("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags3 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
var Table_B_2_lut_abs3 = createTable3("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel3 = createTable3("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex3 = createTable3("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes23);
var Table_C_ranges3 = createRangeTable3("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/string.js
var StringCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes3(value));
  }
  decode(reader) {
    return toUtf8String3(super.decode(reader));
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
init_define_process_env();
var TupleCoder = class extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      values[name2] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack2(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/abi-coder.js
var logger60 = new Logger6(version40);
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var AbiCoder = class {
  constructor(coerceFunc) {
    logger60.checkNew(new.target, AbiCoder);
    defineReadOnly4(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      if (size === 0 || size > 256 || size % 8 !== 0) {
        logger60.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      if (size === 0 || size > 32) {
        logger60.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size, param.name);
    }
    return logger60.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data, allowLoose) {
    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types, values) {
    if (types.length !== values.length) {
      logger60.throwError("types/values length mismatch", Logger6.errors.INVALID_ARGUMENT, {
        count: { types: types.length, values: values.length },
        value: { types, values }
      });
    }
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types, data, loose) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify5(data), loose));
  }
};
var defaultAbiCoder = new AbiCoder();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/interface.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/id.js
init_define_process_env();
function id3(text2) {
  return keccak2564(toUtf8Bytes3(text2));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/namehash.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/_version.js
init_define_process_env();
var version44 = "hash/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger61 = new Logger6(version44);
var Zeros3 = new Uint8Array(32);
Zeros3.fill(0);
var Partition3 = new RegExp("^((.*)\\.)?([^.]+)$");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/message.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/lib.esm/typed-data.js
init_define_process_env();
var logger62 = new Logger6(version44);
var padding3 = new Uint8Array(32);
padding3.fill(0);
var NegativeOne12 = BigNumber5.from(-1);
var Zero12 = BigNumber5.from(0);
var One7 = BigNumber5.from(1);
var MaxUint2567 = BigNumber5.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var hexTrue3 = hexZeroPad5(One7.toHexString(), 32);
var hexFalse3 = hexZeroPad5(Zero12.toHexString(), 32);
function checkString3(key6) {
  return function(value) {
    if (typeof value !== "string") {
      logger62.throwArgumentError(`invalid domain value for ${JSON.stringify(key6)}`, `domain.${key6}`, value);
    }
    return value;
  };
}
var domainChecks3 = {
  name: checkString3("name"),
  version: checkString3("version"),
  chainId: function(value) {
    try {
      return BigNumber5.from(value).toString();
    } catch (error) {
    }
    return logger62.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress3(value).toLowerCase();
    } catch (error) {
    }
    return logger62.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify5(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify5(bytes);
    } catch (error) {
    }
    return logger62.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/abi/lib.esm/interface.js
var logger63 = new Logger6(version40);
var LogDescription = class extends Description2 {
};
var TransactionDescription = class extends Description2 {
};
var ErrorDescription = class extends Description2 {
};
var Indexed = class extends Description2 {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
};
var BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
var Interface = class {
  constructor(fragments) {
    logger63.checkNew(new.target, Interface);
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    defineReadOnly4(this, "fragments", abi.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly4(this, "_abiCoder", getStatic2(new.target, "getAbiCoder")());
    defineReadOnly4(this, "functions", {});
    defineReadOnly4(this, "errors", {});
    defineReadOnly4(this, "events", {});
    defineReadOnly4(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger63.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly4(this, "deploy", fragment);
          return;
        case "function":
          bucket = this.functions;
          break;
        case "event":
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature6 = fragment.format();
      if (bucket[signature6]) {
        logger63.warn("duplicate definition - " + signature6);
        return;
      }
      bucket[signature6] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly4(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly4(this, "_isInterface", true);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.full;
    }
    if (format === FormatTypes.sighash) {
      logger63.throwArgumentError("interface does not support formatting sighash", "format", format);
    }
    const abi = this.fragments.map((fragment) => fragment.format(format));
    if (format === FormatTypes.json) {
      return JSON.stringify(abi.map((j2) => JSON.parse(j2)));
    }
    return abi;
  }
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress3(address);
  }
  static getSighash(fragment) {
    return hexDataSlice3(id3(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id3(eventFragment.format());
  }
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString5(nameOrSignatureOrSighash)) {
      for (const name2 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name2)) {
          return this.functions[name2];
        }
      }
      logger63.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f2) => f2.split("(")[0] === name2);
      if (matching.length === 0) {
        logger63.throwArgumentError("no matching function", "name", name2);
      } else if (matching.length > 1) {
        logger63.throwArgumentError("multiple matching functions", "name", name2);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger63.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString5(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name2 in this.events) {
        if (topichash === this.getEventTopic(name2)) {
          return this.events[name2];
        }
      }
      logger63.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f2) => f2.split("(")[0] === name2);
      if (matching.length === 0) {
        logger63.throwArgumentError("no matching event", "name", name2);
      } else if (matching.length > 1) {
        logger63.throwArgumentError("multiple matching events", "name", name2);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger63.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  getError(nameOrSignatureOrSighash) {
    if (isHexString5(nameOrSignatureOrSighash)) {
      const getSighash = getStatic2(this.constructor, "getSighash");
      for (const name2 in this.errors) {
        const error = this.errors[name2];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name2];
        }
      }
      logger63.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f2) => f2.split("(")[0] === name2);
      if (matching.length === 0) {
        logger63.throwArgumentError("no matching error", "name", name2);
      } else if (matching.length > 1) {
        logger63.throwArgumentError("multiple matching errors", "name", name2);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger63.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_2) {
          throw error;
        }
      }
    }
    return getStatic2(this.constructor, "getSighash")(fragment);
  }
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic2(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data) {
    return this._abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes = arrayify5(data);
    if (hexlify5(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
      logger63.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify5(bytes));
    }
    return this._decodeParams(fragment.inputs, bytes.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify5(concat5([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values || [])
    ]));
  }
  decodeFunctionData(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes = arrayify5(data);
    if (hexlify5(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger63.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify5(bytes));
    }
    return this._decodeParams(functionFragment.inputs, bytes.slice(4));
  }
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify5(concat5([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values || [])
    ]));
  }
  decodeFunctionResult(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes = arrayify5(data);
    let reason = null;
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes);
        } catch (error) {
        }
        break;
      case 4: {
        const selector = hexlify5(bytes.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
        } else {
          try {
            const error = this.getError(selector);
            errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
            errorName = error.name;
            errorSignature = error.format();
          } catch (error) {
            console.log(error);
          }
        }
        break;
      }
    }
    return logger63.throwError("call revert exception", Logger6.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify5(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger63.throwError("too many arguments for " + eventFragment.format(), Logger6.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id3(value);
      } else if (param.type === "bytes") {
        return keccak2564(hexlify5(value));
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad5(hexlify5(value), 32);
    };
    values.forEach((value, index) => {
      let param = eventFragment.inputs[index];
      if (!param.indexed) {
        if (value != null) {
          logger63.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger63.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger63.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id3(value));
        } else if (param.type === "bytes") {
          topics.push(keccak2564(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  decodeEventLog(eventFragment, data, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString5(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger63.throwError("fragment/topic mismatch", Logger6.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat5(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index] = new Indexed({ _isIndexed: true, hash: null });
        } else if (dynamic[index]) {
          result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index] = error;
          }
        }
      } else {
        try {
          result[index] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index] = error;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i2 = 0; i2 < result.length; i2++) {
      const value = result[i2];
      if (value instanceof Error) {
        Object.defineProperty(result, i2, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i2}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber5.from(tx.value || "0")
    });
  }
  parseLog(log) {
    let fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  }
  parseError(data) {
    const hexData = hexlify5(data);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version45 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors7 = false;
var _censorErrors7 = false;
var LogLevels7 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel7 = LogLevels7["default"];
var _globalLogger7 = null;
function _checkNormalize7() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError7 = _checkNormalize7();
var LogLevel7;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel7 || (LogLevel7 = {}));
var ErrorCode7;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode7 || (ErrorCode7 = {}));
var HEX7 = "0123456789abcdef";
var Logger7 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels7[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel7 > LogLevels7[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger7.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger7.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger7.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors7) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger7.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX7[value[i2] >> 4];
            hex += HEX7[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode7.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode7.CALL_EXCEPTION:
      case ErrorCode7.INSUFFICIENT_FUNDS:
      case ErrorCode7.MISSING_NEW:
      case ErrorCode7.NONCE_EXPIRED:
      case ErrorCode7.REPLACEMENT_UNDERPRICED:
      case ErrorCode7.TRANSACTION_REPLACED:
      case ErrorCode7.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger7.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError7) {
      this.throwError("platform missing String.prototype.normalize", Logger7.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError7
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger7.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger7.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger7.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger7.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger7.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger7.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger7.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger7) {
      _globalLogger7 = new Logger7(version45);
    }
    return _globalLogger7;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger7.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors7) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger7.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors7 = !!censorship;
    _permanentCensorErrors7 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels7[logLevel.toLowerCase()];
    if (level == null) {
      Logger7.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel7 = level;
  }
  static from(version130) {
    return new Logger7(version130);
  }
};
Logger7.errors = ErrorCode7;
Logger7.levels = LogLevel7;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version46 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger64 = new Logger7(version46);
function isHexable6(value) {
  return !!value.toHexString;
}
function addSlice6(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice6(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike4(value) {
  return isHexString6(value) && !(value.length % 2) || isBytes6(value);
}
function isInteger6(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes6(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger6(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger6(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify6(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger64.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice6(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable6(value)) {
    value = value.toHexString();
  }
  if (isHexString6(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger64.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice6(new Uint8Array(result));
  }
  if (isBytes6(value)) {
    return addSlice6(new Uint8Array(value));
  }
  return logger64.throwArgumentError("invalid arrayify value", "value", value);
}
function concat6(items) {
  const objects = items.map((item) => arrayify6(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice6(result);
}
function stripZeros4(value) {
  let result = arrayify6(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function isHexString6(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters6 = "0123456789abcdef";
function hexlify6(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger64.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters6[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable6(value)) {
    return value.toHexString();
  }
  if (isHexString6(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger64.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes6(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters6[(v2 & 240) >> 4] + HexCharacters6[v2 & 15];
    }
    return result;
  }
  return logger64.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength4(data) {
  if (typeof data !== "string") {
    data = hexlify6(data);
  } else if (!isHexString6(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice4(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify6(data);
  } else if (!isHexString6(data) || data.length % 2) {
    logger64.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexZeroPad6(value, length) {
  if (typeof value !== "string") {
    value = hexlify6(value);
  } else if (!isHexString6(value)) {
    logger64.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger64.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn7 = __toESM(require_bn());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version47 = "bignumber/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN7 = import_bn7.default.BN;
var logger65 = new Logger7(version47);
var _constructorGuard13 = {};
var MAX_SAFE6 = 9007199254740991;
function isBigNumberish6(value) {
  return value != null && (BigNumber6.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString6(value) || typeof value === "bigint" || isBytes6(value));
}
var _warnedToStringRadix6 = false;
var BigNumber6 = class {
  constructor(constructorGuard, hex) {
    logger65.checkNew(new.target, BigNumber6);
    if (constructorGuard !== _constructorGuard13) {
      logger65.throwError("cannot call constructor directly; use BigNumber.from", Logger7.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber6(toBN6(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber6(toBN6(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber6.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber6(toBN6(this).add(toBN6(other)));
  }
  sub(other) {
    return toBigNumber6(toBN6(this).sub(toBN6(other)));
  }
  div(other) {
    const o = BigNumber6.from(other);
    if (o.isZero()) {
      throwFault11("division-by-zero", "div");
    }
    return toBigNumber6(toBN6(this).div(toBN6(other)));
  }
  mul(other) {
    return toBigNumber6(toBN6(this).mul(toBN6(other)));
  }
  mod(other) {
    const value = toBN6(other);
    if (value.isNeg()) {
      throwFault11("division-by-zero", "mod");
    }
    return toBigNumber6(toBN6(this).umod(value));
  }
  pow(other) {
    const value = toBN6(other);
    if (value.isNeg()) {
      throwFault11("negative-power", "pow");
    }
    return toBigNumber6(toBN6(this).pow(value));
  }
  and(other) {
    const value = toBN6(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault11("unbound-bitwise-result", "and");
    }
    return toBigNumber6(toBN6(this).and(value));
  }
  or(other) {
    const value = toBN6(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault11("unbound-bitwise-result", "or");
    }
    return toBigNumber6(toBN6(this).or(value));
  }
  xor(other) {
    const value = toBN6(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault11("unbound-bitwise-result", "xor");
    }
    return toBigNumber6(toBN6(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault11("negative-width", "mask");
    }
    return toBigNumber6(toBN6(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault11("negative-width", "shl");
    }
    return toBigNumber6(toBN6(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault11("negative-width", "shr");
    }
    return toBigNumber6(toBN6(this).shrn(value));
  }
  eq(other) {
    return toBN6(this).eq(toBN6(other));
  }
  lt(other) {
    return toBN6(this).lt(toBN6(other));
  }
  lte(other) {
    return toBN6(this).lte(toBN6(other));
  }
  gt(other) {
    return toBN6(this).gt(toBN6(other));
  }
  gte(other) {
    return toBN6(this).gte(toBN6(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN6(this).isZero();
  }
  toNumber() {
    try {
      return toBN6(this).toNumber();
    } catch (error) {
      throwFault11("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger65.throwError("this platform does not support BigInt", Logger7.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix6) {
          _warnedToStringRadix6 = true;
          logger65.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger65.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger7.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger65.throwError("BigNumber.toString does not accept parameters", Logger7.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN6(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber6) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber6(_constructorGuard13, toHex6(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber6(_constructorGuard13, toHex6(new BN7(value)));
      }
      return logger65.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault11("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE6 || value <= -MAX_SAFE6) {
        throwFault11("overflow", "BigNumber.from", value);
      }
      return BigNumber6.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber6.from(anyValue.toString());
    }
    if (isBytes6(anyValue)) {
      return BigNumber6.from(hexlify6(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber6.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString6(hex) || hex[0] === "-" && isHexString6(hex.substring(1))) {
            return BigNumber6.from(hex);
          }
        }
      }
    }
    return logger65.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex6(value) {
  if (typeof value !== "string") {
    return toHex6(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger65.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex6(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber6(value) {
  return BigNumber6.from(toHex6(value));
}
function toBN6(value) {
  const hex = BigNumber6.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN7("-" + hex.substring(3), 16);
  }
  return new BN7(hex.substring(2), 16);
}
function throwFault11(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger65.throwError(fault, Logger7.errors.NUMERIC_FAULT, params);
}
function _base36To166(value) {
  return new BN7(value, 36).toString(16);
}
function _base16To366(value) {
  return new BN7(value, 16).toString(36);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger66 = new Logger7(version47);
var _constructorGuard14 = {};
var Zero13 = BigNumber6.from(0);
var NegativeOne13 = BigNumber6.from(-1);
function throwFault12(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger66.throwError(message, Logger7.errors.NUMERIC_FAULT, params);
}
var zeros6 = "0";
while (zeros6.length < 256) {
  zeros6 += zeros6;
}
function getMultiplier6(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber6.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros6.substring(0, decimals);
  }
  return logger66.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed6(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier6(decimals);
  value = BigNumber6.from(value);
  const negative = value.lt(Zero13);
  if (negative) {
    value = value.mul(NegativeOne13);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed6(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier6(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger66.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger66.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger66.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault12("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber6.from(whole);
  const fractionValue = BigNumber6.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne13);
  }
  return wei;
}
var FixedFormat6 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard14) {
      logger66.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger7.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier6(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat6) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger66.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger66.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger66.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger66.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat6(_constructorGuard14, signed, width, decimals);
  }
};
var FixedNumber6 = class {
  constructor(constructorGuard, hex, value, format) {
    logger66.checkNew(new.target, FixedNumber6);
    if (constructorGuard !== _constructorGuard14) {
      logger66.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger7.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger66.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed6(this._value, this.format.decimals);
    const b2 = parseFixed6(other._value, other.format.decimals);
    return FixedNumber6.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed6(this._value, this.format.decimals);
    const b2 = parseFixed6(other._value, other.format.decimals);
    return FixedNumber6.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed6(this._value, this.format.decimals);
    const b2 = parseFixed6(other._value, other.format.decimals);
    return FixedNumber6.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed6(this._value, this.format.decimals);
    const b2 = parseFixed6(other._value, other.format.decimals);
    return FixedNumber6.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber6.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE6.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber6.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE6.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger66.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber6.from("1" + zeros6.substring(0, decimals), this.format);
    const bump = BUMP6.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger66.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber6.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad6(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber6.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish6(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber6.fromString(formatFixed6(value, decimals), FixedFormat6.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat6.from(format);
    const numeric = parseFixed6(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero13)) {
      throwFault12("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad6(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed6(numeric, fixedFormat.decimals);
    return new FixedNumber6(_constructorGuard14, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat6.from(format);
    if (arrayify6(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber6.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed6(numeric, fixedFormat.decimals);
    return new FixedNumber6(_constructorGuard14, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber6.fromString(value, format);
    }
    if (isBytes6(value)) {
      return FixedNumber6.fromBytes(value, format);
    }
    try {
      return FixedNumber6.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger7.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger66.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE6 = FixedNumber6.from(1);
var BUMP6 = FixedNumber6.from("0.5");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha34 = __toESM(require_sha3());
function keccak2565(data) {
  return "0x" + import_js_sha34.default.keccak_256(arrayify6(data));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version48 = "rlp/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger67 = new Logger7(version48);
function arrayifyInteger2(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode3(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode3(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger2(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike4(object)) {
    logger67.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify6(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger2(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode6(object) {
  return hexlify6(_encode3(object));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version49 = "address/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/address/lib.esm/index.js
var logger68 = new Logger7(version49);
function getChecksumAddress4(address) {
  if (!isHexString6(address, 20)) {
    logger68.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify6(keccak2565(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER4 = 9007199254740991;
function log104(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
var ibanLookup4 = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup4[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup4[String.fromCharCode(65 + i2)] = String(10 + i2);
}
var safeDigits4 = Math.floor(log104(MAX_SAFE_INTEGER4));
function ibanChecksum4(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup4[c2];
  }).join("");
  while (expanded.length >= safeDigits4) {
    let block = expanded.substring(0, safeDigits4);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress4(address) {
  let result = null;
  if (typeof address !== "string") {
    logger68.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress4(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger68.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum4(address)) {
      logger68.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To166(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress4("0x" + result);
  } else {
    logger68.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress4(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To366(getAddress4(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum4("XE00" + base36) + base36;
}
function getContractAddress2(transaction) {
  let from2 = null;
  try {
    from2 = getAddress4(transaction.from);
  } catch (error) {
    logger68.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros4(arrayify6(BigNumber6.from(transaction.nonce).toHexString()));
  return getAddress4(hexDataSlice4(keccak2565(encode6([from2, nonce])), 12));
}
function getCreate2Address(from2, salt, initCodeHash) {
  if (hexDataLength4(salt) !== 32) {
    logger68.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength4(initCodeHash) !== 32) {
    logger68.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress4(hexDataSlice4(keccak2565(concat6(["0xff", getAddress4(from2), salt, initCodeHash])), 12));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/base64/lib.esm/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  decode: () => decode3,
  encode: () => encode7
});
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/base64/lib.esm/base64.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/base64/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/base64/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/base64/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version50 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/base64/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors8 = false;
var _censorErrors8 = false;
var LogLevels8 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel8 = LogLevels8["default"];
var _globalLogger8 = null;
function _checkNormalize8() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError8 = _checkNormalize8();
var LogLevel8;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel8 || (LogLevel8 = {}));
var ErrorCode8;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode8 || (ErrorCode8 = {}));
var HEX8 = "0123456789abcdef";
var Logger8 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels8[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel8 > LogLevels8[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger8.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger8.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger8.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors8) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger8.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX8[value[i2] >> 4];
            hex += HEX8[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode8.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode8.CALL_EXCEPTION:
      case ErrorCode8.INSUFFICIENT_FUNDS:
      case ErrorCode8.MISSING_NEW:
      case ErrorCode8.NONCE_EXPIRED:
      case ErrorCode8.REPLACEMENT_UNDERPRICED:
      case ErrorCode8.TRANSACTION_REPLACED:
      case ErrorCode8.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger8.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError8) {
      this.throwError("platform missing String.prototype.normalize", Logger8.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError8
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger8.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger8.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger8.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger8.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger8.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger8.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger8.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger8) {
      _globalLogger8 = new Logger8(version50);
    }
    return _globalLogger8;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger8.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors8) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger8.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors8 = !!censorship;
    _permanentCensorErrors8 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels8[logLevel.toLowerCase()];
    if (level == null) {
      Logger8.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel8 = level;
  }
  static from(version130) {
    return new Logger8(version130);
  }
};
Logger8.errors = ErrorCode8;
Logger8.levels = LogLevel8;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/base64/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version51 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/base64/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger69 = new Logger8(version51);
function isHexable7(value) {
  return !!value.toHexString;
}
function addSlice7(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice7(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger7(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes7(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger7(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger7(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify7(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger69.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice7(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable7(value)) {
    value = value.toHexString();
  }
  if (isHexString7(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger69.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice7(new Uint8Array(result));
  }
  if (isBytes7(value)) {
    return addSlice7(new Uint8Array(value));
  }
  return logger69.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString7(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/base64/lib.esm/base64.js
function decode3(textData) {
  textData = atob(textData);
  const data = [];
  for (let i2 = 0; i2 < textData.length; i2++) {
    data.push(textData.charCodeAt(i2));
  }
  return arrayify7(data);
}
function encode7(data) {
  data = arrayify7(data);
  let textData = "";
  for (let i2 = 0; i2 < data.length; i2++) {
    textData += String.fromCharCode(data[i2]);
  }
  return btoa(textData);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/basex/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/basex/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/basex/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/basex/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version52 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/basex/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors9 = false;
var _censorErrors9 = false;
var LogLevels9 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel9 = LogLevels9["default"];
var _globalLogger9 = null;
function _checkNormalize9() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError9 = _checkNormalize9();
var LogLevel9;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel9 || (LogLevel9 = {}));
var ErrorCode9;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode9 || (ErrorCode9 = {}));
var HEX9 = "0123456789abcdef";
var Logger9 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels9[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel9 > LogLevels9[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger9.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger9.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger9.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors9) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger9.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX9[value[i2] >> 4];
            hex += HEX9[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode9.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode9.CALL_EXCEPTION:
      case ErrorCode9.INSUFFICIENT_FUNDS:
      case ErrorCode9.MISSING_NEW:
      case ErrorCode9.NONCE_EXPIRED:
      case ErrorCode9.REPLACEMENT_UNDERPRICED:
      case ErrorCode9.TRANSACTION_REPLACED:
      case ErrorCode9.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger9.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError9) {
      this.throwError("platform missing String.prototype.normalize", Logger9.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError9
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger9.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger9.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger9.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger9.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger9.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger9.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger9.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger9) {
      _globalLogger9 = new Logger9(version52);
    }
    return _globalLogger9;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger9.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors9) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger9.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors9 = !!censorship;
    _permanentCensorErrors9 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels9[logLevel.toLowerCase()];
    if (level == null) {
      Logger9.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel9 = level;
  }
  static from(version130) {
    return new Logger9(version130);
  }
};
Logger9.errors = ErrorCode9;
Logger9.levels = LogLevel9;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/basex/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version53 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/basex/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger70 = new Logger9(version53);
function isHexable8(value) {
  return !!value.toHexString;
}
function addSlice8(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice8(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger8(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes8(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger8(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger8(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify8(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger70.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice8(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable8(value)) {
    value = value.toHexString();
  }
  if (isHexString8(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger70.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice8(new Uint8Array(result));
  }
  if (isBytes8(value)) {
    return addSlice8(new Uint8Array(value));
  }
  return logger70.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString8(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/basex/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/basex/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version54 = "properties/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/basex/node_modules/@ethersproject/properties/lib.esm/index.js
var logger71 = new Logger9(version54);
function defineReadOnly5(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/basex/lib.esm/index.js
var BaseX2 = class {
  constructor(alphabet) {
    defineReadOnly5(this, "alphabet", alphabet);
    defineReadOnly5(this, "base", alphabet.length);
    defineReadOnly5(this, "_alphabetMap", {});
    defineReadOnly5(this, "_leader", alphabet.charAt(0));
    for (let i2 = 0; i2 < alphabet.length; i2++) {
      this._alphabetMap[alphabet.charAt(i2)] = i2;
    }
  }
  encode(value) {
    let source = arrayify8(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i2 = 0; i2 < source.length; ++i2) {
      let carry = source[i2];
      for (let j2 = 0; j2 < digits.length; ++j2) {
        carry += digits[j2] << 8;
        digits[j2] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k2 = 0; source[k2] === 0 && k2 < source.length - 1; ++k2) {
      string += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string += this.alphabet[digits[q2]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i2 = 0; i2 < value.length; i2++) {
      let byte = this._alphabetMap[value[i2]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j2 = 0; j2 < bytes.length; ++j2) {
        carry += bytes[j2] * this.base;
        bytes[j2] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k2 = 0; value[k2] === this._leader && k2 < value.length - 1; ++k2) {
      bytes.push(0);
    }
    return arrayify8(new Uint8Array(bytes.reverse()));
  }
};
var Base322 = new BaseX2("abcdefghijklmnopqrstuvwxyz234567");
var Base582 = new BaseX2("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bytes/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bytes/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version55 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bytes/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors10 = false;
var _censorErrors10 = false;
var LogLevels10 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel10 = LogLevels10["default"];
var _globalLogger10 = null;
function _checkNormalize10() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError10 = _checkNormalize10();
var LogLevel10;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel10 || (LogLevel10 = {}));
var ErrorCode10;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode10 || (ErrorCode10 = {}));
var HEX10 = "0123456789abcdef";
var Logger10 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels10[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel10 > LogLevels10[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger10.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger10.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger10.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors10) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger10.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX10[value[i2] >> 4];
            hex += HEX10[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode10.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode10.CALL_EXCEPTION:
      case ErrorCode10.INSUFFICIENT_FUNDS:
      case ErrorCode10.MISSING_NEW:
      case ErrorCode10.NONCE_EXPIRED:
      case ErrorCode10.REPLACEMENT_UNDERPRICED:
      case ErrorCode10.TRANSACTION_REPLACED:
      case ErrorCode10.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger10.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError10) {
      this.throwError("platform missing String.prototype.normalize", Logger10.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError10
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger10.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger10.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger10.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger10.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger10.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger10.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger10.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger10) {
      _globalLogger10 = new Logger10(version55);
    }
    return _globalLogger10;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger10.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors10) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger10.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors10 = !!censorship;
    _permanentCensorErrors10 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels10[logLevel.toLowerCase()];
    if (level == null) {
      Logger10.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel10 = level;
  }
  static from(version130) {
    return new Logger10(version130);
  }
};
Logger10.errors = ErrorCode10;
Logger10.levels = LogLevel10;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version56 = "bytes/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger72 = new Logger10(version56);
function isHexable9(value) {
  return !!value.toHexString;
}
function addSlice9(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice9(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike5(value) {
  return isHexString9(value) && !(value.length % 2) || isBytes9(value);
}
function isInteger9(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes9(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger9(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger9(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify9(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger72.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice9(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable9(value)) {
    value = value.toHexString();
  }
  if (isHexString9(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0x0" + hex.substring(2);
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger72.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice9(new Uint8Array(result));
  }
  if (isBytes9(value)) {
    return addSlice9(new Uint8Array(value));
  }
  return logger72.throwArgumentError("invalid arrayify value", "value", value);
}
function concat7(items) {
  const objects = items.map((item) => arrayify9(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice9(result);
}
function stripZeros5(value) {
  let result = arrayify9(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad2(value, length) {
  value = arrayify9(value);
  if (value.length > length) {
    logger72.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice9(result);
}
function isHexString9(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters7 = "0123456789abcdef";
function hexlify7(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger72.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters7[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable9(value)) {
    return value.toHexString();
  }
  if (isHexString9(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger72.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes9(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters7[(v2 & 240) >> 4] + HexCharacters7[v2 & 15];
    }
    return result;
  }
  return logger72.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength5(data) {
  if (typeof data !== "string") {
    data = hexlify7(data);
  } else if (!isHexString9(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice5(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify7(data);
  } else if (!isHexString9(data) || data.length % 2) {
    logger72.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat4(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify7(item).substring(2);
  });
  return result;
}
function hexValue2(value) {
  const trimmed = hexStripZeros2(hexlify7(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros2(value) {
  if (typeof value !== "string") {
    value = hexlify7(value);
  }
  if (!isHexString9(value)) {
    logger72.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad7(value, length) {
  if (typeof value !== "string") {
    value = hexlify7(value);
  } else if (!isHexString9(value)) {
    logger72.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger72.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature2(signature6) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0
  };
  if (isBytesLike5(signature6)) {
    const bytes = arrayify9(signature6);
    if (bytes.length !== 65) {
      logger72.throwArgumentError("invalid signature string; must be 65 bytes", "signature", signature6);
    }
    result.r = hexlify7(bytes.slice(0, 32));
    result.s = hexlify7(bytes.slice(32, 64));
    result.v = bytes[64];
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger72.throwArgumentError("signature invalid v byte", "signature", signature6);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify7(bytes.slice(32, 64));
  } else {
    result.r = signature6.r;
    result.s = signature6.s;
    result.v = signature6.v;
    result.recoveryParam = signature6.recoveryParam;
    result._vs = signature6._vs;
    if (result._vs != null) {
      const vs2 = zeroPad2(arrayify9(result._vs), 32);
      result._vs = hexlify7(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger72.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature6);
      }
      vs2[0] &= 127;
      const s2 = hexlify7(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger72.throwArgumentError("signature v mismatch _vs", "signature", signature6);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger72.throwArgumentError("signature missing v and recoveryParam", "signature", signature6);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger72.throwArgumentError("signature recoveryParam mismatch v", "signature", signature6);
        }
      }
    }
    if (result.r == null || !isHexString9(result.r)) {
      logger72.throwArgumentError("signature missing or invalid r", "signature", signature6);
    } else {
      result.r = hexZeroPad7(result.r, 32);
    }
    if (result.s == null || !isHexString9(result.s)) {
      logger72.throwArgumentError("signature missing or invalid s", "signature", signature6);
    } else {
      result.s = hexZeroPad7(result.s, 32);
    }
    const vs = arrayify9(result.s);
    if (vs[0] >= 128) {
      logger72.throwArgumentError("signature s out of range", "signature", signature6);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify7(vs);
    if (result._vs) {
      if (!isHexString9(result._vs)) {
        logger72.throwArgumentError("signature invalid _vs", "signature", signature6);
      }
      result._vs = hexZeroPad7(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger72.throwArgumentError("signature _vs mismatch v and s", "signature", signature6);
    }
  }
  return result;
}
function joinSignature(signature6) {
  signature6 = splitSignature2(signature6);
  return hexlify7(concat7([
    signature6.r,
    signature6.s,
    signature6.recoveryParam ? "0x1c" : "0x1b"
  ]));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/lib.esm/id.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha35 = __toESM(require_sha3());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version57 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors11 = false;
var _censorErrors11 = false;
var LogLevels11 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel11 = LogLevels11["default"];
var _globalLogger11 = null;
function _checkNormalize11() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError11 = _checkNormalize11();
var LogLevel11;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel11 || (LogLevel11 = {}));
var ErrorCode11;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode11 || (ErrorCode11 = {}));
var HEX11 = "0123456789abcdef";
var Logger11 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels11[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel11 > LogLevels11[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger11.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger11.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger11.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors11) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger11.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX11[value[i2] >> 4];
            hex += HEX11[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode11.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode11.CALL_EXCEPTION:
      case ErrorCode11.INSUFFICIENT_FUNDS:
      case ErrorCode11.MISSING_NEW:
      case ErrorCode11.NONCE_EXPIRED:
      case ErrorCode11.REPLACEMENT_UNDERPRICED:
      case ErrorCode11.TRANSACTION_REPLACED:
      case ErrorCode11.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger11.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError11) {
      this.throwError("platform missing String.prototype.normalize", Logger11.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError11
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger11.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger11.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger11.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger11.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger11.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger11.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger11.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger11) {
      _globalLogger11 = new Logger11(version57);
    }
    return _globalLogger11;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger11.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors11) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger11.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors11 = !!censorship;
    _permanentCensorErrors11 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels11[logLevel.toLowerCase()];
    if (level == null) {
      Logger11.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel11 = level;
  }
  static from(version130) {
    return new Logger11(version130);
  }
};
Logger11.errors = ErrorCode11;
Logger11.levels = LogLevel11;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version58 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger73 = new Logger11(version58);
function isHexable10(value) {
  return !!value.toHexString;
}
function addSlice10(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice10(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger10(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes10(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger10(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger10(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify10(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger73.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice10(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable10(value)) {
    value = value.toHexString();
  }
  if (isHexString10(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger73.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice10(new Uint8Array(result));
  }
  if (isBytes10(value)) {
    return addSlice10(new Uint8Array(value));
  }
  return logger73.throwArgumentError("invalid arrayify value", "value", value);
}
function concat8(items) {
  const objects = items.map((item) => arrayify10(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice10(result);
}
function isHexString10(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters8 = "0123456789abcdef";
function hexlify8(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger73.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters8[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable10(value)) {
    return value.toHexString();
  }
  if (isHexString10(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger73.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes10(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters8[(v2 & 240) >> 4] + HexCharacters8[v2 & 15];
    }
    return result;
  }
  return logger73.throwArgumentError("invalid hexlify value", "value", value);
}
function hexConcat5(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify8(item).substring(2);
  });
  return result;
}
function hexZeroPad8(value, length) {
  if (typeof value !== "string") {
    value = hexlify8(value);
  } else if (!isHexString10(value)) {
    logger73.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger73.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/keccak256/lib.esm/index.js
function keccak2566(data) {
  return "0x" + import_js_sha35.default.keccak_256(arrayify10(data));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn8 = __toESM(require_bn());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version59 = "bignumber/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN8 = import_bn8.default.BN;
var logger74 = new Logger11(version59);
var _constructorGuard15 = {};
var MAX_SAFE7 = 9007199254740991;
function isBigNumberish7(value) {
  return value != null && (BigNumber7.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString10(value) || typeof value === "bigint" || isBytes10(value));
}
var _warnedToStringRadix7 = false;
var BigNumber7 = class {
  constructor(constructorGuard, hex) {
    logger74.checkNew(new.target, BigNumber7);
    if (constructorGuard !== _constructorGuard15) {
      logger74.throwError("cannot call constructor directly; use BigNumber.from", Logger11.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber7(toBN7(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber7(toBN7(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber7.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber7(toBN7(this).add(toBN7(other)));
  }
  sub(other) {
    return toBigNumber7(toBN7(this).sub(toBN7(other)));
  }
  div(other) {
    const o = BigNumber7.from(other);
    if (o.isZero()) {
      throwFault13("division-by-zero", "div");
    }
    return toBigNumber7(toBN7(this).div(toBN7(other)));
  }
  mul(other) {
    return toBigNumber7(toBN7(this).mul(toBN7(other)));
  }
  mod(other) {
    const value = toBN7(other);
    if (value.isNeg()) {
      throwFault13("division-by-zero", "mod");
    }
    return toBigNumber7(toBN7(this).umod(value));
  }
  pow(other) {
    const value = toBN7(other);
    if (value.isNeg()) {
      throwFault13("negative-power", "pow");
    }
    return toBigNumber7(toBN7(this).pow(value));
  }
  and(other) {
    const value = toBN7(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault13("unbound-bitwise-result", "and");
    }
    return toBigNumber7(toBN7(this).and(value));
  }
  or(other) {
    const value = toBN7(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault13("unbound-bitwise-result", "or");
    }
    return toBigNumber7(toBN7(this).or(value));
  }
  xor(other) {
    const value = toBN7(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault13("unbound-bitwise-result", "xor");
    }
    return toBigNumber7(toBN7(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault13("negative-width", "mask");
    }
    return toBigNumber7(toBN7(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault13("negative-width", "shl");
    }
    return toBigNumber7(toBN7(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault13("negative-width", "shr");
    }
    return toBigNumber7(toBN7(this).shrn(value));
  }
  eq(other) {
    return toBN7(this).eq(toBN7(other));
  }
  lt(other) {
    return toBN7(this).lt(toBN7(other));
  }
  lte(other) {
    return toBN7(this).lte(toBN7(other));
  }
  gt(other) {
    return toBN7(this).gt(toBN7(other));
  }
  gte(other) {
    return toBN7(this).gte(toBN7(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN7(this).isZero();
  }
  toNumber() {
    try {
      return toBN7(this).toNumber();
    } catch (error) {
      throwFault13("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger74.throwError("this platform does not support BigInt", Logger11.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix7) {
          _warnedToStringRadix7 = true;
          logger74.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger74.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger11.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger74.throwError("BigNumber.toString does not accept parameters", Logger11.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN7(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber7) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber7(_constructorGuard15, toHex7(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber7(_constructorGuard15, toHex7(new BN8(value)));
      }
      return logger74.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault13("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE7 || value <= -MAX_SAFE7) {
        throwFault13("overflow", "BigNumber.from", value);
      }
      return BigNumber7.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber7.from(anyValue.toString());
    }
    if (isBytes10(anyValue)) {
      return BigNumber7.from(hexlify8(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber7.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString10(hex) || hex[0] === "-" && isHexString10(hex.substring(1))) {
            return BigNumber7.from(hex);
          }
        }
      }
    }
    return logger74.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex7(value) {
  if (typeof value !== "string") {
    return toHex7(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger74.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex7(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber7(value) {
  return BigNumber7.from(toHex7(value));
}
function toBN7(value) {
  const hex = BigNumber7.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN8("-" + hex.substring(3), 16);
  }
  return new BN8(hex.substring(2), 16);
}
function throwFault13(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger74.throwError(fault, Logger11.errors.NUMERIC_FAULT, params);
}
function _base36To167(value) {
  return new BN8(value, 36).toString(16);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger75 = new Logger11(version59);
var _constructorGuard16 = {};
var Zero14 = BigNumber7.from(0);
var NegativeOne14 = BigNumber7.from(-1);
function throwFault14(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger75.throwError(message, Logger11.errors.NUMERIC_FAULT, params);
}
var zeros7 = "0";
while (zeros7.length < 256) {
  zeros7 += zeros7;
}
function getMultiplier7(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber7.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros7.substring(0, decimals);
  }
  return logger75.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed7(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier7(decimals);
  value = BigNumber7.from(value);
  const negative = value.lt(Zero14);
  if (negative) {
    value = value.mul(NegativeOne14);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed7(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier7(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger75.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger75.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger75.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault14("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber7.from(whole);
  const fractionValue = BigNumber7.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne14);
  }
  return wei;
}
var FixedFormat7 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard16) {
      logger75.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger11.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier7(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat7) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger75.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger75.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger75.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger75.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat7(_constructorGuard16, signed, width, decimals);
  }
};
var FixedNumber7 = class {
  constructor(constructorGuard, hex, value, format) {
    logger75.checkNew(new.target, FixedNumber7);
    if (constructorGuard !== _constructorGuard16) {
      logger75.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger11.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger75.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed7(this._value, this.format.decimals);
    const b2 = parseFixed7(other._value, other.format.decimals);
    return FixedNumber7.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed7(this._value, this.format.decimals);
    const b2 = parseFixed7(other._value, other.format.decimals);
    return FixedNumber7.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed7(this._value, this.format.decimals);
    const b2 = parseFixed7(other._value, other.format.decimals);
    return FixedNumber7.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed7(this._value, this.format.decimals);
    const b2 = parseFixed7(other._value, other.format.decimals);
    return FixedNumber7.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber7.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE7.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber7.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE7.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger75.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber7.from("1" + zeros7.substring(0, decimals), this.format);
    const bump = BUMP7.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger75.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber7.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad8(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber7.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish7(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber7.fromString(formatFixed7(value, decimals), FixedFormat7.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat7.from(format);
    const numeric = parseFixed7(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero14)) {
      throwFault14("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad8(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed7(numeric, fixedFormat.decimals);
    return new FixedNumber7(_constructorGuard16, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat7.from(format);
    if (arrayify10(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber7.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed7(numeric, fixedFormat.decimals);
    return new FixedNumber7(_constructorGuard16, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber7.fromString(value, format);
    }
    if (isBytes10(value)) {
      return FixedNumber7.fromBytes(value, format);
    }
    try {
      return FixedNumber7.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger11.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger75.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE7 = FixedNumber7.from(1);
var BUMP7 = FixedNumber7.from("0.5");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne15 = BigNumber7.from(-1);
var Zero15 = BigNumber7.from(0);
var One8 = BigNumber7.from(1);
var Two5 = BigNumber7.from(2);
var WeiPerEther5 = BigNumber7.from("1000000000000000000");
var MaxUint2568 = BigNumber7.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2565 = BigNumber7.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2565 = BigNumber7.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version60 = "strings/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger76 = new Logger11(version60);
var UnicodeNormalizationForm4;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm4 || (UnicodeNormalizationForm4 = {}));
var Utf8ErrorReason4;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason4 || (Utf8ErrorReason4 = {}));
function errorFunc4(reason, offset, bytes, output, badCodepoint) {
  return logger76.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc4(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason4.BAD_PREFIX || reason === Utf8ErrorReason4.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason4.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc4(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason4.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc4(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs4 = Object.freeze({
  error: errorFunc4,
  ignore: ignoreFunc4,
  replace: replaceFunc4
});
function getUtf8CodePoints3(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs4.error;
  }
  bytes = arrayify10(bytes);
  const result = [];
  let i2 = 0;
  while (i2 < bytes.length) {
    const c2 = bytes[i2++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError(Utf8ErrorReason4.UNEXPECTED_CONTINUE, i2 - 1, bytes, result);
      } else {
        i2 += onError(Utf8ErrorReason4.BAD_PREFIX, i2 - 1, bytes, result);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes.length) {
      i2 += onError(Utf8ErrorReason4.OVERRUN, i2 - 1, bytes, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError(Utf8ErrorReason4.MISSING_CONTINUE, i2, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError(Utf8ErrorReason4.OUT_OF_RANGE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError(Utf8ErrorReason4.UTF16_SURROGATE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError(Utf8ErrorReason4.OVERLONG, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes4(str, form = UnicodeNormalizationForm4.current) {
  if (form != UnicodeNormalizationForm4.current) {
    logger76.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify10(result);
}
function _toUtf8String4(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8CodePoints4(str, form = UnicodeNormalizationForm4.current) {
  return getUtf8CodePoints3(toUtf8Bytes4(str, form));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes24(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data.length; i2 += 4) {
    result.push(parseInt(data.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable4(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable4(data) {
  let hi = 0;
  return data.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap2(value, ranges) {
  let lo = 0;
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let range2 = ranges[i2];
    lo += range2.l;
    if (value >= lo && value <= lo + range2.h && (value - lo) % (range2.d || 1) === 0) {
      if (range2.e && range2.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range2;
    }
  }
  return null;
}
var Table_A_1_ranges4 = createRangeTable4("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags4 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
var Table_B_2_ranges2 = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
var Table_B_2_lut_abs4 = createTable4("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel4 = createTable4("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex4 = createTable4("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes24);
var Table_C_ranges4 = createRangeTable4("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten2(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA12(codepoint) {
  return !!matchMap2(codepoint, Table_A_1_ranges4);
}
function _nameprepTableB22(codepoint) {
  let range2 = matchMap2(codepoint, Table_B_2_ranges2);
  if (range2) {
    return [codepoint + range2.s];
  }
  let codes = Table_B_2_lut_abs4[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel4[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex4[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC2(codepoint) {
  return !!matchMap2(codepoint, Table_C_ranges4);
}
function nameprep4(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints4(value);
  codes = flatten2(codes.map((code) => {
    if (Table_B_1_flags4.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 65024 && code <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB22(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code];
  }));
  codes = toUtf8CodePoints4(_toUtf8String4(codes), UnicodeNormalizationForm4.NFKC);
  codes.forEach((code) => {
    if (_nameprepTableC2(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code) => {
    if (_nameprepTableA12(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String4(codes);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  if (name2.length > 63) {
    throw new Error("too long");
  }
  return name2;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/lib.esm/id.js
function id4(text2) {
  return keccak2566(toUtf8Bytes4(text2));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/lib.esm/namehash.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/lib.esm/_version.js
init_define_process_env();
var version61 = "hash/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger77 = new Logger11(version61);
var Zeros4 = new Uint8Array(32);
Zeros4.fill(0);
var Partition4 = new RegExp("^((.*)\\.)?([^.]+)$");
function isValidName4(name2) {
  try {
    const comps = name2.split(".");
    for (let i2 = 0; i2 < comps.length; i2++) {
      if (nameprep4(comps[i2]).length === 0) {
        throw new Error("empty");
      }
    }
    return true;
  } catch (error) {
  }
  return false;
}
function namehash4(name2) {
  if (typeof name2 !== "string") {
    logger77.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let current = name2;
  let result = Zeros4;
  while (current.length) {
    const partition4 = current.match(Partition4);
    if (partition4 == null || partition4[2] === "") {
      logger77.throwArgumentError("invalid ENS address; missing component", "name", name2);
    }
    const label = toUtf8Bytes4(nameprep4(partition4[3]));
    result = keccak2566(concat8([result, keccak2566(label)]));
    current = partition4[2] || "";
  }
  return hexlify8(result);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/lib.esm/message.js
init_define_process_env();
var messagePrefix4 = "Ethereum Signed Message:\n";
function hashMessage4(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes4(message);
  }
  return keccak2566(concat8([
    toUtf8Bytes4(messagePrefix4),
    toUtf8Bytes4(String(message.length)),
    message
  ]));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/lib.esm/typed-data.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version62 = "rlp/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger78 = new Logger11(version62);

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version63 = "address/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/lib.esm/index.js
var logger79 = new Logger11(version63);
function getChecksumAddress5(address) {
  if (!isHexString10(address, 20)) {
    logger79.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify10(keccak2566(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER5 = 9007199254740991;
function log105(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
var ibanLookup5 = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup5[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup5[String.fromCharCode(65 + i2)] = String(10 + i2);
}
var safeDigits5 = Math.floor(log105(MAX_SAFE_INTEGER5));
function ibanChecksum5(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup5[c2];
  }).join("");
  while (expanded.length >= safeDigits5) {
    let block = expanded.substring(0, safeDigits5);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress5(address) {
  let result = null;
  if (typeof address !== "string") {
    logger79.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress5(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger79.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum5(address)) {
      logger79.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To167(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress5("0x" + result);
  } else {
    logger79.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version64 = "properties/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/node_modules/@ethersproject/properties/lib.esm/index.js
var logger80 = new Logger11(version64);
function defineReadOnly6(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function shallowCopy5(object) {
  const result = {};
  for (const key6 in object) {
    result[key6] = object[key6];
  }
  return result;
}
var opaque3 = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen3(object) {
  if (object === void 0 || object === null || opaque3[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i2 = 0; i2 < keys.length; i2++) {
      let value = null;
      try {
        value = object[keys[i2]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen3(value)) {
        return false;
      }
    }
    return true;
  }
  return logger80.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy3(object) {
  if (_isFrozen3(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy4(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key6 in object) {
      const value = object[key6];
      if (value === void 0) {
        continue;
      }
      defineReadOnly6(result, key6, deepCopy4(value));
    }
    return result;
  }
  return logger80.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy4(object) {
  return _deepCopy3(object);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hash/lib.esm/typed-data.js
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger81 = new Logger11(version61);
var padding4 = new Uint8Array(32);
padding4.fill(0);
var NegativeOne16 = BigNumber7.from(-1);
var Zero16 = BigNumber7.from(0);
var One9 = BigNumber7.from(1);
var MaxUint2569 = BigNumber7.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight2(value) {
  const bytes = arrayify10(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat5([bytes, padding4.slice(padOffset)]);
  }
  return hexlify8(bytes);
}
var hexTrue4 = hexZeroPad8(One9.toHexString(), 32);
var hexFalse4 = hexZeroPad8(Zero16.toHexString(), 32);
var domainFieldTypes2 = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames2 = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString4(key6) {
  return function(value) {
    if (typeof value !== "string") {
      logger81.throwArgumentError(`invalid domain value for ${JSON.stringify(key6)}`, `domain.${key6}`, value);
    }
    return value;
  };
}
var domainChecks4 = {
  name: checkString4("name"),
  version: checkString4("version"),
  chainId: function(value) {
    try {
      return BigNumber7.from(value).toString();
    } catch (error) {
    }
    return logger81.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress5(value).toLowerCase();
    } catch (error) {
    }
    return logger81.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify10(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify8(bytes);
    } catch (error) {
    }
    return logger81.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder2(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger81.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint2569.mask(signed ? width - 1 : width);
      const boundsLower = signed ? boundsUpper.add(One9).mul(NegativeOne16) : Zero16;
      return function(value) {
        const v2 = BigNumber7.from(value);
        if (v2.lt(boundsLower) || v2.gt(boundsUpper)) {
          logger81.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad8(v2.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger81.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes = arrayify10(value);
        if (bytes.length !== width) {
          logger81.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight2(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad8(getAddress5(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse4 : hexTrue4;
      };
    case "bytes":
      return function(value) {
        return keccak2566(value);
      };
    case "string":
      return function(value) {
        return id4(value);
      };
  }
  return null;
}
function encodeType2(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
var TypedDataEncoder4 = class {
  constructor(types) {
    defineReadOnly6(this, "types", Object.freeze(deepCopy4(types)));
    defineReadOnly6(this, "_encoderCache", {});
    defineReadOnly6(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types).forEach((type) => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name2 in types) {
      const uniqueNames = {};
      types[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger81.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger81.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        }
        const encoder = getBaseEncoder2(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger81.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n) => parents[n].length === 0);
    if (primaryTypes.length === 0) {
      logger81.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger81.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types);
    }
    defineReadOnly6(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger81.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
      }
      found[type] = true;
      Object.keys(links[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st = Object.keys(subtypes[name2]);
      st.sort();
      this._types[name2] = encodeType2(name2, types[name2]) + st.map((t2) => encodeType2(t2, types[t2])).join("");
    }
  }
  getEncoder(type) {
    let encoder = this._encoderCache[type];
    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder;
  }
  _getEncoder(type) {
    {
      const encoder = getBaseEncoder2(type);
      if (encoder) {
        return encoder;
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return (value) => {
        if (length >= 0 && value.length !== length) {
          logger81.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak2566);
        }
        return keccak2566(hexConcat5(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id4(this._types[type]);
      return (value) => {
        const values = fields.map(({ name: name2, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name2]);
          if (this._types[type2]) {
            return keccak2566(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat5(values);
      };
    }
    return logger81.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger81.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name2, value) {
    return keccak2566(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder2(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);
      if (length >= 0 && value.length !== length) {
        logger81.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v2) => this._visit(subtype, v2, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type2 }) => {
        accum[name2] = this._visit(type2, value[name2], callback);
        return accum;
      }, {});
    }
    return logger81.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types) {
    return new TypedDataEncoder4(types);
  }
  static getPrimaryType(types) {
    return TypedDataEncoder4.from(types).primaryType;
  }
  static hashStruct(name2, types, value) {
    return TypedDataEncoder4.from(types).hashStruct(name2, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name2 in domain) {
      const type = domainFieldTypes2[name2];
      if (!type) {
        logger81.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain);
      }
      domainFields.push({ name: name2, type });
    }
    domainFields.sort((a2, b2) => {
      return domainFieldNames2.indexOf(a2.name) - domainFieldNames2.indexOf(b2.name);
    });
    return TypedDataEncoder4.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types, value) {
    return hexConcat5([
      "0x1901",
      TypedDataEncoder4.hashDomain(domain),
      TypedDataEncoder4.from(types).hash(value)
    ]);
  }
  static hash(domain, types, value) {
    return keccak2566(TypedDataEncoder4.encode(domain, types, value));
  }
  static resolveNames(domain, types, value, resolveName) {
    return __awaiter17(this, void 0, void 0, function* () {
      domain = shallowCopy5(domain);
      const ensCache = {};
      if (domain.verifyingContract && !isHexString10(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder4.from(types);
      encoder.visit(value, (type, value2) => {
        if (type === "address" && !isHexString10(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName(name2);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder.visit(value, (type, value2) => {
        if (type === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    });
  }
  static getPayload(domain, types, value) {
    TypedDataEncoder4.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames2.forEach((name2) => {
      const value2 = domain[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks4[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes2[name2] });
    });
    const encoder = TypedDataEncoder4.from(types);
    const typesWithDomain = shallowCopy5(types);
    if (typesWithDomain.EIP712Domain) {
      logger81.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify8(arrayify10(value2));
        }
        if (type.match(/^u?int/)) {
          return BigNumber7.from(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger81.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger81.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/basex/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version65 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors12 = false;
var _censorErrors12 = false;
var LogLevels12 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel12 = LogLevels12["default"];
var _globalLogger12 = null;
function _checkNormalize12() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError12 = _checkNormalize12();
var LogLevel12;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel12 || (LogLevel12 = {}));
var ErrorCode12;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode12 || (ErrorCode12 = {}));
var HEX12 = "0123456789abcdef";
var Logger12 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels12[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel12 > LogLevels12[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger12.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger12.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger12.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors12) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger12.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX12[value[i2] >> 4];
            hex += HEX12[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode12.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode12.CALL_EXCEPTION:
      case ErrorCode12.INSUFFICIENT_FUNDS:
      case ErrorCode12.MISSING_NEW:
      case ErrorCode12.NONCE_EXPIRED:
      case ErrorCode12.REPLACEMENT_UNDERPRICED:
      case ErrorCode12.TRANSACTION_REPLACED:
      case ErrorCode12.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger12.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError12) {
      this.throwError("platform missing String.prototype.normalize", Logger12.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError12
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger12.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger12.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger12.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger12.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger12.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger12.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger12.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger12) {
      _globalLogger12 = new Logger12(version65);
    }
    return _globalLogger12;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger12.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors12) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger12.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors12 = !!censorship;
    _permanentCensorErrors12 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels12[logLevel.toLowerCase()];
    if (level == null) {
      Logger12.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel12 = level;
  }
  static from(version130) {
    return new Logger12(version130);
  }
};
Logger12.errors = ErrorCode12;
Logger12.levels = LogLevel12;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version66 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger82 = new Logger12(version66);
function isHexable11(value) {
  return !!value.toHexString;
}
function addSlice11(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice11(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike7(value) {
  return isHexString11(value) && !(value.length % 2) || isBytes11(value);
}
function isInteger11(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes11(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger11(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger11(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify11(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger82.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice11(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable11(value)) {
    value = value.toHexString();
  }
  if (isHexString11(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger82.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice11(new Uint8Array(result));
  }
  if (isBytes11(value)) {
    return addSlice11(new Uint8Array(value));
  }
  return logger82.throwArgumentError("invalid arrayify value", "value", value);
}
function concat9(items) {
  const objects = items.map((item) => arrayify11(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice11(result);
}
function zeroPad3(value, length) {
  value = arrayify11(value);
  if (value.length > length) {
    logger82.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice11(result);
}
function isHexString11(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters9 = "0123456789abcdef";
function hexlify9(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger82.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters9[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable11(value)) {
    return value.toHexString();
  }
  if (isHexString11(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger82.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes11(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters9[(v2 & 240) >> 4] + HexCharacters9[v2 & 15];
    }
    return result;
  }
  return logger82.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataSlice7(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify9(data);
  } else if (!isHexString11(data) || data.length % 2) {
    logger82.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexZeroPad9(value, length) {
  if (typeof value !== "string") {
    value = hexlify9(value);
  } else if (!isHexString11(value)) {
    logger82.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger82.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature3(signature6) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike7(signature6)) {
    let bytes = arrayify11(signature6);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify9(bytes.slice(0, 32));
      result.s = hexlify9(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify9(bytes.slice(0, 32));
      result.s = hexlify9(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger82.throwArgumentError("invalid signature string", "signature", signature6);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger82.throwArgumentError("signature invalid v byte", "signature", signature6);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify9(bytes.slice(32, 64));
  } else {
    result.r = signature6.r;
    result.s = signature6.s;
    result.v = signature6.v;
    result.recoveryParam = signature6.recoveryParam;
    result._vs = signature6._vs;
    if (result._vs != null) {
      const vs2 = zeroPad3(arrayify11(result._vs), 32);
      result._vs = hexlify9(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger82.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature6);
      }
      vs2[0] &= 127;
      const s2 = hexlify9(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger82.throwArgumentError("signature v mismatch _vs", "signature", signature6);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger82.throwArgumentError("signature missing v and recoveryParam", "signature", signature6);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger82.throwArgumentError("signature recoveryParam mismatch v", "signature", signature6);
        }
      }
    }
    if (result.r == null || !isHexString11(result.r)) {
      logger82.throwArgumentError("signature missing or invalid r", "signature", signature6);
    } else {
      result.r = hexZeroPad9(result.r, 32);
    }
    if (result.s == null || !isHexString11(result.s)) {
      logger82.throwArgumentError("signature missing or invalid s", "signature", signature6);
    } else {
      result.s = hexZeroPad9(result.s, 32);
    }
    const vs = arrayify11(result.s);
    if (vs[0] >= 128) {
      logger82.throwArgumentError("signature s out of range", "signature", signature6);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify9(vs);
    if (result._vs) {
      if (!isHexString11(result._vs)) {
        logger82.throwArgumentError("signature invalid _vs", "signature", signature6);
      }
      result._vs = hexZeroPad9(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger82.throwArgumentError("signature _vs mismatch v and s", "signature", signature6);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version67 = "properties/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/properties/lib.esm/index.js
var logger83 = new Logger12(version67);
function defineReadOnly7(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/basex/lib.esm/index.js
var BaseX3 = class {
  constructor(alphabet) {
    defineReadOnly7(this, "alphabet", alphabet);
    defineReadOnly7(this, "base", alphabet.length);
    defineReadOnly7(this, "_alphabetMap", {});
    defineReadOnly7(this, "_leader", alphabet.charAt(0));
    for (let i2 = 0; i2 < alphabet.length; i2++) {
      this._alphabetMap[alphabet.charAt(i2)] = i2;
    }
  }
  encode(value) {
    let source = arrayify11(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i2 = 0; i2 < source.length; ++i2) {
      let carry = source[i2];
      for (let j2 = 0; j2 < digits.length; ++j2) {
        carry += digits[j2] << 8;
        digits[j2] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k2 = 0; source[k2] === 0 && k2 < source.length - 1; ++k2) {
      string += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string += this.alphabet[digits[q2]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i2 = 0; i2 < value.length; i2++) {
      let byte = this._alphabetMap[value[i2]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j2 = 0; j2 < bytes.length; ++j2) {
        carry += bytes[j2] * this.base;
        bytes[j2] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k2 = 0; value[k2] === this._leader && k2 < value.length - 1; ++k2) {
      bytes.push(0);
    }
    return arrayify11(new Uint8Array(bytes.reverse()));
  }
};
var Base323 = new BaseX3("abcdefghijklmnopqrstuvwxyz234567");
var Base583 = new BaseX3("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn9 = __toESM(require_bn());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version68 = "bignumber/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN9 = import_bn9.default.BN;
var logger84 = new Logger12(version68);
var _constructorGuard17 = {};
var MAX_SAFE8 = 9007199254740991;
function isBigNumberish8(value) {
  return value != null && (BigNumber8.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString11(value) || typeof value === "bigint" || isBytes11(value));
}
var _warnedToStringRadix8 = false;
var BigNumber8 = class {
  constructor(constructorGuard, hex) {
    logger84.checkNew(new.target, BigNumber8);
    if (constructorGuard !== _constructorGuard17) {
      logger84.throwError("cannot call constructor directly; use BigNumber.from", Logger12.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber8(toBN8(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber8(toBN8(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber8.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber8(toBN8(this).add(toBN8(other)));
  }
  sub(other) {
    return toBigNumber8(toBN8(this).sub(toBN8(other)));
  }
  div(other) {
    const o = BigNumber8.from(other);
    if (o.isZero()) {
      throwFault15("division-by-zero", "div");
    }
    return toBigNumber8(toBN8(this).div(toBN8(other)));
  }
  mul(other) {
    return toBigNumber8(toBN8(this).mul(toBN8(other)));
  }
  mod(other) {
    const value = toBN8(other);
    if (value.isNeg()) {
      throwFault15("division-by-zero", "mod");
    }
    return toBigNumber8(toBN8(this).umod(value));
  }
  pow(other) {
    const value = toBN8(other);
    if (value.isNeg()) {
      throwFault15("negative-power", "pow");
    }
    return toBigNumber8(toBN8(this).pow(value));
  }
  and(other) {
    const value = toBN8(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault15("unbound-bitwise-result", "and");
    }
    return toBigNumber8(toBN8(this).and(value));
  }
  or(other) {
    const value = toBN8(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault15("unbound-bitwise-result", "or");
    }
    return toBigNumber8(toBN8(this).or(value));
  }
  xor(other) {
    const value = toBN8(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault15("unbound-bitwise-result", "xor");
    }
    return toBigNumber8(toBN8(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault15("negative-width", "mask");
    }
    return toBigNumber8(toBN8(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault15("negative-width", "shl");
    }
    return toBigNumber8(toBN8(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault15("negative-width", "shr");
    }
    return toBigNumber8(toBN8(this).shrn(value));
  }
  eq(other) {
    return toBN8(this).eq(toBN8(other));
  }
  lt(other) {
    return toBN8(this).lt(toBN8(other));
  }
  lte(other) {
    return toBN8(this).lte(toBN8(other));
  }
  gt(other) {
    return toBN8(this).gt(toBN8(other));
  }
  gte(other) {
    return toBN8(this).gte(toBN8(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN8(this).isZero();
  }
  toNumber() {
    try {
      return toBN8(this).toNumber();
    } catch (error) {
      throwFault15("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger84.throwError("this platform does not support BigInt", Logger12.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix8) {
          _warnedToStringRadix8 = true;
          logger84.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger84.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger12.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger84.throwError("BigNumber.toString does not accept parameters", Logger12.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN8(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber8) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber8(_constructorGuard17, toHex8(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber8(_constructorGuard17, toHex8(new BN9(value)));
      }
      return logger84.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault15("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE8 || value <= -MAX_SAFE8) {
        throwFault15("overflow", "BigNumber.from", value);
      }
      return BigNumber8.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber8.from(anyValue.toString());
    }
    if (isBytes11(anyValue)) {
      return BigNumber8.from(hexlify9(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber8.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString11(hex) || hex[0] === "-" && isHexString11(hex.substring(1))) {
            return BigNumber8.from(hex);
          }
        }
      }
    }
    return logger84.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex8(value) {
  if (typeof value !== "string") {
    return toHex8(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger84.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex8(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber8(value) {
  return BigNumber8.from(toHex8(value));
}
function toBN8(value) {
  const hex = BigNumber8.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN9("-" + hex.substring(3), 16);
  }
  return new BN9(hex.substring(2), 16);
}
function throwFault15(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger84.throwError(fault, Logger12.errors.NUMERIC_FAULT, params);
}
function _base36To168(value) {
  return new BN9(value, 36).toString(16);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger85 = new Logger12(version68);
var _constructorGuard18 = {};
var Zero17 = BigNumber8.from(0);
var NegativeOne17 = BigNumber8.from(-1);
function throwFault16(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger85.throwError(message, Logger12.errors.NUMERIC_FAULT, params);
}
var zeros8 = "0";
while (zeros8.length < 256) {
  zeros8 += zeros8;
}
function getMultiplier8(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber8.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros8.substring(0, decimals);
  }
  return logger85.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed8(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier8(decimals);
  value = BigNumber8.from(value);
  const negative = value.lt(Zero17);
  if (negative) {
    value = value.mul(NegativeOne17);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed8(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier8(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger85.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger85.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger85.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault16("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber8.from(whole);
  const fractionValue = BigNumber8.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne17);
  }
  return wei;
}
var FixedFormat8 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard18) {
      logger85.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger12.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier8(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat8) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger85.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger85.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger85.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger85.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat8(_constructorGuard18, signed, width, decimals);
  }
};
var FixedNumber8 = class {
  constructor(constructorGuard, hex, value, format) {
    logger85.checkNew(new.target, FixedNumber8);
    if (constructorGuard !== _constructorGuard18) {
      logger85.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger12.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger85.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed8(this._value, this.format.decimals);
    const b2 = parseFixed8(other._value, other.format.decimals);
    return FixedNumber8.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed8(this._value, this.format.decimals);
    const b2 = parseFixed8(other._value, other.format.decimals);
    return FixedNumber8.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed8(this._value, this.format.decimals);
    const b2 = parseFixed8(other._value, other.format.decimals);
    return FixedNumber8.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed8(this._value, this.format.decimals);
    const b2 = parseFixed8(other._value, other.format.decimals);
    return FixedNumber8.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber8.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE8.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber8.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE8.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger85.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber8.from("1" + zeros8.substring(0, decimals), this.format);
    const bump = BUMP8.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger85.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber8.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad9(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber8.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish8(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber8.fromString(formatFixed8(value, decimals), FixedFormat8.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat8.from(format);
    const numeric = parseFixed8(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero17)) {
      throwFault16("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad9(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed8(numeric, fixedFormat.decimals);
    return new FixedNumber8(_constructorGuard18, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat8.from(format);
    if (arrayify11(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber8.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed8(numeric, fixedFormat.decimals);
    return new FixedNumber8(_constructorGuard18, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber8.fromString(value, format);
    }
    if (isBytes11(value)) {
      return FixedNumber8.fromBytes(value, format);
    }
    try {
      return FixedNumber8.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger12.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger85.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE8 = FixedNumber8.from(1);
var BUMP8 = FixedNumber8.from("0.5");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();
var NegativeOne18 = BigNumber8.from(-1);
var Zero18 = BigNumber8.from(0);
var One10 = BigNumber8.from(1);
var Two6 = BigNumber8.from(2);
var WeiPerEther6 = BigNumber8.from("1000000000000000000");
var MaxUint25610 = BigNumber8.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2566 = BigNumber8.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2566 = BigNumber8.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version69 = "strings/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger86 = new Logger12(version69);
var UnicodeNormalizationForm5;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm5 || (UnicodeNormalizationForm5 = {}));
var Utf8ErrorReason5;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason5 || (Utf8ErrorReason5 = {}));
function errorFunc5(reason, offset, bytes, output, badCodepoint) {
  return logger86.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc5(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason5.BAD_PREFIX || reason === Utf8ErrorReason5.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason5.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc5(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason5.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc5(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs5 = Object.freeze({
  error: errorFunc5,
  ignore: ignoreFunc5,
  replace: replaceFunc5
});
function toUtf8Bytes5(str, form = UnicodeNormalizationForm5.current) {
  if (form != UnicodeNormalizationForm5.current) {
    logger86.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify11(result);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes25(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data.length; i2 += 4) {
    result.push(parseInt(data.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable5(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable5(data) {
  let hi = 0;
  return data.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges5 = createRangeTable5("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags5 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
var Table_B_2_lut_abs5 = createTable5("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel5 = createTable5("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex5 = createTable5("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes25);
var Table_C_ranges5 = createRangeTable5("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/lib.esm/sha2.js
init_define_process_env();
var import_hash7 = __toESM(require_hash());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/lib.esm/types.js
init_define_process_env();
var SupportedAlgorithm2;
(function(SupportedAlgorithm5) {
  SupportedAlgorithm5["sha256"] = "sha256";
  SupportedAlgorithm5["sha512"] = "sha512";
})(SupportedAlgorithm2 || (SupportedAlgorithm2 = {}));

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/lib.esm/_version.js
init_define_process_env();
var version70 = "sha2/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/lib.esm/sha2.js
var logger87 = new Logger12(version70);
function ripemd1602(data) {
  return "0x" + import_hash7.default.ripemd160().update(arrayify11(data)).digest("hex");
}
function sha2563(data) {
  return "0x" + import_hash7.default.sha256().update(arrayify11(data)).digest("hex");
}
function computeHmac2(algorithm, key6, data) {
  if (!SupportedAlgorithm2[algorithm]) {
    logger87.throwError("unsupported algorithm " + algorithm, Logger12.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + import_hash7.default.hmac(import_hash7.default[algorithm], arrayify11(key6)).update(arrayify11(data)).digest("hex");
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify11(password);
  salt = arrayify11(salt);
  let hLen;
  let l2 = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r2;
  let T2;
  for (let i2 = 1; i2 <= l2; i2++) {
    block1[salt.length] = i2 >> 24 & 255;
    block1[salt.length + 1] = i2 >> 16 & 255;
    block1[salt.length + 2] = i2 >> 8 & 255;
    block1[salt.length + 3] = i2 & 255;
    let U2 = arrayify11(computeHmac2(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U2.length;
      T2 = new Uint8Array(hLen);
      l2 = Math.ceil(keylen / hLen);
      r2 = keylen - (l2 - 1) * hLen;
    }
    T2.set(U2);
    for (let j2 = 1; j2 < iterations; j2++) {
      U2 = arrayify11(computeHmac2(hashAlgorithm, password, U2));
      for (let k2 = 0; k2 < hLen; k2++)
        T2[k2] ^= U2[k2];
    }
    const destPos = (i2 - 1) * hLen;
    const len = i2 === l2 ? r2 : hLen;
    DK.set(arrayify11(T2).slice(0, len), destPos);
  }
  return hexlify9(DK);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
init_define_process_env();
var import_bn10 = __toESM(require_bn());
var import_hash8 = __toESM(require_hash());
function createCommonjsModule2(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base6) {
      return commonjsRequire2(path, base6 === void 0 || base6 === null ? module.path : base6);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire2() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert2 = assert2;
function assert2(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert2.equal = function assertEqual2(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_12 = createCommonjsModule2(function(module, exports) {
  "use strict";
  var utils = exports;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray2;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex13(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero2(msg[i2].toString(16));
    return res;
  }
  utils.toHex = toHex13;
  utils.encode = function encode18(arr, enc) {
    if (enc === "hex")
      return toHex13(arr);
    else
      return arr;
  };
});
var utils_1$12 = createCommonjsModule2(function(module, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert2;
  utils.toArray = utils_12.toArray;
  utils.zero2 = utils_12.zero2;
  utils.toHex = utils_12.toHex;
  utils.encode = utils_12.encode;
  function getNAF6(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i2 = 0; i2 < naf.length; i2++) {
      var z;
      var mod = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k2.isubn(z);
      } else {
        z = 0;
      }
      naf[i2] = z;
      k2.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF6;
  function getJSF6(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF6;
  function cachedProperty(obj, name2, computer) {
    var key6 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key6] !== void 0 ? this[key6] : this[key6] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn10.default(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});
var getNAF2 = utils_1$12.getNAF;
var getJSF2 = utils_1$12.getJSF;
var assert$12 = utils_1$12.assert;
function BaseCurve2(type, conf) {
  this.type = type;
  this.p = new import_bn10.default(conf.p, 16);
  this.red = conf.prime ? import_bn10.default.red(conf.prime) : import_bn10.default.mont(this.p);
  this.zero = new import_bn10.default(0).toRed(this.red);
  this.one = new import_bn10.default(1).toRed(this.red);
  this.two = new import_bn10.default(2).toRed(this.red);
  this.n = conf.n && new import_bn10.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base2 = BaseCurve2;
BaseCurve2.prototype.point = function point3() {
  throw new Error("Not implemented");
};
BaseCurve2.prototype.validate = function validate5() {
  throw new Error("Not implemented");
};
BaseCurve2.prototype._fixedNafMul = function _fixedNafMul2(p2, k2) {
  assert$12(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF2(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i2 = I2; i2 > 0; i2--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i2)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i2)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve2.prototype._wnafMul = function _wnafMul2(p2, k2) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF2(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i2 = naf.length - 1; i2 >= 0; i2--) {
    for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
      l2++;
    if (i2 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i2 < 0)
      break;
    var z = naf[i2];
    assert$12(z !== 0);
    if (p2.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve2.prototype._wnafMulAdd = function _wnafMulAdd2(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i2;
  var j2;
  var p2;
  for (i2 = 0; i2 < len; i2++) {
    p2 = points[i2];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i2] = nafPoints.wnd;
    wnd[i2] = nafPoints.points;
  }
  for (i2 = len - 1; i2 >= 1; i2 -= 2) {
    var a2 = i2 - 1;
    var b2 = i2;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF2(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF2(coeffs[b2], wndWidth[b2], this._bitLength);
      max2 = Math.max(naf[a2].length, max2);
      max2 = Math.max(naf[b2].length, max2);
      continue;
    }
    var comb = [
      points[a2],
      null,
      null,
      points[b2]
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF2(coeffs[a2], coeffs[b2]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a2] = new Array(max2);
    naf[b2] = new Array(max2);
    for (j2 = 0; j2 < max2; j2++) {
      var ja = jsf[0][j2] | 0;
      var jb = jsf[1][j2] | 0;
      naf[a2][j2] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i2 = max2; i2 >= 0; i2--) {
    var k2 = 0;
    while (i2 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len; j2++) {
        tmp[j2] = naf[j2][i2] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i2--;
    }
    if (i2 >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i2 < 0)
      break;
    for (j2 = 0; j2 < len; j2++) {
      var z = tmp[j2];
      p2;
      if (z === 0)
        continue;
      else if (z > 0)
        p2 = wnd[j2][z - 1 >> 1];
      else if (z < 0)
        p2 = wnd[j2][-z - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i2 = 0; i2 < len; i2++)
    wnd[i2] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint2(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve2.BasePoint = BasePoint2;
BasePoint2.prototype.eq = function eq4() {
  throw new Error("Not implemented");
};
BasePoint2.prototype.validate = function validate6() {
  return this.curve.validate(this);
};
BaseCurve2.prototype.decodePoint = function decodePoint2(bytes, enc) {
  bytes = utils_1$12.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$12(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$12(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint2.prototype.encodeCompressed = function encodeCompressed2(enc) {
  return this.encode(enc, true);
};
BasePoint2.prototype._encode = function _encode4(compact) {
  var len = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len));
};
BasePoint2.prototype.encode = function encode9(enc, compact) {
  return utils_1$12.encode(this._encode(compact), enc);
};
BasePoint2.prototype.precompute = function precompute2(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint2.prototype._hasDoubles = function _hasDoubles2(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
};
BasePoint2.prototype._getDoubles = function _getDoubles2(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i2 = 0; i2 < power; i2 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint2.prototype._getNAFPoints = function _getNAFPoints2(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl11 = max2 === 1 ? null : this.dbl();
  for (var i2 = 1; i2 < max2; i2++)
    res[i2] = res[i2 - 1].add(dbl11);
  return {
    wnd,
    points: res
  };
};
BasePoint2.prototype._getBeta = function _getBeta3() {
  return null;
};
BasePoint2.prototype.dblp = function dblp3(k2) {
  var r2 = this;
  for (var i2 = 0; i2 < k2; i2++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser2 = createCommonjsModule2(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$22 = utils_1$12.assert;
function ShortCurve2(conf) {
  base2.call(this, "short", conf);
  this.a = new import_bn10.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn10.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser2(ShortCurve2, base2);
var short_12 = ShortCurve2;
ShortCurve2.prototype._getEndomorphism = function _getEndomorphism2(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn10.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn10.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$22(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn10.default(vec.a, 16),
        b: new import_bn10.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve2.prototype._getEndoRoots = function _getEndoRoots2(num) {
  var red = num === this.p ? this.red : import_bn10.default.mont(num);
  var tinv = new import_bn10.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new import_bn10.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve2.prototype._getEndoBasis = function _getEndoBasis2(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new import_bn10.default(1);
  var y1 = new import_bn10.default(0);
  var x2 = new import_bn10.default(0);
  var y2 = new import_bn10.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i2 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r2 = v2.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i2 === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y;
  }
  a2 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve2.prototype._endoSplit = function _endoSplit2(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve2.prototype.pointFromX = function pointFromX2(x2, odd) {
  x2 = new import_bn10.default(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x2, y);
};
ShortCurve2.prototype.validate = function validate7(point11) {
  if (point11.inf)
    return true;
  var x2 = point11.x;
  var y = point11.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve2.prototype._endoWnafMulAdd = function _endoWnafMulAdd2(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i2 = 0; i2 < points.length; i2++) {
    var split = this._endoSplit(coeffs[i2]);
    var p2 = points[i2];
    var beta = p2._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i2 * 2] = p2;
    npoints[i2 * 2 + 1] = beta;
    ncoeffs[i2 * 2] = split.k1;
    ncoeffs[i2 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
  for (var j2 = 0; j2 < i2 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point2(curve, x2, y, isRed) {
  base2.BasePoint.call(this, curve, "affine");
  if (x2 === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn10.default(x2, 16);
    this.y = new import_bn10.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser2(Point2, base2.BasePoint);
ShortCurve2.prototype.point = function point4(x2, y, isRed) {
  return new Point2(this, x2, y, isRed);
};
ShortCurve2.prototype.pointFromJSON = function pointFromJSON2(obj, red) {
  return Point2.fromJSON(this, obj, red);
};
Point2.prototype._getBeta = function _getBeta4() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p2) {
      return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point2.prototype.toJSON = function toJSON2() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point2.fromJSON = function fromJSON2(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point2.prototype.inspect = function inspect4() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point2.prototype.isInfinity = function isInfinity3() {
  return this.inf;
};
Point2.prototype.add = function add3(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point2.prototype.dbl = function dbl3() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point2.prototype.getX = function getX2() {
  return this.x.fromRed();
};
Point2.prototype.getY = function getY2() {
  return this.y.fromRed();
};
Point2.prototype.mul = function mul3(k2) {
  k2 = new import_bn10.default(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
};
Point2.prototype.mulAdd = function mulAdd2(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point2.prototype.jmulAdd = function jmulAdd2(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point2.prototype.eq = function eq5(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point2.prototype.neg = function neg3(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point2.prototype.toJ = function toJ2() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint2(curve, x2, y, z) {
  base2.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn10.default(0);
  } else {
    this.x = new import_bn10.default(x2, 16);
    this.y = new import_bn10.default(y, 16);
    this.z = new import_bn10.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser2(JPoint2, base2.BasePoint);
ShortCurve2.prototype.jpoint = function jpoint2(x2, y, z) {
  return new JPoint2(this, x2, y, z);
};
JPoint2.prototype.toP = function toP2() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint2.prototype.neg = function neg4() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint2.prototype.add = function add4(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint2.prototype.mixedAdd = function mixedAdd2(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint2.prototype.dblp = function dblp4(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i2;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i2 = 0; i2 < pow; i2++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i2 = 0; i2 < pow; i2++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i2 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint2.prototype.dbl = function dbl4() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint2.prototype._zeroDbl = function _zeroDbl2() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e = a2.redAdd(a2).redIAdd(a2);
    var f2 = e.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint2.prototype._threeDbl = function _threeDbl2() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint2.prototype._dbl = function _dbl2() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint2.prototype.trpl = function trpl2() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee2 = e.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e).redSqr().redISub(mm).redISub(ee2).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint2.prototype.mul = function mul4(k2, kbase) {
  k2 = new import_bn10.default(k2, kbase);
  return this.curve._wnafMul(this, k2);
};
JPoint2.prototype.eq = function eq6(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint2.prototype.eqXToP = function eqXToP2(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint2.prototype.inspect = function inspect5() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint2.prototype.isInfinity = function isInfinity4() {
  return this.z.cmpn(0) === 0;
};
var curve_12 = createCommonjsModule2(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base2;
  curve.short = short_12;
  curve.mont = null;
  curve.edwards = null;
});
var curves_12 = createCommonjsModule2(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert6 = utils_1$12.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_12.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_12.edwards(options);
    else
      this.curve = new curve_12.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert6(this.g.validate(), "Invalid curve");
    assert6(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash8.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash8.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash8.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash8.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash8.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash8.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash8.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash8.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG2(options) {
  if (!(this instanceof HmacDRBG2))
    return new HmacDRBG2(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_12.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_12.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_12.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert2(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg2 = HmacDRBG2;
HmacDRBG2.prototype._init = function init2(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG2.prototype._hmac = function hmac2() {
  return new import_hash8.default.hmac(this.hash, this.K);
};
HmacDRBG2.prototype._update = function update2(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG2.prototype.reseed = function reseed2(entropy, entropyEnc, add11, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add11;
    add11 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_12.toArray(entropy, entropyEnc);
  add11 = utils_12.toArray(add11, addEnc);
  minimalisticAssert2(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add11 || []));
  this._reseed = 1;
};
HmacDRBG2.prototype.generate = function generate3(len, enc, add11, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add11;
    add11 = enc;
    enc = null;
  }
  if (add11) {
    add11 = utils_12.toArray(add11, addEnc || "hex");
    this._update(add11);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add11);
  this._reseed++;
  return utils_12.encode(res, enc);
};
var assert$32 = utils_1$12.assert;
function KeyPair2(ec6, options) {
  this.ec = ec6;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key2 = KeyPair2;
KeyPair2.fromPublic = function fromPublic2(ec6, pub, enc) {
  if (pub instanceof KeyPair2)
    return pub;
  return new KeyPair2(ec6, {
    pub,
    pubEnc: enc
  });
};
KeyPair2.fromPrivate = function fromPrivate2(ec6, priv, enc) {
  if (priv instanceof KeyPair2)
    return priv;
  return new KeyPair2(ec6, {
    priv,
    privEnc: enc
  });
};
KeyPair2.prototype.validate = function validate8() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair2.prototype.getPublic = function getPublic2(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair2.prototype.getPrivate = function getPrivate2(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair2.prototype._importPrivate = function _importPrivate2(key6, enc) {
  this.priv = new import_bn10.default(key6, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair2.prototype._importPublic = function _importPublic2(key6, enc) {
  if (key6.x || key6.y) {
    if (this.ec.curve.type === "mont") {
      assert$32(key6.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$32(key6.x && key6.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key6.x, key6.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key6, enc);
};
KeyPair2.prototype.derive = function derive2(pub) {
  if (!pub.validate()) {
    assert$32(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair2.prototype.sign = function sign3(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair2.prototype.verify = function verify3(msg, signature6) {
  return this.ec.verify(msg, signature6, this);
};
KeyPair2.prototype.inspect = function inspect6() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$42 = utils_1$12.assert;
function Signature2(options, enc) {
  if (options instanceof Signature2)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$42(options.r && options.s, "Signature without r or s");
  this.r = new import_bn10.default(options.r, 16);
  this.s = new import_bn10.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature2 = Signature2;
function Position2() {
  this.place = 0;
}
function getLength2(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding2(buf) {
  var i2 = 0;
  var len = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
Signature2.prototype._importDER = function _importDER2(data, enc) {
  data = utils_1$12.toArray(data, enc);
  var p2 = new Position2();
  if (data[p2.place++] !== 48) {
    return false;
  }
  var len = getLength2(data, p2);
  if (len === false) {
    return false;
  }
  if (len + p2.place !== data.length) {
    return false;
  }
  if (data[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength2(data, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength2(data, p2);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p2.place) {
    return false;
  }
  var s2 = data.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn10.default(r2);
  this.s = new import_bn10.default(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength2(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature2.prototype.toDER = function toDER2(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding2(r2);
  s2 = rmPadding2(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength2(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength2(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength2(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$12.encode(res, enc);
};
var rand2 = function() {
  throw new Error("unsupported");
};
var assert$52 = utils_1$12.assert;
function EC2(options) {
  if (!(this instanceof EC2))
    return new EC2(options);
  if (typeof options === "string") {
    assert$52(Object.prototype.hasOwnProperty.call(curves_12, options), "Unknown curve " + options);
    options = curves_12[options];
  }
  if (options instanceof curves_12.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec2 = EC2;
EC2.prototype.keyPair = function keyPair2(options) {
  return new key2(this, options);
};
EC2.prototype.keyFromPrivate = function keyFromPrivate2(priv, enc) {
  return key2.fromPrivate(this, priv, enc);
};
EC2.prototype.keyFromPublic = function keyFromPublic2(pub, enc) {
  return key2.fromPublic(this, pub, enc);
};
EC2.prototype.genKeyPair = function genKeyPair2(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg2({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand2(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn10.default(2));
  for (; ; ) {
    var priv = new import_bn10.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC2.prototype._truncateToN = function _truncateToN2(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC2.prototype.sign = function sign4(msg, key6, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key6 = this.keyFromPrivate(key6, enc);
  msg = this._truncateToN(new import_bn10.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key6.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg2({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn10.default(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new import_bn10.default(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k2.invm(this.n).mul(r2.mul(key6.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature2({ r: r2, s: s2, recoveryParam });
  }
};
EC2.prototype.verify = function verify4(msg, signature$1, key6, enc) {
  msg = this._truncateToN(new import_bn10.default(msg, 16));
  key6 = this.keyFromPublic(key6, enc);
  signature$1 = new signature2(signature$1, "hex");
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key6.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key6.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC2.prototype.recoverPubKey = function(msg, signature$1, j2, enc) {
  assert$52((3 & j2) === j2, "The recovery param is more than two bits");
  signature$1 = new signature2(signature$1, enc);
  var n = this.n;
  var e = new import_bn10.default(msg);
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s22 = s2.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r2, s22);
};
EC2.prototype.getKeyRecoveryParam = function(e, signature$1, Q2, enc) {
  signature$1 = new signature2(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i2 = 0; i2 < 4; i2++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i2);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i2;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_12 = createCommonjsModule2(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$12;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_12;
  elliptic.curves = curves_12;
  elliptic.ec = ec2;
  elliptic.eddsa = null;
});
var EC$12 = elliptic_12.ec;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/lib.esm/_version.js
init_define_process_env();
var version71 = "signing-key/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger88 = new Logger12(version71);
var _curve2 = null;
function getCurve2() {
  if (!_curve2) {
    _curve2 = new EC$12("secp256k1");
  }
  return _curve2;
}
var SigningKey2 = class {
  constructor(privateKey) {
    defineReadOnly7(this, "curve", "secp256k1");
    defineReadOnly7(this, "privateKey", hexlify9(privateKey));
    const keyPair6 = getCurve2().keyFromPrivate(arrayify11(this.privateKey));
    defineReadOnly7(this, "publicKey", "0x" + keyPair6.getPublic(false, "hex"));
    defineReadOnly7(this, "compressedPublicKey", "0x" + keyPair6.getPublic(true, "hex"));
    defineReadOnly7(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve2().keyFromPublic(arrayify11(this.publicKey));
    const p1 = getCurve2().keyFromPublic(arrayify11(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest) {
    const keyPair6 = getCurve2().keyFromPrivate(arrayify11(this.privateKey));
    const digestBytes = arrayify11(digest);
    if (digestBytes.length !== 32) {
      logger88.throwArgumentError("bad digest length", "digest", digest);
    }
    const signature6 = keyPair6.sign(digestBytes, { canonical: true });
    return splitSignature3({
      recoveryParam: signature6.recoveryParam,
      r: hexZeroPad9("0x" + signature6.r.toString(16), 32),
      s: hexZeroPad9("0x" + signature6.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair6 = getCurve2().keyFromPrivate(arrayify11(this.privateKey));
    const otherKeyPair = getCurve2().keyFromPublic(arrayify11(computePublicKey2(otherKey)));
    return hexZeroPad9("0x" + keyPair6.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
function computePublicKey2(key6, compressed) {
  const bytes = arrayify11(key6);
  if (bytes.length === 32) {
    const signingKey = new SigningKey2(bytes);
    if (compressed) {
      return "0x" + getCurve2().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify9(bytes);
    }
    return "0x" + getCurve2().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify9(bytes);
    }
    return "0x" + getCurve2().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger88.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha36 = __toESM(require_sha3());
function keccak2567(data) {
  return "0x" + import_js_sha36.default.keccak_256(arrayify11(data));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version72 = "rlp/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger89 = new Logger12(version72);

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version73 = "address/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/lib.esm/index.js
var logger90 = new Logger12(version73);
function getChecksumAddress6(address) {
  if (!isHexString11(address, 20)) {
    logger90.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify11(keccak2567(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER6 = 9007199254740991;
function log106(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
var ibanLookup6 = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup6[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup6[String.fromCharCode(65 + i2)] = String(10 + i2);
}
var safeDigits6 = Math.floor(log106(MAX_SAFE_INTEGER6));
function ibanChecksum6(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup6[c2];
  }).join("");
  while (expanded.length >= safeDigits6) {
    let block = expanded.substring(0, safeDigits6);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress6(address) {
  let result = null;
  if (typeof address !== "string") {
    logger90.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress6(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger90.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum6(address)) {
      logger90.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To168(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress6("0x" + result);
  } else {
    logger90.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/lib.esm/_version.js
init_define_process_env();
var version74 = "transactions/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/lib.esm/index.js
var logger91 = new Logger12(version74);
var TransactionTypes2;
(function(TransactionTypes5) {
  TransactionTypes5[TransactionTypes5["legacy"] = 0] = "legacy";
  TransactionTypes5[TransactionTypes5["eip2930"] = 1] = "eip2930";
  TransactionTypes5[TransactionTypes5["eip1559"] = 2] = "eip1559";
})(TransactionTypes2 || (TransactionTypes2 = {}));
function computeAddress2(key6) {
  const publicKey = computePublicKey2(key6);
  return getAddress6(hexDataSlice7(keccak2567(hexDataSlice7(publicKey, 1)), 12));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/id.js
init_define_process_env();
function id5(text2) {
  return keccak2567(toUtf8Bytes5(text2));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/namehash.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/_version.js
init_define_process_env();
var version75 = "hash/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger92 = new Logger12(version75);
var Zeros5 = new Uint8Array(32);
Zeros5.fill(0);
var Partition5 = new RegExp("^((.*)\\.)?([^.]+)$");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/message.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/lib.esm/typed-data.js
init_define_process_env();
var logger93 = new Logger12(version75);
var padding5 = new Uint8Array(32);
padding5.fill(0);
var NegativeOne19 = BigNumber8.from(-1);
var Zero19 = BigNumber8.from(0);
var One11 = BigNumber8.from(1);
var MaxUint25611 = BigNumber8.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var hexTrue5 = hexZeroPad9(One11.toHexString(), 32);
var hexFalse5 = hexZeroPad9(Zero19.toHexString(), 32);
function checkString5(key6) {
  return function(value) {
    if (typeof value !== "string") {
      logger93.throwArgumentError(`invalid domain value for ${JSON.stringify(key6)}`, `domain.${key6}`, value);
    }
    return value;
  };
}
var domainChecks5 = {
  name: checkString5("name"),
  version: checkString5("version"),
  chainId: function(value) {
    try {
      return BigNumber8.from(value).toString();
    } catch (error) {
    }
    return logger93.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress6(value).toLowerCase();
    } catch (error) {
    }
    return logger93.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify11(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify9(bytes);
    } catch (error) {
    }
    return logger93.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/_version.js
init_define_process_env();
var version76 = "wordlists/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist2 = false;
var logger94 = new Logger12(version76);
var Wordlist2 = class {
  constructor(locale) {
    logger94.checkAbstract(new.target, Wordlist2);
    defineReadOnly7(this, "locale", locale);
  }
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  join(words4) {
    return words4.join(" ");
  }
  static check(wordlist4) {
    const words4 = [];
    for (let i2 = 0; i2 < 2048; i2++) {
      const word = wordlist4.getWord(i2);
      if (i2 !== wordlist4.getWordIndex(word)) {
        return "0x";
      }
      words4.push(word);
    }
    return id5(words4.join("\n") + "\n");
  }
  static register(lang, name2) {
    if (!name2) {
      name2 = lang.locale;
    }
    if (exportWordlist2) {
      try {
        const anyGlobal4 = window;
        if (anyGlobal4._ethers && anyGlobal4._ethers.wordlists) {
          if (!anyGlobal4._ethers.wordlists[name2]) {
            defineReadOnly7(anyGlobal4._ethers.wordlists, name2, lang);
          }
        }
      } catch (error) {
      }
    }
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
init_define_process_env();
var words2 = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
var wordlist2 = null;
function loadWords2(lang) {
  if (wordlist2 != null) {
    return;
  }
  wordlist2 = words2.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist2.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist2 = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var LangEn2 = class extends Wordlist2 {
  constructor() {
    super("en");
  }
  getWord(index) {
    loadWords2(this);
    return wordlist2[index];
  }
  getWordIndex(word) {
    loadWords2(this);
    return wordlist2.indexOf(word);
  }
};
var langEn2 = new LangEn2();
Wordlist2.register(langEn2);

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
var wordlists2 = {
  en: langEn2
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/lib.esm/_version.js
init_define_process_env();
var version77 = "hdnode/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/hdnode/lib.esm/index.js
var logger95 = new Logger12(version77);
var N = BigNumber8.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var MasterSecret = toUtf8Bytes5("Bitcoin seed");
var HardenedBit = 2147483648;
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return hexZeroPad9(hexlify9(value), 32);
}
function base58check(data) {
  return Base583.encode(concat9([data, hexDataSlice7(sha2563(sha2563(data)), 0, 4)]));
}
function getWordlist(wordlist4) {
  if (wordlist4 == null) {
    return wordlists2["en"];
  }
  if (typeof wordlist4 === "string") {
    const words4 = wordlists2[wordlist4];
    if (words4 == null) {
      logger95.throwArgumentError("unknown locale", "wordlist", wordlist4);
    }
    return words4;
  }
  return wordlist4;
}
var _constructorGuard19 = {};
var defaultPath = "m/44'/60'/0'/0/0";
var HDNode = class {
  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
    logger95.checkNew(new.target, HDNode);
    if (constructorGuard !== _constructorGuard19) {
      throw new Error("HDNode constructor cannot be called directly");
    }
    if (privateKey) {
      const signingKey = new SigningKey2(privateKey);
      defineReadOnly7(this, "privateKey", signingKey.privateKey);
      defineReadOnly7(this, "publicKey", signingKey.compressedPublicKey);
    } else {
      defineReadOnly7(this, "privateKey", null);
      defineReadOnly7(this, "publicKey", hexlify9(publicKey));
    }
    defineReadOnly7(this, "parentFingerprint", parentFingerprint);
    defineReadOnly7(this, "fingerprint", hexDataSlice7(ripemd1602(sha2563(this.publicKey)), 0, 4));
    defineReadOnly7(this, "address", computeAddress2(this.publicKey));
    defineReadOnly7(this, "chainCode", chainCode);
    defineReadOnly7(this, "index", index);
    defineReadOnly7(this, "depth", depth);
    if (mnemonicOrPath == null) {
      defineReadOnly7(this, "mnemonic", null);
      defineReadOnly7(this, "path", null);
    } else if (typeof mnemonicOrPath === "string") {
      defineReadOnly7(this, "mnemonic", null);
      defineReadOnly7(this, "path", mnemonicOrPath);
    } else {
      defineReadOnly7(this, "mnemonic", mnemonicOrPath);
      defineReadOnly7(this, "path", mnemonicOrPath.path);
    }
  }
  get extendedKey() {
    if (this.depth >= 256) {
      throw new Error("Depth too large!");
    }
    return base58check(concat9([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      hexlify9(this.depth),
      this.parentFingerprint,
      hexZeroPad9(hexlify9(this.index), 4),
      this.chainCode,
      this.privateKey != null ? concat9(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new HDNode(_constructorGuard19, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(index) {
    if (index > 4294967295) {
      throw new Error("invalid index - " + String(index));
    }
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
    }
    const data = new Uint8Array(37);
    if (index & HardenedBit) {
      if (!this.privateKey) {
        throw new Error("cannot derive child of neutered node");
      }
      data.set(arrayify11(this.privateKey), 1);
      if (path) {
        path += "'";
      }
    } else {
      data.set(arrayify11(this.publicKey));
    }
    for (let i2 = 24; i2 >= 0; i2 -= 8) {
      data[33 + (i2 >> 3)] = index >> 24 - i2 & 255;
    }
    const I2 = arrayify11(computeHmac2(SupportedAlgorithm2.sha512, this.chainCode, data));
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    let ki = null;
    let Ki = null;
    if (this.privateKey) {
      ki = bytes32(BigNumber8.from(IL).add(this.privateKey).mod(N));
    } else {
      const ek = new SigningKey2(hexlify9(IL));
      Ki = ek._addPoint(this.publicKey);
    }
    let mnemonicOrPath = path;
    const srcMnemonic = this.mnemonic;
    if (srcMnemonic) {
      mnemonicOrPath = Object.freeze({
        phrase: srcMnemonic.phrase,
        path,
        locale: srcMnemonic.locale || "en"
      });
    }
    return new HDNode(_constructorGuard19, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
  }
  derivePath(path) {
    const components = path.split("/");
    if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
      throw new Error("invalid path - " + path);
    }
    if (components[0] === "m") {
      components.shift();
    }
    let result = this;
    for (let i2 = 0; i2 < components.length; i2++) {
      const component = components[i2];
      if (component.match(/^[0-9]+'$/)) {
        const index = parseInt(component.substring(0, component.length - 1));
        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(HardenedBit + index);
      } else if (component.match(/^[0-9]+$/)) {
        const index = parseInt(component);
        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(index);
      } else {
        throw new Error("invalid path component - " + component);
      }
    }
    return result;
  }
  static _fromSeed(seed, mnemonic) {
    const seedArray = arrayify11(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new Error("invalid seed");
    }
    const I2 = arrayify11(computeHmac2(SupportedAlgorithm2.sha512, MasterSecret, seedArray));
    return new HDNode(_constructorGuard19, bytes32(I2.slice(0, 32)), null, "0x00000000", bytes32(I2.slice(32)), 0, 0, mnemonic);
  }
  static fromMnemonic(mnemonic, password, wordlist4) {
    wordlist4 = getWordlist(wordlist4);
    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist4), wordlist4);
    return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
      phrase: mnemonic,
      path: "m",
      locale: wordlist4.locale
    });
  }
  static fromSeed(seed) {
    return HDNode._fromSeed(seed, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes = Base583.decode(extendedKey);
    if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
      logger95.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
    const depth = bytes[4];
    const parentFingerprint = hexlify9(bytes.slice(5, 9));
    const index = parseInt(hexlify9(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify9(bytes.slice(13, 45));
    const key6 = bytes.slice(45, 78);
    switch (hexlify9(bytes.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard19, null, hexlify9(key6), parentFingerprint, chainCode, index, depth, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (key6[0] !== 0) {
          break;
        }
        return new HDNode(_constructorGuard19, hexlify9(key6.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
    }
    return logger95.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
};
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes5("mnemonic" + password, UnicodeNormalizationForm5.NFKD);
  return pbkdf2(toUtf8Bytes5(mnemonic, UnicodeNormalizationForm5.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist4) {
  wordlist4 = getWordlist(wordlist4);
  logger95.checkNormalize();
  const words4 = wordlist4.split(mnemonic);
  if (words4.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify11(new Uint8Array(Math.ceil(11 * words4.length / 8)));
  let offset = 0;
  for (let i2 = 0; i2 < words4.length; i2++) {
    let index = wordlist4.getWordIndex(words4[i2].normalize("NFKD"));
    if (index === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words4.length / 3;
  const checksumBits = words4.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify11(sha2563(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify9(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist4) {
  wordlist4 = getWordlist(wordlist4);
  entropy = arrayify11(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i2 = 0; i2 < entropy.length; i2++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i2];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i2] >> 8 - remainingBits;
      indices.push(entropy[i2] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify11(sha2563(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist4.join(indices.map((index) => wordlist4.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist4) {
  try {
    mnemonicToEntropy(mnemonic, wordlist4);
    return true;
  } catch (error) {
  }
  return false;
}
function getAccountPath(index) {
  if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
    logger95.throwArgumentError("invalid account index", "index", index);
  }
  return `m/44'/60'/${index}'/0/0`;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
init_define_process_env();
var import_aes_js = __toESM(require_aes_js());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version78 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors13 = false;
var _censorErrors13 = false;
var LogLevels13 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel13 = LogLevels13["default"];
var _globalLogger13 = null;
function _checkNormalize13() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError13 = _checkNormalize13();
var LogLevel13;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel13 || (LogLevel13 = {}));
var ErrorCode13;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode13 || (ErrorCode13 = {}));
var HEX13 = "0123456789abcdef";
var Logger13 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels13[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel13 > LogLevels13[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger13.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger13.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger13.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors13) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger13.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX13[value[i2] >> 4];
            hex += HEX13[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode13.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode13.CALL_EXCEPTION:
      case ErrorCode13.INSUFFICIENT_FUNDS:
      case ErrorCode13.MISSING_NEW:
      case ErrorCode13.NONCE_EXPIRED:
      case ErrorCode13.REPLACEMENT_UNDERPRICED:
      case ErrorCode13.TRANSACTION_REPLACED:
      case ErrorCode13.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger13.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError13) {
      this.throwError("platform missing String.prototype.normalize", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError13
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger13.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger13.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger13.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger13.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger13.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger13.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger13.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger13) {
      _globalLogger13 = new Logger13(version78);
    }
    return _globalLogger13;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors13) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors13 = !!censorship;
    _permanentCensorErrors13 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels13[logLevel.toLowerCase()];
    if (level == null) {
      Logger13.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel13 = level;
  }
  static from(version130) {
    return new Logger13(version130);
  }
};
Logger13.errors = ErrorCode13;
Logger13.levels = LogLevel13;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version79 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger96 = new Logger13(version79);
function isHexable12(value) {
  return !!value.toHexString;
}
function addSlice12(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice12(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger12(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes12(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger12(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger12(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify12(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger96.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice12(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable12(value)) {
    value = value.toHexString();
  }
  if (isHexString12(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger96.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice12(new Uint8Array(result));
  }
  if (isBytes12(value)) {
    return addSlice12(new Uint8Array(value));
  }
  return logger96.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString12(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters10 = "0123456789abcdef";
function hexlify10(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger96.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters10[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable12(value)) {
    return value.toHexString();
  }
  if (isHexString12(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger96.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes12(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters10[(v2 & 240) >> 4] + HexCharacters10[v2 & 15];
    }
    return result;
  }
  return logger96.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad10(value, length) {
  if (typeof value !== "string") {
    value = hexlify10(value);
  } else if (!isHexString12(value)) {
    logger96.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger96.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn11 = __toESM(require_bn());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version80 = "bignumber/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN11 = import_bn11.default.BN;
var logger97 = new Logger13(version80);
var _constructorGuard20 = {};
var MAX_SAFE9 = 9007199254740991;
function isBigNumberish9(value) {
  return value != null && (BigNumber9.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString12(value) || typeof value === "bigint" || isBytes12(value));
}
var _warnedToStringRadix9 = false;
var BigNumber9 = class {
  constructor(constructorGuard, hex) {
    logger97.checkNew(new.target, BigNumber9);
    if (constructorGuard !== _constructorGuard20) {
      logger97.throwError("cannot call constructor directly; use BigNumber.from", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber9(toBN9(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber9(toBN9(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber9.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber9(toBN9(this).add(toBN9(other)));
  }
  sub(other) {
    return toBigNumber9(toBN9(this).sub(toBN9(other)));
  }
  div(other) {
    const o = BigNumber9.from(other);
    if (o.isZero()) {
      throwFault17("division-by-zero", "div");
    }
    return toBigNumber9(toBN9(this).div(toBN9(other)));
  }
  mul(other) {
    return toBigNumber9(toBN9(this).mul(toBN9(other)));
  }
  mod(other) {
    const value = toBN9(other);
    if (value.isNeg()) {
      throwFault17("division-by-zero", "mod");
    }
    return toBigNumber9(toBN9(this).umod(value));
  }
  pow(other) {
    const value = toBN9(other);
    if (value.isNeg()) {
      throwFault17("negative-power", "pow");
    }
    return toBigNumber9(toBN9(this).pow(value));
  }
  and(other) {
    const value = toBN9(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault17("unbound-bitwise-result", "and");
    }
    return toBigNumber9(toBN9(this).and(value));
  }
  or(other) {
    const value = toBN9(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault17("unbound-bitwise-result", "or");
    }
    return toBigNumber9(toBN9(this).or(value));
  }
  xor(other) {
    const value = toBN9(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault17("unbound-bitwise-result", "xor");
    }
    return toBigNumber9(toBN9(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault17("negative-width", "mask");
    }
    return toBigNumber9(toBN9(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault17("negative-width", "shl");
    }
    return toBigNumber9(toBN9(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault17("negative-width", "shr");
    }
    return toBigNumber9(toBN9(this).shrn(value));
  }
  eq(other) {
    return toBN9(this).eq(toBN9(other));
  }
  lt(other) {
    return toBN9(this).lt(toBN9(other));
  }
  lte(other) {
    return toBN9(this).lte(toBN9(other));
  }
  gt(other) {
    return toBN9(this).gt(toBN9(other));
  }
  gte(other) {
    return toBN9(this).gte(toBN9(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN9(this).isZero();
  }
  toNumber() {
    try {
      return toBN9(this).toNumber();
    } catch (error) {
      throwFault17("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger97.throwError("this platform does not support BigInt", Logger13.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix9) {
          _warnedToStringRadix9 = true;
          logger97.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger97.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger13.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger97.throwError("BigNumber.toString does not accept parameters", Logger13.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN9(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber9) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber9(_constructorGuard20, toHex9(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber9(_constructorGuard20, toHex9(new BN11(value)));
      }
      return logger97.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault17("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE9 || value <= -MAX_SAFE9) {
        throwFault17("overflow", "BigNumber.from", value);
      }
      return BigNumber9.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber9.from(anyValue.toString());
    }
    if (isBytes12(anyValue)) {
      return BigNumber9.from(hexlify10(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber9.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString12(hex) || hex[0] === "-" && isHexString12(hex.substring(1))) {
            return BigNumber9.from(hex);
          }
        }
      }
    }
    return logger97.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex9(value) {
  if (typeof value !== "string") {
    return toHex9(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger97.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex9(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber9(value) {
  return BigNumber9.from(toHex9(value));
}
function toBN9(value) {
  const hex = BigNumber9.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN11("-" + hex.substring(3), 16);
  }
  return new BN11(hex.substring(2), 16);
}
function throwFault17(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger97.throwError(fault, Logger13.errors.NUMERIC_FAULT, params);
}
function _base36To169(value) {
  return new BN11(value, 36).toString(16);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger98 = new Logger13(version80);
var _constructorGuard21 = {};
var Zero20 = BigNumber9.from(0);
var NegativeOne20 = BigNumber9.from(-1);
function throwFault18(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger98.throwError(message, Logger13.errors.NUMERIC_FAULT, params);
}
var zeros9 = "0";
while (zeros9.length < 256) {
  zeros9 += zeros9;
}
function getMultiplier9(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber9.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros9.substring(0, decimals);
  }
  return logger98.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed9(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier9(decimals);
  value = BigNumber9.from(value);
  const negative = value.lt(Zero20);
  if (negative) {
    value = value.mul(NegativeOne20);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed9(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier9(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger98.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger98.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger98.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault18("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber9.from(whole);
  const fractionValue = BigNumber9.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne20);
  }
  return wei;
}
var FixedFormat9 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard21) {
      logger98.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier9(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat9) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger98.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger98.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger98.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger98.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat9(_constructorGuard21, signed, width, decimals);
  }
};
var FixedNumber9 = class {
  constructor(constructorGuard, hex, value, format) {
    logger98.checkNew(new.target, FixedNumber9);
    if (constructorGuard !== _constructorGuard21) {
      logger98.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger98.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed9(this._value, this.format.decimals);
    const b2 = parseFixed9(other._value, other.format.decimals);
    return FixedNumber9.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed9(this._value, this.format.decimals);
    const b2 = parseFixed9(other._value, other.format.decimals);
    return FixedNumber9.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed9(this._value, this.format.decimals);
    const b2 = parseFixed9(other._value, other.format.decimals);
    return FixedNumber9.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed9(this._value, this.format.decimals);
    const b2 = parseFixed9(other._value, other.format.decimals);
    return FixedNumber9.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber9.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE9.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber9.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE9.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger98.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber9.from("1" + zeros9.substring(0, decimals), this.format);
    const bump = BUMP9.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger98.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber9.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad10(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber9.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish9(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber9.fromString(formatFixed9(value, decimals), FixedFormat9.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat9.from(format);
    const numeric = parseFixed9(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero20)) {
      throwFault18("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad10(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed9(numeric, fixedFormat.decimals);
    return new FixedNumber9(_constructorGuard21, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat9.from(format);
    if (arrayify12(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber9.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed9(numeric, fixedFormat.decimals);
    return new FixedNumber9(_constructorGuard21, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber9.fromString(value, format);
    }
    if (isBytes12(value)) {
      return FixedNumber9.fromBytes(value, format);
    }
    try {
      return FixedNumber9.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger13.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger98.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE9 = FixedNumber9.from(1);
var BUMP9 = FixedNumber9.from("0.5");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha37 = __toESM(require_sha3());
function keccak2568(data) {
  return "0x" + import_js_sha37.default.keccak_256(arrayify12(data));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version81 = "rlp/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger99 = new Logger13(version81);

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version82 = "address/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/lib.esm/index.js
var logger100 = new Logger13(version82);
function getChecksumAddress7(address) {
  if (!isHexString12(address, 20)) {
    logger100.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify12(keccak2568(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER7 = 9007199254740991;
function log107(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
var ibanLookup7 = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup7[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup7[String.fromCharCode(65 + i2)] = String(10 + i2);
}
var safeDigits7 = Math.floor(log107(MAX_SAFE_INTEGER7));
function ibanChecksum7(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup7[c2];
  }).join("");
  while (expanded.length >= safeDigits7) {
    let block = expanded.substring(0, safeDigits7);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress7(address) {
  let result = null;
  if (typeof address !== "string") {
    logger100.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress7(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger100.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum7(address)) {
      logger100.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To169(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress7("0x" + result);
  } else {
    logger100.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/pbkdf2/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/sha2/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/sha2/lib.esm/sha2.js
init_define_process_env();
var import_hash10 = __toESM(require_hash());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/sha2/lib.esm/types.js
init_define_process_env();
var SupportedAlgorithm3;
(function(SupportedAlgorithm5) {
  SupportedAlgorithm5["sha256"] = "sha256";
  SupportedAlgorithm5["sha512"] = "sha512";
})(SupportedAlgorithm3 || (SupportedAlgorithm3 = {}));

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/sha2/lib.esm/_version.js
init_define_process_env();
var version83 = "sha2/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/sha2/lib.esm/sha2.js
var logger101 = new Logger13(version83);

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();
var NegativeOne21 = BigNumber9.from(-1);
var Zero21 = BigNumber9.from(0);
var One12 = BigNumber9.from(1);
var Two7 = BigNumber9.from(2);
var WeiPerEther7 = BigNumber9.from("1000000000000000000");
var MaxUint25612 = BigNumber9.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2567 = BigNumber9.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2567 = BigNumber9.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version84 = "strings/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger102 = new Logger13(version84);
var UnicodeNormalizationForm6;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm6 || (UnicodeNormalizationForm6 = {}));
var Utf8ErrorReason6;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason6 || (Utf8ErrorReason6 = {}));
function errorFunc6(reason, offset, bytes, output, badCodepoint) {
  return logger102.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc6(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason6.BAD_PREFIX || reason === Utf8ErrorReason6.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason6.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc6(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason6.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc6(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs6 = Object.freeze({
  error: errorFunc6,
  ignore: ignoreFunc6,
  replace: replaceFunc6
});
function toUtf8Bytes6(str, form = UnicodeNormalizationForm6.current) {
  if (form != UnicodeNormalizationForm6.current) {
    logger102.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify12(result);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes26(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data.length; i2 += 4) {
    result.push(parseInt(data.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable6(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable6(data) {
  let hi = 0;
  return data.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges6 = createRangeTable6("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags6 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
var Table_B_2_lut_abs6 = createTable6("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel6 = createTable6("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex6 = createTable6("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes26);
var Table_C_ranges6 = createRangeTable6("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version85 = "properties/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/properties/lib.esm/index.js
var logger103 = new Logger13(version85);
function defineReadOnly8(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/lib.esm/_version.js
init_define_process_env();
var version86 = "json-wallets/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/lib.esm/utils.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
var logger104 = new Logger13(version86);

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/lib.esm/inspect.js
init_define_process_env();
function isCrowdsaleWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return getAddress7(JSON.parse(json).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json)) {
    try {
      return getAddress7(JSON.parse(json).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
init_define_process_env();
var import_aes_js2 = __toESM(require_aes_js());
var import_scrypt_js = __toESM(require_scrypt());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hdnode/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/basex/lib.esm/index.js
init_define_process_env();
var BaseX4 = class {
  constructor(alphabet) {
    defineReadOnly8(this, "alphabet", alphabet);
    defineReadOnly8(this, "base", alphabet.length);
    defineReadOnly8(this, "_alphabetMap", {});
    defineReadOnly8(this, "_leader", alphabet.charAt(0));
    for (let i2 = 0; i2 < alphabet.length; i2++) {
      this._alphabetMap[alphabet.charAt(i2)] = i2;
    }
  }
  encode(value) {
    let source = arrayify12(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i2 = 0; i2 < source.length; ++i2) {
      let carry = source[i2];
      for (let j2 = 0; j2 < digits.length; ++j2) {
        carry += digits[j2] << 8;
        digits[j2] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string = "";
    for (let k2 = 0; source[k2] === 0 && k2 < source.length - 1; ++k2) {
      string += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string += this.alphabet[digits[q2]];
    }
    return string;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i2 = 0; i2 < value.length; i2++) {
      let byte = this._alphabetMap[value[i2]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j2 = 0; j2 < bytes.length; ++j2) {
        carry += bytes[j2] * this.base;
        bytes[j2] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k2 = 0; value[k2] === this._leader && k2 < value.length - 1; ++k2) {
      bytes.push(0);
    }
    return arrayify12(new Uint8Array(bytes.reverse()));
  }
};
var Base324 = new BaseX4("abcdefghijklmnopqrstuvwxyz234567");
var Base584 = new BaseX4("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/signing-key/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
init_define_process_env();
var import_bn12 = __toESM(require_bn());
var import_hash11 = __toESM(require_hash());
function createCommonjsModule3(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base6) {
      return commonjsRequire3(path, base6 === void 0 || base6 === null ? module.path : base6);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire3() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert3 = assert3;
function assert3(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert3.equal = function assertEqual3(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_13 = createCommonjsModule3(function(module, exports) {
  "use strict";
  var utils = exports;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray2;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex13(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero2(msg[i2].toString(16));
    return res;
  }
  utils.toHex = toHex13;
  utils.encode = function encode18(arr, enc) {
    if (enc === "hex")
      return toHex13(arr);
    else
      return arr;
  };
});
var utils_1$13 = createCommonjsModule3(function(module, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert3;
  utils.toArray = utils_13.toArray;
  utils.zero2 = utils_13.zero2;
  utils.toHex = utils_13.toHex;
  utils.encode = utils_13.encode;
  function getNAF6(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i2 = 0; i2 < naf.length; i2++) {
      var z;
      var mod = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k2.isubn(z);
      } else {
        z = 0;
      }
      naf[i2] = z;
      k2.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF6;
  function getJSF6(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF6;
  function cachedProperty(obj, name2, computer) {
    var key6 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key6] !== void 0 ? this[key6] : this[key6] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn12.default(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});
var getNAF3 = utils_1$13.getNAF;
var getJSF3 = utils_1$13.getJSF;
var assert$13 = utils_1$13.assert;
function BaseCurve3(type, conf) {
  this.type = type;
  this.p = new import_bn12.default(conf.p, 16);
  this.red = conf.prime ? import_bn12.default.red(conf.prime) : import_bn12.default.mont(this.p);
  this.zero = new import_bn12.default(0).toRed(this.red);
  this.one = new import_bn12.default(1).toRed(this.red);
  this.two = new import_bn12.default(2).toRed(this.red);
  this.n = conf.n && new import_bn12.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base3 = BaseCurve3;
BaseCurve3.prototype.point = function point5() {
  throw new Error("Not implemented");
};
BaseCurve3.prototype.validate = function validate9() {
  throw new Error("Not implemented");
};
BaseCurve3.prototype._fixedNafMul = function _fixedNafMul3(p2, k2) {
  assert$13(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF3(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i2 = I2; i2 > 0; i2--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i2)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i2)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve3.prototype._wnafMul = function _wnafMul3(p2, k2) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF3(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i2 = naf.length - 1; i2 >= 0; i2--) {
    for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
      l2++;
    if (i2 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i2 < 0)
      break;
    var z = naf[i2];
    assert$13(z !== 0);
    if (p2.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve3.prototype._wnafMulAdd = function _wnafMulAdd3(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i2;
  var j2;
  var p2;
  for (i2 = 0; i2 < len; i2++) {
    p2 = points[i2];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i2] = nafPoints.wnd;
    wnd[i2] = nafPoints.points;
  }
  for (i2 = len - 1; i2 >= 1; i2 -= 2) {
    var a2 = i2 - 1;
    var b2 = i2;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF3(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF3(coeffs[b2], wndWidth[b2], this._bitLength);
      max2 = Math.max(naf[a2].length, max2);
      max2 = Math.max(naf[b2].length, max2);
      continue;
    }
    var comb = [
      points[a2],
      null,
      null,
      points[b2]
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF3(coeffs[a2], coeffs[b2]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a2] = new Array(max2);
    naf[b2] = new Array(max2);
    for (j2 = 0; j2 < max2; j2++) {
      var ja = jsf[0][j2] | 0;
      var jb = jsf[1][j2] | 0;
      naf[a2][j2] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i2 = max2; i2 >= 0; i2--) {
    var k2 = 0;
    while (i2 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len; j2++) {
        tmp[j2] = naf[j2][i2] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i2--;
    }
    if (i2 >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i2 < 0)
      break;
    for (j2 = 0; j2 < len; j2++) {
      var z = tmp[j2];
      p2;
      if (z === 0)
        continue;
      else if (z > 0)
        p2 = wnd[j2][z - 1 >> 1];
      else if (z < 0)
        p2 = wnd[j2][-z - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i2 = 0; i2 < len; i2++)
    wnd[i2] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint3(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve3.BasePoint = BasePoint3;
BasePoint3.prototype.eq = function eq7() {
  throw new Error("Not implemented");
};
BasePoint3.prototype.validate = function validate10() {
  return this.curve.validate(this);
};
BaseCurve3.prototype.decodePoint = function decodePoint3(bytes, enc) {
  bytes = utils_1$13.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$13(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$13(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint3.prototype.encodeCompressed = function encodeCompressed3(enc) {
  return this.encode(enc, true);
};
BasePoint3.prototype._encode = function _encode5(compact) {
  var len = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len));
};
BasePoint3.prototype.encode = function encode12(enc, compact) {
  return utils_1$13.encode(this._encode(compact), enc);
};
BasePoint3.prototype.precompute = function precompute3(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint3.prototype._hasDoubles = function _hasDoubles3(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
};
BasePoint3.prototype._getDoubles = function _getDoubles3(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i2 = 0; i2 < power; i2 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint3.prototype._getNAFPoints = function _getNAFPoints3(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl11 = max2 === 1 ? null : this.dbl();
  for (var i2 = 1; i2 < max2; i2++)
    res[i2] = res[i2 - 1].add(dbl11);
  return {
    wnd,
    points: res
  };
};
BasePoint3.prototype._getBeta = function _getBeta5() {
  return null;
};
BasePoint3.prototype.dblp = function dblp5(k2) {
  var r2 = this;
  for (var i2 = 0; i2 < k2; i2++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser3 = createCommonjsModule3(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$23 = utils_1$13.assert;
function ShortCurve3(conf) {
  base3.call(this, "short", conf);
  this.a = new import_bn12.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn12.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser3(ShortCurve3, base3);
var short_13 = ShortCurve3;
ShortCurve3.prototype._getEndomorphism = function _getEndomorphism3(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn12.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn12.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$23(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn12.default(vec.a, 16),
        b: new import_bn12.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve3.prototype._getEndoRoots = function _getEndoRoots3(num) {
  var red = num === this.p ? this.red : import_bn12.default.mont(num);
  var tinv = new import_bn12.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new import_bn12.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve3.prototype._getEndoBasis = function _getEndoBasis3(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new import_bn12.default(1);
  var y1 = new import_bn12.default(0);
  var x2 = new import_bn12.default(0);
  var y2 = new import_bn12.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i2 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r2 = v2.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i2 === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y;
  }
  a2 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve3.prototype._endoSplit = function _endoSplit3(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve3.prototype.pointFromX = function pointFromX3(x2, odd) {
  x2 = new import_bn12.default(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x2, y);
};
ShortCurve3.prototype.validate = function validate11(point11) {
  if (point11.inf)
    return true;
  var x2 = point11.x;
  var y = point11.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve3.prototype._endoWnafMulAdd = function _endoWnafMulAdd3(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i2 = 0; i2 < points.length; i2++) {
    var split = this._endoSplit(coeffs[i2]);
    var p2 = points[i2];
    var beta = p2._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i2 * 2] = p2;
    npoints[i2 * 2 + 1] = beta;
    ncoeffs[i2 * 2] = split.k1;
    ncoeffs[i2 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
  for (var j2 = 0; j2 < i2 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point3(curve, x2, y, isRed) {
  base3.BasePoint.call(this, curve, "affine");
  if (x2 === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn12.default(x2, 16);
    this.y = new import_bn12.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser3(Point3, base3.BasePoint);
ShortCurve3.prototype.point = function point6(x2, y, isRed) {
  return new Point3(this, x2, y, isRed);
};
ShortCurve3.prototype.pointFromJSON = function pointFromJSON3(obj, red) {
  return Point3.fromJSON(this, obj, red);
};
Point3.prototype._getBeta = function _getBeta6() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p2) {
      return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point3.prototype.toJSON = function toJSON3() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point3.fromJSON = function fromJSON3(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point3.prototype.inspect = function inspect7() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point3.prototype.isInfinity = function isInfinity5() {
  return this.inf;
};
Point3.prototype.add = function add5(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point3.prototype.dbl = function dbl5() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point3.prototype.getX = function getX3() {
  return this.x.fromRed();
};
Point3.prototype.getY = function getY3() {
  return this.y.fromRed();
};
Point3.prototype.mul = function mul5(k2) {
  k2 = new import_bn12.default(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
};
Point3.prototype.mulAdd = function mulAdd3(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point3.prototype.jmulAdd = function jmulAdd3(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point3.prototype.eq = function eq8(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point3.prototype.neg = function neg5(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point3.prototype.toJ = function toJ3() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint3(curve, x2, y, z) {
  base3.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn12.default(0);
  } else {
    this.x = new import_bn12.default(x2, 16);
    this.y = new import_bn12.default(y, 16);
    this.z = new import_bn12.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser3(JPoint3, base3.BasePoint);
ShortCurve3.prototype.jpoint = function jpoint3(x2, y, z) {
  return new JPoint3(this, x2, y, z);
};
JPoint3.prototype.toP = function toP3() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint3.prototype.neg = function neg6() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint3.prototype.add = function add6(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint3.prototype.mixedAdd = function mixedAdd3(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint3.prototype.dblp = function dblp6(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i2;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i2 = 0; i2 < pow; i2++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i2 = 0; i2 < pow; i2++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i2 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint3.prototype.dbl = function dbl6() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint3.prototype._zeroDbl = function _zeroDbl3() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e = a2.redAdd(a2).redIAdd(a2);
    var f2 = e.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint3.prototype._threeDbl = function _threeDbl3() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint3.prototype._dbl = function _dbl3() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint3.prototype.trpl = function trpl3() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee2 = e.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e).redSqr().redISub(mm).redISub(ee2).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint3.prototype.mul = function mul6(k2, kbase) {
  k2 = new import_bn12.default(k2, kbase);
  return this.curve._wnafMul(this, k2);
};
JPoint3.prototype.eq = function eq9(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint3.prototype.eqXToP = function eqXToP3(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint3.prototype.inspect = function inspect8() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint3.prototype.isInfinity = function isInfinity6() {
  return this.z.cmpn(0) === 0;
};
var curve_13 = createCommonjsModule3(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base3;
  curve.short = short_13;
  curve.mont = null;
  curve.edwards = null;
});
var curves_13 = createCommonjsModule3(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert6 = utils_1$13.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_13.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_13.edwards(options);
    else
      this.curve = new curve_13.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert6(this.g.validate(), "Invalid curve");
    assert6(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash11.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash11.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash11.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash11.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash11.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash11.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash11.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash11.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG3(options) {
  if (!(this instanceof HmacDRBG3))
    return new HmacDRBG3(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_13.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_13.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_13.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert3(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg3 = HmacDRBG3;
HmacDRBG3.prototype._init = function init3(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG3.prototype._hmac = function hmac3() {
  return new import_hash11.default.hmac(this.hash, this.K);
};
HmacDRBG3.prototype._update = function update3(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG3.prototype.reseed = function reseed3(entropy, entropyEnc, add11, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add11;
    add11 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_13.toArray(entropy, entropyEnc);
  add11 = utils_13.toArray(add11, addEnc);
  minimalisticAssert3(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add11 || []));
  this._reseed = 1;
};
HmacDRBG3.prototype.generate = function generate4(len, enc, add11, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add11;
    add11 = enc;
    enc = null;
  }
  if (add11) {
    add11 = utils_13.toArray(add11, addEnc || "hex");
    this._update(add11);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add11);
  this._reseed++;
  return utils_13.encode(res, enc);
};
var assert$33 = utils_1$13.assert;
function KeyPair3(ec6, options) {
  this.ec = ec6;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key3 = KeyPair3;
KeyPair3.fromPublic = function fromPublic3(ec6, pub, enc) {
  if (pub instanceof KeyPair3)
    return pub;
  return new KeyPair3(ec6, {
    pub,
    pubEnc: enc
  });
};
KeyPair3.fromPrivate = function fromPrivate3(ec6, priv, enc) {
  if (priv instanceof KeyPair3)
    return priv;
  return new KeyPair3(ec6, {
    priv,
    privEnc: enc
  });
};
KeyPair3.prototype.validate = function validate12() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair3.prototype.getPublic = function getPublic3(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair3.prototype.getPrivate = function getPrivate3(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair3.prototype._importPrivate = function _importPrivate3(key6, enc) {
  this.priv = new import_bn12.default(key6, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair3.prototype._importPublic = function _importPublic3(key6, enc) {
  if (key6.x || key6.y) {
    if (this.ec.curve.type === "mont") {
      assert$33(key6.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$33(key6.x && key6.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key6.x, key6.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key6, enc);
};
KeyPair3.prototype.derive = function derive3(pub) {
  if (!pub.validate()) {
    assert$33(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair3.prototype.sign = function sign5(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair3.prototype.verify = function verify5(msg, signature6) {
  return this.ec.verify(msg, signature6, this);
};
KeyPair3.prototype.inspect = function inspect9() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$43 = utils_1$13.assert;
function Signature3(options, enc) {
  if (options instanceof Signature3)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$43(options.r && options.s, "Signature without r or s");
  this.r = new import_bn12.default(options.r, 16);
  this.s = new import_bn12.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature3 = Signature3;
function Position3() {
  this.place = 0;
}
function getLength3(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding3(buf) {
  var i2 = 0;
  var len = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
Signature3.prototype._importDER = function _importDER3(data, enc) {
  data = utils_1$13.toArray(data, enc);
  var p2 = new Position3();
  if (data[p2.place++] !== 48) {
    return false;
  }
  var len = getLength3(data, p2);
  if (len === false) {
    return false;
  }
  if (len + p2.place !== data.length) {
    return false;
  }
  if (data[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength3(data, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength3(data, p2);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p2.place) {
    return false;
  }
  var s2 = data.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn12.default(r2);
  this.s = new import_bn12.default(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength3(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature3.prototype.toDER = function toDER3(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding3(r2);
  s2 = rmPadding3(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength3(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength3(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength3(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$13.encode(res, enc);
};
var rand3 = function() {
  throw new Error("unsupported");
};
var assert$53 = utils_1$13.assert;
function EC3(options) {
  if (!(this instanceof EC3))
    return new EC3(options);
  if (typeof options === "string") {
    assert$53(Object.prototype.hasOwnProperty.call(curves_13, options), "Unknown curve " + options);
    options = curves_13[options];
  }
  if (options instanceof curves_13.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec3 = EC3;
EC3.prototype.keyPair = function keyPair3(options) {
  return new key3(this, options);
};
EC3.prototype.keyFromPrivate = function keyFromPrivate3(priv, enc) {
  return key3.fromPrivate(this, priv, enc);
};
EC3.prototype.keyFromPublic = function keyFromPublic3(pub, enc) {
  return key3.fromPublic(this, pub, enc);
};
EC3.prototype.genKeyPair = function genKeyPair3(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg3({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand3(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn12.default(2));
  for (; ; ) {
    var priv = new import_bn12.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC3.prototype._truncateToN = function _truncateToN3(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC3.prototype.sign = function sign6(msg, key6, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key6 = this.keyFromPrivate(key6, enc);
  msg = this._truncateToN(new import_bn12.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key6.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg3({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn12.default(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new import_bn12.default(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k2.invm(this.n).mul(r2.mul(key6.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature3({ r: r2, s: s2, recoveryParam });
  }
};
EC3.prototype.verify = function verify6(msg, signature$1, key6, enc) {
  msg = this._truncateToN(new import_bn12.default(msg, 16));
  key6 = this.keyFromPublic(key6, enc);
  signature$1 = new signature3(signature$1, "hex");
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key6.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key6.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC3.prototype.recoverPubKey = function(msg, signature$1, j2, enc) {
  assert$53((3 & j2) === j2, "The recovery param is more than two bits");
  signature$1 = new signature3(signature$1, enc);
  var n = this.n;
  var e = new import_bn12.default(msg);
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s22 = s2.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r2, s22);
};
EC3.prototype.getKeyRecoveryParam = function(e, signature$1, Q2, enc) {
  signature$1 = new signature3(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i2 = 0; i2 < 4; i2++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i2);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i2;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_13 = createCommonjsModule3(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$13;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_13;
  elliptic.curves = curves_13;
  elliptic.ec = ec3;
  elliptic.eddsa = null;
});
var EC$13 = elliptic_13.ec;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/signing-key/lib.esm/_version.js
init_define_process_env();
var version87 = "signing-key/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger105 = new Logger13(version87);

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/transactions/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/transactions/lib.esm/_version.js
init_define_process_env();
var version88 = "transactions/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/transactions/lib.esm/index.js
var logger106 = new Logger13(version88);
var TransactionTypes3;
(function(TransactionTypes5) {
  TransactionTypes5[TransactionTypes5["legacy"] = 0] = "legacy";
  TransactionTypes5[TransactionTypes5["eip2930"] = 1] = "eip2930";
  TransactionTypes5[TransactionTypes5["eip1559"] = 2] = "eip1559";
})(TransactionTypes3 || (TransactionTypes3 = {}));

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/id.js
init_define_process_env();
function id6(text2) {
  return keccak2568(toUtf8Bytes6(text2));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/namehash.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/_version.js
init_define_process_env();
var version89 = "hash/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger107 = new Logger13(version89);
var Zeros6 = new Uint8Array(32);
Zeros6.fill(0);
var Partition6 = new RegExp("^((.*)\\.)?([^.]+)$");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/message.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/lib.esm/typed-data.js
init_define_process_env();
var logger108 = new Logger13(version89);
var padding6 = new Uint8Array(32);
padding6.fill(0);
var NegativeOne22 = BigNumber9.from(-1);
var Zero22 = BigNumber9.from(0);
var One13 = BigNumber9.from(1);
var MaxUint25613 = BigNumber9.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var hexTrue6 = hexZeroPad10(One13.toHexString(), 32);
var hexFalse6 = hexZeroPad10(Zero22.toHexString(), 32);
function checkString6(key6) {
  return function(value) {
    if (typeof value !== "string") {
      logger108.throwArgumentError(`invalid domain value for ${JSON.stringify(key6)}`, `domain.${key6}`, value);
    }
    return value;
  };
}
var domainChecks6 = {
  name: checkString6("name"),
  version: checkString6("version"),
  chainId: function(value) {
    try {
      return BigNumber9.from(value).toString();
    } catch (error) {
    }
    return logger108.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress7(value).toLowerCase();
    } catch (error) {
    }
    return logger108.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify12(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify10(bytes);
    } catch (error) {
    }
    return logger108.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/lib.esm/_version.js
init_define_process_env();
var version90 = "wordlists/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist3 = false;
var logger109 = new Logger13(version90);
var Wordlist3 = class {
  constructor(locale) {
    logger109.checkAbstract(new.target, Wordlist3);
    defineReadOnly8(this, "locale", locale);
  }
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  join(words4) {
    return words4.join(" ");
  }
  static check(wordlist4) {
    const words4 = [];
    for (let i2 = 0; i2 < 2048; i2++) {
      const word = wordlist4.getWord(i2);
      if (i2 !== wordlist4.getWordIndex(word)) {
        return "0x";
      }
      words4.push(word);
    }
    return id6(words4.join("\n") + "\n");
  }
  static register(lang, name2) {
    if (!name2) {
      name2 = lang.locale;
    }
    if (exportWordlist3) {
      try {
        const anyGlobal4 = window;
        if (anyGlobal4._ethers && anyGlobal4._ethers.wordlists) {
          if (!anyGlobal4._ethers.wordlists[name2]) {
            defineReadOnly8(anyGlobal4._ethers.wordlists, name2, lang);
          }
        }
      } catch (error) {
      }
    }
  }
};

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
init_define_process_env();
var words3 = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
var wordlist3 = null;
function loadWords3(lang) {
  if (wordlist3 != null) {
    return;
  }
  wordlist3 = words3.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist3.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist3 = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var LangEn3 = class extends Wordlist3 {
  constructor() {
    super("en");
  }
  getWord(index) {
    loadWords3(this);
    return wordlist3[index];
  }
  getWordIndex(word) {
    loadWords3(this);
    return wordlist3.indexOf(word);
  }
};
var langEn3 = new LangEn3();
Wordlist3.register(langEn3);

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hdnode/lib.esm/_version.js
init_define_process_env();
var version91 = "hdnode/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hdnode/lib.esm/index.js
var logger110 = new Logger13(version91);
var N2 = BigNumber9.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var MasterSecret2 = toUtf8Bytes6("Bitcoin seed");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/random/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/random/lib.esm/random.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/random/lib.esm/_version.js
init_define_process_env();
var version92 = "random/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/random/lib.esm/random.js
var logger111 = new Logger13(version92);
function getGlobal2() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal2 = getGlobal2();
var crypto2 = anyGlobal2.crypto || anyGlobal2.msCrypto;
if (!crypto2 || !crypto2.getRandomValues) {
  logger111.warn("WARNING: Missing strong random number source");
  crypto2 = {
    getRandomValues: function(buffer2) {
      return logger111.throwError("no secure random source avaialble", Logger13.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/random/lib.esm/shuffle.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
var logger112 = new Logger13(version86);

// node_modules/@web3-onboard/core/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha38 = __toESM(require_sha3());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version93 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors14 = false;
var _censorErrors14 = false;
var LogLevels14 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel14 = LogLevels14["default"];
var _globalLogger14 = null;
function _checkNormalize14() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError14 = _checkNormalize14();
var LogLevel14;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel14 || (LogLevel14 = {}));
var ErrorCode14;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode14 || (ErrorCode14 = {}));
var HEX14 = "0123456789abcdef";
var Logger14 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels14[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel14 > LogLevels14[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger14.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger14.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger14.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors14) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger14.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX14[value[i2] >> 4];
            hex += HEX14[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode14.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode14.CALL_EXCEPTION:
      case ErrorCode14.INSUFFICIENT_FUNDS:
      case ErrorCode14.MISSING_NEW:
      case ErrorCode14.NONCE_EXPIRED:
      case ErrorCode14.REPLACEMENT_UNDERPRICED:
      case ErrorCode14.TRANSACTION_REPLACED:
      case ErrorCode14.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger14.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError14) {
      this.throwError("platform missing String.prototype.normalize", Logger14.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError14
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger14.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger14.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger14.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger14.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger14.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger14.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger14.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger14) {
      _globalLogger14 = new Logger14(version93);
    }
    return _globalLogger14;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger14.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors14) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger14.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors14 = !!censorship;
    _permanentCensorErrors14 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels14[logLevel.toLowerCase()];
    if (level == null) {
      Logger14.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel14 = level;
  }
  static from(version130) {
    return new Logger14(version130);
  }
};
Logger14.errors = ErrorCode14;
Logger14.levels = LogLevel14;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version94 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger113 = new Logger14(version94);
function isHexable13(value) {
  return !!value.toHexString;
}
function addSlice13(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice13(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger13(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes13(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger13(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger13(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify13(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger113.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice13(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable13(value)) {
    value = value.toHexString();
  }
  if (isHexString13(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger113.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice13(new Uint8Array(result));
  }
  if (isBytes13(value)) {
    return addSlice13(new Uint8Array(value));
  }
  return logger113.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString13(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/keccak256/lib.esm/index.js
function keccak2569(data) {
  return "0x" + import_js_sha38.default.keccak_256(arrayify13(data));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version95 = "logger/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors15 = false;
var _censorErrors15 = false;
var LogLevels15 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel15 = LogLevels15["default"];
var _globalLogger15 = null;
function _checkNormalize15() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError15 = _checkNormalize15();
var LogLevel15;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel15 || (LogLevel15 = {}));
var ErrorCode15;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode15 || (ErrorCode15 = {}));
var HEX15 = "0123456789abcdef";
var Logger15 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels15[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel15 > LogLevels15[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger15.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger15.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger15.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors15) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger15.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX15[value[i2] >> 4];
            hex += HEX15[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger15.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError15) {
      this.throwError("platform missing String.prototype.normalize", Logger15.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError15
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger15.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger15.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger15.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger15.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger15.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger15.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger15.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger15) {
      _globalLogger15 = new Logger15(version95);
    }
    return _globalLogger15;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger15.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors15) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger15.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors15 = !!censorship;
    _permanentCensorErrors15 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels15[logLevel.toLowerCase()];
    if (level == null) {
      Logger15.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel15 = level;
  }
  static from(version130) {
    return new Logger15(version130);
  }
};
Logger15.errors = ErrorCode15;
Logger15.levels = LogLevel15;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/sha2/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/sha2/lib.esm/sha2.js
init_define_process_env();
var import_hash13 = __toESM(require_hash());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/sha2/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/sha2/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version96 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/sha2/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors16 = false;
var _censorErrors16 = false;
var LogLevels16 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel16 = LogLevels16["default"];
var _globalLogger16 = null;
function _checkNormalize16() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError16 = _checkNormalize16();
var LogLevel16;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel16 || (LogLevel16 = {}));
var ErrorCode16;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode16 || (ErrorCode16 = {}));
var HEX16 = "0123456789abcdef";
var Logger16 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels16[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel16 > LogLevels16[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger16.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger16.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger16.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors16) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger16.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX16[value[i2] >> 4];
            hex += HEX16[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode16.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode16.CALL_EXCEPTION:
      case ErrorCode16.INSUFFICIENT_FUNDS:
      case ErrorCode16.MISSING_NEW:
      case ErrorCode16.NONCE_EXPIRED:
      case ErrorCode16.REPLACEMENT_UNDERPRICED:
      case ErrorCode16.TRANSACTION_REPLACED:
      case ErrorCode16.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger16.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError16) {
      this.throwError("platform missing String.prototype.normalize", Logger16.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError16
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger16.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger16.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger16.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger16.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger16.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger16.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger16.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger16) {
      _globalLogger16 = new Logger16(version96);
    }
    return _globalLogger16;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger16.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors16) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger16.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors16 = !!censorship;
    _permanentCensorErrors16 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels16[logLevel.toLowerCase()];
    if (level == null) {
      Logger16.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel16 = level;
  }
  static from(version130) {
    return new Logger16(version130);
  }
};
Logger16.errors = ErrorCode16;
Logger16.levels = LogLevel16;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version97 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger114 = new Logger16(version97);
function isHexable14(value) {
  return !!value.toHexString;
}
function addSlice14(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice14(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger14(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes14(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger14(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger14(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify14(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger114.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice14(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable14(value)) {
    value = value.toHexString();
  }
  if (isHexString14(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger114.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice14(new Uint8Array(result));
  }
  if (isBytes14(value)) {
    return addSlice14(new Uint8Array(value));
  }
  return logger114.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString14(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/sha2/lib.esm/types.js
init_define_process_env();
var SupportedAlgorithm4;
(function(SupportedAlgorithm5) {
  SupportedAlgorithm5["sha256"] = "sha256";
  SupportedAlgorithm5["sha512"] = "sha512";
})(SupportedAlgorithm4 || (SupportedAlgorithm4 = {}));

// node_modules/@web3-onboard/core/node_modules/@ethersproject/sha2/lib.esm/_version.js
init_define_process_env();
var version98 = "sha2/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/sha2/lib.esm/sha2.js
var logger115 = new Logger16(version98);
function ripemd1604(data) {
  return "0x" + import_hash13.default.ripemd160().update(arrayify14(data)).digest("hex");
}
function sha2565(data) {
  return "0x" + import_hash13.default.sha256().update(arrayify14(data)).digest("hex");
}
function sha5124(data) {
  return "0x" + import_hash13.default.sha512().update(arrayify14(data)).digest("hex");
}
function computeHmac4(algorithm, key6, data) {
  if (!SupportedAlgorithm4[algorithm]) {
    logger115.throwError("unsupported algorithm " + algorithm, Logger16.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + import_hash13.default.hmac(import_hash13.default[algorithm], arrayify14(key6)).update(arrayify14(data)).digest("hex");
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/random/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/random/lib.esm/random.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/random/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/random/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/random/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version99 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/random/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors17 = false;
var _censorErrors17 = false;
var LogLevels17 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel17 = LogLevels17["default"];
var _globalLogger17 = null;
function _checkNormalize17() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError17 = _checkNormalize17();
var LogLevel17;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel17 || (LogLevel17 = {}));
var ErrorCode17;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode17 || (ErrorCode17 = {}));
var HEX17 = "0123456789abcdef";
var Logger17 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels17[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel17 > LogLevels17[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger17.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger17.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger17.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors17) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger17.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX17[value[i2] >> 4];
            hex += HEX17[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode17.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode17.CALL_EXCEPTION:
      case ErrorCode17.INSUFFICIENT_FUNDS:
      case ErrorCode17.MISSING_NEW:
      case ErrorCode17.NONCE_EXPIRED:
      case ErrorCode17.REPLACEMENT_UNDERPRICED:
      case ErrorCode17.TRANSACTION_REPLACED:
      case ErrorCode17.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger17.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError17) {
      this.throwError("platform missing String.prototype.normalize", Logger17.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError17
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger17.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger17.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger17.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger17.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger17.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger17.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger17.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger17) {
      _globalLogger17 = new Logger17(version99);
    }
    return _globalLogger17;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger17.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors17) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger17.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors17 = !!censorship;
    _permanentCensorErrors17 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels17[logLevel.toLowerCase()];
    if (level == null) {
      Logger17.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel17 = level;
  }
  static from(version130) {
    return new Logger17(version130);
  }
};
Logger17.errors = ErrorCode17;
Logger17.levels = LogLevel17;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/random/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version100 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/random/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger116 = new Logger17(version100);
function isHexable15(value) {
  return !!value.toHexString;
}
function addSlice15(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice15(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger15(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes15(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger15(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger15(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify15(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger116.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice15(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable15(value)) {
    value = value.toHexString();
  }
  if (isHexString15(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger116.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice15(new Uint8Array(result));
  }
  if (isBytes15(value)) {
    return addSlice15(new Uint8Array(value));
  }
  return logger116.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString15(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/random/lib.esm/_version.js
init_define_process_env();
var version101 = "random/5.5.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/random/lib.esm/random.js
var logger117 = new Logger17(version101);
function getGlobal3() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal3 = getGlobal3();
var crypto3 = anyGlobal3.crypto || anyGlobal3.msCrypto;
if (!crypto3 || !crypto3.getRandomValues) {
  logger117.warn("WARNING: Missing strong random number source");
  crypto3 = {
    getRandomValues: function(buffer2) {
      return logger117.throwError("no secure random source avaialble", Logger17.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}
function randomBytes3(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger117.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto3.getRandomValues(result);
  return arrayify15(result);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/random/lib.esm/shuffle.js
init_define_process_env();
function shuffled3(array) {
  array = array.slice();
  for (let i2 = array.length - 1; i2 > 0; i2--) {
    const j2 = Math.floor(Math.random() * (i2 + 1));
    const tmp = array[i2];
    array[i2] = array[j2];
    array[j2] = tmp;
  }
  return array;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/properties/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/properties/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version102 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/properties/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors18 = false;
var _censorErrors18 = false;
var LogLevels18 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel18 = LogLevels18["default"];
var _globalLogger18 = null;
function _checkNormalize18() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError18 = _checkNormalize18();
var LogLevel18;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel18 || (LogLevel18 = {}));
var ErrorCode18;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode18 || (ErrorCode18 = {}));
var HEX18 = "0123456789abcdef";
var Logger18 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels18[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel18 > LogLevels18[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger18.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger18.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger18.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors18) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger18.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX18[value[i2] >> 4];
            hex += HEX18[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode18.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode18.CALL_EXCEPTION:
      case ErrorCode18.INSUFFICIENT_FUNDS:
      case ErrorCode18.MISSING_NEW:
      case ErrorCode18.NONCE_EXPIRED:
      case ErrorCode18.REPLACEMENT_UNDERPRICED:
      case ErrorCode18.TRANSACTION_REPLACED:
      case ErrorCode18.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger18.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError18) {
      this.throwError("platform missing String.prototype.normalize", Logger18.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError18
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger18.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger18.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger18.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger18.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger18.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger18.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger18.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger18) {
      _globalLogger18 = new Logger18(version102);
    }
    return _globalLogger18;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger18.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors18) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger18.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors18 = !!censorship;
    _permanentCensorErrors18 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels18[logLevel.toLowerCase()];
    if (level == null) {
      Logger18.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel18 = level;
  }
  static from(version130) {
    return new Logger18(version130);
  }
};
Logger18.errors = ErrorCode18;
Logger18.levels = LogLevel18;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version103 = "properties/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/properties/lib.esm/index.js
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger118 = new Logger18(version103);
function defineReadOnly9(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic3(ctor, key6) {
  for (let i2 = 0; i2 < 32; i2++) {
    if (ctor[key6]) {
      return ctor[key6];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties3(object) {
  return __awaiter18(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key6) => {
      const value = object[key6];
      return Promise.resolve(value).then((v2) => ({ key: key6, value: v2 }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties4(object, properties) {
  if (!object || typeof object !== "object") {
    logger118.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key6) => {
    if (!properties[key6]) {
      logger118.throwArgumentError("invalid object key - " + key6, "transaction:" + key6, object);
    }
  });
}
function shallowCopy8(object) {
  const result = {};
  for (const key6 in object) {
    result[key6] = object[key6];
  }
  return result;
}
var opaque4 = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen4(object) {
  if (object === void 0 || object === null || opaque4[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i2 = 0; i2 < keys.length; i2++) {
      let value = null;
      try {
        value = object[keys[i2]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen4(value)) {
        return false;
      }
    }
    return true;
  }
  return logger118.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy4(object) {
  if (_isFrozen4(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy7(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key6 in object) {
      const value = object[key6];
      if (value === void 0) {
        continue;
      }
      defineReadOnly9(result, key6, deepCopy7(value));
    }
    return result;
  }
  return logger118.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy7(object) {
  return _deepCopy4(object);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/rlp/lib.esm/index.js
var lib_exports7 = {};
__export(lib_exports7, {
  decode: () => decode6,
  encode: () => encode13
});
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/rlp/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/rlp/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version104 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/rlp/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors19 = false;
var _censorErrors19 = false;
var LogLevels19 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel19 = LogLevels19["default"];
var _globalLogger19 = null;
function _checkNormalize19() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError19 = _checkNormalize19();
var LogLevel19;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel19 || (LogLevel19 = {}));
var ErrorCode19;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode19 || (ErrorCode19 = {}));
var HEX19 = "0123456789abcdef";
var Logger19 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels19[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel19 > LogLevels19[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger19.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger19.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger19.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors19) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger19.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX19[value[i2] >> 4];
            hex += HEX19[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode19.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode19.CALL_EXCEPTION:
      case ErrorCode19.INSUFFICIENT_FUNDS:
      case ErrorCode19.MISSING_NEW:
      case ErrorCode19.NONCE_EXPIRED:
      case ErrorCode19.REPLACEMENT_UNDERPRICED:
      case ErrorCode19.TRANSACTION_REPLACED:
      case ErrorCode19.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger19.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError19) {
      this.throwError("platform missing String.prototype.normalize", Logger19.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError19
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger19.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger19.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger19.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger19.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger19.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger19.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger19.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger19) {
      _globalLogger19 = new Logger19(version104);
    }
    return _globalLogger19;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger19.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors19) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger19.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors19 = !!censorship;
    _permanentCensorErrors19 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels19[logLevel.toLowerCase()];
    if (level == null) {
      Logger19.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel19 = level;
  }
  static from(version130) {
    return new Logger19(version130);
  }
};
Logger19.errors = ErrorCode19;
Logger19.levels = LogLevel19;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version105 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger119 = new Logger19(version105);
function isHexable16(value) {
  return !!value.toHexString;
}
function addSlice16(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice16(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike9(value) {
  return isHexString16(value) && !(value.length % 2) || isBytes16(value);
}
function isInteger16(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes16(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger16(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger16(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify16(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger119.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice16(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable16(value)) {
    value = value.toHexString();
  }
  if (isHexString16(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger119.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice16(new Uint8Array(result));
  }
  if (isBytes16(value)) {
    return addSlice16(new Uint8Array(value));
  }
  return logger119.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString16(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters11 = "0123456789abcdef";
function hexlify11(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger119.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters11[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable16(value)) {
    return value.toHexString();
  }
  if (isHexString16(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger119.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes16(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters11[(v2 & 240) >> 4] + HexCharacters11[v2 & 15];
    }
    return result;
  }
  return logger119.throwArgumentError("invalid hexlify value", "value", value);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version106 = "rlp/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger120 = new Logger19(version106);
function arrayifyInteger3(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger2(data, offset, length) {
  let result = 0;
  for (let i2 = 0; i2 < length; i2++) {
    result = result * 256 + data[offset + i2];
  }
  return result;
}
function _encode6(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode6(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger3(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike9(object)) {
    logger120.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify16(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger3(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode13(object) {
  return hexlify11(_encode6(object));
}
function _decodeChildren2(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode2(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger120.throwError("child data too short", Logger19.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode2(data, offset) {
  if (data.length === 0) {
    logger120.throwError("data too short", Logger19.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger120.throwError("data short segment too short", Logger19.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger2(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger120.throwError("data long segment too short", Logger19.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren2(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger120.throwError("data array too short", Logger19.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren2(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger120.throwError("data array too short", Logger19.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger2(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger120.throwError("data array too short", Logger19.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify11(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger120.throwError("data too short", Logger19.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify11(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify11(data[offset]) };
}
function decode6(data) {
  const bytes = arrayify16(data);
  const decoded = _decode2(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger120.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
init_define_process_env();
var import_bn13 = __toESM(require_bn());
var import_hash14 = __toESM(require_hash());
function createCommonjsModule4(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base6) {
      return commonjsRequire4(path, base6 === void 0 || base6 === null ? module.path : base6);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire4() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert4 = assert4;
function assert4(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert4.equal = function assertEqual4(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_14 = createCommonjsModule4(function(module, exports) {
  "use strict";
  var utils = exports;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray2;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex13(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero2(msg[i2].toString(16));
    return res;
  }
  utils.toHex = toHex13;
  utils.encode = function encode18(arr, enc) {
    if (enc === "hex")
      return toHex13(arr);
    else
      return arr;
  };
});
var utils_1$14 = createCommonjsModule4(function(module, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert4;
  utils.toArray = utils_14.toArray;
  utils.zero2 = utils_14.zero2;
  utils.toHex = utils_14.toHex;
  utils.encode = utils_14.encode;
  function getNAF6(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i2 = 0; i2 < naf.length; i2++) {
      var z;
      var mod = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k2.isubn(z);
      } else {
        z = 0;
      }
      naf[i2] = z;
      k2.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF6;
  function getJSF6(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF6;
  function cachedProperty(obj, name2, computer) {
    var key6 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key6] !== void 0 ? this[key6] : this[key6] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn13.default(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});
var getNAF4 = utils_1$14.getNAF;
var getJSF4 = utils_1$14.getJSF;
var assert$14 = utils_1$14.assert;
function BaseCurve4(type, conf) {
  this.type = type;
  this.p = new import_bn13.default(conf.p, 16);
  this.red = conf.prime ? import_bn13.default.red(conf.prime) : import_bn13.default.mont(this.p);
  this.zero = new import_bn13.default(0).toRed(this.red);
  this.one = new import_bn13.default(1).toRed(this.red);
  this.two = new import_bn13.default(2).toRed(this.red);
  this.n = conf.n && new import_bn13.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base4 = BaseCurve4;
BaseCurve4.prototype.point = function point7() {
  throw new Error("Not implemented");
};
BaseCurve4.prototype.validate = function validate13() {
  throw new Error("Not implemented");
};
BaseCurve4.prototype._fixedNafMul = function _fixedNafMul4(p2, k2) {
  assert$14(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF4(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i2 = I2; i2 > 0; i2--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i2)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i2)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve4.prototype._wnafMul = function _wnafMul4(p2, k2) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF4(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i2 = naf.length - 1; i2 >= 0; i2--) {
    for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
      l2++;
    if (i2 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i2 < 0)
      break;
    var z = naf[i2];
    assert$14(z !== 0);
    if (p2.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve4.prototype._wnafMulAdd = function _wnafMulAdd4(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i2;
  var j2;
  var p2;
  for (i2 = 0; i2 < len; i2++) {
    p2 = points[i2];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i2] = nafPoints.wnd;
    wnd[i2] = nafPoints.points;
  }
  for (i2 = len - 1; i2 >= 1; i2 -= 2) {
    var a2 = i2 - 1;
    var b2 = i2;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF4(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF4(coeffs[b2], wndWidth[b2], this._bitLength);
      max2 = Math.max(naf[a2].length, max2);
      max2 = Math.max(naf[b2].length, max2);
      continue;
    }
    var comb = [
      points[a2],
      null,
      null,
      points[b2]
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF4(coeffs[a2], coeffs[b2]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a2] = new Array(max2);
    naf[b2] = new Array(max2);
    for (j2 = 0; j2 < max2; j2++) {
      var ja = jsf[0][j2] | 0;
      var jb = jsf[1][j2] | 0;
      naf[a2][j2] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i2 = max2; i2 >= 0; i2--) {
    var k2 = 0;
    while (i2 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len; j2++) {
        tmp[j2] = naf[j2][i2] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i2--;
    }
    if (i2 >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i2 < 0)
      break;
    for (j2 = 0; j2 < len; j2++) {
      var z = tmp[j2];
      p2;
      if (z === 0)
        continue;
      else if (z > 0)
        p2 = wnd[j2][z - 1 >> 1];
      else if (z < 0)
        p2 = wnd[j2][-z - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i2 = 0; i2 < len; i2++)
    wnd[i2] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint4(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve4.BasePoint = BasePoint4;
BasePoint4.prototype.eq = function eq10() {
  throw new Error("Not implemented");
};
BasePoint4.prototype.validate = function validate14() {
  return this.curve.validate(this);
};
BaseCurve4.prototype.decodePoint = function decodePoint4(bytes, enc) {
  bytes = utils_1$14.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$14(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$14(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint4.prototype.encodeCompressed = function encodeCompressed4(enc) {
  return this.encode(enc, true);
};
BasePoint4.prototype._encode = function _encode7(compact) {
  var len = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len));
};
BasePoint4.prototype.encode = function encode14(enc, compact) {
  return utils_1$14.encode(this._encode(compact), enc);
};
BasePoint4.prototype.precompute = function precompute4(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint4.prototype._hasDoubles = function _hasDoubles4(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
};
BasePoint4.prototype._getDoubles = function _getDoubles4(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i2 = 0; i2 < power; i2 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint4.prototype._getNAFPoints = function _getNAFPoints4(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl11 = max2 === 1 ? null : this.dbl();
  for (var i2 = 1; i2 < max2; i2++)
    res[i2] = res[i2 - 1].add(dbl11);
  return {
    wnd,
    points: res
  };
};
BasePoint4.prototype._getBeta = function _getBeta7() {
  return null;
};
BasePoint4.prototype.dblp = function dblp7(k2) {
  var r2 = this;
  for (var i2 = 0; i2 < k2; i2++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser4 = createCommonjsModule4(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$24 = utils_1$14.assert;
function ShortCurve4(conf) {
  base4.call(this, "short", conf);
  this.a = new import_bn13.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn13.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser4(ShortCurve4, base4);
var short_14 = ShortCurve4;
ShortCurve4.prototype._getEndomorphism = function _getEndomorphism4(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn13.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn13.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$24(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn13.default(vec.a, 16),
        b: new import_bn13.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve4.prototype._getEndoRoots = function _getEndoRoots4(num) {
  var red = num === this.p ? this.red : import_bn13.default.mont(num);
  var tinv = new import_bn13.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new import_bn13.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve4.prototype._getEndoBasis = function _getEndoBasis4(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new import_bn13.default(1);
  var y1 = new import_bn13.default(0);
  var x2 = new import_bn13.default(0);
  var y2 = new import_bn13.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i2 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r2 = v2.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i2 === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y;
  }
  a2 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve4.prototype._endoSplit = function _endoSplit4(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve4.prototype.pointFromX = function pointFromX4(x2, odd) {
  x2 = new import_bn13.default(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x2, y);
};
ShortCurve4.prototype.validate = function validate15(point11) {
  if (point11.inf)
    return true;
  var x2 = point11.x;
  var y = point11.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve4.prototype._endoWnafMulAdd = function _endoWnafMulAdd4(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i2 = 0; i2 < points.length; i2++) {
    var split = this._endoSplit(coeffs[i2]);
    var p2 = points[i2];
    var beta = p2._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i2 * 2] = p2;
    npoints[i2 * 2 + 1] = beta;
    ncoeffs[i2 * 2] = split.k1;
    ncoeffs[i2 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
  for (var j2 = 0; j2 < i2 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point4(curve, x2, y, isRed) {
  base4.BasePoint.call(this, curve, "affine");
  if (x2 === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn13.default(x2, 16);
    this.y = new import_bn13.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser4(Point4, base4.BasePoint);
ShortCurve4.prototype.point = function point8(x2, y, isRed) {
  return new Point4(this, x2, y, isRed);
};
ShortCurve4.prototype.pointFromJSON = function pointFromJSON4(obj, red) {
  return Point4.fromJSON(this, obj, red);
};
Point4.prototype._getBeta = function _getBeta8() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p2) {
      return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point4.prototype.toJSON = function toJSON4() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point4.fromJSON = function fromJSON4(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point4.prototype.inspect = function inspect10() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point4.prototype.isInfinity = function isInfinity7() {
  return this.inf;
};
Point4.prototype.add = function add7(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point4.prototype.dbl = function dbl7() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point4.prototype.getX = function getX4() {
  return this.x.fromRed();
};
Point4.prototype.getY = function getY4() {
  return this.y.fromRed();
};
Point4.prototype.mul = function mul7(k2) {
  k2 = new import_bn13.default(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
};
Point4.prototype.mulAdd = function mulAdd4(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point4.prototype.jmulAdd = function jmulAdd4(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point4.prototype.eq = function eq11(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point4.prototype.neg = function neg7(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point4.prototype.toJ = function toJ4() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint4(curve, x2, y, z) {
  base4.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn13.default(0);
  } else {
    this.x = new import_bn13.default(x2, 16);
    this.y = new import_bn13.default(y, 16);
    this.z = new import_bn13.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser4(JPoint4, base4.BasePoint);
ShortCurve4.prototype.jpoint = function jpoint4(x2, y, z) {
  return new JPoint4(this, x2, y, z);
};
JPoint4.prototype.toP = function toP4() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint4.prototype.neg = function neg8() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint4.prototype.add = function add8(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint4.prototype.mixedAdd = function mixedAdd4(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint4.prototype.dblp = function dblp8(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i2;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i2 = 0; i2 < pow; i2++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i2 = 0; i2 < pow; i2++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i2 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint4.prototype.dbl = function dbl8() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint4.prototype._zeroDbl = function _zeroDbl4() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e = a2.redAdd(a2).redIAdd(a2);
    var f2 = e.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint4.prototype._threeDbl = function _threeDbl4() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint4.prototype._dbl = function _dbl4() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint4.prototype.trpl = function trpl4() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee2 = e.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e).redSqr().redISub(mm).redISub(ee2).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint4.prototype.mul = function mul8(k2, kbase) {
  k2 = new import_bn13.default(k2, kbase);
  return this.curve._wnafMul(this, k2);
};
JPoint4.prototype.eq = function eq12(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint4.prototype.eqXToP = function eqXToP4(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint4.prototype.inspect = function inspect11() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint4.prototype.isInfinity = function isInfinity8() {
  return this.z.cmpn(0) === 0;
};
var curve_14 = createCommonjsModule4(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base4;
  curve.short = short_14;
  curve.mont = null;
  curve.edwards = null;
});
var curves_14 = createCommonjsModule4(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert6 = utils_1$14.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_14.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_14.edwards(options);
    else
      this.curve = new curve_14.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert6(this.g.validate(), "Invalid curve");
    assert6(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash14.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash14.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash14.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash14.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash14.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash14.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash14.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash14.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG4(options) {
  if (!(this instanceof HmacDRBG4))
    return new HmacDRBG4(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_14.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_14.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_14.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert4(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg4 = HmacDRBG4;
HmacDRBG4.prototype._init = function init4(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG4.prototype._hmac = function hmac4() {
  return new import_hash14.default.hmac(this.hash, this.K);
};
HmacDRBG4.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG4.prototype.reseed = function reseed4(entropy, entropyEnc, add11, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add11;
    add11 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_14.toArray(entropy, entropyEnc);
  add11 = utils_14.toArray(add11, addEnc);
  minimalisticAssert4(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add11 || []));
  this._reseed = 1;
};
HmacDRBG4.prototype.generate = function generate5(len, enc, add11, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add11;
    add11 = enc;
    enc = null;
  }
  if (add11) {
    add11 = utils_14.toArray(add11, addEnc || "hex");
    this._update(add11);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add11);
  this._reseed++;
  return utils_14.encode(res, enc);
};
var assert$34 = utils_1$14.assert;
function KeyPair4(ec6, options) {
  this.ec = ec6;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key4 = KeyPair4;
KeyPair4.fromPublic = function fromPublic4(ec6, pub, enc) {
  if (pub instanceof KeyPair4)
    return pub;
  return new KeyPair4(ec6, {
    pub,
    pubEnc: enc
  });
};
KeyPair4.fromPrivate = function fromPrivate4(ec6, priv, enc) {
  if (priv instanceof KeyPair4)
    return priv;
  return new KeyPair4(ec6, {
    priv,
    privEnc: enc
  });
};
KeyPair4.prototype.validate = function validate16() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair4.prototype.getPublic = function getPublic4(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair4.prototype.getPrivate = function getPrivate4(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair4.prototype._importPrivate = function _importPrivate4(key6, enc) {
  this.priv = new import_bn13.default(key6, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair4.prototype._importPublic = function _importPublic4(key6, enc) {
  if (key6.x || key6.y) {
    if (this.ec.curve.type === "mont") {
      assert$34(key6.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$34(key6.x && key6.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key6.x, key6.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key6, enc);
};
KeyPair4.prototype.derive = function derive4(pub) {
  if (!pub.validate()) {
    assert$34(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair4.prototype.sign = function sign7(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair4.prototype.verify = function verify7(msg, signature6) {
  return this.ec.verify(msg, signature6, this);
};
KeyPair4.prototype.inspect = function inspect12() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$44 = utils_1$14.assert;
function Signature4(options, enc) {
  if (options instanceof Signature4)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$44(options.r && options.s, "Signature without r or s");
  this.r = new import_bn13.default(options.r, 16);
  this.s = new import_bn13.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature4 = Signature4;
function Position4() {
  this.place = 0;
}
function getLength4(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding4(buf) {
  var i2 = 0;
  var len = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
Signature4.prototype._importDER = function _importDER4(data, enc) {
  data = utils_1$14.toArray(data, enc);
  var p2 = new Position4();
  if (data[p2.place++] !== 48) {
    return false;
  }
  var len = getLength4(data, p2);
  if (len === false) {
    return false;
  }
  if (len + p2.place !== data.length) {
    return false;
  }
  if (data[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength4(data, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength4(data, p2);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p2.place) {
    return false;
  }
  var s2 = data.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn13.default(r2);
  this.s = new import_bn13.default(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength4(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature4.prototype.toDER = function toDER4(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding4(r2);
  s2 = rmPadding4(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength4(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength4(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength4(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$14.encode(res, enc);
};
var rand4 = function() {
  throw new Error("unsupported");
};
var assert$54 = utils_1$14.assert;
function EC4(options) {
  if (!(this instanceof EC4))
    return new EC4(options);
  if (typeof options === "string") {
    assert$54(Object.prototype.hasOwnProperty.call(curves_14, options), "Unknown curve " + options);
    options = curves_14[options];
  }
  if (options instanceof curves_14.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec4 = EC4;
EC4.prototype.keyPair = function keyPair4(options) {
  return new key4(this, options);
};
EC4.prototype.keyFromPrivate = function keyFromPrivate4(priv, enc) {
  return key4.fromPrivate(this, priv, enc);
};
EC4.prototype.keyFromPublic = function keyFromPublic4(pub, enc) {
  return key4.fromPublic(this, pub, enc);
};
EC4.prototype.genKeyPair = function genKeyPair4(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg4({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand4(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn13.default(2));
  for (; ; ) {
    var priv = new import_bn13.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC4.prototype._truncateToN = function _truncateToN4(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC4.prototype.sign = function sign8(msg, key6, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key6 = this.keyFromPrivate(key6, enc);
  msg = this._truncateToN(new import_bn13.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key6.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg4({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn13.default(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new import_bn13.default(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k2.invm(this.n).mul(r2.mul(key6.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature4({ r: r2, s: s2, recoveryParam });
  }
};
EC4.prototype.verify = function verify8(msg, signature$1, key6, enc) {
  msg = this._truncateToN(new import_bn13.default(msg, 16));
  key6 = this.keyFromPublic(key6, enc);
  signature$1 = new signature4(signature$1, "hex");
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key6.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key6.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC4.prototype.recoverPubKey = function(msg, signature$1, j2, enc) {
  assert$54((3 & j2) === j2, "The recovery param is more than two bits");
  signature$1 = new signature4(signature$1, enc);
  var n = this.n;
  var e = new import_bn13.default(msg);
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s22 = s2.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r2, s22);
};
EC4.prototype.getKeyRecoveryParam = function(e, signature$1, Q2, enc) {
  signature$1 = new signature4(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i2 = 0; i2 < 4; i2++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i2);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i2;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_14 = createCommonjsModule4(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$14;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_14;
  elliptic.curves = curves_14;
  elliptic.ec = ec4;
  elliptic.eddsa = null;
});
var EC$14 = elliptic_14.ec;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version107 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors20 = false;
var _censorErrors20 = false;
var LogLevels20 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel20 = LogLevels20["default"];
var _globalLogger20 = null;
function _checkNormalize20() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError20 = _checkNormalize20();
var LogLevel20;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel20 || (LogLevel20 = {}));
var ErrorCode20;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode20 || (ErrorCode20 = {}));
var HEX20 = "0123456789abcdef";
var Logger20 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels20[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel20 > LogLevels20[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger20.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger20.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger20.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors20) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger20.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX20[value[i2] >> 4];
            hex += HEX20[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode20.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode20.CALL_EXCEPTION:
      case ErrorCode20.INSUFFICIENT_FUNDS:
      case ErrorCode20.MISSING_NEW:
      case ErrorCode20.NONCE_EXPIRED:
      case ErrorCode20.REPLACEMENT_UNDERPRICED:
      case ErrorCode20.TRANSACTION_REPLACED:
      case ErrorCode20.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger20.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError20) {
      this.throwError("platform missing String.prototype.normalize", Logger20.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError20
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger20.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger20.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger20.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger20.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger20.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger20.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger20.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger20) {
      _globalLogger20 = new Logger20(version107);
    }
    return _globalLogger20;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger20.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors20) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger20.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors20 = !!censorship;
    _permanentCensorErrors20 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels20[logLevel.toLowerCase()];
    if (level == null) {
      Logger20.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel20 = level;
  }
  static from(version130) {
    return new Logger20(version130);
  }
};
Logger20.errors = ErrorCode20;
Logger20.levels = LogLevel20;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version108 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger121 = new Logger20(version108);
function isHexable17(value) {
  return !!value.toHexString;
}
function addSlice17(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice17(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike10(value) {
  return isHexString17(value) && !(value.length % 2) || isBytes17(value);
}
function isInteger17(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes17(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger17(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger17(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify17(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger121.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice17(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable17(value)) {
    value = value.toHexString();
  }
  if (isHexString17(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger121.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice17(new Uint8Array(result));
  }
  if (isBytes17(value)) {
    return addSlice17(new Uint8Array(value));
  }
  return logger121.throwArgumentError("invalid arrayify value", "value", value);
}
function zeroPad4(value, length) {
  value = arrayify17(value);
  if (value.length > length) {
    logger121.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice17(result);
}
function isHexString17(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters12 = "0123456789abcdef";
function hexlify12(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger121.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters12[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable17(value)) {
    return value.toHexString();
  }
  if (isHexString17(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger121.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes17(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters12[(v2 & 240) >> 4] + HexCharacters12[v2 & 15];
    }
    return result;
  }
  return logger121.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad11(value, length) {
  if (typeof value !== "string") {
    value = hexlify12(value);
  } else if (!isHexString17(value)) {
    logger121.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger121.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature5(signature6) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike10(signature6)) {
    let bytes = arrayify17(signature6);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify12(bytes.slice(0, 32));
      result.s = hexlify12(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify12(bytes.slice(0, 32));
      result.s = hexlify12(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger121.throwArgumentError("invalid signature string", "signature", signature6);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger121.throwArgumentError("signature invalid v byte", "signature", signature6);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify12(bytes.slice(32, 64));
  } else {
    result.r = signature6.r;
    result.s = signature6.s;
    result.v = signature6.v;
    result.recoveryParam = signature6.recoveryParam;
    result._vs = signature6._vs;
    if (result._vs != null) {
      const vs2 = zeroPad4(arrayify17(result._vs), 32);
      result._vs = hexlify12(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger121.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature6);
      }
      vs2[0] &= 127;
      const s2 = hexlify12(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger121.throwArgumentError("signature v mismatch _vs", "signature", signature6);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger121.throwArgumentError("signature missing v and recoveryParam", "signature", signature6);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger121.throwArgumentError("signature recoveryParam mismatch v", "signature", signature6);
        }
      }
    }
    if (result.r == null || !isHexString17(result.r)) {
      logger121.throwArgumentError("signature missing or invalid r", "signature", signature6);
    } else {
      result.r = hexZeroPad11(result.r, 32);
    }
    if (result.s == null || !isHexString17(result.s)) {
      logger121.throwArgumentError("signature missing or invalid s", "signature", signature6);
    } else {
      result.s = hexZeroPad11(result.s, 32);
    }
    const vs = arrayify17(result.s);
    if (vs[0] >= 128) {
      logger121.throwArgumentError("signature s out of range", "signature", signature6);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify12(vs);
    if (result._vs) {
      if (!isHexString17(result._vs)) {
        logger121.throwArgumentError("signature invalid _vs", "signature", signature6);
      }
      result._vs = hexZeroPad11(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger121.throwArgumentError("signature _vs mismatch v and s", "signature", signature6);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version109 = "properties/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/properties/lib.esm/index.js
var logger122 = new Logger20(version109);
function defineReadOnly10(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/lib.esm/_version.js
init_define_process_env();
var version110 = "signing-key/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger123 = new Logger20(version110);
var _curve3 = null;
function getCurve3() {
  if (!_curve3) {
    _curve3 = new EC$14("secp256k1");
  }
  return _curve3;
}
var SigningKey4 = class {
  constructor(privateKey) {
    defineReadOnly10(this, "curve", "secp256k1");
    defineReadOnly10(this, "privateKey", hexlify12(privateKey));
    const keyPair6 = getCurve3().keyFromPrivate(arrayify17(this.privateKey));
    defineReadOnly10(this, "publicKey", "0x" + keyPair6.getPublic(false, "hex"));
    defineReadOnly10(this, "compressedPublicKey", "0x" + keyPair6.getPublic(true, "hex"));
    defineReadOnly10(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve3().keyFromPublic(arrayify17(this.publicKey));
    const p1 = getCurve3().keyFromPublic(arrayify17(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest) {
    const keyPair6 = getCurve3().keyFromPrivate(arrayify17(this.privateKey));
    const digestBytes = arrayify17(digest);
    if (digestBytes.length !== 32) {
      logger123.throwArgumentError("bad digest length", "digest", digest);
    }
    const signature6 = keyPair6.sign(digestBytes, { canonical: true });
    return splitSignature5({
      recoveryParam: signature6.recoveryParam,
      r: hexZeroPad11("0x" + signature6.r.toString(16), 32),
      s: hexZeroPad11("0x" + signature6.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair6 = getCurve3().keyFromPrivate(arrayify17(this.privateKey));
    const otherKeyPair = getCurve3().keyFromPublic(arrayify17(computePublicKey4(otherKey)));
    return hexZeroPad11("0x" + keyPair6.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
function recoverPublicKey4(digest, signature6) {
  const sig = splitSignature5(signature6);
  const rs = { r: arrayify17(sig.r), s: arrayify17(sig.s) };
  return "0x" + getCurve3().recoverPubKey(arrayify17(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey4(key6, compressed) {
  const bytes = arrayify17(key6);
  if (bytes.length === 32) {
    const signingKey = new SigningKey4(bytes);
    if (compressed) {
      return "0x" + getCurve3().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify12(bytes);
    }
    return "0x" + getCurve3().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify12(bytes);
    }
    return "0x" + getCurve3().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger123.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn14 = __toESM(require_bn());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version111 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors21 = false;
var _censorErrors21 = false;
var LogLevels21 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel21 = LogLevels21["default"];
var _globalLogger21 = null;
function _checkNormalize21() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError21 = _checkNormalize21();
var LogLevel21;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel21 || (LogLevel21 = {}));
var ErrorCode21;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode21 || (ErrorCode21 = {}));
var HEX21 = "0123456789abcdef";
var Logger21 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels21[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel21 > LogLevels21[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger21.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger21.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger21.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors21) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger21.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX21[value[i2] >> 4];
            hex += HEX21[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode21.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode21.CALL_EXCEPTION:
      case ErrorCode21.INSUFFICIENT_FUNDS:
      case ErrorCode21.MISSING_NEW:
      case ErrorCode21.NONCE_EXPIRED:
      case ErrorCode21.REPLACEMENT_UNDERPRICED:
      case ErrorCode21.TRANSACTION_REPLACED:
      case ErrorCode21.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger21.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError21) {
      this.throwError("platform missing String.prototype.normalize", Logger21.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError21
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger21.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger21.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger21.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger21.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger21.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger21.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger21.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger21) {
      _globalLogger21 = new Logger21(version111);
    }
    return _globalLogger21;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger21.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors21) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger21.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors21 = !!censorship;
    _permanentCensorErrors21 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels21[logLevel.toLowerCase()];
    if (level == null) {
      Logger21.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel21 = level;
  }
  static from(version130) {
    return new Logger21(version130);
  }
};
Logger21.errors = ErrorCode21;
Logger21.levels = LogLevel21;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version112 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger124 = new Logger21(version112);
function isHexable18(value) {
  return !!value.toHexString;
}
function addSlice18(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice18(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger18(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes18(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger18(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger18(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify18(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger124.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice18(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable18(value)) {
    value = value.toHexString();
  }
  if (isHexString18(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger124.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice18(new Uint8Array(result));
  }
  if (isBytes18(value)) {
    return addSlice18(new Uint8Array(value));
  }
  return logger124.throwArgumentError("invalid arrayify value", "value", value);
}
function concat11(items) {
  const objects = items.map((item) => arrayify18(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice18(result);
}
function isHexString18(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters13 = "0123456789abcdef";
function hexlify13(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger124.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters13[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable18(value)) {
    return value.toHexString();
  }
  if (isHexString18(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger124.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes18(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters13[(v2 & 240) >> 4] + HexCharacters13[v2 & 15];
    }
    return result;
  }
  return logger124.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad12(value, length) {
  if (typeof value !== "string") {
    value = hexlify13(value);
  } else if (!isHexString18(value)) {
    logger124.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger124.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version113 = "bignumber/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN14 = import_bn14.default.BN;
var logger125 = new Logger21(version113);
var _constructorGuard22 = {};
var MAX_SAFE10 = 9007199254740991;
function isBigNumberish10(value) {
  return value != null && (BigNumber10.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString18(value) || typeof value === "bigint" || isBytes18(value));
}
var _warnedToStringRadix10 = false;
var BigNumber10 = class {
  constructor(constructorGuard, hex) {
    logger125.checkNew(new.target, BigNumber10);
    if (constructorGuard !== _constructorGuard22) {
      logger125.throwError("cannot call constructor directly; use BigNumber.from", Logger21.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber10(toBN10(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber10(toBN10(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber10.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber10(toBN10(this).add(toBN10(other)));
  }
  sub(other) {
    return toBigNumber10(toBN10(this).sub(toBN10(other)));
  }
  div(other) {
    const o = BigNumber10.from(other);
    if (o.isZero()) {
      throwFault19("division-by-zero", "div");
    }
    return toBigNumber10(toBN10(this).div(toBN10(other)));
  }
  mul(other) {
    return toBigNumber10(toBN10(this).mul(toBN10(other)));
  }
  mod(other) {
    const value = toBN10(other);
    if (value.isNeg()) {
      throwFault19("division-by-zero", "mod");
    }
    return toBigNumber10(toBN10(this).umod(value));
  }
  pow(other) {
    const value = toBN10(other);
    if (value.isNeg()) {
      throwFault19("negative-power", "pow");
    }
    return toBigNumber10(toBN10(this).pow(value));
  }
  and(other) {
    const value = toBN10(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault19("unbound-bitwise-result", "and");
    }
    return toBigNumber10(toBN10(this).and(value));
  }
  or(other) {
    const value = toBN10(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault19("unbound-bitwise-result", "or");
    }
    return toBigNumber10(toBN10(this).or(value));
  }
  xor(other) {
    const value = toBN10(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault19("unbound-bitwise-result", "xor");
    }
    return toBigNumber10(toBN10(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault19("negative-width", "mask");
    }
    return toBigNumber10(toBN10(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault19("negative-width", "shl");
    }
    return toBigNumber10(toBN10(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault19("negative-width", "shr");
    }
    return toBigNumber10(toBN10(this).shrn(value));
  }
  eq(other) {
    return toBN10(this).eq(toBN10(other));
  }
  lt(other) {
    return toBN10(this).lt(toBN10(other));
  }
  lte(other) {
    return toBN10(this).lte(toBN10(other));
  }
  gt(other) {
    return toBN10(this).gt(toBN10(other));
  }
  gte(other) {
    return toBN10(this).gte(toBN10(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN10(this).isZero();
  }
  toNumber() {
    try {
      return toBN10(this).toNumber();
    } catch (error) {
      throwFault19("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger125.throwError("this platform does not support BigInt", Logger21.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix10) {
          _warnedToStringRadix10 = true;
          logger125.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger125.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger21.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger125.throwError("BigNumber.toString does not accept parameters", Logger21.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN10(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber10) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber10(_constructorGuard22, toHex10(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber10(_constructorGuard22, toHex10(new BN14(value)));
      }
      return logger125.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault19("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE10 || value <= -MAX_SAFE10) {
        throwFault19("overflow", "BigNumber.from", value);
      }
      return BigNumber10.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber10.from(anyValue.toString());
    }
    if (isBytes18(anyValue)) {
      return BigNumber10.from(hexlify13(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber10.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString18(hex) || hex[0] === "-" && isHexString18(hex.substring(1))) {
            return BigNumber10.from(hex);
          }
        }
      }
    }
    return logger125.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex10(value) {
  if (typeof value !== "string") {
    return toHex10(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger125.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex10(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber10(value) {
  return BigNumber10.from(toHex10(value));
}
function toBN10(value) {
  const hex = BigNumber10.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN14("-" + hex.substring(3), 16);
  }
  return new BN14(hex.substring(2), 16);
}
function throwFault19(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger125.throwError(fault, Logger21.errors.NUMERIC_FAULT, params);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger126 = new Logger21(version113);
var _constructorGuard23 = {};
var Zero23 = BigNumber10.from(0);
var NegativeOne23 = BigNumber10.from(-1);
function throwFault20(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger126.throwError(message, Logger21.errors.NUMERIC_FAULT, params);
}
var zeros10 = "0";
while (zeros10.length < 256) {
  zeros10 += zeros10;
}
function getMultiplier10(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber10.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros10.substring(0, decimals);
  }
  return logger126.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed10(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier10(decimals);
  value = BigNumber10.from(value);
  const negative = value.lt(Zero23);
  if (negative) {
    value = value.mul(NegativeOne23);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed10(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier10(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger126.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger126.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger126.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault20("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber10.from(whole);
  const fractionValue = BigNumber10.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne23);
  }
  return wei;
}
var FixedFormat10 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard23) {
      logger126.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger21.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier10(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat10) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger126.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger126.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger126.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger126.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat10(_constructorGuard23, signed, width, decimals);
  }
};
var FixedNumber10 = class {
  constructor(constructorGuard, hex, value, format) {
    logger126.checkNew(new.target, FixedNumber10);
    if (constructorGuard !== _constructorGuard23) {
      logger126.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger21.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger126.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed10(this._value, this.format.decimals);
    const b2 = parseFixed10(other._value, other.format.decimals);
    return FixedNumber10.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed10(this._value, this.format.decimals);
    const b2 = parseFixed10(other._value, other.format.decimals);
    return FixedNumber10.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed10(this._value, this.format.decimals);
    const b2 = parseFixed10(other._value, other.format.decimals);
    return FixedNumber10.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed10(this._value, this.format.decimals);
    const b2 = parseFixed10(other._value, other.format.decimals);
    return FixedNumber10.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber10.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE10.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber10.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE10.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger126.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber10.from("1" + zeros10.substring(0, decimals), this.format);
    const bump = BUMP10.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger126.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber10.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad12(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber10.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish10(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber10.fromString(formatFixed10(value, decimals), FixedFormat10.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat10.from(format);
    const numeric = parseFixed10(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero23)) {
      throwFault20("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad12(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed10(numeric, fixedFormat.decimals);
    return new FixedNumber10(_constructorGuard23, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat10.from(format);
    if (arrayify18(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber10.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed10(numeric, fixedFormat.decimals);
    return new FixedNumber10(_constructorGuard23, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber10.fromString(value, format);
    }
    if (isBytes18(value)) {
      return FixedNumber10.fromBytes(value, format);
    }
    try {
      return FixedNumber10.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger21.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger126.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE10 = FixedNumber10.from(1);
var BUMP10 = FixedNumber10.from("0.5");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne24 = BigNumber10.from(-1);
var Zero24 = BigNumber10.from(0);
var One14 = BigNumber10.from(1);
var Two8 = BigNumber10.from(2);
var WeiPerEther8 = BigNumber10.from("1000000000000000000");
var MaxUint25614 = BigNumber10.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2568 = BigNumber10.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2568 = BigNumber10.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();
var HashZero8 = "0x0000000000000000000000000000000000000000000000000000000000000000";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version114 = "strings/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger127 = new Logger21(version114);
var UnicodeNormalizationForm7;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm7 || (UnicodeNormalizationForm7 = {}));
var Utf8ErrorReason7;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason7 || (Utf8ErrorReason7 = {}));
function errorFunc7(reason, offset, bytes, output, badCodepoint) {
  return logger127.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc7(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason7.BAD_PREFIX || reason === Utf8ErrorReason7.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason7.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc7(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason7.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc7(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs7 = Object.freeze({
  error: errorFunc7,
  ignore: ignoreFunc7,
  replace: replaceFunc7
});
function getUtf8CodePoints4(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs7.error;
  }
  bytes = arrayify18(bytes);
  const result = [];
  let i2 = 0;
  while (i2 < bytes.length) {
    const c2 = bytes[i2++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError(Utf8ErrorReason7.UNEXPECTED_CONTINUE, i2 - 1, bytes, result);
      } else {
        i2 += onError(Utf8ErrorReason7.BAD_PREFIX, i2 - 1, bytes, result);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes.length) {
      i2 += onError(Utf8ErrorReason7.OVERRUN, i2 - 1, bytes, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError(Utf8ErrorReason7.MISSING_CONTINUE, i2, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError(Utf8ErrorReason7.OUT_OF_RANGE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError(Utf8ErrorReason7.UTF16_SURROGATE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError(Utf8ErrorReason7.OVERLONG, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes7(str, form = UnicodeNormalizationForm7.current) {
  if (form != UnicodeNormalizationForm7.current) {
    logger127.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify18(result);
}
function escapeChar(value) {
  const hex = "0000" + value.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String7(bytes, onError) {
  return '"' + getUtf8CodePoints4(bytes, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String7(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String7(bytes, onError) {
  return _toUtf8String7(getUtf8CodePoints4(bytes, onError));
}
function toUtf8CodePoints7(str, form = UnicodeNormalizationForm7.current) {
  return getUtf8CodePoints4(toUtf8Bytes7(str, form));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/lib.esm/bytes32.js
function formatBytes32String7(text2) {
  const bytes = toUtf8Bytes7(text2);
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify13(concat11([bytes, HashZero8]).slice(0, 32));
}
function parseBytes32String7(bytes) {
  const data = arrayify18(bytes);
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String7(data.slice(0, length));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes27(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data.length; i2 += 4) {
    result.push(parseInt(data.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable7(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable7(data) {
  let hi = 0;
  return data.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap3(value, ranges) {
  let lo = 0;
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let range2 = ranges[i2];
    lo += range2.l;
    if (value >= lo && value <= lo + range2.h && (value - lo) % (range2.d || 1) === 0) {
      if (range2.e && range2.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range2;
    }
  }
  return null;
}
var Table_A_1_ranges7 = createRangeTable7("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags7 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
var Table_B_2_ranges3 = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
var Table_B_2_lut_abs7 = createTable7("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel7 = createTable7("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex7 = createTable7("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes27);
var Table_C_ranges7 = createRangeTable7("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten3(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA13(codepoint) {
  return !!matchMap3(codepoint, Table_A_1_ranges7);
}
function _nameprepTableB23(codepoint) {
  let range2 = matchMap3(codepoint, Table_B_2_ranges3);
  if (range2) {
    return [codepoint + range2.s];
  }
  let codes = Table_B_2_lut_abs7[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel7[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex7[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC3(codepoint) {
  return !!matchMap3(codepoint, Table_C_ranges7);
}
function nameprep7(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints7(value);
  codes = flatten3(codes.map((code) => {
    if (Table_B_1_flags7.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 65024 && code <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB23(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code];
  }));
  codes = toUtf8CodePoints7(_toUtf8String7(codes), UnicodeNormalizationForm7.NFKC);
  codes.forEach((code) => {
    if (_nameprepTableC3(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code) => {
    if (_nameprepTableA13(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String7(codes);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  if (name2.length > 63) {
    throw new Error("too long");
  }
  return name2;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version115 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors22 = false;
var _censorErrors22 = false;
var LogLevels22 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel22 = LogLevels22["default"];
var _globalLogger22 = null;
function _checkNormalize22() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError22 = _checkNormalize22();
var LogLevel22;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel22 || (LogLevel22 = {}));
var ErrorCode22;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode22 || (ErrorCode22 = {}));
var HEX22 = "0123456789abcdef";
var Logger22 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels22[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel22 > LogLevels22[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger22.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger22.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger22.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors22) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger22.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX22[value[i2] >> 4];
            hex += HEX22[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode22.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode22.CALL_EXCEPTION:
      case ErrorCode22.INSUFFICIENT_FUNDS:
      case ErrorCode22.MISSING_NEW:
      case ErrorCode22.NONCE_EXPIRED:
      case ErrorCode22.REPLACEMENT_UNDERPRICED:
      case ErrorCode22.TRANSACTION_REPLACED:
      case ErrorCode22.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger22.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError22) {
      this.throwError("platform missing String.prototype.normalize", Logger22.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError22
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger22.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger22.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger22.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger22.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger22.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger22.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger22.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger22) {
      _globalLogger22 = new Logger22(version115);
    }
    return _globalLogger22;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger22.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors22) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger22.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors22 = !!censorship;
    _permanentCensorErrors22 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels22[logLevel.toLowerCase()];
    if (level == null) {
      Logger22.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel22 = level;
  }
  static from(version130) {
    return new Logger22(version130);
  }
};
Logger22.errors = ErrorCode22;
Logger22.levels = LogLevel22;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version116 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger128 = new Logger22(version116);
function isHexable19(value) {
  return !!value.toHexString;
}
function addSlice19(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice19(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike11(value) {
  return isHexString19(value) && !(value.length % 2) || isBytes19(value);
}
function isInteger19(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes19(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger19(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger19(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify19(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger128.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice19(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable19(value)) {
    value = value.toHexString();
  }
  if (isHexString19(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger128.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice19(new Uint8Array(result));
  }
  if (isBytes19(value)) {
    return addSlice19(new Uint8Array(value));
  }
  return logger128.throwArgumentError("invalid arrayify value", "value", value);
}
function stripZeros9(value) {
  let result = arrayify19(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad5(value, length) {
  value = arrayify19(value);
  if (value.length > length) {
    logger128.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice19(result);
}
function isHexString19(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters14 = "0123456789abcdef";
function hexlify14(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger128.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters14[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable19(value)) {
    return value.toHexString();
  }
  if (isHexString19(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger128.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes19(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters14[(v2 & 240) >> 4] + HexCharacters14[v2 & 15];
    }
    return result;
  }
  return logger128.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength9(data) {
  if (typeof data !== "string") {
    data = hexlify14(data);
  } else if (!isHexString19(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice9(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify14(data);
  } else if (!isHexString19(data) || data.length % 2) {
    logger128.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat8(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify14(item).substring(2);
  });
  return result;
}
function hexZeroPad13(value, length) {
  if (typeof value !== "string") {
    value = hexlify14(value);
  } else if (!isHexString19(value)) {
    logger128.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger128.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature6(signature6) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike11(signature6)) {
    let bytes = arrayify19(signature6);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify14(bytes.slice(0, 32));
      result.s = hexlify14(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify14(bytes.slice(0, 32));
      result.s = hexlify14(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger128.throwArgumentError("invalid signature string", "signature", signature6);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger128.throwArgumentError("signature invalid v byte", "signature", signature6);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify14(bytes.slice(32, 64));
  } else {
    result.r = signature6.r;
    result.s = signature6.s;
    result.v = signature6.v;
    result.recoveryParam = signature6.recoveryParam;
    result._vs = signature6._vs;
    if (result._vs != null) {
      const vs2 = zeroPad5(arrayify19(result._vs), 32);
      result._vs = hexlify14(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger128.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature6);
      }
      vs2[0] &= 127;
      const s2 = hexlify14(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger128.throwArgumentError("signature v mismatch _vs", "signature", signature6);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger128.throwArgumentError("signature missing v and recoveryParam", "signature", signature6);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger128.throwArgumentError("signature recoveryParam mismatch v", "signature", signature6);
        }
      }
    }
    if (result.r == null || !isHexString19(result.r)) {
      logger128.throwArgumentError("signature missing or invalid r", "signature", signature6);
    } else {
      result.r = hexZeroPad13(result.r, 32);
    }
    if (result.s == null || !isHexString19(result.s)) {
      logger128.throwArgumentError("signature missing or invalid s", "signature", signature6);
    } else {
      result.s = hexZeroPad13(result.s, 32);
    }
    const vs = arrayify19(result.s);
    if (vs[0] >= 128) {
      logger128.throwArgumentError("signature s out of range", "signature", signature6);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify14(vs);
    if (result._vs) {
      if (!isHexString19(result._vs)) {
        logger128.throwArgumentError("signature invalid _vs", "signature", signature6);
      }
      result._vs = hexZeroPad13(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger128.throwArgumentError("signature _vs mismatch v and s", "signature", signature6);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn15 = __toESM(require_bn());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version117 = "bignumber/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN15 = import_bn15.default.BN;
var logger129 = new Logger22(version117);
var _constructorGuard24 = {};
var MAX_SAFE11 = 9007199254740991;
function isBigNumberish11(value) {
  return value != null && (BigNumber11.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString19(value) || typeof value === "bigint" || isBytes19(value));
}
var _warnedToStringRadix11 = false;
var BigNumber11 = class {
  constructor(constructorGuard, hex) {
    logger129.checkNew(new.target, BigNumber11);
    if (constructorGuard !== _constructorGuard24) {
      logger129.throwError("cannot call constructor directly; use BigNumber.from", Logger22.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber11(toBN11(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber11(toBN11(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber11.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber11(toBN11(this).add(toBN11(other)));
  }
  sub(other) {
    return toBigNumber11(toBN11(this).sub(toBN11(other)));
  }
  div(other) {
    const o = BigNumber11.from(other);
    if (o.isZero()) {
      throwFault21("division-by-zero", "div");
    }
    return toBigNumber11(toBN11(this).div(toBN11(other)));
  }
  mul(other) {
    return toBigNumber11(toBN11(this).mul(toBN11(other)));
  }
  mod(other) {
    const value = toBN11(other);
    if (value.isNeg()) {
      throwFault21("division-by-zero", "mod");
    }
    return toBigNumber11(toBN11(this).umod(value));
  }
  pow(other) {
    const value = toBN11(other);
    if (value.isNeg()) {
      throwFault21("negative-power", "pow");
    }
    return toBigNumber11(toBN11(this).pow(value));
  }
  and(other) {
    const value = toBN11(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault21("unbound-bitwise-result", "and");
    }
    return toBigNumber11(toBN11(this).and(value));
  }
  or(other) {
    const value = toBN11(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault21("unbound-bitwise-result", "or");
    }
    return toBigNumber11(toBN11(this).or(value));
  }
  xor(other) {
    const value = toBN11(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault21("unbound-bitwise-result", "xor");
    }
    return toBigNumber11(toBN11(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault21("negative-width", "mask");
    }
    return toBigNumber11(toBN11(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault21("negative-width", "shl");
    }
    return toBigNumber11(toBN11(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault21("negative-width", "shr");
    }
    return toBigNumber11(toBN11(this).shrn(value));
  }
  eq(other) {
    return toBN11(this).eq(toBN11(other));
  }
  lt(other) {
    return toBN11(this).lt(toBN11(other));
  }
  lte(other) {
    return toBN11(this).lte(toBN11(other));
  }
  gt(other) {
    return toBN11(this).gt(toBN11(other));
  }
  gte(other) {
    return toBN11(this).gte(toBN11(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN11(this).isZero();
  }
  toNumber() {
    try {
      return toBN11(this).toNumber();
    } catch (error) {
      throwFault21("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger129.throwError("this platform does not support BigInt", Logger22.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix11) {
          _warnedToStringRadix11 = true;
          logger129.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger129.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger22.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger129.throwError("BigNumber.toString does not accept parameters", Logger22.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN11(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber11) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber11(_constructorGuard24, toHex11(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber11(_constructorGuard24, toHex11(new BN15(value)));
      }
      return logger129.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault21("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE11 || value <= -MAX_SAFE11) {
        throwFault21("overflow", "BigNumber.from", value);
      }
      return BigNumber11.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber11.from(anyValue.toString());
    }
    if (isBytes19(anyValue)) {
      return BigNumber11.from(hexlify14(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber11.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString19(hex) || hex[0] === "-" && isHexString19(hex.substring(1))) {
            return BigNumber11.from(hex);
          }
        }
      }
    }
    return logger129.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex11(value) {
  if (typeof value !== "string") {
    return toHex11(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger129.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex11(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber11(value) {
  return BigNumber11.from(toHex11(value));
}
function toBN11(value) {
  const hex = BigNumber11.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN15("-" + hex.substring(3), 16);
  }
  return new BN15(hex.substring(2), 16);
}
function throwFault21(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger129.throwError(fault, Logger22.errors.NUMERIC_FAULT, params);
}
function _base36To1611(value) {
  return new BN15(value, 36).toString(16);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger130 = new Logger22(version117);
var _constructorGuard25 = {};
var Zero25 = BigNumber11.from(0);
var NegativeOne25 = BigNumber11.from(-1);
function throwFault22(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger130.throwError(message, Logger22.errors.NUMERIC_FAULT, params);
}
var zeros11 = "0";
while (zeros11.length < 256) {
  zeros11 += zeros11;
}
function getMultiplier11(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber11.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros11.substring(0, decimals);
  }
  return logger130.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed11(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier11(decimals);
  value = BigNumber11.from(value);
  const negative = value.lt(Zero25);
  if (negative) {
    value = value.mul(NegativeOne25);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed11(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier11(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger130.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger130.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger130.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault22("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber11.from(whole);
  const fractionValue = BigNumber11.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne25);
  }
  return wei;
}
var FixedFormat11 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard25) {
      logger130.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger22.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier11(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat11) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger130.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger130.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger130.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger130.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat11(_constructorGuard25, signed, width, decimals);
  }
};
var FixedNumber11 = class {
  constructor(constructorGuard, hex, value, format) {
    logger130.checkNew(new.target, FixedNumber11);
    if (constructorGuard !== _constructorGuard25) {
      logger130.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger22.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger130.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed11(this._value, this.format.decimals);
    const b2 = parseFixed11(other._value, other.format.decimals);
    return FixedNumber11.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed11(this._value, this.format.decimals);
    const b2 = parseFixed11(other._value, other.format.decimals);
    return FixedNumber11.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed11(this._value, this.format.decimals);
    const b2 = parseFixed11(other._value, other.format.decimals);
    return FixedNumber11.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed11(this._value, this.format.decimals);
    const b2 = parseFixed11(other._value, other.format.decimals);
    return FixedNumber11.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber11.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE11.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber11.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE11.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger130.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber11.from("1" + zeros11.substring(0, decimals), this.format);
    const bump = BUMP11.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger130.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber11.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad13(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber11.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish11(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber11.fromString(formatFixed11(value, decimals), FixedFormat11.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat11.from(format);
    const numeric = parseFixed11(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero25)) {
      throwFault22("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad13(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed11(numeric, fixedFormat.decimals);
    return new FixedNumber11(_constructorGuard25, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat11.from(format);
    if (arrayify19(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber11.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed11(numeric, fixedFormat.decimals);
    return new FixedNumber11(_constructorGuard25, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber11.fromString(value, format);
    }
    if (isBytes19(value)) {
      return FixedNumber11.fromBytes(value, format);
    }
    try {
      return FixedNumber11.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger22.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger130.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE11 = FixedNumber11.from(1);
var BUMP11 = FixedNumber11.from("0.5");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/keccak256/lib.esm/index.js
init_define_process_env();
var import_js_sha39 = __toESM(require_sha3());
function keccak25610(data) {
  return "0x" + import_js_sha39.default.keccak_256(arrayify19(data));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/rlp/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/rlp/lib.esm/_version.js
init_define_process_env();
var version118 = "rlp/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/rlp/lib.esm/index.js
var logger131 = new Logger22(version118);
function arrayifyInteger4(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger3(data, offset, length) {
  let result = 0;
  for (let i2 = 0; i2 < length; i2++) {
    result = result * 256 + data[offset + i2];
  }
  return result;
}
function _encode8(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode8(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger4(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike11(object)) {
    logger131.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify19(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger4(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode15(object) {
  return hexlify14(_encode8(object));
}
function _decodeChildren3(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode3(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger131.throwError("child data too short", Logger22.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode3(data, offset) {
  if (data.length === 0) {
    logger131.throwError("data too short", Logger22.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger131.throwError("data short segment too short", Logger22.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger3(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger131.throwError("data long segment too short", Logger22.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren3(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger131.throwError("data array too short", Logger22.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren3(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger131.throwError("data array too short", Logger22.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger3(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger131.throwError("data array too short", Logger22.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify14(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger131.throwError("data too short", Logger22.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify14(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify14(data[offset]) };
}
function decode7(data) {
  const bytes = arrayify19(data);
  const decoded = _decode3(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger131.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/lib.esm/_version.js
init_define_process_env();
var version119 = "address/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/lib.esm/index.js
var logger132 = new Logger22(version119);
function getChecksumAddress8(address) {
  if (!isHexString19(address, 20)) {
    logger132.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify19(keccak25610(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER8 = 9007199254740991;
function log108(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
var ibanLookup8 = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup8[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup8[String.fromCharCode(65 + i2)] = String(10 + i2);
}
var safeDigits8 = Math.floor(log108(MAX_SAFE_INTEGER8));
function ibanChecksum8(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup8[c2];
  }).join("");
  while (expanded.length >= safeDigits8) {
    let block = expanded.substring(0, safeDigits8);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress8(address) {
  let result = null;
  if (typeof address !== "string") {
    logger132.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress8(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger132.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum8(address)) {
      logger132.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To1611(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress8("0x" + result);
  } else {
    logger132.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();
var NegativeOne26 = BigNumber11.from(-1);
var Zero26 = BigNumber11.from(0);
var One15 = BigNumber11.from(1);
var Two9 = BigNumber11.from(2);
var WeiPerEther9 = BigNumber11.from("1000000000000000000");
var MaxUint25615 = BigNumber11.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt2569 = BigNumber11.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt2569 = BigNumber11.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version120 = "properties/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/properties/lib.esm/index.js
var logger133 = new Logger22(version120);
function defineReadOnly11(object, name2, value) {
  Object.defineProperty(object, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function checkProperties5(object, properties) {
  if (!object || typeof object !== "object") {
    logger133.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach((key6) => {
    if (!properties[key6]) {
      logger133.throwArgumentError("invalid object key - " + key6, "transaction:" + key6, object);
    }
  });
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
init_define_process_env();
var import_bn16 = __toESM(require_bn());
var import_hash15 = __toESM(require_hash());
function createCommonjsModule5(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base6) {
      return commonjsRequire5(path, base6 === void 0 || base6 === null ? module.path : base6);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire5() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert5 = assert5;
function assert5(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert5.equal = function assertEqual5(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_15 = createCommonjsModule5(function(module, exports) {
  "use strict";
  var utils = exports;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray2;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex13(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero2(msg[i2].toString(16));
    return res;
  }
  utils.toHex = toHex13;
  utils.encode = function encode18(arr, enc) {
    if (enc === "hex")
      return toHex13(arr);
    else
      return arr;
  };
});
var utils_1$15 = createCommonjsModule5(function(module, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert5;
  utils.toArray = utils_15.toArray;
  utils.zero2 = utils_15.zero2;
  utils.toHex = utils_15.toHex;
  utils.encode = utils_15.encode;
  function getNAF6(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i2 = 0; i2 < naf.length; i2++) {
      var z;
      var mod = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k2.isubn(z);
      } else {
        z = 0;
      }
      naf[i2] = z;
      k2.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF6;
  function getJSF6(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF6;
  function cachedProperty(obj, name2, computer) {
    var key6 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key6] !== void 0 ? this[key6] : this[key6] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn16.default(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});
var getNAF5 = utils_1$15.getNAF;
var getJSF5 = utils_1$15.getJSF;
var assert$15 = utils_1$15.assert;
function BaseCurve5(type, conf) {
  this.type = type;
  this.p = new import_bn16.default(conf.p, 16);
  this.red = conf.prime ? import_bn16.default.red(conf.prime) : import_bn16.default.mont(this.p);
  this.zero = new import_bn16.default(0).toRed(this.red);
  this.one = new import_bn16.default(1).toRed(this.red);
  this.two = new import_bn16.default(2).toRed(this.red);
  this.n = conf.n && new import_bn16.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base5 = BaseCurve5;
BaseCurve5.prototype.point = function point9() {
  throw new Error("Not implemented");
};
BaseCurve5.prototype.validate = function validate17() {
  throw new Error("Not implemented");
};
BaseCurve5.prototype._fixedNafMul = function _fixedNafMul5(p2, k2) {
  assert$15(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF5(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i2 = I2; i2 > 0; i2--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i2)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i2)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve5.prototype._wnafMul = function _wnafMul5(p2, k2) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF5(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i2 = naf.length - 1; i2 >= 0; i2--) {
    for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
      l2++;
    if (i2 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i2 < 0)
      break;
    var z = naf[i2];
    assert$15(z !== 0);
    if (p2.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve5.prototype._wnafMulAdd = function _wnafMulAdd5(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i2;
  var j2;
  var p2;
  for (i2 = 0; i2 < len; i2++) {
    p2 = points[i2];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i2] = nafPoints.wnd;
    wnd[i2] = nafPoints.points;
  }
  for (i2 = len - 1; i2 >= 1; i2 -= 2) {
    var a2 = i2 - 1;
    var b2 = i2;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF5(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF5(coeffs[b2], wndWidth[b2], this._bitLength);
      max2 = Math.max(naf[a2].length, max2);
      max2 = Math.max(naf[b2].length, max2);
      continue;
    }
    var comb = [
      points[a2],
      null,
      null,
      points[b2]
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF5(coeffs[a2], coeffs[b2]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a2] = new Array(max2);
    naf[b2] = new Array(max2);
    for (j2 = 0; j2 < max2; j2++) {
      var ja = jsf[0][j2] | 0;
      var jb = jsf[1][j2] | 0;
      naf[a2][j2] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i2 = max2; i2 >= 0; i2--) {
    var k2 = 0;
    while (i2 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len; j2++) {
        tmp[j2] = naf[j2][i2] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i2--;
    }
    if (i2 >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i2 < 0)
      break;
    for (j2 = 0; j2 < len; j2++) {
      var z = tmp[j2];
      p2;
      if (z === 0)
        continue;
      else if (z > 0)
        p2 = wnd[j2][z - 1 >> 1];
      else if (z < 0)
        p2 = wnd[j2][-z - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i2 = 0; i2 < len; i2++)
    wnd[i2] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint5(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve5.BasePoint = BasePoint5;
BasePoint5.prototype.eq = function eq13() {
  throw new Error("Not implemented");
};
BasePoint5.prototype.validate = function validate18() {
  return this.curve.validate(this);
};
BaseCurve5.prototype.decodePoint = function decodePoint5(bytes, enc) {
  bytes = utils_1$15.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$15(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$15(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint5.prototype.encodeCompressed = function encodeCompressed5(enc) {
  return this.encode(enc, true);
};
BasePoint5.prototype._encode = function _encode9(compact) {
  var len = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len));
};
BasePoint5.prototype.encode = function encode16(enc, compact) {
  return utils_1$15.encode(this._encode(compact), enc);
};
BasePoint5.prototype.precompute = function precompute5(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint5.prototype._hasDoubles = function _hasDoubles5(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
};
BasePoint5.prototype._getDoubles = function _getDoubles5(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i2 = 0; i2 < power; i2 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint5.prototype._getNAFPoints = function _getNAFPoints5(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl11 = max2 === 1 ? null : this.dbl();
  for (var i2 = 1; i2 < max2; i2++)
    res[i2] = res[i2 - 1].add(dbl11);
  return {
    wnd,
    points: res
  };
};
BasePoint5.prototype._getBeta = function _getBeta9() {
  return null;
};
BasePoint5.prototype.dblp = function dblp9(k2) {
  var r2 = this;
  for (var i2 = 0; i2 < k2; i2++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser5 = createCommonjsModule5(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$25 = utils_1$15.assert;
function ShortCurve5(conf) {
  base5.call(this, "short", conf);
  this.a = new import_bn16.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn16.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser5(ShortCurve5, base5);
var short_15 = ShortCurve5;
ShortCurve5.prototype._getEndomorphism = function _getEndomorphism5(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn16.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn16.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$25(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn16.default(vec.a, 16),
        b: new import_bn16.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve5.prototype._getEndoRoots = function _getEndoRoots5(num) {
  var red = num === this.p ? this.red : import_bn16.default.mont(num);
  var tinv = new import_bn16.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new import_bn16.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve5.prototype._getEndoBasis = function _getEndoBasis5(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new import_bn16.default(1);
  var y1 = new import_bn16.default(0);
  var x2 = new import_bn16.default(0);
  var y2 = new import_bn16.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i2 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r2 = v2.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i2 === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y;
  }
  a2 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve5.prototype._endoSplit = function _endoSplit5(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve5.prototype.pointFromX = function pointFromX5(x2, odd) {
  x2 = new import_bn16.default(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x2, y);
};
ShortCurve5.prototype.validate = function validate19(point11) {
  if (point11.inf)
    return true;
  var x2 = point11.x;
  var y = point11.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve5.prototype._endoWnafMulAdd = function _endoWnafMulAdd5(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i2 = 0; i2 < points.length; i2++) {
    var split = this._endoSplit(coeffs[i2]);
    var p2 = points[i2];
    var beta = p2._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i2 * 2] = p2;
    npoints[i2 * 2 + 1] = beta;
    ncoeffs[i2 * 2] = split.k1;
    ncoeffs[i2 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
  for (var j2 = 0; j2 < i2 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point5(curve, x2, y, isRed) {
  base5.BasePoint.call(this, curve, "affine");
  if (x2 === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn16.default(x2, 16);
    this.y = new import_bn16.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser5(Point5, base5.BasePoint);
ShortCurve5.prototype.point = function point10(x2, y, isRed) {
  return new Point5(this, x2, y, isRed);
};
ShortCurve5.prototype.pointFromJSON = function pointFromJSON5(obj, red) {
  return Point5.fromJSON(this, obj, red);
};
Point5.prototype._getBeta = function _getBeta10() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p2) {
      return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point5.prototype.toJSON = function toJSON5() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point5.fromJSON = function fromJSON5(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point5.prototype.inspect = function inspect13() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point5.prototype.isInfinity = function isInfinity9() {
  return this.inf;
};
Point5.prototype.add = function add9(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point5.prototype.dbl = function dbl9() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point5.prototype.getX = function getX5() {
  return this.x.fromRed();
};
Point5.prototype.getY = function getY5() {
  return this.y.fromRed();
};
Point5.prototype.mul = function mul9(k2) {
  k2 = new import_bn16.default(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
};
Point5.prototype.mulAdd = function mulAdd5(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point5.prototype.jmulAdd = function jmulAdd5(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point5.prototype.eq = function eq14(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point5.prototype.neg = function neg9(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point5.prototype.toJ = function toJ5() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint5(curve, x2, y, z) {
  base5.BasePoint.call(this, curve, "jacobian");
  if (x2 === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn16.default(0);
  } else {
    this.x = new import_bn16.default(x2, 16);
    this.y = new import_bn16.default(y, 16);
    this.z = new import_bn16.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser5(JPoint5, base5.BasePoint);
ShortCurve5.prototype.jpoint = function jpoint5(x2, y, z) {
  return new JPoint5(this, x2, y, z);
};
JPoint5.prototype.toP = function toP5() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint5.prototype.neg = function neg10() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint5.prototype.add = function add10(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint5.prototype.mixedAdd = function mixedAdd5(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint5.prototype.dblp = function dblp10(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i2;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i2 = 0; i2 < pow; i2++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i2 = 0; i2 < pow; i2++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i2 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint5.prototype.dbl = function dbl10() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint5.prototype._zeroDbl = function _zeroDbl5() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e = a2.redAdd(a2).redIAdd(a2);
    var f2 = e.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint5.prototype._threeDbl = function _threeDbl5() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint5.prototype._dbl = function _dbl5() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint5.prototype.trpl = function trpl5() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  var ee2 = e.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e).redSqr().redISub(mm).redISub(ee2).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee2).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e.redMul(ee2)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint5.prototype.mul = function mul10(k2, kbase) {
  k2 = new import_bn16.default(k2, kbase);
  return this.curve._wnafMul(this, k2);
};
JPoint5.prototype.eq = function eq15(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint5.prototype.eqXToP = function eqXToP5(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint5.prototype.inspect = function inspect14() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint5.prototype.isInfinity = function isInfinity10() {
  return this.z.cmpn(0) === 0;
};
var curve_15 = createCommonjsModule5(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base5;
  curve.short = short_15;
  curve.mont = null;
  curve.edwards = null;
});
var curves_15 = createCommonjsModule5(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert6 = utils_1$15.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_15.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_15.edwards(options);
    else
      this.curve = new curve_15.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert6(this.g.validate(), "Invalid curve");
    assert6(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash15.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash15.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash15.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash15.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash15.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash15.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash15.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash15.default.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG5(options) {
  if (!(this instanceof HmacDRBG5))
    return new HmacDRBG5(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_15.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_15.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_15.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert5(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg5 = HmacDRBG5;
HmacDRBG5.prototype._init = function init5(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG5.prototype._hmac = function hmac5() {
  return new import_hash15.default.hmac(this.hash, this.K);
};
HmacDRBG5.prototype._update = function update5(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG5.prototype.reseed = function reseed5(entropy, entropyEnc, add11, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add11;
    add11 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_15.toArray(entropy, entropyEnc);
  add11 = utils_15.toArray(add11, addEnc);
  minimalisticAssert5(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add11 || []));
  this._reseed = 1;
};
HmacDRBG5.prototype.generate = function generate6(len, enc, add11, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add11;
    add11 = enc;
    enc = null;
  }
  if (add11) {
    add11 = utils_15.toArray(add11, addEnc || "hex");
    this._update(add11);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add11);
  this._reseed++;
  return utils_15.encode(res, enc);
};
var assert$35 = utils_1$15.assert;
function KeyPair5(ec6, options) {
  this.ec = ec6;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key5 = KeyPair5;
KeyPair5.fromPublic = function fromPublic5(ec6, pub, enc) {
  if (pub instanceof KeyPair5)
    return pub;
  return new KeyPair5(ec6, {
    pub,
    pubEnc: enc
  });
};
KeyPair5.fromPrivate = function fromPrivate5(ec6, priv, enc) {
  if (priv instanceof KeyPair5)
    return priv;
  return new KeyPair5(ec6, {
    priv,
    privEnc: enc
  });
};
KeyPair5.prototype.validate = function validate20() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair5.prototype.getPublic = function getPublic5(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair5.prototype.getPrivate = function getPrivate5(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair5.prototype._importPrivate = function _importPrivate5(key6, enc) {
  this.priv = new import_bn16.default(key6, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair5.prototype._importPublic = function _importPublic5(key6, enc) {
  if (key6.x || key6.y) {
    if (this.ec.curve.type === "mont") {
      assert$35(key6.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$35(key6.x && key6.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key6.x, key6.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key6, enc);
};
KeyPair5.prototype.derive = function derive5(pub) {
  if (!pub.validate()) {
    assert$35(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair5.prototype.sign = function sign9(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair5.prototype.verify = function verify9(msg, signature6) {
  return this.ec.verify(msg, signature6, this);
};
KeyPair5.prototype.inspect = function inspect15() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$45 = utils_1$15.assert;
function Signature5(options, enc) {
  if (options instanceof Signature5)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$45(options.r && options.s, "Signature without r or s");
  this.r = new import_bn16.default(options.r, 16);
  this.s = new import_bn16.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature5 = Signature5;
function Position5() {
  this.place = 0;
}
function getLength5(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding5(buf) {
  var i2 = 0;
  var len = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
Signature5.prototype._importDER = function _importDER5(data, enc) {
  data = utils_1$15.toArray(data, enc);
  var p2 = new Position5();
  if (data[p2.place++] !== 48) {
    return false;
  }
  var len = getLength5(data, p2);
  if (len === false) {
    return false;
  }
  if (len + p2.place !== data.length) {
    return false;
  }
  if (data[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength5(data, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength5(data, p2);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p2.place) {
    return false;
  }
  var s2 = data.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn16.default(r2);
  this.s = new import_bn16.default(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength5(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature5.prototype.toDER = function toDER5(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding5(r2);
  s2 = rmPadding5(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength5(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength5(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength5(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$15.encode(res, enc);
};
var rand5 = function() {
  throw new Error("unsupported");
};
var assert$55 = utils_1$15.assert;
function EC5(options) {
  if (!(this instanceof EC5))
    return new EC5(options);
  if (typeof options === "string") {
    assert$55(Object.prototype.hasOwnProperty.call(curves_15, options), "Unknown curve " + options);
    options = curves_15[options];
  }
  if (options instanceof curves_15.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec5 = EC5;
EC5.prototype.keyPair = function keyPair5(options) {
  return new key5(this, options);
};
EC5.prototype.keyFromPrivate = function keyFromPrivate5(priv, enc) {
  return key5.fromPrivate(this, priv, enc);
};
EC5.prototype.keyFromPublic = function keyFromPublic5(pub, enc) {
  return key5.fromPublic(this, pub, enc);
};
EC5.prototype.genKeyPair = function genKeyPair5(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg5({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand5(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new import_bn16.default(2));
  for (; ; ) {
    var priv = new import_bn16.default(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC5.prototype._truncateToN = function _truncateToN5(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC5.prototype.sign = function sign10(msg, key6, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key6 = this.keyFromPrivate(key6, enc);
  msg = this._truncateToN(new import_bn16.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key6.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg5({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn16.default(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new import_bn16.default(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k2.invm(this.n).mul(r2.mul(key6.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature5({ r: r2, s: s2, recoveryParam });
  }
};
EC5.prototype.verify = function verify10(msg, signature$1, key6, enc) {
  msg = this._truncateToN(new import_bn16.default(msg, 16));
  key6 = this.keyFromPublic(key6, enc);
  signature$1 = new signature5(signature$1, "hex");
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key6.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key6.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC5.prototype.recoverPubKey = function(msg, signature$1, j2, enc) {
  assert$55((3 & j2) === j2, "The recovery param is more than two bits");
  signature$1 = new signature5(signature$1, enc);
  var n = this.n;
  var e = new import_bn16.default(msg);
  var r2 = signature$1.r;
  var s2 = signature$1.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s22 = s2.mul(rInv).umod(n);
  return this.g.mulAdd(s1, r2, s22);
};
EC5.prototype.getKeyRecoveryParam = function(e, signature$1, Q2, enc) {
  signature$1 = new signature5(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i2 = 0; i2 < 4; i2++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i2);
    } catch (e2) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i2;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_15 = createCommonjsModule5(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = { version: "6.5.4" }.version;
  elliptic.utils = utils_1$15;
  elliptic.rand = function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_15;
  elliptic.curves = curves_15;
  elliptic.ec = ec5;
  elliptic.eddsa = null;
});
var EC$15 = elliptic_15.ec;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/lib.esm/_version.js
init_define_process_env();
var version121 = "signing-key/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger134 = new Logger22(version121);
var _curve4 = null;
function getCurve4() {
  if (!_curve4) {
    _curve4 = new EC$15("secp256k1");
  }
  return _curve4;
}
var SigningKey5 = class {
  constructor(privateKey) {
    defineReadOnly11(this, "curve", "secp256k1");
    defineReadOnly11(this, "privateKey", hexlify14(privateKey));
    const keyPair6 = getCurve4().keyFromPrivate(arrayify19(this.privateKey));
    defineReadOnly11(this, "publicKey", "0x" + keyPair6.getPublic(false, "hex"));
    defineReadOnly11(this, "compressedPublicKey", "0x" + keyPair6.getPublic(true, "hex"));
    defineReadOnly11(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve4().keyFromPublic(arrayify19(this.publicKey));
    const p1 = getCurve4().keyFromPublic(arrayify19(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest) {
    const keyPair6 = getCurve4().keyFromPrivate(arrayify19(this.privateKey));
    const digestBytes = arrayify19(digest);
    if (digestBytes.length !== 32) {
      logger134.throwArgumentError("bad digest length", "digest", digest);
    }
    const signature6 = keyPair6.sign(digestBytes, { canonical: true });
    return splitSignature6({
      recoveryParam: signature6.recoveryParam,
      r: hexZeroPad13("0x" + signature6.r.toString(16), 32),
      s: hexZeroPad13("0x" + signature6.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair6 = getCurve4().keyFromPrivate(arrayify19(this.privateKey));
    const otherKeyPair = getCurve4().keyFromPublic(arrayify19(computePublicKey5(otherKey)));
    return hexZeroPad13("0x" + keyPair6.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
function recoverPublicKey5(digest, signature6) {
  const sig = splitSignature6(signature6);
  const rs = { r: arrayify19(sig.r), s: arrayify19(sig.s) };
  return "0x" + getCurve4().recoverPubKey(arrayify19(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey5(key6, compressed) {
  const bytes = arrayify19(key6);
  if (bytes.length === 32) {
    const signingKey = new SigningKey5(bytes);
    if (compressed) {
      return "0x" + getCurve4().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify14(bytes);
    }
    return "0x" + getCurve4().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify14(bytes);
    }
    return "0x" + getCurve4().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger134.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/lib.esm/_version.js
init_define_process_env();
var version122 = "transactions/5.5.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/transactions/lib.esm/index.js
var logger135 = new Logger22(version122);
var TransactionTypes4;
(function(TransactionTypes5) {
  TransactionTypes5[TransactionTypes5["legacy"] = 0] = "legacy";
  TransactionTypes5[TransactionTypes5["eip2930"] = 1] = "eip2930";
  TransactionTypes5[TransactionTypes5["eip1559"] = 2] = "eip1559";
})(TransactionTypes4 || (TransactionTypes4 = {}));
function handleAddress2(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress8(value);
}
function handleNumber2(value) {
  if (value === "0x") {
    return Zero26;
  }
  return BigNumber11.from(value);
}
var transactionFields = [
  { name: "nonce", maxLength: 32, numeric: true },
  { name: "gasPrice", maxLength: 32, numeric: true },
  { name: "gasLimit", maxLength: 32, numeric: true },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: true },
  { name: "data" }
];
var allowedTransactionKeys4 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  type: true,
  value: true
};
function computeAddress4(key6) {
  const publicKey = computePublicKey5(key6);
  return getAddress8(hexDataSlice9(keccak25610(hexDataSlice9(publicKey, 1)), 12));
}
function recoverAddress2(digest, signature6) {
  return computeAddress4(recoverPublicKey5(arrayify19(digest), signature6));
}
function formatNumber2(value, name2) {
  const result = stripZeros9(BigNumber11.from(value).toHexString());
  if (result.length > 32) {
    logger135.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify2(addr, storageKeys) {
  return {
    address: getAddress8(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength9(storageKey) !== 32) {
        logger135.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify2(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger135.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
        }
        return accessSetify2(set[0], set[1]);
      }
      return accessSetify2(set.address, set.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify2(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function formatAccessList2(value) {
  return accessListify2(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip15592(transaction, signature6) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber11.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber11.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger135.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber2(transaction.chainId || 0, "chainId"),
    formatNumber2(transaction.nonce || 0, "nonce"),
    formatNumber2(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber2(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber2(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress8(transaction.to) : "0x",
    formatNumber2(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList2(transaction.accessList || [])
  ];
  if (signature6) {
    const sig = splitSignature6(signature6);
    fields.push(formatNumber2(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros9(sig.r));
    fields.push(stripZeros9(sig.s));
  }
  return hexConcat8(["0x02", encode15(fields)]);
}
function _serializeEip29302(transaction, signature6) {
  const fields = [
    formatNumber2(transaction.chainId || 0, "chainId"),
    formatNumber2(transaction.nonce || 0, "nonce"),
    formatNumber2(transaction.gasPrice || 0, "gasPrice"),
    formatNumber2(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress8(transaction.to) : "0x",
    formatNumber2(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList2(transaction.accessList || [])
  ];
  if (signature6) {
    const sig = splitSignature6(signature6);
    fields.push(formatNumber2(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros9(sig.r));
    fields.push(stripZeros9(sig.s));
  }
  return hexConcat8(["0x01", encode15(fields)]);
}
function _serialize(transaction, signature6) {
  checkProperties5(transaction, allowedTransactionKeys4);
  const raw = [];
  transactionFields.forEach(function(fieldInfo) {
    let value = transaction[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value = arrayify19(hexlify14(value, options));
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger135.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    if (fieldInfo.maxLength) {
      value = stripZeros9(value);
      if (value.length > fieldInfo.maxLength) {
        logger135.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw.push(hexlify14(value));
  });
  let chainId2 = 0;
  if (transaction.chainId != null) {
    chainId2 = transaction.chainId;
    if (typeof chainId2 !== "number") {
      logger135.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature6 && !isBytesLike11(signature6) && signature6.v > 28) {
    chainId2 = Math.floor((signature6.v - 35) / 2);
  }
  if (chainId2 !== 0) {
    raw.push(hexlify14(chainId2));
    raw.push("0x");
    raw.push("0x");
  }
  if (!signature6) {
    return encode15(raw);
  }
  const sig = splitSignature6(signature6);
  let v2 = 27 + sig.recoveryParam;
  if (chainId2 !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v2 += chainId2 * 2 + 8;
    if (sig.v > 28 && sig.v !== v2) {
      logger135.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature6);
    }
  } else if (sig.v !== v2) {
    logger135.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature6);
  }
  raw.push(hexlify14(v2));
  raw.push(stripZeros9(arrayify19(sig.r)));
  raw.push(stripZeros9(arrayify19(sig.s)));
  return encode15(raw);
}
function serialize2(transaction, signature6) {
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger135.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature6);
  }
  switch (transaction.type) {
    case 1:
      return _serializeEip29302(transaction, signature6);
    case 2:
      return _serializeEip15592(transaction, signature6);
    default:
      break;
  }
  return logger135.throwError(`unsupported transaction type: ${transaction.type}`, Logger22.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
function _parseEipSignature2(tx, fields, serialize3) {
  try {
    const recid = handleNumber2(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger135.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad13(fields[1], 32);
  tx.s = hexZeroPad13(fields[2], 32);
  try {
    const digest = keccak25610(serialize3(tx));
    tx.from = recoverAddress2(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
    console.log(error);
  }
}
function _parseEip15592(payload) {
  const transaction = decode7(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger135.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify14(payload));
  }
  const maxPriorityFeePerGas = handleNumber2(transaction[2]);
  const maxFeePerGas = handleNumber2(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber2(transaction[0]).toNumber(),
    nonce: handleNumber2(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber2(transaction[4]),
    to: handleAddress2(transaction[5]),
    value: handleNumber2(transaction[6]),
    data: transaction[7],
    accessList: accessListify2(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak25610(payload);
  _parseEipSignature2(tx, transaction.slice(9), _serializeEip15592);
  return tx;
}
function _parseEip29302(payload) {
  const transaction = decode7(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger135.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify14(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber2(transaction[0]).toNumber(),
    nonce: handleNumber2(transaction[1]).toNumber(),
    gasPrice: handleNumber2(transaction[2]),
    gasLimit: handleNumber2(transaction[3]),
    to: handleAddress2(transaction[4]),
    value: handleNumber2(transaction[5]),
    data: transaction[6],
    accessList: accessListify2(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak25610(payload);
  _parseEipSignature2(tx, transaction.slice(8), _serializeEip29302);
  return tx;
}
function _parse2(rawTransaction) {
  const transaction = decode7(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger135.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber2(transaction[0]).toNumber(),
    gasPrice: handleNumber2(transaction[1]),
    gasLimit: handleNumber2(transaction[2]),
    to: handleAddress2(transaction[3]),
    value: handleNumber2(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber11.from(transaction[6]).toNumber();
  } catch (error) {
    console.log(error);
    return tx;
  }
  tx.r = hexZeroPad13(transaction[7], 32);
  tx.s = hexZeroPad13(transaction[8], 32);
  if (BigNumber11.from(tx.r).isZero() && BigNumber11.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify14(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest = keccak25610(encode15(raw));
    try {
      tx.from = recoverAddress2(digest, { r: hexlify14(tx.r), s: hexlify14(tx.s), recoveryParam });
    } catch (error) {
      console.log(error);
    }
    tx.hash = keccak25610(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse2(rawTransaction) {
  const payload = arrayify19(rawTransaction);
  if (payload[0] > 127) {
    return _parse2(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip29302(payload);
    case 2:
      return _parseEip15592(payload);
    default:
      break;
  }
  return logger135.throwError(`unsupported transaction type: ${payload[0]}`, Logger22.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/base64/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/base64/lib.esm/base64.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/bytes/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/logger/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/logger/lib.esm/_version.js
init_define_process_env();
var version123 = "logger/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors23 = false;
var _censorErrors23 = false;
var LogLevels23 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel23 = LogLevels23["default"];
var _globalLogger23 = null;
function _checkNormalize23() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError23 = _checkNormalize23();
var LogLevel23;
(function(LogLevel24) {
  LogLevel24["DEBUG"] = "DEBUG";
  LogLevel24["INFO"] = "INFO";
  LogLevel24["WARNING"] = "WARNING";
  LogLevel24["ERROR"] = "ERROR";
  LogLevel24["OFF"] = "OFF";
})(LogLevel23 || (LogLevel23 = {}));
var ErrorCode23;
(function(ErrorCode25) {
  ErrorCode25["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode25["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode25["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode25["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode25["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode25["TIMEOUT"] = "TIMEOUT";
  ErrorCode25["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode25["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode25["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode25["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode25["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode25["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode25["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode25["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode25["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode25["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode25["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode25["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode23 || (ErrorCode23 = {}));
var HEX23 = "0123456789abcdef";
var Logger23 = class {
  constructor(version130) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version130,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels23[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel23 > LogLevels23[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger23.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger23.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger23.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors23) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger23.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key6) => {
      const value = params[key6];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value.length; i2++) {
            hex += HEX23[value[i2] >> 4];
            hex += HEX23[value[i2] & 15];
          }
          messageDetails.push(key6 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key6 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key6 + "=" + JSON.stringify(params[key6].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode23.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode23.CALL_EXCEPTION:
      case ErrorCode23.INSUFFICIENT_FUNDS:
      case ErrorCode23.MISSING_NEW:
      case ErrorCode23.NONCE_EXPIRED:
      case ErrorCode23.REPLACEMENT_UNDERPRICED:
      case ErrorCode23.TRANSACTION_REPLACED:
      case ErrorCode23.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key6) {
      error[key6] = params[key6];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, Logger23.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError23) {
      this.throwError("platform missing String.prototype.normalize", Logger23.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError23
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger23.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger23.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger23.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger23.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger23.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger23.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger23.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger23) {
      _globalLogger23 = new Logger23(version123);
    }
    return _globalLogger23;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger23.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors23) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger23.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors23 = !!censorship;
    _permanentCensorErrors23 = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels23[logLevel.toLowerCase()];
    if (level == null) {
      Logger23.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel23 = level;
  }
  static from(version130) {
    return new Logger23(version130);
  }
};
Logger23.errors = ErrorCode23;
Logger23.levels = LogLevel23;

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/bytes/lib.esm/_version.js
init_define_process_env();
var version124 = "bytes/5.6.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/bytes/lib.esm/index.js
var logger136 = new Logger23(version124);
function isHexable20(value) {
  return !!value.toHexString;
}
function addSlice20(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice20(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike12(value) {
  return isHexString20(value) && !(value.length % 2) || isBytes20(value);
}
function isInteger20(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes20(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger20(value.length) || value.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value.length; i2++) {
    const v2 = value[i2];
    if (!isInteger20(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify20(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger136.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice20(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable20(value)) {
    value = value.toHexString();
  }
  if (isHexString20(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger136.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice20(new Uint8Array(result));
  }
  if (isBytes20(value)) {
    return addSlice20(new Uint8Array(value));
  }
  return logger136.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString20(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters15 = "0123456789abcdef";
function hexlify15(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger136.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters15[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable20(value)) {
    return value.toHexString();
  }
  if (isHexString20(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger136.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes20(value)) {
    let result = "0x";
    for (let i2 = 0; i2 < value.length; i2++) {
      let v2 = value[i2];
      result += HexCharacters15[(v2 & 240) >> 4] + HexCharacters15[v2 & 15];
    }
    return result;
  }
  return logger136.throwArgumentError("invalid hexlify value", "value", value);
}
function hexZeroPad14(value, length) {
  if (typeof value !== "string") {
    value = hexlify15(value);
  } else if (!isHexString20(value)) {
    logger136.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger136.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/base64/lib.esm/base64.js
function decode8(textData) {
  textData = atob(textData);
  const data = [];
  for (let i2 = 0; i2 < textData.length; i2++) {
    data.push(textData.charCodeAt(i2));
  }
  return arrayify20(data);
}
function encode17(data) {
  data = arrayify20(data);
  let textData = "";
  for (let i2 = 0; i2 < data.length; i2++) {
    textData += String.fromCharCode(data[i2]);
  }
  return btoa(textData);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/properties/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/properties/lib.esm/_version.js
init_define_process_env();
var version125 = "properties/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/properties/lib.esm/index.js
var logger137 = new Logger23(version125);
function shallowCopy9(object) {
  const result = {};
  for (const key6 in object) {
    result[key6] = object[key6];
  }
  return result;
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/lib.esm/bytes32.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/constants/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/constants/lib.esm/addresses.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/bignumber/lib.esm/index.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
init_define_process_env();
var import_bn17 = __toESM(require_bn());

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/bignumber/lib.esm/_version.js
init_define_process_env();
var version126 = "bignumber/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN17 = import_bn17.default.BN;
var logger138 = new Logger23(version126);
var _constructorGuard26 = {};
var MAX_SAFE12 = 9007199254740991;
function isBigNumberish12(value) {
  return value != null && (BigNumber12.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString20(value) || typeof value === "bigint" || isBytes20(value));
}
var _warnedToStringRadix12 = false;
var BigNumber12 = class {
  constructor(constructorGuard, hex) {
    logger138.checkNew(new.target, BigNumber12);
    if (constructorGuard !== _constructorGuard26) {
      logger138.throwError("cannot call constructor directly; use BigNumber.from", Logger23.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber12(toBN12(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber12(toBN12(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber12.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber12(toBN12(this).add(toBN12(other)));
  }
  sub(other) {
    return toBigNumber12(toBN12(this).sub(toBN12(other)));
  }
  div(other) {
    const o = BigNumber12.from(other);
    if (o.isZero()) {
      throwFault23("division-by-zero", "div");
    }
    return toBigNumber12(toBN12(this).div(toBN12(other)));
  }
  mul(other) {
    return toBigNumber12(toBN12(this).mul(toBN12(other)));
  }
  mod(other) {
    const value = toBN12(other);
    if (value.isNeg()) {
      throwFault23("division-by-zero", "mod");
    }
    return toBigNumber12(toBN12(this).umod(value));
  }
  pow(other) {
    const value = toBN12(other);
    if (value.isNeg()) {
      throwFault23("negative-power", "pow");
    }
    return toBigNumber12(toBN12(this).pow(value));
  }
  and(other) {
    const value = toBN12(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault23("unbound-bitwise-result", "and");
    }
    return toBigNumber12(toBN12(this).and(value));
  }
  or(other) {
    const value = toBN12(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault23("unbound-bitwise-result", "or");
    }
    return toBigNumber12(toBN12(this).or(value));
  }
  xor(other) {
    const value = toBN12(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault23("unbound-bitwise-result", "xor");
    }
    return toBigNumber12(toBN12(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault23("negative-width", "mask");
    }
    return toBigNumber12(toBN12(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault23("negative-width", "shl");
    }
    return toBigNumber12(toBN12(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault23("negative-width", "shr");
    }
    return toBigNumber12(toBN12(this).shrn(value));
  }
  eq(other) {
    return toBN12(this).eq(toBN12(other));
  }
  lt(other) {
    return toBN12(this).lt(toBN12(other));
  }
  lte(other) {
    return toBN12(this).lte(toBN12(other));
  }
  gt(other) {
    return toBN12(this).gt(toBN12(other));
  }
  gte(other) {
    return toBN12(this).gte(toBN12(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN12(this).isZero();
  }
  toNumber() {
    try {
      return toBN12(this).toNumber();
    } catch (error) {
      throwFault23("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger138.throwError("this platform does not support BigInt", Logger23.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix12) {
          _warnedToStringRadix12 = true;
          logger138.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger138.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger23.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger138.throwError("BigNumber.toString does not accept parameters", Logger23.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN12(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key6) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber12) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber12(_constructorGuard26, toHex12(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber12(_constructorGuard26, toHex12(new BN17(value)));
      }
      return logger138.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault23("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE12 || value <= -MAX_SAFE12) {
        throwFault23("overflow", "BigNumber.from", value);
      }
      return BigNumber12.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber12.from(anyValue.toString());
    }
    if (isBytes20(anyValue)) {
      return BigNumber12.from(hexlify15(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber12.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString20(hex) || hex[0] === "-" && isHexString20(hex.substring(1))) {
            return BigNumber12.from(hex);
          }
        }
      }
    }
    return logger138.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex12(value) {
  if (typeof value !== "string") {
    return toHex12(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger138.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex12(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber12(value) {
  return BigNumber12.from(toHex12(value));
}
function toBN12(value) {
  const hex = BigNumber12.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN17("-" + hex.substring(3), 16);
  }
  return new BN17(hex.substring(2), 16);
}
function throwFault23(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger138.throwError(fault, Logger23.errors.NUMERIC_FAULT, params);
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
init_define_process_env();
var logger139 = new Logger23(version126);
var _constructorGuard27 = {};
var Zero27 = BigNumber12.from(0);
var NegativeOne27 = BigNumber12.from(-1);
function throwFault24(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger139.throwError(message, Logger23.errors.NUMERIC_FAULT, params);
}
var zeros12 = "0";
while (zeros12.length < 256) {
  zeros12 += zeros12;
}
function getMultiplier12(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber12.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros12.substring(0, decimals);
  }
  return logger139.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed12(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier12(decimals);
  value = BigNumber12.from(value);
  const negative = value.lt(Zero27);
  if (negative) {
    value = value.mul(NegativeOne27);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed12(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier12(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger139.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger139.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger139.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault24("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber12.from(whole);
  const fractionValue = BigNumber12.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne27);
  }
  return wei;
}
var FixedFormat12 = class {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard27) {
      logger139.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger23.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier12(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat12) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger139.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key6, type, defaultValue) => {
        if (value[key6] == null) {
          return defaultValue;
        }
        if (typeof value[key6] !== type) {
          logger139.throwArgumentError("invalid fixed format (" + key6 + " not " + type + ")", "format." + key6, value[key6]);
        }
        return value[key6];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger139.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger139.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat12(_constructorGuard27, signed, width, decimals);
  }
};
var FixedNumber12 = class {
  constructor(constructorGuard, hex, value, format) {
    logger139.checkNew(new.target, FixedNumber12);
    if (constructorGuard !== _constructorGuard27) {
      logger139.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger23.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger139.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed12(this._value, this.format.decimals);
    const b2 = parseFixed12(other._value, other.format.decimals);
    return FixedNumber12.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed12(this._value, this.format.decimals);
    const b2 = parseFixed12(other._value, other.format.decimals);
    return FixedNumber12.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed12(this._value, this.format.decimals);
    const b2 = parseFixed12(other._value, other.format.decimals);
    return FixedNumber12.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed12(this._value, this.format.decimals);
    const b2 = parseFixed12(other._value, other.format.decimals);
    return FixedNumber12.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber12.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE12.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber12.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE12.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger139.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber12.from("1" + zeros12.substring(0, decimals), this.format);
    const bump = BUMP12.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger139.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber12.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad14(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber12.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish12(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber12.fromString(formatFixed12(value, decimals), FixedFormat12.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat12.from(format);
    const numeric = parseFixed12(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero27)) {
      throwFault24("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad14(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed12(numeric, fixedFormat.decimals);
    return new FixedNumber12(_constructorGuard27, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat12.from(format);
    if (arrayify20(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber12.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed12(numeric, fixedFormat.decimals);
    return new FixedNumber12(_constructorGuard27, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber12.fromString(value, format);
    }
    if (isBytes20(value)) {
      return FixedNumber12.fromBytes(value, format);
    }
    try {
      return FixedNumber12.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger23.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger139.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE12 = FixedNumber12.from(1);
var BUMP12 = FixedNumber12.from("0.5");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne28 = BigNumber12.from(-1);
var Zero28 = BigNumber12.from(0);
var One16 = BigNumber12.from(1);
var Two10 = BigNumber12.from(2);
var WeiPerEther10 = BigNumber12.from("1000000000000000000");
var MaxUint25616 = BigNumber12.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt25610 = BigNumber12.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt25610 = BigNumber12.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/constants/lib.esm/hashes.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/constants/lib.esm/strings.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/lib.esm/utf8.js
init_define_process_env();

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/lib.esm/_version.js
init_define_process_env();
var version127 = "strings/5.6.0";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger140 = new Logger23(version127);
var UnicodeNormalizationForm8;
(function(UnicodeNormalizationForm9) {
  UnicodeNormalizationForm9["current"] = "";
  UnicodeNormalizationForm9["NFC"] = "NFC";
  UnicodeNormalizationForm9["NFD"] = "NFD";
  UnicodeNormalizationForm9["NFKC"] = "NFKC";
  UnicodeNormalizationForm9["NFKD"] = "NFKD";
})(UnicodeNormalizationForm8 || (UnicodeNormalizationForm8 = {}));
var Utf8ErrorReason8;
(function(Utf8ErrorReason9) {
  Utf8ErrorReason9["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason9["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason9["OVERRUN"] = "string overrun";
  Utf8ErrorReason9["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason9["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason9["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason9["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason8 || (Utf8ErrorReason8 = {}));
function errorFunc8(reason, offset, bytes, output, badCodepoint) {
  return logger140.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc8(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason8.BAD_PREFIX || reason === Utf8ErrorReason8.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason8.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc8(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason8.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc8(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs8 = Object.freeze({
  error: errorFunc8,
  ignore: ignoreFunc8,
  replace: replaceFunc8
});
function getUtf8CodePoints5(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs8.error;
  }
  bytes = arrayify20(bytes);
  const result = [];
  let i2 = 0;
  while (i2 < bytes.length) {
    const c2 = bytes[i2++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError(Utf8ErrorReason8.UNEXPECTED_CONTINUE, i2 - 1, bytes, result);
      } else {
        i2 += onError(Utf8ErrorReason8.BAD_PREFIX, i2 - 1, bytes, result);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes.length) {
      i2 += onError(Utf8ErrorReason8.OVERRUN, i2 - 1, bytes, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError(Utf8ErrorReason8.MISSING_CONTINUE, i2, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError(Utf8ErrorReason8.OUT_OF_RANGE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError(Utf8ErrorReason8.UTF16_SURROGATE, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError(Utf8ErrorReason8.OVERLONG, i2 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes8(str, form = UnicodeNormalizationForm8.current) {
  if (form != UnicodeNormalizationForm8.current) {
    logger140.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++) {
    const c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str.charCodeAt(i2);
      if (i2 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify20(result);
}
function _toUtf8String8(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String8(bytes, onError) {
  return _toUtf8String8(getUtf8CodePoints5(bytes, onError));
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/lib.esm/idna.js
init_define_process_env();
function bytes28(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data.length; i2 += 4) {
    result.push(parseInt(data.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable8(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable8(data) {
  let hi = 0;
  return data.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges8 = createRangeTable8("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags8 = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
var Table_B_2_lut_abs8 = createTable8("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel8 = createTable8("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex8 = createTable8("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes28);
var Table_C_ranges8 = createRangeTable8("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/lib.esm/_version.js
init_define_process_env();
var version128 = "web/5.5.1";

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/lib.esm/geturl.js
init_define_process_env();
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl2(href, options) {
  return __awaiter19(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    ;
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key6) => {
        headers[key6.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key6) => {
        headers[key6.toLowerCase()] = response.headers.get(key6);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify20(new Uint8Array(body))
    };
  });
}

// node_modules/@web3-onboard/core/node_modules/@ethersproject/web/lib.esm/index.js
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger141 = new Logger23(version128);
function staller2(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify2(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike12(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String8(value);
      } catch (error) {
      }
      ;
    }
    return hexlify15(value);
  }
  return value;
}
function _fetchData2(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger141.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger141.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout2 = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger141.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout2 = connection.timeout;
    }
    if (connection.headers) {
      for (const key6 in connection.headers) {
        headers[key6.toLowerCase()] = { key: key6, value: String(connection.headers[key6]) };
        if (["if-none-match", "if-modified-since"].indexOf(key6.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger141.throwError("basic authentication requires a secure https url", Logger23.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode17(toUtf8Bytes8(authorization))
      };
    }
  }
  const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] },
        body: decode8(dataMatch[2])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger141.throwError("processing response error", Logger23.errors.SERVER_ERROR, {
        body: bodyify2(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key6) => {
    const header = headers[key6];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer3 = null;
    const promise2 = new Promise(function(resolve, reject) {
      if (timeout2) {
        timer3 = setTimeout(() => {
          if (timer3 == null) {
            return;
          }
          timer3 = null;
          reject(logger141.makeError("timeout", Logger23.errors.TIMEOUT, {
            requestBody: bodyify2(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout: timeout2,
            url
          }));
        }, timeout2);
      }
    });
    const cancel = function() {
      if (timer3 == null) {
        return;
      }
      clearTimeout(timer3);
      timer3 = null;
    };
    return { promise: promise2, cancel };
  }();
  const runningFetch = function() {
    return __awaiter20(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl2(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location = response.headers.location || "";
              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall3 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall3 = parseInt(retryAfter) * 1e3;
                } else {
                  stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller2(stall3);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger141.throwError("missing response", Logger23.errors.SERVER_ERROR, {
              requestBody: bodyify2(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (response.statusCode < 200 || response.statusCode >= 300) {
          runningTimeout.cancel();
          logger141.throwError("bad response", Logger23.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify2(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify2(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller2(timeout3);
                continue;
              }
            }
            runningTimeout.cancel();
            logger141.throwError("processing response error", Logger23.errors.SERVER_ERROR, {
              body: bodyify2(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify2(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger141.throwError("failed response", Logger23.errors.SERVER_ERROR, {
        requestBody: bodyify2(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson2(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String8(value));
      } catch (error) {
        logger141.throwError("invalid JSON", Logger23.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes8(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy9(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k2) => k2.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy9(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData2(connection, body, processJsonFunc);
}
function poll2(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy9(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer3 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer3) {
        clearTimeout(timer3);
      }
      return true;
    };
    if (options.timeout) {
      timer3 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout2 = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout2 < options.floor) {
            timeout2 = options.floor;
          }
          if (timeout2 > options.ceiling) {
            timeout2 = options.ceiling;
          }
          setTimeout(check, timeout2);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}

// node_modules/@web3-onboard/core/node_modules/ethers/lib.esm/_version.js
init_define_process_env();
var version129 = "ethers/5.5.3";

// node_modules/@web3-onboard/core/node_modules/ethers/lib.esm/ethers.js
var logger142 = new Logger15(version129);

// node_modules/@web3-onboard/core/node_modules/ethers/lib.esm/index.js
try {
  const anyGlobal4 = window;
  if (anyGlobal4._ethers == null) {
    anyGlobal4._ethers = ethers_exports;
  }
} catch (error) {
}

// node_modules/svelte-i18n/dist/runtime.esm.js
init_define_process_env();

// node_modules/svelte/store/index.mjs
init_define_process_env();

// node_modules/svelte/internal/index.mjs
init_define_process_env();
function noop2() {
}
function run(fn) {
  return fn();
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop2;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
var resolved_promise = Promise.resolve();
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key6 in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key6]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop2;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop2) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update7(fn) {
    set(fn(value));
  }
  function subscribe3(run3, invalidate = noop2) {
    const subscriber = [run3, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop2;
    }
    run3(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update7, subscribe: subscribe3 };
}
function derived(stores, fn, initial_value) {
  const single2 = !Array.isArray(stores);
  const stores_array = single2 ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop2;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single2 ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop2;
      }
    };
    const unsubscribers = stores_array.map((store, i2) => subscribe(store, (value) => {
      values[i2] = value;
      pending &= ~(1 << i2);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i2;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}

// node_modules/svelte-i18n/dist/runtime.esm.js
var import_deepmerge = __toESM(require_cjs());

// node_modules/intl-messageformat/lib/index.js
init_define_process_env();

// node_modules/intl-messageformat/lib/src/core.js
init_define_process_env();

// node_modules/@formatjs/icu-messageformat-parser/lib/index.js
init_define_process_env();

// node_modules/@formatjs/icu-messageformat-parser/lib/error.js
init_define_process_env();
var ErrorKind;
(function(ErrorKind2) {
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
  ErrorKind2[ErrorKind2["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
  ErrorKind2[ErrorKind2["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
  ErrorKind2[ErrorKind2["INVALID_TAG"] = 23] = "INVALID_TAG";
  ErrorKind2[ErrorKind2["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
  ErrorKind2[ErrorKind2["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
  ErrorKind2[ErrorKind2["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));

// node_modules/@formatjs/icu-messageformat-parser/lib/parser.js
init_define_process_env();

// node_modules/@formatjs/icu-messageformat-parser/lib/types.js
init_define_process_env();
var TYPE;
(function(TYPE2) {
  TYPE2[TYPE2["literal"] = 0] = "literal";
  TYPE2[TYPE2["argument"] = 1] = "argument";
  TYPE2[TYPE2["number"] = 2] = "number";
  TYPE2[TYPE2["date"] = 3] = "date";
  TYPE2[TYPE2["time"] = 4] = "time";
  TYPE2[TYPE2["select"] = 5] = "select";
  TYPE2[TYPE2["plural"] = 6] = "plural";
  TYPE2[TYPE2["pound"] = 7] = "pound";
  TYPE2[TYPE2["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(SKELETON_TYPE2) {
  SKELETON_TYPE2[SKELETON_TYPE2["number"] = 0] = "number";
  SKELETON_TYPE2[SKELETON_TYPE2["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(el) {
  return el.type === TYPE.literal;
}
function isArgumentElement(el) {
  return el.type === TYPE.argument;
}
function isNumberElement(el) {
  return el.type === TYPE.number;
}
function isDateElement(el) {
  return el.type === TYPE.date;
}
function isTimeElement(el) {
  return el.type === TYPE.time;
}
function isSelectElement(el) {
  return el.type === TYPE.select;
}
function isPluralElement(el) {
  return el.type === TYPE.plural;
}
function isPoundElement(el) {
  return el.type === TYPE.pound;
}
function isTagElement(el) {
  return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.dateTime);
}

// node_modules/@formatjs/icu-messageformat-parser/lib/regex.generated.js
init_define_process_env();
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

// node_modules/@formatjs/icu-skeleton-parser/lib/index.js
init_define_process_env();

// node_modules/@formatjs/icu-skeleton-parser/lib/date-time.js
init_define_process_env();
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
  var result = {};
  skeleton.replace(DATE_TIME_REGEX, function(match) {
    var len = match.length;
    switch (match[0]) {
      case "G":
        result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "y":
        result.year = len === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        result.month = ["numeric", "2-digit", "short", "long", "narrow"][len - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        result.day = ["numeric", "2-digit"][len - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        result.weekday = len === 4 ? "short" : len === 5 ? "narrow" : "short";
        break;
      case "e":
        if (len < 4) {
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "c":
        if (len < 4) {
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "a":
        result.hour12 = true;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        result.hourCycle = "h12";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "H":
        result.hourCycle = "h23";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "K":
        result.hourCycle = "h11";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "k":
        result.hourCycle = "h24";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        result.minute = ["numeric", "2-digit"][len - 1];
        break;
      case "s":
        result.second = ["numeric", "2-digit"][len - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      case "z":
        result.timeZoneName = len < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  });
  return result;
}

// node_modules/@formatjs/icu-skeleton-parser/lib/number.js
init_define_process_env();

// node_modules/@formatjs/icu-skeleton-parser/lib/regex.generated.js
init_define_process_env();
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

// node_modules/@formatjs/icu-skeleton-parser/lib/number.js
function parseNumberSkeletonFromString(skeleton) {
  if (skeleton.length === 0) {
    throw new Error("Number skeleton cannot be empty");
  }
  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function(x2) {
    return x2.length > 0;
  });
  var tokens = [];
  for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
    var stringToken = stringTokens_1[_i];
    var stemAndOptions = stringToken.split("/");
    if (stemAndOptions.length === 0) {
      throw new Error("Invalid number skeleton");
    }
    var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
    for (var _a2 = 0, options_1 = options; _a2 < options_1.length; _a2++) {
      var option = options_1[_a2];
      if (option.length === 0) {
        throw new Error("Invalid number skeleton");
      }
    }
    tokens.push({ stem, options });
  }
  return tokens;
}
function icuUnitToEcma(unit) {
  return unit.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
  var result = {};
  if (str[str.length - 1] === "r") {
    result.roundingPriority = "morePrecision";
  } else if (str[str.length - 1] === "s") {
    result.roundingPriority = "lessPrecision";
  }
  str.replace(SIGNIFICANT_PRECISION_REGEX, function(_2, g1, g2) {
    if (typeof g2 !== "string") {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length;
    } else if (g2 === "+") {
      result.minimumSignificantDigits = g1.length;
    } else if (g1[0] === "#") {
      result.maximumSignificantDigits = g1.length;
    } else {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length + (typeof g2 === "string" ? g2.length : 0);
    }
    return "";
  });
  return result;
}
function parseSign(str) {
  switch (str) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(stem) {
  var result;
  if (stem[0] === "E" && stem[1] === "E") {
    result = {
      notation: "engineering"
    };
    stem = stem.slice(2);
  } else if (stem[0] === "E") {
    result = {
      notation: "scientific"
    };
    stem = stem.slice(1);
  }
  if (result) {
    var signDisplay = stem.slice(0, 2);
    if (signDisplay === "+!") {
      result.signDisplay = "always";
      stem = stem.slice(2);
    } else if (signDisplay === "+?") {
      result.signDisplay = "exceptZero";
      stem = stem.slice(2);
    }
    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
      throw new Error("Malformed concise eng/scientific notation");
    }
    result.minimumIntegerDigits = stem.length;
  }
  return result;
}
function parseNotationOptions(opt) {
  var result = {};
  var signOpts = parseSign(opt);
  if (signOpts) {
    return signOpts;
  }
  return result;
}
function parseNumberSkeleton(tokens) {
  var result = {};
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    switch (token.stem) {
      case "percent":
      case "%":
        result.style = "percent";
        continue;
      case "%x100":
        result.style = "percent";
        result.scale = 100;
        continue;
      case "currency":
        result.style = "currency";
        result.currency = token.options[0];
        continue;
      case "group-off":
      case ",_":
        result.useGrouping = false;
        continue;
      case "precision-integer":
      case ".":
        result.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        result.style = "unit";
        result.unit = icuUnitToEcma(token.options[0]);
        continue;
      case "compact-short":
      case "K":
        result.notation = "compact";
        result.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        result.notation = "compact";
        result.compactDisplay = "long";
        continue;
      case "scientific":
        result = __assign(__assign(__assign({}, result), { notation: "scientific" }), token.options.reduce(function(all, opt2) {
          return __assign(__assign({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "engineering":
        result = __assign(__assign(__assign({}, result), { notation: "engineering" }), token.options.reduce(function(all, opt2) {
          return __assign(__assign({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "notation-simple":
        result.notation = "standard";
        continue;
      case "unit-width-narrow":
        result.currencyDisplay = "narrowSymbol";
        result.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        result.currencyDisplay = "code";
        result.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        result.currencyDisplay = "name";
        result.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        result.currencyDisplay = "symbol";
        continue;
      case "scale":
        result.scale = parseFloat(token.options[0]);
        continue;
      case "integer-width":
        if (token.options.length > 1) {
          throw new RangeError("integer-width stems only accept a single optional option");
        }
        token.options[0].replace(INTEGER_WIDTH_REGEX, function(_2, g1, g2, g3, g4, g5) {
          if (g1) {
            result.minimumIntegerDigits = g2.length;
          } else if (g3 && g4) {
            throw new Error("We currently do not support maximum integer digits");
          } else if (g5) {
            throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
      result.minimumIntegerDigits = token.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(token.stem)) {
      if (token.options.length > 1) {
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      }
      token.stem.replace(FRACTION_PRECISION_REGEX, function(_2, g1, g2, g3, g4, g5) {
        if (g2 === "*") {
          result.minimumFractionDigits = g1.length;
        } else if (g3 && g3[0] === "#") {
          result.maximumFractionDigits = g3.length;
        } else if (g4 && g5) {
          result.minimumFractionDigits = g4.length;
          result.maximumFractionDigits = g4.length + g5.length;
        } else {
          result.minimumFractionDigits = g1.length;
          result.maximumFractionDigits = g1.length;
        }
        return "";
      });
      var opt = token.options[0];
      if (opt === "w") {
        result = __assign(__assign({}, result), { trailingZeroDisplay: "stripIfInteger" });
      } else if (opt) {
        result = __assign(__assign({}, result), parseSignificantPrecision(opt));
      }
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
      result = __assign(__assign({}, result), parseSignificantPrecision(token.stem));
      continue;
    }
    var signOpts = parseSign(token.stem);
    if (signOpts) {
      result = __assign(__assign({}, result), signOpts);
    }
    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
    if (conciseScientificAndEngineeringOpts) {
      result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);
    }
  }
  return result;
}

// node_modules/@formatjs/icu-messageformat-parser/lib/parser.js
var _a;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start, end) {
  return { start, end };
}
var hasNativeStartsWith = !!String.prototype.startsWith;
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(n) {
  return typeof n === "number" && isFinite(n) && Math.floor(n) === n && Math.abs(n) <= 9007199254740991;
};
var REGEX_SUPPORTS_U_AND_Y = true;
try {
  re = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
} catch (_2) {
  REGEX_SUPPORTS_U_AND_Y = false;
}
var re;
var startsWith = hasNativeStartsWith ? function startsWith2(s2, search, position) {
  return s2.startsWith(search, position);
} : function startsWith3(s2, search, position) {
  return s2.slice(position, position + search.length) === search;
};
var fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : function fromCodePoint2() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  var elements = "";
  var length = codePoints.length;
  var i2 = 0;
  var code;
  while (length > i2) {
    code = codePoints[i2++];
    if (code > 1114111)
      throw RangeError(code + " is not a valid code point");
    elements += code < 65536 ? String.fromCharCode(code) : String.fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
  }
  return elements;
};
var fromEntries = hasNativeFromEntries ? Object.fromEntries : function fromEntries2(entries) {
  var obj = {};
  for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
    var _a2 = entries_1[_i], k2 = _a2[0], v2 = _a2[1];
    obj[k2] = v2;
  }
  return obj;
};
var codePointAt = hasNativeCodePointAt ? function codePointAt2(s2, index) {
  return s2.codePointAt(index);
} : function codePointAt3(s2, index) {
  var size = s2.length;
  if (index < 0 || index >= size) {
    return void 0;
  }
  var first2 = s2.charCodeAt(index);
  var second;
  return first2 < 55296 || first2 > 56319 || index + 1 === size || (second = s2.charCodeAt(index + 1)) < 56320 || second > 57343 ? first2 : (first2 - 55296 << 10) + (second - 56320) + 65536;
};
var trimStart = hasTrimStart ? function trimStart2(s2) {
  return s2.trimStart();
} : function trimStart3(s2) {
  return s2.replace(SPACE_SEPARATOR_START_REGEX, "");
};
var trimEnd = hasTrimEnd ? function trimEnd2(s2) {
  return s2.trimEnd();
} : function trimEnd3(s2) {
  return s2.replace(SPACE_SEPARATOR_END_REGEX, "");
};
function RE(s2, flag) {
  return new RegExp(s2, flag);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s2, index) {
    var _a2;
    IDENTIFIER_PREFIX_RE_1.lastIndex = index;
    var match = IDENTIFIER_PREFIX_RE_1.exec(s2);
    return (_a2 = match[1]) !== null && _a2 !== void 0 ? _a2 : "";
  };
} else {
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s2, index) {
    var match = [];
    while (true) {
      var c2 = codePointAt(s2, index);
      if (c2 === void 0 || _isWhiteSpace(c2) || _isPatternSyntax(c2)) {
        break;
      }
      match.push(c2);
      index += c2 >= 65536 ? 2 : 1;
    }
    return fromCodePoint.apply(void 0, match);
  };
}
var IDENTIFIER_PREFIX_RE_1;
var Parser2 = function() {
  function Parser3(message, options) {
    if (options === void 0) {
      options = {};
    }
    this.message = message;
    this.position = { offset: 0, line: 1, column: 1 };
    this.ignoreTag = !!options.ignoreTag;
    this.requiresOtherClause = !!options.requiresOtherClause;
    this.shouldParseSkeletons = !!options.shouldParseSkeletons;
  }
  Parser3.prototype.parse = function() {
    if (this.offset() !== 0) {
      throw Error("parser can only be used once");
    }
    return this.parseMessage(0, "", false);
  };
  Parser3.prototype.parseMessage = function(nestingLevel, parentArgType, expectingCloseTag) {
    var elements = [];
    while (!this.isEOF()) {
      var char = this.char();
      if (char === 123) {
        var result = this.parseArgument(nestingLevel, expectingCloseTag);
        if (result.err) {
          return result;
        }
        elements.push(result.val);
      } else if (char === 125 && nestingLevel > 0) {
        break;
      } else if (char === 35 && (parentArgType === "plural" || parentArgType === "selectordinal")) {
        var position = this.clonePosition();
        this.bump();
        elements.push({
          type: TYPE.pound,
          location: createLocation(position, this.clonePosition())
        });
      } else if (char === 60 && !this.ignoreTag && this.peek() === 47) {
        if (expectingCloseTag) {
          break;
        } else {
          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
        }
      } else if (char === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
        var result = this.parseTag(nestingLevel, parentArgType);
        if (result.err) {
          return result;
        }
        elements.push(result.val);
      } else {
        var result = this.parseLiteral(nestingLevel, parentArgType);
        if (result.err) {
          return result;
        }
        elements.push(result.val);
      }
    }
    return { val: elements, err: null };
  };
  Parser3.prototype.parseTag = function(nestingLevel, parentArgType) {
    var startPosition = this.clonePosition();
    this.bump();
    var tagName = this.parseTagName();
    this.bumpSpace();
    if (this.bumpIf("/>")) {
      return {
        val: {
          type: TYPE.literal,
          value: "<".concat(tagName, "/>"),
          location: createLocation(startPosition, this.clonePosition())
        },
        err: null
      };
    } else if (this.bumpIf(">")) {
      var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
      if (childrenResult.err) {
        return childrenResult;
      }
      var children2 = childrenResult.val;
      var endTagStartPosition = this.clonePosition();
      if (this.bumpIf("</")) {
        if (this.isEOF() || !_isAlpha(this.char())) {
          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
        }
        var closingTagNameStartPosition = this.clonePosition();
        var closingTagName = this.parseTagName();
        if (tagName !== closingTagName) {
          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
        }
        this.bumpSpace();
        if (!this.bumpIf(">")) {
          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
        }
        return {
          val: {
            type: TYPE.tag,
            value: tagName,
            children: children2,
            location: createLocation(startPosition, this.clonePosition())
          },
          err: null
        };
      } else {
        return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
      }
    } else {
      return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
    }
  };
  Parser3.prototype.parseTagName = function() {
    var startOffset = this.offset();
    this.bump();
    while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
      this.bump();
    }
    return this.message.slice(startOffset, this.offset());
  };
  Parser3.prototype.parseLiteral = function(nestingLevel, parentArgType) {
    var start = this.clonePosition();
    var value = "";
    while (true) {
      var parseQuoteResult = this.tryParseQuote(parentArgType);
      if (parseQuoteResult) {
        value += parseQuoteResult;
        continue;
      }
      var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
      if (parseUnquotedResult) {
        value += parseUnquotedResult;
        continue;
      }
      var parseLeftAngleResult = this.tryParseLeftAngleBracket();
      if (parseLeftAngleResult) {
        value += parseLeftAngleResult;
        continue;
      }
      break;
    }
    var location = createLocation(start, this.clonePosition());
    return {
      val: { type: TYPE.literal, value, location },
      err: null
    };
  };
  Parser3.prototype.tryParseLeftAngleBracket = function() {
    if (!this.isEOF() && this.char() === 60 && (this.ignoreTag || !_isAlphaOrSlash(this.peek() || 0))) {
      this.bump();
      return "<";
    }
    return null;
  };
  Parser3.prototype.tryParseQuote = function(parentArgType) {
    if (this.isEOF() || this.char() !== 39) {
      return null;
    }
    switch (this.peek()) {
      case 39:
        this.bump();
        this.bump();
        return "'";
      case 123:
      case 60:
      case 62:
      case 125:
        break;
      case 35:
        if (parentArgType === "plural" || parentArgType === "selectordinal") {
          break;
        }
        return null;
      default:
        return null;
    }
    this.bump();
    var codePoints = [this.char()];
    this.bump();
    while (!this.isEOF()) {
      var ch = this.char();
      if (ch === 39) {
        if (this.peek() === 39) {
          codePoints.push(39);
          this.bump();
        } else {
          this.bump();
          break;
        }
      } else {
        codePoints.push(ch);
      }
      this.bump();
    }
    return fromCodePoint.apply(void 0, codePoints);
  };
  Parser3.prototype.tryParseUnquoted = function(nestingLevel, parentArgType) {
    if (this.isEOF()) {
      return null;
    }
    var ch = this.char();
    if (ch === 60 || ch === 123 || ch === 35 && (parentArgType === "plural" || parentArgType === "selectordinal") || ch === 125 && nestingLevel > 0) {
      return null;
    } else {
      this.bump();
      return fromCodePoint(ch);
    }
  };
  Parser3.prototype.parseArgument = function(nestingLevel, expectingCloseTag) {
    var openingBracePosition = this.clonePosition();
    this.bump();
    this.bumpSpace();
    if (this.isEOF()) {
      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
    }
    if (this.char() === 125) {
      this.bump();
      return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
    }
    var value = this.parseIdentifierIfPossible().value;
    if (!value) {
      return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
    }
    this.bumpSpace();
    if (this.isEOF()) {
      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
    }
    switch (this.char()) {
      case 125: {
        this.bump();
        return {
          val: {
            type: TYPE.argument,
            value,
            location: createLocation(openingBracePosition, this.clonePosition())
          },
          err: null
        };
      }
      case 44: {
        this.bump();
        this.bumpSpace();
        if (this.isEOF()) {
          return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
        }
        return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
      }
      default:
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
    }
  };
  Parser3.prototype.parseIdentifierIfPossible = function() {
    var startingPosition = this.clonePosition();
    var startOffset = this.offset();
    var value = matchIdentifierAtIndex(this.message, startOffset);
    var endOffset = startOffset + value.length;
    this.bumpTo(endOffset);
    var endPosition = this.clonePosition();
    var location = createLocation(startingPosition, endPosition);
    return { value, location };
  };
  Parser3.prototype.parseArgumentOptions = function(nestingLevel, expectingCloseTag, value, openingBracePosition) {
    var _a2;
    var typeStartPosition = this.clonePosition();
    var argType = this.parseIdentifierIfPossible().value;
    var typeEndPosition = this.clonePosition();
    switch (argType) {
      case "":
        return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
      case "number":
      case "date":
      case "time": {
        this.bumpSpace();
        var styleAndLocation = null;
        if (this.bumpIf(",")) {
          this.bumpSpace();
          var styleStartPosition = this.clonePosition();
          var result = this.parseSimpleArgStyleIfPossible();
          if (result.err) {
            return result;
          }
          var style = trimEnd(result.val);
          if (style.length === 0) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
          }
          var styleLocation = createLocation(styleStartPosition, this.clonePosition());
          styleAndLocation = { style, styleLocation };
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        var location_1 = createLocation(openingBracePosition, this.clonePosition());
        if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, "::", 0)) {
          var skeleton = trimStart(styleAndLocation.style.slice(2));
          if (argType === "number") {
            var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
            if (result.err) {
              return result;
            }
            return {
              val: { type: TYPE.number, value, location: location_1, style: result.val },
              err: null
            };
          } else {
            if (skeleton.length === 0) {
              return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
            }
            var style = {
              type: SKELETON_TYPE.dateTime,
              pattern: skeleton,
              location: styleAndLocation.styleLocation,
              parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(skeleton) : {}
            };
            var type = argType === "date" ? TYPE.date : TYPE.time;
            return {
              val: { type, value, location: location_1, style },
              err: null
            };
          }
        }
        return {
          val: {
            type: argType === "number" ? TYPE.number : argType === "date" ? TYPE.date : TYPE.time,
            value,
            location: location_1,
            style: (_a2 = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a2 !== void 0 ? _a2 : null
          },
          err: null
        };
      }
      case "plural":
      case "selectordinal":
      case "select": {
        var typeEndPosition_1 = this.clonePosition();
        this.bumpSpace();
        if (!this.bumpIf(",")) {
          return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));
        }
        this.bumpSpace();
        var identifierAndLocation = this.parseIdentifierIfPossible();
        var pluralOffset = 0;
        if (argType !== "select" && identifierAndLocation.value === "offset") {
          if (!this.bumpIf(":")) {
            return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
          }
          this.bumpSpace();
          var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
          if (result.err) {
            return result;
          }
          this.bumpSpace();
          identifierAndLocation = this.parseIdentifierIfPossible();
          pluralOffset = result.val;
        }
        var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
        if (optionsResult.err) {
          return optionsResult;
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        var location_2 = createLocation(openingBracePosition, this.clonePosition());
        if (argType === "select") {
          return {
            val: {
              type: TYPE.select,
              value,
              options: fromEntries(optionsResult.val),
              location: location_2
            },
            err: null
          };
        } else {
          return {
            val: {
              type: TYPE.plural,
              value,
              options: fromEntries(optionsResult.val),
              offset: pluralOffset,
              pluralType: argType === "plural" ? "cardinal" : "ordinal",
              location: location_2
            },
            err: null
          };
        }
      }
      default:
        return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
    }
  };
  Parser3.prototype.tryParseArgumentClose = function(openingBracePosition) {
    if (this.isEOF() || this.char() !== 125) {
      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
    }
    this.bump();
    return { val: true, err: null };
  };
  Parser3.prototype.parseSimpleArgStyleIfPossible = function() {
    var nestedBraces = 0;
    var startPosition = this.clonePosition();
    while (!this.isEOF()) {
      var ch = this.char();
      switch (ch) {
        case 39: {
          this.bump();
          var apostrophePosition = this.clonePosition();
          if (!this.bumpUntil("'")) {
            return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
          }
          this.bump();
          break;
        }
        case 123: {
          nestedBraces += 1;
          this.bump();
          break;
        }
        case 125: {
          if (nestedBraces > 0) {
            nestedBraces -= 1;
          } else {
            return {
              val: this.message.slice(startPosition.offset, this.offset()),
              err: null
            };
          }
          break;
        }
        default:
          this.bump();
          break;
      }
    }
    return {
      val: this.message.slice(startPosition.offset, this.offset()),
      err: null
    };
  };
  Parser3.prototype.parseNumberSkeletonFromString = function(skeleton, location) {
    var tokens = [];
    try {
      tokens = parseNumberSkeletonFromString(skeleton);
    } catch (e) {
      return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);
    }
    return {
      val: {
        type: SKELETON_TYPE.number,
        tokens,
        location,
        parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}
      },
      err: null
    };
  };
  Parser3.prototype.tryParsePluralOrSelectOptions = function(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
    var _a2;
    var hasOtherClause = false;
    var options = [];
    var parsedSelectors = /* @__PURE__ */ new Set();
    var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
    while (true) {
      if (selector.length === 0) {
        var startPosition = this.clonePosition();
        if (parentArgType !== "select" && this.bumpIf("=")) {
          var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
          if (result.err) {
            return result;
          }
          selectorLocation = createLocation(startPosition, this.clonePosition());
          selector = this.message.slice(startPosition.offset, this.offset());
        } else {
          break;
        }
      }
      if (parsedSelectors.has(selector)) {
        return this.error(parentArgType === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
      }
      if (selector === "other") {
        hasOtherClause = true;
      }
      this.bumpSpace();
      var openingBracePosition = this.clonePosition();
      if (!this.bumpIf("{")) {
        return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
      }
      var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
      if (fragmentResult.err) {
        return fragmentResult;
      }
      var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
      if (argCloseResult.err) {
        return argCloseResult;
      }
      options.push([
        selector,
        {
          value: fragmentResult.val,
          location: createLocation(openingBracePosition, this.clonePosition())
        }
      ]);
      parsedSelectors.add(selector);
      this.bumpSpace();
      _a2 = this.parseIdentifierIfPossible(), selector = _a2.value, selectorLocation = _a2.location;
    }
    if (options.length === 0) {
      return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
    }
    if (this.requiresOtherClause && !hasOtherClause) {
      return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
    }
    return { val: options, err: null };
  };
  Parser3.prototype.tryParseDecimalInteger = function(expectNumberError, invalidNumberError) {
    var sign11 = 1;
    var startingPosition = this.clonePosition();
    if (this.bumpIf("+")) {
    } else if (this.bumpIf("-")) {
      sign11 = -1;
    }
    var hasDigits = false;
    var decimal = 0;
    while (!this.isEOF()) {
      var ch = this.char();
      if (ch >= 48 && ch <= 57) {
        hasDigits = true;
        decimal = decimal * 10 + (ch - 48);
        this.bump();
      } else {
        break;
      }
    }
    var location = createLocation(startingPosition, this.clonePosition());
    if (!hasDigits) {
      return this.error(expectNumberError, location);
    }
    decimal *= sign11;
    if (!isSafeInteger(decimal)) {
      return this.error(invalidNumberError, location);
    }
    return { val: decimal, err: null };
  };
  Parser3.prototype.offset = function() {
    return this.position.offset;
  };
  Parser3.prototype.isEOF = function() {
    return this.offset() === this.message.length;
  };
  Parser3.prototype.clonePosition = function() {
    return {
      offset: this.position.offset,
      line: this.position.line,
      column: this.position.column
    };
  };
  Parser3.prototype.char = function() {
    var offset = this.position.offset;
    if (offset >= this.message.length) {
      throw Error("out of bound");
    }
    var code = codePointAt(this.message, offset);
    if (code === void 0) {
      throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
    }
    return code;
  };
  Parser3.prototype.error = function(kind, location) {
    return {
      val: null,
      err: {
        kind,
        message: this.message,
        location
      }
    };
  };
  Parser3.prototype.bump = function() {
    if (this.isEOF()) {
      return;
    }
    var code = this.char();
    if (code === 10) {
      this.position.line += 1;
      this.position.column = 1;
      this.position.offset += 1;
    } else {
      this.position.column += 1;
      this.position.offset += code < 65536 ? 1 : 2;
    }
  };
  Parser3.prototype.bumpIf = function(prefix) {
    if (startsWith(this.message, prefix, this.offset())) {
      for (var i2 = 0; i2 < prefix.length; i2++) {
        this.bump();
      }
      return true;
    }
    return false;
  };
  Parser3.prototype.bumpUntil = function(pattern) {
    var currentOffset = this.offset();
    var index = this.message.indexOf(pattern, currentOffset);
    if (index >= 0) {
      this.bumpTo(index);
      return true;
    } else {
      this.bumpTo(this.message.length);
      return false;
    }
  };
  Parser3.prototype.bumpTo = function(targetOffset) {
    if (this.offset() > targetOffset) {
      throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
    }
    targetOffset = Math.min(targetOffset, this.message.length);
    while (true) {
      var offset = this.offset();
      if (offset === targetOffset) {
        break;
      }
      if (offset > targetOffset) {
        throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
      }
      this.bump();
      if (this.isEOF()) {
        break;
      }
    }
  };
  Parser3.prototype.bumpSpace = function() {
    while (!this.isEOF() && _isWhiteSpace(this.char())) {
      this.bump();
    }
  };
  Parser3.prototype.peek = function() {
    if (this.isEOF()) {
      return null;
    }
    var code = this.char();
    var offset = this.offset();
    var nextCode = this.message.charCodeAt(offset + (code >= 65536 ? 2 : 1));
    return nextCode !== null && nextCode !== void 0 ? nextCode : null;
  };
  return Parser3;
}();
function _isAlpha(codepoint) {
  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
}
function _isAlphaOrSlash(codepoint) {
  return _isAlpha(codepoint) || codepoint === 47;
}
function _isPotentialElementNameChar(c2) {
  return c2 === 45 || c2 === 46 || c2 >= 48 && c2 <= 57 || c2 === 95 || c2 >= 97 && c2 <= 122 || c2 >= 65 && c2 <= 90 || c2 == 183 || c2 >= 192 && c2 <= 214 || c2 >= 216 && c2 <= 246 || c2 >= 248 && c2 <= 893 || c2 >= 895 && c2 <= 8191 || c2 >= 8204 && c2 <= 8205 || c2 >= 8255 && c2 <= 8256 || c2 >= 8304 && c2 <= 8591 || c2 >= 11264 && c2 <= 12271 || c2 >= 12289 && c2 <= 55295 || c2 >= 63744 && c2 <= 64975 || c2 >= 65008 && c2 <= 65533 || c2 >= 65536 && c2 <= 983039;
}
function _isWhiteSpace(c2) {
  return c2 >= 9 && c2 <= 13 || c2 === 32 || c2 === 133 || c2 >= 8206 && c2 <= 8207 || c2 === 8232 || c2 === 8233;
}
function _isPatternSyntax(c2) {
  return c2 >= 33 && c2 <= 35 || c2 === 36 || c2 >= 37 && c2 <= 39 || c2 === 40 || c2 === 41 || c2 === 42 || c2 === 43 || c2 === 44 || c2 === 45 || c2 >= 46 && c2 <= 47 || c2 >= 58 && c2 <= 59 || c2 >= 60 && c2 <= 62 || c2 >= 63 && c2 <= 64 || c2 === 91 || c2 === 92 || c2 === 93 || c2 === 94 || c2 === 96 || c2 === 123 || c2 === 124 || c2 === 125 || c2 === 126 || c2 === 161 || c2 >= 162 && c2 <= 165 || c2 === 166 || c2 === 167 || c2 === 169 || c2 === 171 || c2 === 172 || c2 === 174 || c2 === 176 || c2 === 177 || c2 === 182 || c2 === 187 || c2 === 191 || c2 === 215 || c2 === 247 || c2 >= 8208 && c2 <= 8213 || c2 >= 8214 && c2 <= 8215 || c2 === 8216 || c2 === 8217 || c2 === 8218 || c2 >= 8219 && c2 <= 8220 || c2 === 8221 || c2 === 8222 || c2 === 8223 || c2 >= 8224 && c2 <= 8231 || c2 >= 8240 && c2 <= 8248 || c2 === 8249 || c2 === 8250 || c2 >= 8251 && c2 <= 8254 || c2 >= 8257 && c2 <= 8259 || c2 === 8260 || c2 === 8261 || c2 === 8262 || c2 >= 8263 && c2 <= 8273 || c2 === 8274 || c2 === 8275 || c2 >= 8277 && c2 <= 8286 || c2 >= 8592 && c2 <= 8596 || c2 >= 8597 && c2 <= 8601 || c2 >= 8602 && c2 <= 8603 || c2 >= 8604 && c2 <= 8607 || c2 === 8608 || c2 >= 8609 && c2 <= 8610 || c2 === 8611 || c2 >= 8612 && c2 <= 8613 || c2 === 8614 || c2 >= 8615 && c2 <= 8621 || c2 === 8622 || c2 >= 8623 && c2 <= 8653 || c2 >= 8654 && c2 <= 8655 || c2 >= 8656 && c2 <= 8657 || c2 === 8658 || c2 === 8659 || c2 === 8660 || c2 >= 8661 && c2 <= 8691 || c2 >= 8692 && c2 <= 8959 || c2 >= 8960 && c2 <= 8967 || c2 === 8968 || c2 === 8969 || c2 === 8970 || c2 === 8971 || c2 >= 8972 && c2 <= 8991 || c2 >= 8992 && c2 <= 8993 || c2 >= 8994 && c2 <= 9e3 || c2 === 9001 || c2 === 9002 || c2 >= 9003 && c2 <= 9083 || c2 === 9084 || c2 >= 9085 && c2 <= 9114 || c2 >= 9115 && c2 <= 9139 || c2 >= 9140 && c2 <= 9179 || c2 >= 9180 && c2 <= 9185 || c2 >= 9186 && c2 <= 9254 || c2 >= 9255 && c2 <= 9279 || c2 >= 9280 && c2 <= 9290 || c2 >= 9291 && c2 <= 9311 || c2 >= 9472 && c2 <= 9654 || c2 === 9655 || c2 >= 9656 && c2 <= 9664 || c2 === 9665 || c2 >= 9666 && c2 <= 9719 || c2 >= 9720 && c2 <= 9727 || c2 >= 9728 && c2 <= 9838 || c2 === 9839 || c2 >= 9840 && c2 <= 10087 || c2 === 10088 || c2 === 10089 || c2 === 10090 || c2 === 10091 || c2 === 10092 || c2 === 10093 || c2 === 10094 || c2 === 10095 || c2 === 10096 || c2 === 10097 || c2 === 10098 || c2 === 10099 || c2 === 10100 || c2 === 10101 || c2 >= 10132 && c2 <= 10175 || c2 >= 10176 && c2 <= 10180 || c2 === 10181 || c2 === 10182 || c2 >= 10183 && c2 <= 10213 || c2 === 10214 || c2 === 10215 || c2 === 10216 || c2 === 10217 || c2 === 10218 || c2 === 10219 || c2 === 10220 || c2 === 10221 || c2 === 10222 || c2 === 10223 || c2 >= 10224 && c2 <= 10239 || c2 >= 10240 && c2 <= 10495 || c2 >= 10496 && c2 <= 10626 || c2 === 10627 || c2 === 10628 || c2 === 10629 || c2 === 10630 || c2 === 10631 || c2 === 10632 || c2 === 10633 || c2 === 10634 || c2 === 10635 || c2 === 10636 || c2 === 10637 || c2 === 10638 || c2 === 10639 || c2 === 10640 || c2 === 10641 || c2 === 10642 || c2 === 10643 || c2 === 10644 || c2 === 10645 || c2 === 10646 || c2 === 10647 || c2 === 10648 || c2 >= 10649 && c2 <= 10711 || c2 === 10712 || c2 === 10713 || c2 === 10714 || c2 === 10715 || c2 >= 10716 && c2 <= 10747 || c2 === 10748 || c2 === 10749 || c2 >= 10750 && c2 <= 11007 || c2 >= 11008 && c2 <= 11055 || c2 >= 11056 && c2 <= 11076 || c2 >= 11077 && c2 <= 11078 || c2 >= 11079 && c2 <= 11084 || c2 >= 11085 && c2 <= 11123 || c2 >= 11124 && c2 <= 11125 || c2 >= 11126 && c2 <= 11157 || c2 === 11158 || c2 >= 11159 && c2 <= 11263 || c2 >= 11776 && c2 <= 11777 || c2 === 11778 || c2 === 11779 || c2 === 11780 || c2 === 11781 || c2 >= 11782 && c2 <= 11784 || c2 === 11785 || c2 === 11786 || c2 === 11787 || c2 === 11788 || c2 === 11789 || c2 >= 11790 && c2 <= 11798 || c2 === 11799 || c2 >= 11800 && c2 <= 11801 || c2 === 11802 || c2 === 11803 || c2 === 11804 || c2 === 11805 || c2 >= 11806 && c2 <= 11807 || c2 === 11808 || c2 === 11809 || c2 === 11810 || c2 === 11811 || c2 === 11812 || c2 === 11813 || c2 === 11814 || c2 === 11815 || c2 === 11816 || c2 === 11817 || c2 >= 11818 && c2 <= 11822 || c2 === 11823 || c2 >= 11824 && c2 <= 11833 || c2 >= 11834 && c2 <= 11835 || c2 >= 11836 && c2 <= 11839 || c2 === 11840 || c2 === 11841 || c2 === 11842 || c2 >= 11843 && c2 <= 11855 || c2 >= 11856 && c2 <= 11857 || c2 === 11858 || c2 >= 11859 && c2 <= 11903 || c2 >= 12289 && c2 <= 12291 || c2 === 12296 || c2 === 12297 || c2 === 12298 || c2 === 12299 || c2 === 12300 || c2 === 12301 || c2 === 12302 || c2 === 12303 || c2 === 12304 || c2 === 12305 || c2 >= 12306 && c2 <= 12307 || c2 === 12308 || c2 === 12309 || c2 === 12310 || c2 === 12311 || c2 === 12312 || c2 === 12313 || c2 === 12314 || c2 === 12315 || c2 === 12316 || c2 === 12317 || c2 >= 12318 && c2 <= 12319 || c2 === 12320 || c2 === 12336 || c2 === 64830 || c2 === 64831 || c2 >= 65093 && c2 <= 65094;
}

// node_modules/@formatjs/icu-messageformat-parser/lib/index.js
function pruneLocation(els) {
  els.forEach(function(el) {
    delete el.location;
    if (isSelectElement(el) || isPluralElement(el)) {
      for (var k2 in el.options) {
        delete el.options[k2].location;
        pruneLocation(el.options[k2].value);
      }
    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
      delete el.style.location;
    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {
      delete el.style.location;
    } else if (isTagElement(el)) {
      pruneLocation(el.children);
    }
  });
}
function parse3(message, opts) {
  if (opts === void 0) {
    opts = {};
  }
  opts = __assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
  var result = new Parser2(message, opts).parse();
  if (result.err) {
    var error = SyntaxError(ErrorKind[result.err.kind]);
    error.location = result.err.location;
    error.originalMessage = result.err.message;
    throw error;
  }
  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
    pruneLocation(result.val);
  }
  return result.val;
}

// node_modules/@formatjs/fast-memoize/lib/index.js
init_define_process_env();
function memoize(fn, options) {
  var cache = options && options.cache ? options.cache : cacheDefault;
  var serializer = options && options.serializer ? options.serializer : serializerDefault;
  var strategy = options && options.strategy ? options.strategy : strategyDefault;
  return strategy(fn, {
    cache,
    serializer
  });
}
function isPrimitive(value) {
  return value == null || typeof value === "number" || typeof value === "boolean";
}
function monadic(fn, cache, serializer, arg) {
  var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
  var computedValue = cache.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn.call(this, arg);
    cache.set(cacheKey, computedValue);
  }
  return computedValue;
}
function variadic(fn, cache, serializer) {
  var args = Array.prototype.slice.call(arguments, 3);
  var cacheKey = serializer(args);
  var computedValue = cache.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn.apply(this, args);
    cache.set(cacheKey, computedValue);
  }
  return computedValue;
}
function assemble(fn, context2, strategy, cache, serialize3) {
  return strategy.bind(context2, fn, cache, serialize3);
}
function strategyDefault(fn, options) {
  var strategy = fn.length === 1 ? monadic : variadic;
  return assemble(fn, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn, options) {
  return assemble(fn, this, variadic, options.cache.create(), options.serializer);
}
function strategyMonadic(fn, options) {
  return assemble(fn, this, monadic, options.cache.create(), options.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(key6) {
  return this.cache[key6];
};
ObjectWithoutPrototypeCache.prototype.set = function(key6, value) {
  this.cache[key6] = value;
};
var cacheDefault = {
  create: function create() {
    return new ObjectWithoutPrototypeCache();
  }
};
var strategies = {
  variadic: strategyVariadic,
  monadic: strategyMonadic
};

// node_modules/intl-messageformat/lib/src/formatters.js
init_define_process_env();

// node_modules/intl-messageformat/lib/src/error.js
init_define_process_env();
var ErrorCode24;
(function(ErrorCode25) {
  ErrorCode25["MISSING_VALUE"] = "MISSING_VALUE";
  ErrorCode25["INVALID_VALUE"] = "INVALID_VALUE";
  ErrorCode25["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode24 || (ErrorCode24 = {}));
var FormatError = function(_super) {
  __extends(FormatError2, _super);
  function FormatError2(msg, code, originalMessage) {
    var _this = _super.call(this, msg) || this;
    _this.code = code;
    _this.originalMessage = originalMessage;
    return _this;
  }
  FormatError2.prototype.toString = function() {
    return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
  };
  return FormatError2;
}(Error);
var InvalidValueError = function(_super) {
  __extends(InvalidValueError2, _super);
  function InvalidValueError2(variableId, value, options, originalMessage) {
    return _super.call(this, 'Invalid values for "'.concat(variableId, '": "').concat(value, '". Options are "').concat(Object.keys(options).join('", "'), '"'), ErrorCode24.INVALID_VALUE, originalMessage) || this;
  }
  return InvalidValueError2;
}(FormatError);
var InvalidValueTypeError = function(_super) {
  __extends(InvalidValueTypeError2, _super);
  function InvalidValueTypeError2(value, type, originalMessage) {
    return _super.call(this, 'Value for "'.concat(value, '" must be of type ').concat(type), ErrorCode24.INVALID_VALUE, originalMessage) || this;
  }
  return InvalidValueTypeError2;
}(FormatError);
var MissingValueError = function(_super) {
  __extends(MissingValueError2, _super);
  function MissingValueError2(variableId, originalMessage) {
    return _super.call(this, 'The intl string context variable "'.concat(variableId, '" was not provided to the string "').concat(originalMessage, '"'), ErrorCode24.MISSING_VALUE, originalMessage) || this;
  }
  return MissingValueError2;
}(FormatError);

// node_modules/intl-messageformat/lib/src/formatters.js
var PART_TYPE;
(function(PART_TYPE2) {
  PART_TYPE2[PART_TYPE2["literal"] = 0] = "literal";
  PART_TYPE2[PART_TYPE2["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
  if (parts.length < 2) {
    return parts;
  }
  return parts.reduce(function(all, part) {
    var lastPart = all[all.length - 1];
    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
      all.push(part);
    } else {
      lastPart.value += part.value;
    }
    return all;
  }, []);
}
function isFormatXMLElementFn(el) {
  return typeof el === "function";
}
function formatToParts(els, locales, formatters, formats, values, currentPluralValue, originalMessage) {
  if (els.length === 1 && isLiteralElement(els[0])) {
    return [
      {
        type: PART_TYPE.literal,
        value: els[0].value
      }
    ];
  }
  var result = [];
  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
    var el = els_1[_i];
    if (isLiteralElement(el)) {
      result.push({
        type: PART_TYPE.literal,
        value: el.value
      });
      continue;
    }
    if (isPoundElement(el)) {
      if (typeof currentPluralValue === "number") {
        result.push({
          type: PART_TYPE.literal,
          value: formatters.getNumberFormat(locales).format(currentPluralValue)
        });
      }
      continue;
    }
    var varName = el.value;
    if (!(values && varName in values)) {
      throw new MissingValueError(varName, originalMessage);
    }
    var value = values[varName];
    if (isArgumentElement(el)) {
      if (!value || typeof value === "string" || typeof value === "number") {
        value = typeof value === "string" || typeof value === "number" ? String(value) : "";
      }
      result.push({
        type: typeof value === "string" ? PART_TYPE.literal : PART_TYPE.object,
        value
      });
      continue;
    }
    if (isDateElement(el)) {
      var style = typeof el.style === "string" ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTimeElement(el)) {
      var style = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isNumberElement(el)) {
      var style = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : void 0;
      if (style && style.scale) {
        value = value * (style.scale || 1);
      }
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getNumberFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTagElement(el)) {
      var children2 = el.children, value_1 = el.value;
      var formatFn = values[value_1];
      if (!isFormatXMLElementFn(formatFn)) {
        throw new InvalidValueTypeError(value_1, "function", originalMessage);
      }
      var parts = formatToParts(children2, locales, formatters, formats, values, currentPluralValue);
      var chunks = formatFn(parts.map(function(p2) {
        return p2.value;
      }));
      if (!Array.isArray(chunks)) {
        chunks = [chunks];
      }
      result.push.apply(result, chunks.map(function(c2) {
        return {
          type: typeof c2 === "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: c2
        };
      }));
    }
    if (isSelectElement(el)) {
      var opt = el.options[value] || el.options.other;
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
      continue;
    }
    if (isPluralElement(el)) {
      var opt = el.options["=".concat(value)];
      if (!opt) {
        if (!Intl.PluralRules) {
          throw new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode24.MISSING_INTL_API, originalMessage);
        }
        var rule = formatters.getPluralRules(locales, { type: el.pluralType }).select(value - (el.offset || 0));
        opt = el.options[rule] || el.options.other;
      }
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(result);
}

// node_modules/intl-messageformat/lib/src/core.js
function mergeConfig(c1, c2) {
  if (!c2) {
    return c1;
  }
  return __assign(__assign(__assign({}, c1 || {}), c2 || {}), Object.keys(c1).reduce(function(all, k2) {
    all[k2] = __assign(__assign({}, c1[k2]), c2[k2] || {});
    return all;
  }, {}));
}
function mergeConfigs(defaultConfig, configs) {
  if (!configs) {
    return defaultConfig;
  }
  return Object.keys(defaultConfig).reduce(function(all, k2) {
    all[k2] = mergeConfig(defaultConfig[k2], configs[k2]);
    return all;
  }, __assign({}, defaultConfig));
}
function createFastMemoizeCache(store) {
  return {
    create: function() {
      return {
        get: function(key6) {
          return store[key6];
        },
        set: function(key6, value) {
          store[key6] = value;
        }
      };
    }
  };
}
function createDefaultFormatters(cache) {
  if (cache === void 0) {
    cache = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
  }
  return {
    getNumberFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = function() {
  function IntlMessageFormat2(message, locales, overrideFormats, opts) {
    var _this = this;
    if (locales === void 0) {
      locales = IntlMessageFormat2.defaultLocale;
    }
    this.formatterCache = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
    this.format = function(values) {
      var parts = _this.formatToParts(values);
      if (parts.length === 1) {
        return parts[0].value;
      }
      var result = parts.reduce(function(all, part) {
        if (!all.length || part.type !== PART_TYPE.literal || typeof all[all.length - 1] !== "string") {
          all.push(part.value);
        } else {
          all[all.length - 1] += part.value;
        }
        return all;
      }, []);
      if (result.length <= 1) {
        return result[0] || "";
      }
      return result;
    };
    this.formatToParts = function(values) {
      return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, void 0, _this.message);
    };
    this.resolvedOptions = function() {
      return {
        locale: Intl.NumberFormat.supportedLocalesOf(_this.locales)[0]
      };
    };
    this.getAst = function() {
      return _this.ast;
    };
    if (typeof message === "string") {
      this.message = message;
      if (!IntlMessageFormat2.__parse) {
        throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
      }
      this.ast = IntlMessageFormat2.__parse(message, {
        ignoreTag: opts === null || opts === void 0 ? void 0 : opts.ignoreTag
      });
    } else {
      this.ast = message;
    }
    if (!Array.isArray(this.ast)) {
      throw new TypeError("A message must be provided as a String or AST.");
    }
    this.formats = mergeConfigs(IntlMessageFormat2.formats, overrideFormats);
    this.locales = locales;
    this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
  }
  Object.defineProperty(IntlMessageFormat2, "defaultLocale", {
    get: function() {
      if (!IntlMessageFormat2.memoizedDefaultLocale) {
        IntlMessageFormat2.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
      }
      return IntlMessageFormat2.memoizedDefaultLocale;
    },
    enumerable: false,
    configurable: true
  });
  IntlMessageFormat2.memoizedDefaultLocale = null;
  IntlMessageFormat2.__parse = parse3;
  IntlMessageFormat2.formats = {
    number: {
      integer: {
        maximumFractionDigits: 0
      },
      currency: {
        style: "currency"
      },
      percent: {
        style: "percent"
      }
    },
    date: {
      short: {
        month: "numeric",
        day: "numeric",
        year: "2-digit"
      },
      medium: {
        month: "short",
        day: "numeric",
        year: "numeric"
      },
      long: {
        month: "long",
        day: "numeric",
        year: "numeric"
      },
      full: {
        weekday: "long",
        month: "long",
        day: "numeric",
        year: "numeric"
      }
    },
    time: {
      short: {
        hour: "numeric",
        minute: "numeric"
      },
      medium: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric"
      },
      long: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        timeZoneName: "short"
      },
      full: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        timeZoneName: "short"
      }
    }
  };
  return IntlMessageFormat2;
}();

// node_modules/intl-messageformat/lib/index.js
var lib_default = IntlMessageFormat;

// node_modules/svelte-i18n/dist/runtime.esm.js
var r = {};
var i = (e, n, t2) => t2 ? (n in r || (r[n] = {}), e in r[n] || (r[n][e] = t2), t2) : t2;
var l = (e, n) => {
  if (n == null)
    return;
  if (n in r && e in r[n])
    return r[n][e];
  const t2 = E(n);
  for (let o = 0; o < t2.length; o++) {
    const r2 = c(t2[o], e);
    if (r2)
      return i(e, n, r2);
  }
};
var a;
var s = writable({});
function u(e) {
  return e in a;
}
function c(e, n) {
  if (!u(e))
    return null;
  return function(e2, n2) {
    if (n2 == null)
      return;
    if (n2 in e2)
      return e2[n2];
    const t2 = n2.split(".");
    let o = e2;
    for (let e3 = 0; e3 < t2.length; e3++)
      if (typeof o == "object") {
        if (e3 > 0) {
          const n3 = t2.slice(e3, t2.length).join(".");
          if (n3 in o) {
            o = o[n3];
            break;
          }
        }
        o = o[t2[e3]];
      } else
        o = void 0;
    return o;
  }(function(e2) {
    return a[e2] || null;
  }(e), n);
}
function m(e, ...n) {
  delete r[e], s.update((o) => (o[e] = import_deepmerge.default.all([o[e] || {}, ...n]), o));
}
var f = derived([s], ([e]) => Object.keys(e));
s.subscribe((e) => a = e);
var d = {};
function g(e) {
  return d[e];
}
function w(e) {
  return e != null && E(e).some((e2) => {
    var n;
    return (n = g(e2)) === null || n === void 0 ? void 0 : n.size;
  });
}
function h(e, n) {
  return Promise.all(n.map((n2) => (function(e2, n3) {
    d[e2].delete(n3), d[e2].size === 0 && delete d[e2];
  }(e, n2), n2().then((e2) => e2.default || e2)))).then((n2) => m(e, ...n2));
}
var p = {};
function b(e) {
  if (!w(e))
    return e in p ? p[e] : Promise.resolve();
  const n = function(e2) {
    return E(e2).map((e3) => {
      const n2 = g(e3);
      return [e3, n2 ? [...n2] : []];
    }).filter(([, e3]) => e3.length > 0);
  }(e);
  return p[e] = Promise.all(n.map(([e2, n2]) => h(e2, n2))).then(() => {
    if (w(e))
      return b(e);
    delete p[e];
  }), p[e];
}
function v(e, n) {
  var t2 = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && n.indexOf(o) < 0 && (t2[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") {
    var r2 = 0;
    for (o = Object.getOwnPropertySymbols(e); r2 < o.length; r2++)
      n.indexOf(o[r2]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r2]) && (t2[o[r2]] = e[o[r2]]);
  }
  return t2;
}
var O = { fallbackLocale: null, loadingDelay: 200, formats: { number: { scientific: { notation: "scientific" }, engineering: { notation: "engineering" }, compactLong: { notation: "compact", compactDisplay: "long" }, compactShort: { notation: "compact", compactDisplay: "short" } }, date: { short: { month: "numeric", day: "numeric", year: "2-digit" }, medium: { month: "short", day: "numeric", year: "numeric" }, long: { month: "long", day: "numeric", year: "numeric" }, full: { weekday: "long", month: "long", day: "numeric", year: "numeric" } }, time: { short: { hour: "numeric", minute: "numeric" }, medium: { hour: "numeric", minute: "numeric", second: "numeric" }, long: { hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "short" }, full: { hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "short" } } }, warnOnMissingMessages: true, ignoreTag: true };
function j() {
  return O;
}
function $(e) {
  const { formats: n } = e, t2 = v(e, ["formats"]), o = e.initialLocale || e.fallbackLocale;
  return Object.assign(O, t2, { initialLocale: o }), n && ("number" in n && Object.assign(O.formats.number, n.number), "date" in n && Object.assign(O.formats.date, n.date), "time" in n && Object.assign(O.formats.time, n.time)), M.set(o);
}
var k = writable(false);
var L;
var T = writable(null);
function x(e) {
  return e.split("-").map((e2, n, t2) => t2.slice(0, n + 1).join("-")).reverse();
}
function E(e, n = j().fallbackLocale) {
  const t2 = x(e);
  return n ? [.../* @__PURE__ */ new Set([...t2, ...x(n)])] : t2;
}
function D() {
  return L != null ? L : void 0;
}
T.subscribe((e) => {
  L = e != null ? e : void 0, typeof window != "undefined" && e != null && document.documentElement.setAttribute("lang", e);
});
var M = Object.assign(Object.assign({}, T), { set: (e) => {
  if (e && function(e2) {
    if (e2 == null)
      return;
    const n = E(e2);
    for (let e3 = 0; e3 < n.length; e3++) {
      const t2 = n[e3];
      if (u(t2))
        return t2;
    }
  }(e) && w(e)) {
    const { loadingDelay: n } = j();
    let t2;
    return typeof window != "undefined" && D() != null && n ? t2 = window.setTimeout(() => k.set(true), n) : k.set(true), b(e).then(() => {
      T.set(e);
    }).finally(() => {
      clearTimeout(t2), k.set(false);
    });
  }
  return T.set(e);
} });
var I = () => typeof window == "undefined" ? null : window.navigator.language || window.navigator.languages[0];
var Z = (e) => {
  const n = /* @__PURE__ */ Object.create(null);
  return (t2) => {
    const o = JSON.stringify(t2);
    return o in n ? n[o] : n[o] = e(t2);
  };
};
var C = (e, n) => {
  const { formats: t2 } = j();
  if (e in t2 && n in t2[e])
    return t2[e][n];
  throw new Error(`[svelte-i18n] Unknown "${n}" ${e} format.`);
};
var G = Z((e) => {
  var { locale: n, format: t2 } = e, o = v(e, ["locale", "format"]);
  if (n == null)
    throw new Error('[svelte-i18n] A "locale" must be set to format numbers');
  return t2 && (o = C("number", t2)), new Intl.NumberFormat(n, o);
});
var J = Z((e) => {
  var { locale: n, format: t2 } = e, o = v(e, ["locale", "format"]);
  if (n == null)
    throw new Error('[svelte-i18n] A "locale" must be set to format dates');
  return t2 ? o = C("date", t2) : Object.keys(o).length === 0 && (o = C("date", "short")), new Intl.DateTimeFormat(n, o);
});
var U = Z((e) => {
  var { locale: n, format: t2 } = e, o = v(e, ["locale", "format"]);
  if (n == null)
    throw new Error('[svelte-i18n] A "locale" must be set to format time values');
  return t2 ? o = C("time", t2) : Object.keys(o).length === 0 && (o = C("time", "short")), new Intl.DateTimeFormat(n, o);
});
var _ = (e = {}) => {
  var { locale: n = D() } = e, t2 = v(e, ["locale"]);
  return G(Object.assign({ locale: n }, t2));
};
var q = (e = {}) => {
  var { locale: n = D() } = e, t2 = v(e, ["locale"]);
  return J(Object.assign({ locale: n }, t2));
};
var B = (e = {}) => {
  var { locale: n = D() } = e, t2 = v(e, ["locale"]);
  return U(Object.assign({ locale: n }, t2));
};
var H = Z((e, n = D()) => new lib_default(e, n, j().formats, { ignoreTag: j().ignoreTag }));
var K = (e, n = {}) => {
  let t2 = n;
  typeof e == "object" && (t2 = e, e = t2.id);
  const { values: o, locale: r2 = D(), default: i2 } = t2;
  if (r2 == null)
    throw new Error("[svelte-i18n] Cannot format a message without first setting the initial locale.");
  let a2 = l(e, r2);
  if (a2) {
    if (typeof a2 != "string")
      return console.warn(`[svelte-i18n] Message with id "${e}" must be of type "string", found: "${typeof a2}". Gettin its value through the "$format" method is deprecated; use the "json" method instead.`), a2;
  } else
    j().warnOnMissingMessages && console.warn(`[svelte-i18n] The message "${e}" was not found in "${E(r2).join('", "')}".${w(D()) ? "\n\nNote: there are at least one loader still registered to this locale that wasn't executed." : ""}`), a2 = i2 != null ? i2 : e;
  if (!o)
    return a2;
  let s2 = a2;
  try {
    s2 = H(a2, r2).format(o);
  } catch (n2) {
    console.warn(`[svelte-i18n] Message "${e}" has syntax error:`, n2.message);
  }
  return s2;
};
var Q = (e, n) => B(n).format(e);
var R = (e, n) => q(n).format(e);
var V = (e, n) => _(n).format(e);
var W = (e, n = D()) => l(e, n);
var X = derived([M, s], () => K);
var Y = derived([M], () => Q);
var ee = derived([M], () => R);
var ne = derived([M], () => V);
var te = derived([M, s], () => W);

// node_modules/@web3-onboard/core/dist/index.js
var import_lodash2 = __toESM(require_lodash());
var import_eventemitter3 = __toESM(require_eventemitter3());
var ADD_CHAINS = "add_chains";
var RESET_STORE = "reset_store";
var ADD_WALLET = "add_wallet";
var UPDATE_WALLET = "update_wallet";
var REMOVE_WALLET = "remove_wallet";
var UPDATE_ACCOUNT = "update_account";
var SET_WALLET_MODULES = "set_wallet_modules";
var APP_INITIAL_STATE = {
  chains: [],
  walletModules: [],
  wallets: []
};
var STORAGE_KEYS = {
  TERMS_AGREEMENT: "onboard.js:agreement"
};
var notNullish = (value) => value != null;
function getDeviceInfo() {
  const parsed = bowser_default.getParser(window.navigator.userAgent);
  const os = parsed.getOS();
  const browser = parsed.getBrowser();
  const { type } = parsed.getPlatform();
  return {
    type,
    os,
    browser
  };
}
function validEnsChain(chainId2) {
  switch (chainId2) {
    case "0x1":
    case "0x3":
    case "0x4":
    case "0x5":
      return true;
    default:
      return false;
  }
}
function isSVG(str) {
  return str.includes("<svg");
}
function initializeWalletModules(modules, device) {
  return modules.reduce((acc, walletInit2) => {
    const initialized = walletInit2({ device });
    if (initialized) {
      acc.push(...Array.isArray(initialized) ? initialized : [initialized]);
    }
    return acc;
  }, []);
}
function reducer(state2, action) {
  const { type, payload } = action;
  switch (type) {
    case ADD_CHAINS:
      return __spreadProps(__spreadValues({}, state2), {
        chains: [...state2.chains, ...payload]
      });
    case ADD_WALLET: {
      const wallet2 = payload;
      const existingWallet = state2.wallets.find(({ label }) => label === wallet2.label);
      return __spreadProps(__spreadValues({}, state2), {
        wallets: [
          existingWallet || payload,
          ...state2.wallets.filter(({ label }) => label !== wallet2.label)
        ]
      });
    }
    case UPDATE_WALLET: {
      const update7 = payload;
      const _a2 = update7, { id: id7 } = _a2, walletUpdate = __objRest(_a2, ["id"]);
      const updatedWallets = state2.wallets.map((wallet2) => wallet2.label === id7 ? __spreadValues(__spreadValues({}, wallet2), walletUpdate) : wallet2);
      return __spreadProps(__spreadValues({}, state2), {
        wallets: updatedWallets
      });
    }
    case REMOVE_WALLET: {
      const update7 = payload;
      return __spreadProps(__spreadValues({}, state2), {
        wallets: state2.wallets.filter(({ label }) => label !== update7.id)
      });
    }
    case UPDATE_ACCOUNT: {
      const update7 = payload;
      const _b = update7, { id: id7, address } = _b, accountUpdate = __objRest(_b, ["id", "address"]);
      const updatedWallets = state2.wallets.map((wallet2) => {
        if (wallet2.label === id7) {
          wallet2.accounts = wallet2.accounts.map((account2) => {
            if (account2.address === address) {
              return __spreadValues(__spreadValues({}, account2), accountUpdate);
            }
            return account2;
          });
        }
        return wallet2;
      });
      return __spreadProps(__spreadValues({}, state2), {
        wallets: updatedWallets
      });
    }
    case SET_WALLET_MODULES: {
      return __spreadProps(__spreadValues({}, state2), {
        walletModules: payload
      });
    }
    case RESET_STORE:
      return APP_INITIAL_STATE;
    default:
      throw new Error(`Unknown type: ${type} in appStore reducer`);
  }
}
var _store = new BehaviorSubject(APP_INITIAL_STATE);
var _stateUpdates = new Subject();
_stateUpdates.subscribe(_store);
function dispatch$1(action) {
  const state2 = _store.getValue();
  _stateUpdates.next(reducer(state2, action));
}
function select(stateKey) {
  if (!stateKey)
    return _stateUpdates.asObservable();
  const validStateKeys = Object.keys(_store.getValue());
  if (!validStateKeys.includes(String(stateKey))) {
    throw new Error(`key: ${stateKey} does not exist on this store`);
  }
  return _stateUpdates.asObservable().pipe(distinctUntilKeyChanged(stateKey), pluck(stateKey), filter(notNullish));
}
function get() {
  return _store.getValue();
}
var state = {
  select,
  get
};
function noop3() {
}
var identity2 = (x2) => x2;
function assign(tar, src) {
  for (const k2 in src)
    tar[k2] = src[k2];
  return tar;
}
function is_promise(value) {
  return value && typeof value === "object" && typeof value.then === "function";
}
function run2(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all2(fns) {
  fns.forEach(run2);
}
function is_function2(thing) {
  return typeof thing === "function";
}
function safe_not_equal2(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty2(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe2(store, ...callbacks) {
  if (store == null) {
    return noop3;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe2(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i2 = 0; i2 < len; i2 += 1) {
        merged[i2] = $$scope.dirty[i2] | lets[i2];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i2 = 0; i2 < length; i2++) {
      dirty[i2] = -1;
    }
    return dirty;
  }
  return -1;
}
var is_client = typeof window !== "undefined";
var now2 = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop3;
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now3) {
  tasks.forEach((task) => {
    if (!task.c(now3)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element(name2) {
  return document.createElement(name2);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty2() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_style(node, key6, value, important) {
  if (value === null) {
    node.style.removeProperty(key6);
  } else {
    node.style.setProperty(key6, value, important ? "important" : "");
  }
}
function toggle_class(element2, name2, toggle) {
  element2.classList[toggle ? "add" : "remove"](name2);
}
function custom_event(type, detail, bubbles = false) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, false, detail);
  return e;
}
var HtmlTag = class {
  constructor() {
    this.e = this.n = null;
  }
  c(html) {
    this.h(html);
  }
  m(html, target, anchor = null) {
    if (!this.e) {
      this.e = element(target.nodeName);
      this.t = target;
      this.c(html);
    }
    this.i(anchor);
  }
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(this.e.childNodes);
  }
  i(anchor) {
    for (let i2 = 0; i2 < this.n.length; i2 += 1) {
      insert(this.t, this.n[i2], anchor);
    }
  }
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
};
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash10(str) {
  let hash11 = 5381;
  let i2 = str.length;
  while (i2--)
    hash11 = (hash11 << 5) - hash11 ^ str.charCodeAt(i2);
  return hash11 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a2, b2, duration, delay2, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p2 = 0; p2 <= 1; p2 += step) {
    const t2 = a2 + (b2 - a2) * ease(p2);
    keyframes += p2 * 100 + `%{${fn(t2, 1 - t2)}}
`;
  }
  const rule = keyframes + `100% {${fn(b2, 1 - b2)}}
}`;
  const name2 = `__svelte_${hash10(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name2]) {
    rules[name2] = true;
    stylesheet.insertRule(`@keyframes ${name2} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name2} ${duration}ms linear ${delay2}ms 1 both`;
  active += 1;
  return name2;
}
function delete_rule(node, name2) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(name2 ? (anim) => anim.indexOf(name2) < 0 : (anim) => anim.indexOf("__svelte") === -1);
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { stylesheet } = info;
      let i2 = stylesheet.cssRules.length;
      while (i2--)
        stylesheet.deleteRule(i2);
      info.rules = {};
    });
    managed_styles.clear();
  });
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function beforeUpdate(fn) {
  get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise2 = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise2.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update6(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update6($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all2($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all2(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}
var null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
  let config2 = fn(node, params);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function go() {
    const { delay: delay2 = 0, duration = 300, easing = identity2, tick = noop3, css } = config2 || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration, delay2, easing, css, uid++);
    tick(0, 1);
    const start_time = now2() + delay2;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, "start"));
    task = loop((now3) => {
      if (running) {
        if (now3 >= end_time) {
          tick(1, 0);
          dispatch(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now3 >= start_time) {
          const t2 = easing((now3 - start_time) / duration);
          tick(t2, 1 - t2);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function2(config2)) {
        config2 = config2();
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_bidirectional_transition(node, fn, params, intro) {
  let config2 = fn(node, params);
  let t2 = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init8(program, duration) {
    const d2 = program.b - t2;
    duration *= Math.abs(d2);
    return {
      a: t2,
      b: program.b,
      d: d2,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b2) {
    const { delay: delay2 = 0, duration = 300, easing = identity2, tick = noop3, css } = config2 || null_transition;
    const program = {
      start: now2() + delay2,
      b: b2
    };
    if (!b2) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t2, b2, duration, delay2, easing, css);
      }
      if (b2)
        tick(0, 1);
      running_program = init8(program, duration);
      add_render_callback(() => dispatch(node, b2, "start"));
      loop((now3) => {
        if (pending_program && now3 > pending_program.start) {
          running_program = init8(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t2, running_program.b, running_program.duration, 0, easing, config2.css);
          }
        }
        if (running_program) {
          if (now3 >= running_program.end) {
            tick(t2 = running_program.b, 1 - t2);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all2(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now3 >= running_program.start) {
            const p2 = now3 - running_program.start;
            t2 = running_program.a + running_program.d * easing(p2 / running_program.duration);
            tick(t2, 1 - t2);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b2) {
      if (is_function2(config2)) {
        wait().then(() => {
          config2 = config2();
          go(b2);
        });
      } else {
        go(b2);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function handle_promise(promise2, info) {
  const token = info.token = {};
  function update7(type, index, key6, value) {
    if (info.token !== token)
      return;
    info.resolved = value;
    let child_ctx = info.ctx;
    if (key6 !== void 0) {
      child_ctx = child_ctx.slice();
      child_ctx[key6] = value;
    }
    const block = type && (info.current = type)(child_ctx);
    let needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block2, i2) => {
          if (i2 !== index && block2) {
            group_outros();
            transition_out(block2, 1, 1, () => {
              if (info.blocks[i2] === block2) {
                info.blocks[i2] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block;
    if (info.blocks)
      info.blocks[index] = block;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise2)) {
    const current_component2 = get_current_component();
    promise2.then((value) => {
      set_current_component(current_component2);
      update7(info.then, 1, info.value, value);
      set_current_component(null);
    }, (error) => {
      set_current_component(current_component2);
      update7(info.catch, 2, info.error, error);
      set_current_component(null);
      if (!info.hasCatch) {
        throw error;
      }
    });
    if (info.current !== info.pending) {
      update7(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update7(info.then, 1, info.value, promise2);
      return true;
    }
    info.resolved = promise2;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  const child_ctx = ctx.slice();
  const { resolved: resolved2 } = info;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved2;
  }
  if (info.current === info.catch) {
    child_ctx[info.error] = resolved2;
  }
  info.block.p(child_ctx, dirty);
}
function bind2(component, name2, callback) {
  const index = component.$$.props[name2];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run2).filter(is_function2);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all2(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component2(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all2($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init$1(component, options, instance2, create_fragment2, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop3,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all2($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    flush();
  }
  set_current_component(parent_component);
}
var SvelteComponent = class {
  $destroy() {
    destroy_component2(this, 1);
    this.$destroy = noop3;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty2($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};
var chainId = import_joi.default.string().pattern(/^0x[0-9a-fA-F]+$/);
var chainNamespace = import_joi.default.string().valid("evm");
var unknownObject = import_joi.default.object().unknown();
var chain = import_joi.default.object({
  namespace: chainNamespace,
  id: chainId.required(),
  rpcUrl: import_joi.default.string().required(),
  label: import_joi.default.string().required(),
  token: import_joi.default.string().required()
});
var connectedChain = import_joi.default.object({
  namespace: chainNamespace.required(),
  id: chainId.required()
});
var ens = import_joi.default.any().allow(import_joi.default.object({
  name: import_joi.default.string().required(),
  avatar: import_joi.default.string(),
  contentHash: import_joi.default.any().allow(import_joi.default.string(), null),
  getText: import_joi.default.function().arity(1).required()
}), null);
var balance = import_joi.default.any().allow(import_joi.default.object({
  eth: import_joi.default.number()
}).unknown(), null);
var account = {
  address: import_joi.default.string().required(),
  ens,
  balance
};
var chains = import_joi.default.array().items(chain);
var accounts = import_joi.default.array().items(account);
var wallet = import_joi.default.object({
  label: import_joi.default.string(),
  icon: import_joi.default.string(),
  provider: unknownObject,
  instance: unknownObject,
  accounts,
  chains: import_joi.default.array().items(connectedChain)
});
var recommendedWallet = import_joi.default.object({
  name: import_joi.default.string().required(),
  url: import_joi.default.string().uri().required()
});
var agreement = import_joi.default.object({
  version: import_joi.default.string().required(),
  termsUrl: import_joi.default.string().uri(),
  privacyUrl: import_joi.default.string().uri()
});
var appMetadata = import_joi.default.object({
  name: import_joi.default.string().required(),
  description: import_joi.default.string().required(),
  icon: import_joi.default.string().required(),
  logo: import_joi.default.string(),
  gettingStartedGuide: import_joi.default.string(),
  email: import_joi.default.string(),
  appUrl: import_joi.default.string(),
  explore: import_joi.default.string(),
  recommendedInjectedWallets: import_joi.default.array().items(recommendedWallet),
  agreement
});
import_joi.default.object({
  label: import_joi.default.string().required(),
  getInfo: import_joi.default.function().arity(1).required(),
  getInterface: import_joi.default.function().arity(1).required()
});
var walletInit = import_joi.default.array().items(import_joi.default.function()).required();
var initOptions = import_joi.default.object({
  wallets: walletInit,
  chains: chains.required(),
  appMetadata,
  i18n: import_joi.default.object().unknown()
});
var connectOptions = import_joi.default.object({
  autoSelect: [
    import_joi.default.object({
      label: import_joi.default.string().required(),
      disableModals: import_joi.default.boolean()
    }),
    import_joi.default.string()
  ]
});
var disconnectOptions = import_joi.default.object({
  label: import_joi.default.string().required()
}).required();
var setChainOptions = import_joi.default.object({
  chainId: chainId.required(),
  wallet: import_joi.default.string()
});
function validate21(validator, data) {
  const result = validator.validate(data);
  return result.error ? result : null;
}
function validateWallet(data) {
  return validate21(wallet, data);
}
function validateInitOptions(data) {
  return validate21(initOptions, data);
}
function validateConnectOptions(data) {
  return validate21(connectOptions, data);
}
function validateDisconnectOptions(data) {
  return validate21(disconnectOptions, data);
}
function validateString(str) {
  return validate21(import_joi.default.string().required(), str);
}
function validateSetChainOptions(data) {
  return validate21(setChainOptions, data);
}
function validateWalletInit(data) {
  return validate21(walletInit, data);
}
function addChains(chains2) {
  const action = {
    type: ADD_CHAINS,
    payload: chains2.map((_a2) => {
      var _b = _a2, { namespace = "evm" } = _b, rest = __objRest(_b, ["namespace"]);
      return __spreadProps(__spreadValues({}, rest), {
        namespace
      });
    })
  };
  dispatch$1(action);
}
function addWallet(wallet2) {
  const error = validateWallet(wallet2);
  if (error) {
    console.error(error);
    throw error;
  }
  const action = {
    type: ADD_WALLET,
    payload: wallet2
  };
  dispatch$1(action);
}
function updateWallet(id7, update7) {
  const error = validateWallet(update7);
  if (error) {
    console.error(error);
    throw error;
  }
  const action = {
    type: UPDATE_WALLET,
    payload: __spreadValues({
      id: id7
    }, update7)
  };
  dispatch$1(action);
}
function removeWallet(id7) {
  const error = validateString(id7);
  if (error) {
    throw error;
  }
  const action = {
    type: REMOVE_WALLET,
    payload: {
      id: id7
    }
  };
  dispatch$1(action);
}
function updateAccount(id7, address, update7) {
  const action = {
    type: UPDATE_ACCOUNT,
    payload: __spreadValues({
      id: id7,
      address
    }, update7)
  };
  dispatch$1(action);
}
function resetStore() {
  const action = {
    type: RESET_STORE
  };
  dispatch$1(action);
}
function setWalletModules(wallets) {
  const error = validateWalletInit(wallets);
  if (error) {
    throw error;
  }
  const modules = initializeWalletModules(wallets, internalState$.getValue().device);
  const action = {
    type: SET_WALLET_MODULES,
    payload: modules
  };
  dispatch$1(action);
}
var reset$ = new Subject();
var disconnectWallet$ = new Subject();
var internalState$ = new BehaviorSubject({
  svelteInstance: null,
  appMetadata: null,
  device: null
});
var connectWallet$ = new BehaviorSubject({ inProgress: false, actionRequired: "" });
var switchChainModal$ = new BehaviorSubject(null);
var wallets$ = state.select("wallets").pipe(shareReplay(1));
reset$.pipe(withLatestFrom(wallets$), pluck("1")).subscribe((wallets) => {
  wallets.forEach(({ label }) => {
    disconnectWallet$.next(label);
  });
  resetStore();
});
defer(() => {
  const subject = new Subject();
  onMount(() => {
    subject.next();
  });
  return subject.asObservable().pipe(take(1));
});
var onDestroy$ = defer(() => {
  const subject = new Subject();
  onDestroy(() => {
    subject.next();
  });
  return subject.asObservable().pipe(take(1));
});
defer(() => {
  const subject = new Subject();
  afterUpdate(() => {
    subject.next();
  });
  return subject.asObservable().pipe(takeUntil(onDestroy$));
});
defer(() => {
  const subject = new Subject();
  beforeUpdate(() => {
    subject.next();
  });
  return subject.asObservable().pipe(takeUntil(onDestroy$));
});
async function connect$1(options) {
  if (options) {
    const error = validateConnectOptions(options);
    if (error) {
      throw error;
    }
  }
  const { chains: chains2 } = state.get();
  if (!chains2.length)
    throw new Error("At least one chain must be set before attempting to connect a wallet");
  const { autoSelect } = options || {
    autoSelect: { label: "", disableModals: false }
  };
  connectWallet$.next({
    autoSelect: typeof autoSelect === "string" ? { label: autoSelect, disableModals: false } : autoSelect,
    inProgress: true
  });
  const result$ = connectWallet$.pipe(filter(({ inProgress, actionRequired }) => inProgress === false && !actionRequired), withLatestFrom(wallets$), pluck(1));
  return firstValueFrom(result$);
}
async function disconnect(options) {
  const error = validateDisconnectOptions(options);
  if (error) {
    throw error;
  }
  const { label } = options;
  disconnectWallet$.next(label);
  removeWallet(label);
  return state.get().wallets;
}
var ethersProviders = {};
function requestAccounts(provider) {
  const args = { method: "eth_requestAccounts" };
  return provider.request(args);
}
function selectAccounts(provider) {
  const args = { method: "eth_selectAccounts" };
  return provider.request(args);
}
function getChainId(provider) {
  return provider.request({ method: "eth_chainId" });
}
function listenAccountsChanged(args) {
  const { provider, disconnected$ } = args;
  const addHandler = (handler) => {
    provider.on("accountsChanged", handler);
  };
  const removeHandler = (handler) => {
    provider.removeListener("accountsChanged", handler);
  };
  return fromEventPattern(addHandler, removeHandler).pipe(takeUntil(disconnected$));
}
function listenChainChanged(args) {
  const { provider, disconnected$ } = args;
  const addHandler = (handler) => {
    provider.on("chainChanged", handler);
  };
  const removeHandler = (handler) => {
    provider.removeListener("chainChanged", handler);
  };
  return fromEventPattern(addHandler, removeHandler).pipe(takeUntil(disconnected$));
}
function trackWallet(provider, label) {
  const disconnected$ = disconnectWallet$.pipe(filter((wallet2) => wallet2 === label), take(1));
  const accountsChanged$ = listenAccountsChanged({
    provider,
    disconnected$
  }).pipe(share());
  accountsChanged$.subscribe(([address]) => {
    if (!address) {
      disconnect({ label });
      return;
    }
    const { wallets } = state.get();
    const { accounts: accounts2 } = wallets.find((wallet2) => wallet2.label === label);
    const [[existingAccount], restAccounts] = (0, import_lodash.default)(accounts2, (account2) => account2.address === address);
    updateWallet(label, {
      accounts: [
        existingAccount || { address, ens: null, balance: null },
        ...restAccounts
      ]
    });
  });
  accountsChanged$.pipe(switchMap(async ([address]) => {
    if (!address)
      return;
    const { wallets, chains: chains2 } = state.get();
    const { chains: walletChains, accounts: accounts2 } = wallets.find((wallet2) => wallet2.label === label);
    const [connectedWalletChain] = walletChains;
    const chain2 = chains2.find(({ namespace, id: id7 }) => namespace === "evm" && id7 === connectedWalletChain.id);
    const balanceProm = getBalance(address, chain2);
    const account2 = accounts2.find((account3) => account3.address === address);
    const ensProm = account2.ens ? Promise.resolve(account2.ens) : validEnsChain(connectedWalletChain.id) ? getEns(address, chain2) : Promise.resolve(null);
    return Promise.all([Promise.resolve(address), balanceProm, ensProm]);
  })).subscribe((res) => {
    if (!res)
      return;
    const [address, balance2, ens2] = res;
    updateAccount(label, address, { balance: balance2, ens: ens2 });
  });
  const chainChanged$ = listenChainChanged({ provider, disconnected$ }).pipe(share());
  chainChanged$.subscribe((chainId2) => {
    const { wallets } = state.get();
    const { chains: chains2, accounts: accounts2 } = wallets.find((wallet2) => wallet2.label === label);
    const [connectedWalletChain] = chains2;
    if (chainId2 === connectedWalletChain.id)
      return;
    const resetAccounts = accounts2.map(({ address }) => ({
      address,
      ens: null,
      balance: null
    }));
    updateWallet(label, {
      chains: [{ namespace: "evm", id: chainId2 }],
      accounts: resetAccounts
    });
  });
  chainChanged$.pipe(switchMap(async (chainId2) => {
    const { wallets, chains: chains2 } = state.get();
    const { accounts: accounts2 } = wallets.find((wallet2) => wallet2.label === label);
    const chain2 = chains2.find(({ namespace, id: id7 }) => namespace === "evm" && id7 === chainId2);
    return Promise.all(accounts2.map(async ({ address }) => {
      const balanceProm = getBalance(address, chain2);
      const ensProm = validEnsChain(chainId2) ? getEns(address, chain2) : Promise.resolve(null);
      const [balance2, ens2] = await Promise.all([balanceProm, ensProm]);
      return {
        address,
        balance: balance2,
        ens: ens2
      };
    }));
  })).subscribe((updatedAccounts) => {
    updatedAccounts && updateWallet(label, { accounts: updatedAccounts });
  });
  disconnected$.subscribe(() => {
    provider.disconnect && provider.disconnect();
  });
}
async function getEns(address, chain2) {
  if (!chain2)
    return null;
  if (!ethersProviders[chain2.rpcUrl]) {
    ethersProviders[chain2.rpcUrl] = new lib_exports3.StaticJsonRpcProvider(chain2.rpcUrl);
  }
  const provider = ethersProviders[chain2.rpcUrl];
  try {
    const name2 = await provider.lookupAddress(address);
    let ens2 = null;
    if (name2) {
      const resolver = await provider.getResolver(name2);
      if (resolver) {
        const [contentHash, avatar] = await Promise.all([
          resolver.getContentHash(),
          resolver.getAvatar()
        ]);
        const getText = resolver.getText.bind(resolver);
        ens2 = {
          name: name2,
          avatar,
          contentHash,
          getText
        };
      }
    }
    return ens2;
  } catch (error) {
    console.error(error);
    return null;
  }
}
async function getBalance(address, chain2) {
  if (!chain2)
    return null;
  if (!ethersProviders[chain2.rpcUrl]) {
    ethersProviders[chain2.rpcUrl] = new lib_exports3.StaticJsonRpcProvider(chain2.rpcUrl);
  }
  const provider = ethersProviders[chain2.rpcUrl];
  try {
    const balanceWei = await provider.getBalance(address);
    return balanceWei ? { [chain2.token || "eth"]: utils_exports.formatEther(balanceWei) } : null;
  } catch (error) {
    console.error(error);
    return null;
  }
}
function switchChain(provider, chainId2) {
  return provider.request({
    method: "wallet_switchEthereumChain",
    params: [{ chainId: chainId2 }]
  });
}
function addNewChain(provider, chain2) {
  return provider.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: chain2.id,
        chainName: chain2.label,
        nativeCurrency: {
          name: chain2.label,
          symbol: chain2.token,
          decimals: 18
        },
        rpcUrls: [chain2.rpcUrl]
      }
    ]
  });
}
async function setChain(options) {
  const error = validateSetChainOptions(options);
  if (error) {
    throw error;
  }
  const { wallets, chains: chains2 } = state.get();
  const { chainId: chainId2, chainNamespace: chainNamespace2 = "evm", wallet: walletToSet } = options;
  const chain2 = chains2.find(({ namespace, id: id7 }) => namespace === chainNamespace2 && id7 === chainId2);
  if (!chain2) {
    throw new Error(`Chain with chainId: ${chainId2} and chainNamespace: ${chainNamespace2} has not been set and must be added when Onboard is initialized.`);
  }
  const wallet2 = walletToSet ? wallets.find(({ label }) => label === walletToSet) : wallets[0];
  if (!wallet2) {
    throw new Error(walletToSet ? `Wallet with label ${walletToSet} is not connected` : "A wallet must be connected before a chain can be set");
  }
  const [walletConnectedChain] = wallet2.chains;
  if (walletConnectedChain.namespace === chainNamespace2 && walletConnectedChain.id === chainId2) {
    return true;
  }
  try {
    await switchChain(wallet2.provider, chainId2);
    return true;
  } catch (error2) {
    const { code } = error2;
    const switchChainModalClosed$ = switchChainModal$.pipe(filter((x2) => x2 === null), mapTo(false));
    if (code === ProviderRpcErrorCode.CHAIN_NOT_ADDED) {
      try {
        await addNewChain(wallet2.provider, chain2);
        await switchChain(wallet2.provider, chainId2);
        return true;
      } catch (error3) {
        switchChainModal$.next({ chain: chain2 });
        return firstValueFrom(switchChainModalClosed$);
      }
    }
    if (code === ProviderRpcErrorCode.UNSUPPORTED_METHOD) {
      switchChainModal$.next({ chain: chain2 });
      return firstValueFrom(switchChainModalClosed$);
    }
  }
  return false;
}
var connect2 = {
  selectingWallet: {
    header: "Available Wallets",
    sidebar: {
      heading: "Get Started",
      subheading: "Connect your wallet",
      paragraph: "Connecting your wallet is like \u201Clogging in\u201D to Web3. Select your wallet from the options to get started."
    },
    recommendedWalletsPart1: "{app} only supports",
    recommendedWalletsPart2: "on this platform. Please use or install one of the supported wallets to continue",
    installWallet: "You do not have any wallets installed that {app} supports, please use a supported wallet",
    agreement: {
      agree: "I agree to the",
      terms: "Terms & Conditions",
      and: "and",
      privacy: "Privacy Policy"
    }
  },
  connectingWallet: {
    header: "{connectionRejected, select, false {Connecting to {wallet}...} other {Connection Rejected}}",
    sidebar: {
      subheading: "Approve Connection",
      paragraph: "Please approve the connection in your wallet and authorize access to continue."
    },
    mainText: "Connecting...",
    paragraph: "Make sure to select all accounts that you want to grant access to.",
    rejectedText: "Connection Rejected!",
    rejectedCTA: "Click here to try again",
    primaryButton: "Back to wallets"
  },
  connectedWallet: {
    header: "Connection Successful",
    sidebar: {
      subheading: "Connection Successful!",
      paragraph: "Your wallet is now connected to {app}"
    },
    mainText: "Connected"
  }
};
var modals = {
  actionRequired: {
    heading: "Action required in {wallet}",
    paragraph: "Please switch the active account in your wallet.",
    linkText: "Learn more.",
    buttonText: "Okay"
  },
  switchChain: {
    heading: "Switch Chain",
    paragraph1: "{app} requires that you switch your wallet to the {nextNetworkName} network to continue.",
    paragraph2: "*Some wallets may not support changing networks. If you can not change networks in your wallet you may consider switching to a different wallet."
  }
};
var en = {
  connect: connect2,
  modals
};
function initialize(options) {
  if (options) {
    const { en: customizedEn } = options;
    const merged = (0, import_lodash2.default)(en, customizedEn || {});
    m("en", merged);
    const customLocales = Object.keys(options).filter((key6) => key6 !== "en");
    customLocales.forEach((locale) => {
      const dictionary = options[locale];
      dictionary && m(locale, dictionary);
    });
  } else {
    m("en", en);
  }
  $({
    fallbackLocale: "en",
    initialLocale: I()
  });
}
var closeIcon = `
  <svg width="100%" height="100%" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M11.6569 1.75736L7.41429 6L11.6569 10.2426L10.2427 11.6569L6.00008 7.41421L1.75744 11.6569L0.343227 10.2426L4.58587 6L0.343227 1.75736L1.75744 0.343146L6.00008 4.58579L10.2427 0.343146L11.6569 1.75736Z" fill="currentColor"/>
  </svg>
`;
function add_css$h(target) {
  append_styles(target, "svelte-fio0ht", ".close-button-container.svelte-fio0ht{cursor:pointer;display:flex;justify-content:center;align-items:center}.close-button.svelte-fio0ht{width:2rem;height:2rem;box-sizing:border-box;display:flex;justify-content:center;align-items:center;padding:0.4rem;background:var(\n      --onboard-close-button-background,\n      var(--onboard-gray-100, var(--gray-100))\n    );border-radius:40px;color:var(\n      --onboard-close-button-color,\n      var(--onboard-gray-400, var(--gray-400))\n    )}.close-icon.svelte-fio0ht{width:14px;display:flex;align-items:center}");
}
function create_fragment$h(ctx) {
  let div2;
  let div1;
  let div0;
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "close-icon svelte-fio0ht");
      attr(div1, "class", "close-button svelte-fio0ht");
      attr(div2, "class", "close-button-container svelte-fio0ht");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      div0.innerHTML = closeIcon;
    },
    p: noop3,
    i: noop3,
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div2);
    }
  };
}
var CloseButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, null, create_fragment$h, safe_not_equal2, {}, add_css$h);
  }
};
function fade(node, { delay: delay2 = 0, duration = 400, easing = identity2 } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay: delay2,
    duration,
    easing,
    css: (t2) => `opacity: ${t2 * o}`
  };
}
function add_css$g(target) {
  append_styles(target, "svelte-lkspmm", "section.svelte-lkspmm{position:absolute;top:0;left:0;pointer-events:none;z-index:var(--onboard-modal-z-index, var(--modal-z-index))}.background.svelte-lkspmm{width:100vw;height:100vh;display:flex;justify-content:center;align-items:center;background:rgba(0, 0, 0, 0.6);pointer-events:all}.relative.svelte-lkspmm{position:relative;display:flex;max-height:calc(100vh - 2rem)}.modal-overflow.svelte-lkspmm{position:relative;overflow:hidden;border-radius:24px;display:flex;justify-content:center}.modal.svelte-lkspmm{position:relative;border-radius:24px;overflow-y:auto;background:white}@media all and (max-width: 520px){.relative.svelte-lkspmm{width:calc(100% - 1rem)}.modal-overflow.svelte-lkspmm{width:100%}.modal.svelte-lkspmm{width:100%}}");
}
function create_fragment$g(ctx) {
  let section;
  let div3;
  let div2;
  let div1;
  let div0;
  let section_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      section = element("section");
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "modal svelte-lkspmm");
      attr(div1, "class", "modal-overflow svelte-lkspmm");
      attr(div2, "class", "relative svelte-lkspmm");
      attr(div3, "class", "background svelte-lkspmm");
      attr(section, "class", "svelte-lkspmm");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div3);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div2, "click", stop_propagation(ctx[3])),
          listen(div3, "click", function() {
            if (is_function2(ctx[0]))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(default_slot, default_slot_template, ctx, ctx[1], !current ? get_all_dirty_from_scope(ctx[1]) : get_slot_changes(default_slot_template, ctx[1], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!section_transition)
          section_transition = create_bidirectional_transition(section, fade, {}, true);
        section_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (!section_transition)
        section_transition = create_bidirectional_transition(section, fade, {}, false);
      section_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && section_transition)
        section_transition.end();
      mounted = false;
      run_all2(dispose);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { close } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("close" in $$props2)
      $$invalidate(0, close = $$props2.close);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [close, $$scope, slots, click_handler];
}
var Modal = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$g, create_fragment$g, safe_not_equal2, { close: 0 }, add_css$g);
  }
};
function add_css$f(target) {
  append_styles(target, "svelte-1y8va6v", ".container.svelte-1y8va6v{display:flex;align-items:center;padding:var(--onboard-spacing-4, var(--spacing-4));font-size:var(--onboard-font-size-6, var(--font-size-6));line-height:24px}label.svelte-1y8va6v{display:flex;align-items:center}input.svelte-1y8va6v{height:1rem;width:1rem;margin-right:0.5rem}.spacer.svelte-1y8va6v{padding-top:var(--onboard-spacing-4, var(--spacing-4))}");
}
function create_else_block$4(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "spacer svelte-1y8va6v");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop3,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$9(ctx) {
  let div;
  let label;
  let input;
  let t0;
  let span;
  let t1_value = ctx[1]("connect.selectingWallet.agreement.agree") + "";
  let t1;
  let t2;
  let t3_value = " ";
  let t3;
  let t4;
  let t5;
  let mounted;
  let dispose;
  let if_block0 = ctx[2] && create_if_block_2$3(ctx);
  let if_block1 = ctx[3] && create_if_block_1$4(ctx);
  return {
    c() {
      div = element("div");
      label = element("label");
      input = element("input");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      if (if_block1)
        if_block1.c();
      attr(input, "class", " svelte-1y8va6v");
      attr(input, "type", "checkbox");
      attr(label, "class", "svelte-1y8va6v");
      attr(div, "class", "container svelte-1y8va6v");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, input);
      input.checked = ctx[0];
      append(label, t0);
      append(label, span);
      append(span, t1);
      append(span, t2);
      append(span, t3);
      append(span, t4);
      if (if_block0)
        if_block0.m(span, null);
      append(span, t5);
      if (if_block1)
        if_block1.m(span, null);
      if (!mounted) {
        dispose = listen(input, "change", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        input.checked = ctx2[0];
      }
      if (dirty & 2 && t1_value !== (t1_value = ctx2[1]("connect.selectingWallet.agreement.agree") + ""))
        set_data(t1, t1_value);
      if (ctx2[2])
        if_block0.p(ctx2, dirty);
      if (ctx2[3])
        if_block1.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$3(ctx) {
  let a2;
  let t0_value = ctx[1]("connect.selectingWallet.agreement.terms") + "";
  let t0;
  let t1_value = ctx[3] ? " " + ctx[1]("connect.selectingWallet.agreement.and") + " " : ".";
  let t1;
  return {
    c() {
      a2 = element("a");
      t0 = text(t0_value);
      t1 = text(t1_value);
      attr(a2, "href", ctx[2]);
      attr(a2, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      append(a2, t0);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1]("connect.selectingWallet.agreement.terms") + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t1_value !== (t1_value = ctx2[3] ? " " + ctx2[1]("connect.selectingWallet.agreement.and") + " " : "."))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(a2);
      if (detaching)
        detach(t1);
    }
  };
}
function create_if_block_1$4(ctx) {
  let a2;
  let t0_value = ctx[1]("connect.selectingWallet.agreement.privacy") + "";
  let t0;
  let t1;
  return {
    c() {
      a2 = element("a");
      t0 = text(t0_value);
      t1 = text(".");
      attr(a2, "href", ctx[3]);
      attr(a2, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      append(a2, t0);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1]("connect.selectingWallet.agreement.privacy") + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(a2);
      if (detaching)
        detach(t1);
    }
  };
}
function create_fragment$f(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return create_if_block$9;
    return create_else_block$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: noop3,
    o: noop3,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(1, $_ = $$value));
  let { agreed } = $$props;
  const { terms: termsAgreed, privacy: privacyAgreed, version: versionAgreed } = JSON.parse(localStorage.getItem(STORAGE_KEYS.TERMS_AGREEMENT) || "{}");
  const blankAgreement = {
    termsUrl: "",
    privacyUrl: "",
    version: ""
  };
  const { appMetadata: appMetadata2 } = internalState$.getValue();
  const { termsUrl, privacyUrl, version: version130 } = appMetadata2 && appMetadata2.agreement || blankAgreement;
  const showTermsOfService = !!(termsUrl && !termsAgreed || privacyUrl && !privacyAgreed || version130 && version130 !== versionAgreed);
  agreed = !showTermsOfService;
  function input_change_handler() {
    agreed = this.checked;
    $$invalidate(0, agreed);
  }
  $$self.$$set = ($$props2) => {
    if ("agreed" in $$props2)
      $$invalidate(0, agreed = $$props2.agreed);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      if (agreed) {
        localStorage.setItem(STORAGE_KEYS.TERMS_AGREEMENT, JSON.stringify({
          version: version130,
          terms: !!termsUrl,
          privacy: !!privacyUrl
        }));
      } else if (agreed === false) {
        localStorage.removeItem(STORAGE_KEYS.TERMS_AGREEMENT);
      }
    }
  };
  return [agreed, $_, termsUrl, privacyUrl, showTermsOfService, input_change_handler];
}
var Agreement = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$f, create_fragment$f, safe_not_equal2, { agreed: 0 }, add_css$f);
  }
};
var success = `
  <svg width="100%" height="100%" viewBox="0 0 10 8" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M3.5002 6.0998L1.4002 3.9998L0.700195 4.6998L3.5002 7.4998L9.5002 1.4998L8.8002 0.799805L3.5002 6.0998Z" fill="currentColor"/>
  </svg>
`;
function add_css$e(target) {
  append_styles(target, "svelte-1nnukeb", ".loading-container.svelte-1nnukeb.svelte-1nnukeb{display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:inherit;font-size:inherit;color:inherit}span.svelte-1nnukeb.svelte-1nnukeb{font-family:inherit;font-size:0.889em;margin-top:1rem}.loading.svelte-1nnukeb.svelte-1nnukeb{display:inline-block;position:relative}.loading.svelte-1nnukeb div.svelte-1nnukeb{box-sizing:border-box;font-size:inherit;display:block;position:absolute;border:3px solid;border-radius:50%;animation:svelte-1nnukeb-bn-loading 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;border-color:currentColor transparent transparent transparent}.loading.svelte-1nnukeb .loading-first.svelte-1nnukeb{animation-delay:-0.45s}.loading.svelte-1nnukeb .loading-second.svelte-1nnukeb{animation-delay:-0.3s}.loading.svelte-1nnukeb .loading-third.svelte-1nnukeb{animation-delay:-0.15s}@keyframes svelte-1nnukeb-bn-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}");
}
function create_if_block$8(ctx) {
  let span;
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(ctx[0]);
      attr(span, "class", "svelte-1nnukeb");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t2, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$e(ctx) {
  let div4;
  let div3;
  let div0;
  let div0_style_value;
  let t0;
  let div1;
  let div1_style_value;
  let t1;
  let div2;
  let div2_style_value;
  let div3_style_value;
  let t2;
  let if_block = ctx[0] && create_if_block$8(ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "loading-first svelte-1nnukeb");
      attr(div0, "style", div0_style_value = `height: ${ctx[1]}; width: ${ctx[1]};`);
      attr(div1, "class", "loading-second svelte-1nnukeb");
      attr(div1, "style", div1_style_value = `height: ${ctx[1]}; width: ${ctx[1]};`);
      attr(div2, "class", "loading-third svelte-1nnukeb");
      attr(div2, "style", div2_style_value = `height: ${ctx[1]}; width: ${ctx[1]};`);
      attr(div3, "class", "loading svelte-1nnukeb");
      attr(div3, "style", div3_style_value = `height: ${ctx[1]}; width: ${ctx[1]};`);
      attr(div4, "class", "loading-container absolute svelte-1nnukeb");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div0);
      append(div3, t0);
      append(div3, div1);
      append(div3, t1);
      append(div3, div2);
      append(div4, t2);
      if (if_block)
        if_block.m(div4, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2 && div0_style_value !== (div0_style_value = `height: ${ctx2[1]}; width: ${ctx2[1]};`)) {
        attr(div0, "style", div0_style_value);
      }
      if (dirty & 2 && div1_style_value !== (div1_style_value = `height: ${ctx2[1]}; width: ${ctx2[1]};`)) {
        attr(div1, "style", div1_style_value);
      }
      if (dirty & 2 && div2_style_value !== (div2_style_value = `height: ${ctx2[1]}; width: ${ctx2[1]};`)) {
        attr(div2, "style", div2_style_value);
      }
      if (dirty & 2 && div3_style_value !== (div3_style_value = `height: ${ctx2[1]}; width: ${ctx2[1]};`)) {
        attr(div3, "style", div3_style_value);
      }
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          if_block.m(div4, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop3,
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let { description = "" } = $$props;
  let { size = "2rem" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("description" in $$props2)
      $$invalidate(0, description = $$props2.description);
    if ("size" in $$props2)
      $$invalidate(1, size = $$props2.size);
  };
  return [description, size];
}
var Spinner = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$e, create_fragment$e, safe_not_equal2, { description: 0, size: 1 }, add_css$e);
  }
};
function add_css$d(target) {
  append_styles(target, "svelte-1rtrnn2", ".icon-container.svelte-1rtrnn2{position:relative;border-radius:12px;box-sizing:border-box}.icon.svelte-1rtrnn2{display:flex;justify-content:center;align-items:center;height:100%}.border-yellow.svelte-1rtrnn2{border:1px solid var(--onboard-warning-500, var(--warning-500))}.border-gray.svelte-1rtrnn2{border:1px solid var(--onboard-gray-300, var(--gray-300))}.border-green.svelte-1rtrnn2{border:1px solid var(--onboard-success-500, var(--success-500))}.border-dark-green.svelte-1rtrnn2{border:1px solid var(--onboard-success-700, var(--success-700))}.border-blue.svelte-1rtrnn2{border:1px solid\n      var(\n        --onboard-wallet-app-icon-border-color,\n        var(--onboard-primary-300, var(--primary-300))\n      )}.border-dark-blue.svelte-1rtrnn2{border:1px solid\n      var(\n        --onboard-wallet-app-icon-border-color,\n        var(--onboard-primary-600, var(--primary-600))\n      )}.background-gray.svelte-1rtrnn2{background:var(--onboard-gray-500, var(--gray-500))}.background-light-gray.svelte-1rtrnn2{background:var(--onboard-gray-100, var(--gray-100))}.background-light-blue.svelte-1rtrnn2{background:var(--onboard-primary-100, var(--primary-100))}.background-green.svelte-1rtrnn2{background:var(--onboard-success-100, var(--success-100))}.background-white.svelte-1rtrnn2{background:var(--onboard-white, var(--white))}.background-transparent.svelte-1rtrnn2{background:transparent}@keyframes svelte-1rtrnn2-pulse{from{opacity:0}to{opacity:1}}.placeholder-icon.svelte-1rtrnn2{width:100%;height:100%;background:var(--onboard-gray-100, var(--gray-100));border-radius:32px;animation:svelte-1rtrnn2-pulse infinite 750ms alternate ease-in-out}.spinner-container.svelte-1rtrnn2{color:var(--onboard-primary-300, var(--primary-300))}img.svelte-1rtrnn2{max-width:100%;height:auto}");
}
var get_status_slot_changes = (dirty) => ({});
var get_status_slot_context = (ctx) => ({});
function create_else_block$3(ctx) {
  let await_block_anchor;
  let promise2;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 10
  };
  handle_promise(promise2 = ctx[1], info);
  return {
    c() {
      await_block_anchor = empty2();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 2 && promise2 !== (promise2 = ctx[1]) && handle_promise(promise2, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      transition_in(info.block);
    },
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block$7(ctx) {
  let div;
  let spinner;
  let current;
  spinner = new Spinner({ props: { size: "2rem" } });
  return {
    c() {
      div = element("div");
      create_component(spinner.$$.fragment);
      attr(div, "class", "spinner-container svelte-1rtrnn2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner, div, null);
      current = true;
    },
    p: noop3,
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component2(spinner);
    }
  };
}
function create_catch_block(ctx) {
  return {
    c: noop3,
    m: noop3,
    p: noop3,
    i: noop3,
    o: noop3,
    d: noop3
  };
}
function create_then_block(ctx) {
  let div;
  let show_if;
  let div_intro;
  function select_block_type_1(ctx2, dirty) {
    if (dirty & 2)
      show_if = null;
    if (show_if == null)
      show_if = !!isSVG(ctx2[10]);
    if (show_if)
      return create_if_block_1$3;
    return create_else_block_1$1;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "icon svelte-1rtrnn2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    i(local) {
      if (!div_intro) {
        add_render_callback(() => {
          div_intro = create_in_transition(div, fade, {});
          div_intro.start();
        });
      }
    },
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_else_block_1$1(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = ctx[10]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "logo");
      attr(img, "class", "svelte-1rtrnn2");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && !src_url_equal(img.src, img_src_value = ctx2[10])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_if_block_1$3(ctx) {
  let html_tag;
  let raw_value = ctx[10] + "";
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag();
      html_anchor = empty2();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && raw_value !== (raw_value = ctx2[10] + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_pending_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "placeholder-icon svelte-1rtrnn2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop3,
    i: noop3,
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$d(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t2;
  let div_style_value;
  let current;
  const if_block_creators = [create_if_block$7, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const status_slot_template = ctx[9].status;
  const status_slot = create_slot(status_slot_template, ctx, ctx[8], get_status_slot_context);
  return {
    c() {
      div = element("div");
      if_block.c();
      t2 = space();
      if (status_slot)
        status_slot.c();
      attr(div, "class", "icon-container svelte-1rtrnn2");
      attr(div, "style", div_style_value = `${ctx[5] === "custom" ? ctx[6] : ""}; padding: ${ctx[3] - 1}px; width: ${ctx[0]}px; height: ${ctx[0]}px;`);
      toggle_class(div, "opaque", ctx[7]);
      toggle_class(div, "border-yellow", ctx[4] === "yellow");
      toggle_class(div, "border-gray", ctx[4] === "gray");
      toggle_class(div, "border-green", ctx[4] === "green");
      toggle_class(div, "border-dark-green", ctx[4] === "darkGreen");
      toggle_class(div, "border-blue", ctx[4] === "blue");
      toggle_class(div, "border-dark-blue", ctx[4] === "darkBlue");
      toggle_class(div, "background-gray", ctx[5] === "gray");
      toggle_class(div, "background-light-gray", ctx[5] === "lightGray");
      toggle_class(div, "background-light-blue", ctx[5] === "lightBlue");
      toggle_class(div, "background-green", ctx[5] === "green");
      toggle_class(div, "background-white", ctx[5] === "white");
      toggle_class(div, "background-transparent", ctx[5] === "transparent");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t2);
      if (status_slot) {
        status_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t2);
      }
      if (status_slot) {
        if (status_slot.p && (!current || dirty & 256)) {
          update_slot_base(status_slot, status_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(status_slot_template, ctx2[8], dirty, get_status_slot_changes), get_status_slot_context);
        }
      }
      if (!current || dirty & 105 && div_style_value !== (div_style_value = `${ctx2[5] === "custom" ? ctx2[6] : ""}; padding: ${ctx2[3] - 1}px; width: ${ctx2[0]}px; height: ${ctx2[0]}px;`)) {
        attr(div, "style", div_style_value);
      }
      if (dirty & 128) {
        toggle_class(div, "opaque", ctx2[7]);
      }
      if (dirty & 16) {
        toggle_class(div, "border-yellow", ctx2[4] === "yellow");
      }
      if (dirty & 16) {
        toggle_class(div, "border-gray", ctx2[4] === "gray");
      }
      if (dirty & 16) {
        toggle_class(div, "border-green", ctx2[4] === "green");
      }
      if (dirty & 16) {
        toggle_class(div, "border-dark-green", ctx2[4] === "darkGreen");
      }
      if (dirty & 16) {
        toggle_class(div, "border-blue", ctx2[4] === "blue");
      }
      if (dirty & 16) {
        toggle_class(div, "border-dark-blue", ctx2[4] === "darkBlue");
      }
      if (dirty & 32) {
        toggle_class(div, "background-gray", ctx2[5] === "gray");
      }
      if (dirty & 32) {
        toggle_class(div, "background-light-gray", ctx2[5] === "lightGray");
      }
      if (dirty & 32) {
        toggle_class(div, "background-light-blue", ctx2[5] === "lightBlue");
      }
      if (dirty & 32) {
        toggle_class(div, "background-green", ctx2[5] === "green");
      }
      if (dirty & 32) {
        toggle_class(div, "background-white", ctx2[5] === "white");
      }
      if (dirty & 32) {
        toggle_class(div, "background-transparent", ctx2[5] === "transparent");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(status_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(status_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if (status_slot)
        status_slot.d(detaching);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { size } = $$props;
  let { icon } = $$props;
  let { loading = false } = $$props;
  let { padding: padding7 = size / 6 } = $$props;
  let { border = "blue" } = $$props;
  let { background = "white" } = $$props;
  let { customBackgroundColor = "" } = $$props;
  let { backgroundOpaque = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("icon" in $$props2)
      $$invalidate(1, icon = $$props2.icon);
    if ("loading" in $$props2)
      $$invalidate(2, loading = $$props2.loading);
    if ("padding" in $$props2)
      $$invalidate(3, padding7 = $$props2.padding);
    if ("border" in $$props2)
      $$invalidate(4, border = $$props2.border);
    if ("background" in $$props2)
      $$invalidate(5, background = $$props2.background);
    if ("customBackgroundColor" in $$props2)
      $$invalidate(6, customBackgroundColor = $$props2.customBackgroundColor);
    if ("backgroundOpaque" in $$props2)
      $$invalidate(7, backgroundOpaque = $$props2.backgroundOpaque);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  return [
    size,
    icon,
    loading,
    padding7,
    border,
    background,
    customBackgroundColor,
    backgroundOpaque,
    $$scope,
    slots
  ];
}
var WalletAppBadge = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$d, create_fragment$d, safe_not_equal2, {
      size: 0,
      icon: 1,
      loading: 2,
      padding: 3,
      border: 4,
      background: 5,
      customBackgroundColor: 6,
      backgroundOpaque: 7
    }, add_css$d);
  }
};
var defaultAppIcon = `
<svg height="80%" viewBox="0 0 12 19" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5.07004 9.85C5.84004 8.46 7.32004 7.64 8.18004 6.41C9.09004 5.12 8.58004 2.71 6.00004 2.71C4.31004 2.71 3.48004 3.99 3.13004 5.05L0.540039 3.96C1.25004 1.83 3.18004 0 5.99004 0C8.34004 0 9.95004 1.07 10.77 2.41C11.47 3.56 11.88 5.71 10.8 7.31C9.60004 9.08 8.45004 9.62 7.83004 10.76C7.58004 11.22 7.48004 11.52 7.48004 13H4.59004C4.58004 12.22 4.46004 10.95 5.07004 9.85ZM8.00004 17C8.00004 18.1 7.10004 19 6.00004 19C4.90004 19 4.00004 18.1 4.00004 17C4.00004 15.9 4.90004 15 6.00004 15C7.10004 15 8.00004 15.9 8.00004 17Z" fill="#999CA5"/>
</svg>
`;
function add_css$c(target) {
  append_styles(target, "svelte-sv0as5", ".icon.svelte-sv0as5{display:flex;color:var(--onboard-white, var(--white));border-radius:50px;box-sizing:border-box;position:absolute;z-index:1}.green.svelte-sv0as5{background:var(--onboard-success-600, var(--success-600))}.blue.svelte-sv0as5{background:var(--onboard-primary-1, var(--primary-1))}");
}
function create_fragment$c(ctx) {
  let div;
  let div_style_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", "icon svelte-sv0as5");
      attr(div, "style", div_style_value = `width: ${ctx[0]}px; height: ${ctx[0]}px; padding: ${ctx[0] / 5}px; ${ctx[2] !== null ? `bottom: ${ctx[2]}px;` : ""} ${ctx[3] !== null ? `right: ${ctx[3]}px;` : ""}`);
      toggle_class(div, "green", ctx[1] === "green");
      toggle_class(div, "blue", ctx[1] === "blue");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = success;
    },
    p(ctx2, [dirty]) {
      if (dirty & 13 && div_style_value !== (div_style_value = `width: ${ctx2[0]}px; height: ${ctx2[0]}px; padding: ${ctx2[0] / 5}px; ${ctx2[2] !== null ? `bottom: ${ctx2[2]}px;` : ""} ${ctx2[3] !== null ? `right: ${ctx2[3]}px;` : ""}`)) {
        attr(div, "style", div_style_value);
      }
      if (dirty & 2) {
        toggle_class(div, "green", ctx2[1] === "green");
      }
      if (dirty & 2) {
        toggle_class(div, "blue", ctx2[1] === "blue");
      }
    },
    i: noop3,
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let { size } = $$props;
  let { color = "green" } = $$props;
  let { bottom = -4 } = $$props;
  let { right = -4 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("bottom" in $$props2)
      $$invalidate(2, bottom = $$props2.bottom);
    if ("right" in $$props2)
      $$invalidate(3, right = $$props2.right);
  };
  return [size, color, bottom, right];
}
var SuccessStatusIcon = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$c, create_fragment$c, safe_not_equal2, { size: 0, color: 1, bottom: 2, right: 3 }, add_css$c);
  }
};
function add_css$b(target) {
  append_styles(target, "svelte-1cswia4", ".container.svelte-1cswia4{padding:var(--onboard-spacing-4, var(--spacing-4))}.connecting-container.svelte-1cswia4{display:flex;justify-content:space-between;align-items:center;padding:var(--onboard-spacing-4, var(--spacing-4));border-radius:24px;background:var(--onboard-success-100, var(--success-100));border:1px solid var(--onboard-success-600, var(--success-600));width:100%;box-sizing:border-box}.icons.svelte-1cswia4{display:flex;justify-content:center;position:relative}.text.svelte-1cswia4{position:relative;right:var(--onboard-spacing-5, var(--spacing-5))}.tick.svelte-1cswia4{display:flex;color:var(--onboard-success-700, var(--success-700))}@media all and (max-width: 520px){}");
}
function create_fragment$b(ctx) {
  let div6;
  let div5;
  let div2;
  let walletappbadge0;
  let t0;
  let div0;
  let successstatusicon;
  let t1;
  let div1;
  let walletappbadge1;
  let t2;
  let div3;
  let t3_value = ctx[1]("connect.connectedWallet.mainText", {
    default: en.connect.connectedWallet.mainText
  }) + "";
  let t3;
  let t4;
  let div4;
  let current;
  walletappbadge0 = new WalletAppBadge({
    props: {
      size: 40,
      padding: 8,
      background: ctx[2] && ctx[2].icon ? "lightBlue" : "lightGray",
      border: "darkGreen",
      icon: ctx[2] && ctx[2].icon || defaultAppIcon
    }
  });
  successstatusicon = new SuccessStatusIcon({ props: { size: 17, right: null } });
  walletappbadge1 = new WalletAppBadge({
    props: {
      size: 40,
      padding: 8,
      border: "darkGreen",
      icon: ctx[0].icon
    }
  });
  return {
    c() {
      div6 = element("div");
      div5 = element("div");
      div2 = element("div");
      create_component(walletappbadge0.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(successstatusicon.$$.fragment);
      t1 = space();
      div1 = element("div");
      create_component(walletappbadge1.$$.fragment);
      t2 = space();
      div3 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div4 = element("div");
      set_style(div0, "position", "relative");
      set_style(div0, "right", "0.85rem");
      set_style(div0, "top", "2px");
      set_style(div1, "position", "relative");
      set_style(div1, "right", "0.5rem");
      attr(div2, "class", "icons svelte-1cswia4");
      attr(div3, "class", "text svelte-1cswia4");
      attr(div4, "class", "tick svelte-1cswia4");
      set_style(div4, "width", "20px");
      attr(div5, "class", "connecting-container svelte-1cswia4");
      attr(div6, "class", "container svelte-1cswia4");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div5);
      append(div5, div2);
      mount_component(walletappbadge0, div2, null);
      append(div2, t0);
      append(div2, div0);
      mount_component(successstatusicon, div0, null);
      append(div2, t1);
      append(div2, div1);
      mount_component(walletappbadge1, div1, null);
      append(div5, t2);
      append(div5, div3);
      append(div3, t3);
      append(div5, t4);
      append(div5, div4);
      div4.innerHTML = success;
      current = true;
    },
    p(ctx2, [dirty]) {
      const walletappbadge1_changes = {};
      if (dirty & 1)
        walletappbadge1_changes.icon = ctx2[0].icon;
      walletappbadge1.$set(walletappbadge1_changes);
      if ((!current || dirty & 2) && t3_value !== (t3_value = ctx2[1]("connect.connectedWallet.mainText", {
        default: en.connect.connectedWallet.mainText
      }) + ""))
        set_data(t3, t3_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(walletappbadge0.$$.fragment, local);
      transition_in(successstatusicon.$$.fragment, local);
      transition_in(walletappbadge1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(walletappbadge0.$$.fragment, local);
      transition_out(successstatusicon.$$.fragment, local);
      transition_out(walletappbadge1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_component2(walletappbadge0);
      destroy_component2(successstatusicon);
      destroy_component2(walletappbadge1);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(1, $_ = $$value));
  let { selectedWallet } = $$props;
  const { appMetadata: appMetadata2 } = internalState$.getValue();
  $$self.$$set = ($$props2) => {
    if ("selectedWallet" in $$props2)
      $$invalidate(0, selectedWallet = $$props2.selectedWallet);
  };
  return [selectedWallet, $_, appMetadata2];
}
var ConnectedWallet = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$b, create_fragment$b, safe_not_equal2, { selectedWallet: 0 }, add_css$b);
  }
};
function add_css$a(target) {
  append_styles(target, "svelte-gfxo3f", ".container.svelte-gfxo3f{display:flex;flex-direction:column;align-items:center;padding:var(--onboard-spacing-4, var(--spacing-4))}.connecting-container.svelte-gfxo3f{display:flex;justify-content:space-between;align-items:center;width:100%;padding:var(--onboard-spacing-4, var(--spacing-4));transition:background-color 100ms ease-in-out,\n      border-color 100ms ease-in-out;border-radius:24px;background-color:var(--onboard-primary-100, var(--primary-100));border:1px solid;border-color:var(--onboard-primary-300, var(--primary-300));box-sizing:border-box;color:var(--onboard-gray-600, var(--gray-600))}.connecting-container.warning.svelte-gfxo3f{background-color:var(--onboard-warning-100, var(--warning-100));border-color:var(--onboard-warning-400, var(--warning-400))}.icons.svelte-gfxo3f{display:flex;justify-content:center;position:relative}.text.svelte-gfxo3f{line-height:16px;margin-bottom:var(--onboard-spacing-5, var(--spacing-5))}.text.text-rejected.svelte-gfxo3f{line-height:24px;margin-bottom:0}.subtext.svelte-gfxo3f{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px}.rejected-cta.svelte-gfxo3f{color:var(--onboard-primary-500, var(--primary-500));cursor:pointer}.onboard-button-primary.svelte-gfxo3f{position:absolute;bottom:var(--onboard-spacing-3, var(--spacing-3))}.centered-flex-column.svelte-gfxo3f{display:flex;flex-direction:column;justify-content:center}.ml.svelte-gfxo3f{margin-left:var(--onboard-spacing-4, var(--spacing-4))}");
}
function create_else_block$2(ctx) {
  let div;
  let t_value = ctx[5]("connect.connectingWallet.paragraph", {
    default: en.connect.connectingWallet.paragraph
  }) + "";
  let t2;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
      attr(div, "class", "subtext svelte-gfxo3f");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[5]("connect.connectingWallet.paragraph", {
        default: en.connect.connectingWallet.paragraph
      }) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$6(ctx) {
  let div;
  let t_value = ctx[5]("connect.connectingWallet.rejectedCTA", {
    default: en.connect.connectingWallet.rejectedCTA
  }) + "";
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t2 = text(t_value);
      attr(div, "class", "rejected-cta subtext svelte-gfxo3f");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
      if (!mounted) {
        dispose = listen(div, "click", function() {
          if (is_function2(ctx[0]))
            ctx[0].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32 && t_value !== (t_value = ctx[5]("connect.connectingWallet.rejectedCTA", {
        default: en.connect.connectingWallet.rejectedCTA
      }) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$a(ctx) {
  let div6;
  let div5;
  let div4;
  let div1;
  let walletappbadge0;
  let t0;
  let div0;
  let walletappbadge1;
  let t1;
  let div3;
  let div2;
  let t2_value = ctx[5](ctx[4] ? "connect.connectingWallet.rejectedText" : "connect.connectingWallet.mainText", {
    default: ctx[4] ? en.connect.connectingWallet.rejectedText : en.connect.connectingWallet.mainText
  }) + "";
  let t2;
  let t3;
  let t4;
  let button;
  let t5_value = ctx[5]("connect.connectingWallet.primaryButton", {
    default: en.connect.connectingWallet.primaryButton
  }) + "";
  let t5;
  let current;
  let mounted;
  let dispose;
  walletappbadge0 = new WalletAppBadge({
    props: {
      size: 40,
      padding: 8,
      icon: ctx[6] && ctx[6].icon || defaultAppIcon,
      border: ctx[4] ? "yellow" : "blue",
      background: "lightGray"
    }
  });
  walletappbadge1 = new WalletAppBadge({
    props: {
      size: 40,
      padding: 8,
      border: ctx[4] ? "yellow" : "blue",
      background: "white",
      icon: ctx[1].icon
    }
  });
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return create_if_block$6;
    return create_else_block$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div6 = element("div");
      div5 = element("div");
      div4 = element("div");
      div1 = element("div");
      create_component(walletappbadge0.$$.fragment);
      t0 = space();
      div0 = element("div");
      create_component(walletappbadge1.$$.fragment);
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      t2 = text(t2_value);
      t3 = space();
      if_block.c();
      t4 = space();
      button = element("button");
      t5 = text(t5_value);
      set_style(div0, "position", "relative");
      set_style(div0, "right", "0.5rem");
      attr(div1, "class", "icons svelte-gfxo3f");
      attr(div2, "class", "text svelte-gfxo3f");
      toggle_class(div2, "text-rejected", ctx[4]);
      attr(div3, "class", "centered-flex-column ml svelte-gfxo3f");
      set_style(div4, "display", "flex");
      attr(div5, "class", "connecting-container svelte-gfxo3f");
      toggle_class(div5, "warning", ctx[4]);
      attr(button, "class", "onboard-button-primary svelte-gfxo3f");
      attr(div6, "class", "container svelte-gfxo3f");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div5);
      append(div5, div4);
      append(div4, div1);
      mount_component(walletappbadge0, div1, null);
      append(div1, t0);
      append(div1, div0);
      mount_component(walletappbadge1, div0, null);
      append(div4, t1);
      append(div4, div3);
      append(div3, div2);
      append(div2, t2);
      append(div3, t3);
      if_block.m(div3, null);
      append(div6, t4);
      append(div6, button);
      append(button, t5);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const walletappbadge0_changes = {};
      if (dirty & 16)
        walletappbadge0_changes.border = ctx2[4] ? "yellow" : "blue";
      walletappbadge0.$set(walletappbadge0_changes);
      const walletappbadge1_changes = {};
      if (dirty & 16)
        walletappbadge1_changes.border = ctx2[4] ? "yellow" : "blue";
      if (dirty & 2)
        walletappbadge1_changes.icon = ctx2[1].icon;
      walletappbadge1.$set(walletappbadge1_changes);
      if ((!current || dirty & 48) && t2_value !== (t2_value = ctx2[5](ctx2[4] ? "connect.connectingWallet.rejectedText" : "connect.connectingWallet.mainText", {
        default: ctx2[4] ? en.connect.connectingWallet.rejectedText : en.connect.connectingWallet.mainText
      }) + ""))
        set_data(t2, t2_value);
      if (dirty & 16) {
        toggle_class(div2, "text-rejected", ctx2[4]);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div3, null);
        }
      }
      if (dirty & 16) {
        toggle_class(div5, "warning", ctx2[4]);
      }
      if ((!current || dirty & 32) && t5_value !== (t5_value = ctx2[5]("connect.connectingWallet.primaryButton", {
        default: en.connect.connectingWallet.primaryButton
      }) + ""))
        set_data(t5, t5_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(walletappbadge0.$$.fragment, local);
      transition_in(walletappbadge1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(walletappbadge0.$$.fragment, local);
      transition_out(walletappbadge1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_component2(walletappbadge0);
      destroy_component2(walletappbadge1);
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(5, $_ = $$value));
  let { connectWallet } = $$props;
  let { selectedWallet } = $$props;
  let { deselectWallet } = $$props;
  let { setStep } = $$props;
  let { connectionRejected } = $$props;
  const { appMetadata: appMetadata2 } = internalState$.getValue();
  const click_handler = () => {
    deselectWallet(selectedWallet.label);
    setStep("selectingWallet");
  };
  $$self.$$set = ($$props2) => {
    if ("connectWallet" in $$props2)
      $$invalidate(0, connectWallet = $$props2.connectWallet);
    if ("selectedWallet" in $$props2)
      $$invalidate(1, selectedWallet = $$props2.selectedWallet);
    if ("deselectWallet" in $$props2)
      $$invalidate(2, deselectWallet = $$props2.deselectWallet);
    if ("setStep" in $$props2)
      $$invalidate(3, setStep = $$props2.setStep);
    if ("connectionRejected" in $$props2)
      $$invalidate(4, connectionRejected = $$props2.connectionRejected);
  };
  return [
    connectWallet,
    selectedWallet,
    deselectWallet,
    setStep,
    connectionRejected,
    $_,
    appMetadata2,
    click_handler
  ];
}
var ConnectingWallet = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$a, create_fragment$a, safe_not_equal2, {
      connectWallet: 0,
      selectedWallet: 1,
      deselectWallet: 2,
      setStep: 3,
      connectionRejected: 4
    }, add_css$a);
  }
};
var infoIcon = `
<svg width="100%" height="100%" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M8 0.5C3.86 0.5 0.5 3.86 0.5 8C0.5 12.14 3.86 15.5 8 15.5C12.14 15.5 15.5 12.14 15.5 8C15.5 3.86 12.14 0.5 8 0.5ZM8.75 11.75H7.25L7.25 7.25L8.75 7.25L8.75 11.75ZM8.75 5.75L7.25 5.75L7.25 4.25H8.75L8.75 5.75Z" fill="currentColor"/>
</svg>
`;
function add_css$9(target) {
  append_styles(target, "svelte-2c2etc", ".container.svelte-2c2etc{display:flex;justify-content:space-between;padding:var(--onboard-spacing-5, var(--spacing-5));color:var(--onboard-warning-700, var(--warning-700));font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px;border:1px solid var(--onboard-warning-400, var(--warning-400));background-color:var(--onboard-warning-100, var(--warning-100));margin:0;border-radius:12px}.icon.svelte-2c2etc{color:var(--onboard-warning-700, var(--warning-700));width:1rem;height:1rem;margin-left:var(--onboard-spacing-5, var(--spacing-5))}p.svelte-2c2etc{margin:0;width:fit-content}");
}
function create_fragment$9(ctx) {
  let div1;
  let p2;
  let t2;
  let div0;
  let div1_intro;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div1 = element("div");
      p2 = element("p");
      if (default_slot)
        default_slot.c();
      t2 = space();
      div0 = element("div");
      attr(p2, "class", "svelte-2c2etc");
      attr(div0, "class", "icon svelte-2c2etc");
      attr(div1, "class", "container svelte-2c2etc");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p2);
      if (default_slot) {
        default_slot.m(p2, null);
      }
      append(div1, t2);
      append(div1, div0);
      div0.innerHTML = infoIcon;
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (!div1_intro) {
        add_render_callback(() => {
          div1_intro = create_in_transition(div1, fade, {});
          div1_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Warning = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$9, create_fragment$9, safe_not_equal2, {}, add_css$9);
  }
};
function add_css$8(target) {
  append_styles(target, "svelte-up669r", ".outer-container.svelte-up669r{padding:var(--onboard-spacing-4, var(--spacing-4))}.link.svelte-up669r{font-size:var(--onboard-font-size-7, var(--font-size-7));line-height:16px;color:var(--onboard-primary-500, var(--primary-500));cursor:pointer;text-decoration:none}");
}
function get_each_context$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2].name;
  child_ctx[3] = list[i2].url;
  child_ctx[5] = i2;
  return child_ctx;
}
function create_else_block$1(ctx) {
  let t_value = ctx[0]("connect.selectingWallet.installWallet", {
    default: en.connect.selectingWallet.installWallet,
    values: { app: ctx[2] || "this app" }
  }) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0]("connect.selectingWallet.installWallet", {
        default: en.connect.selectingWallet.installWallet,
        values: { app: ctx2[2] || "this app" }
      }) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t2);
    }
  };
}
function create_if_block$5(ctx) {
  let t0_value = ctx[0]("connect.selectingWallet.recommendedWalletsPart1", {
    default: en.connect.selectingWallet.recommendedWalletsPart1,
    values: { app: ctx[2] || "This app" }
  }) + "";
  let t0;
  let t1;
  let t2;
  let t3_value = ctx[0]("connect.selectingWallet.recommendedWalletsPart2", {
    default: en.connect.selectingWallet.recommendedWalletsPart2
  }) + "";
  let t3;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1(get_each_context$1(ctx, each_value, i2));
  }
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, t2, anchor);
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[0]("connect.selectingWallet.recommendedWalletsPart1", {
        default: en.connect.selectingWallet.recommendedWalletsPart1,
        values: { app: ctx2[2] || "This app" }
      }) + ""))
        set_data(t0, t0_value);
      if (dirty & 2) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(t2.parentNode, t2);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 1 && t3_value !== (t3_value = ctx2[0]("connect.selectingWallet.recommendedWalletsPart2", {
        default: en.connect.selectingWallet.recommendedWalletsPart2
      }) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block$1(ctx) {
  let a2;
  let t0_value = ctx[2] + "";
  let t0;
  let t1_value = ctx[5] < ctx[1].length - 1 ? ", " : "";
  let t1;
  let a_href_value;
  return {
    c() {
      a2 = element("a");
      t0 = text(t0_value);
      t1 = text(t1_value);
      attr(a2, "class", "link svelte-up669r");
      attr(a2, "href", a_href_value = ctx[3]);
      attr(a2, "target", "_blank");
      attr(a2, "rel", "noreferrer noopener");
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      append(a2, t0);
      append(a2, t1);
    },
    p: noop3,
    d(detaching) {
      if (detaching)
        detach(a2);
    }
  };
}
function create_default_slot$4(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block$5;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$8(ctx) {
  let div;
  let warning;
  let current;
  warning = new Warning({
    props: {
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(warning.$$.fragment);
      attr(div, "class", "outer-container svelte-up669r");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(warning, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const warning_changes = {};
      if (dirty & 65) {
        warning_changes.$$scope = { dirty, ctx: ctx2 };
      }
      warning.$set(warning_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(warning.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(warning.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component2(warning);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(0, $_ = $$value));
  const { recommendedInjectedWallets, name: name2 } = internalState$.getValue().appMetadata || {};
  return [$_, recommendedInjectedWallets, name2];
}
var InstallWallet = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$8, create_fragment$8, safe_not_equal2, {}, add_css$8);
  }
};
function add_css$7(target) {
  append_styles(target, "svelte-kjyo9y", "button.svelte-kjyo9y{position:relative;background-color:var(\n      --onboard-wallet-button-background,\n      var(--onboard-white, var(--white))\n    );border:1px solid\n      var(\n        --onboard-wallet-button-border-color,\n        var(--onboard-primary-200, var(--primary-200))\n      );transition:background-color 250ms ease-in-out;color:var(\n      --onboard-wallet-button-color,\n      var(--onboard-gray-700, var(--gray-700))\n    )}button.svelte-kjyo9y:hover{background-color:var(\n      --onboard-wallet-button-background-hover,\n      var(--onboard-primary-100, var(--primary-100))\n    )}button.connected.svelte-kjyo9y{border:1px solid var(--onboard-success-200, var(--success-200))}button.connected.svelte-kjyo9y:hover{background-color:var(--onboard-success-100, var(--success-100))}.name.svelte-kjyo9y{margin-left:var(--onboard-spacing-4, var(--spacing-4))}");
}
function create_if_block$4(ctx) {
  let successstatusicon;
  let current;
  successstatusicon = new SuccessStatusIcon({
    props: { size: 16, bottom: null, right: 16 }
  });
  return {
    c() {
      create_component(successstatusicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(successstatusicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(successstatusicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(successstatusicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(successstatusicon, detaching);
    }
  };
}
function create_fragment$7(ctx) {
  let button;
  let walletappbadge;
  let t0;
  let span;
  let t1;
  let t2;
  let button_intro;
  let current;
  let mounted;
  let dispose;
  walletappbadge = new WalletAppBadge({
    props: {
      size: 48,
      icon: ctx[0],
      loading: ctx[4],
      border: ctx[3] ? "green" : "blue",
      background: "transparent"
    }
  });
  let if_block = ctx[3] && create_if_block$4();
  return {
    c() {
      button = element("button");
      create_component(walletappbadge.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(ctx[1]);
      t2 = space();
      if (if_block)
        if_block.c();
      attr(span, "class", "name svelte-kjyo9y");
      attr(button, "class", "svelte-kjyo9y");
      toggle_class(button, "connected", ctx[3]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(walletappbadge, button, null);
      append(button, t0);
      append(button, span);
      append(span, t1);
      append(button, t2);
      if (if_block)
        if_block.m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function2(ctx[2]))
            ctx[2].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const walletappbadge_changes = {};
      if (dirty & 1)
        walletappbadge_changes.icon = ctx[0];
      if (dirty & 16)
        walletappbadge_changes.loading = ctx[4];
      if (dirty & 8)
        walletappbadge_changes.border = ctx[3] ? "green" : "blue";
      walletappbadge.$set(walletappbadge_changes);
      if (!current || dirty & 2)
        set_data(t1, ctx[1]);
      if (ctx[3]) {
        if (if_block) {
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$4();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 8) {
        toggle_class(button, "connected", ctx[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(walletappbadge.$$.fragment, local);
      transition_in(if_block);
      if (!button_intro) {
        add_render_callback(() => {
          button_intro = create_in_transition(button, fade, {});
          button_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(walletappbadge.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      destroy_component2(walletappbadge);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let { icon } = $$props;
  let { label } = $$props;
  let { onClick } = $$props;
  let { connected } = $$props;
  let { connecting } = $$props;
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2)
      $$invalidate(0, icon = $$props2.icon);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("connected" in $$props2)
      $$invalidate(3, connected = $$props2.connected);
    if ("connecting" in $$props2)
      $$invalidate(4, connecting = $$props2.connecting);
  };
  return [icon, label, onClick, connected, connecting];
}
var WalletButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$7, create_fragment$7, safe_not_equal2, {
      icon: 0,
      label: 1,
      onClick: 2,
      connected: 3,
      connecting: 4
    }, add_css$7);
  }
};
function add_css$6(target) {
  append_styles(target, "svelte-9xeusa", ".outer-container.svelte-9xeusa{display:flex;flex-direction:column;padding:var(--onboard-spacing-4, var(--spacing-4));padding-top:0}.wallets-container.svelte-9xeusa{display:grid;grid-template-columns:repeat(var(--onboard-wallet-columns, 2), 1fr);gap:var(--onboard-spacing-5, var(--spacing-5));width:100%}.warning-container.svelte-9xeusa{margin-bottom:1rem}@media all and (max-width: 520px){.wallets-container.svelte-9xeusa{grid-template-columns:repeat(1, 1fr)}}");
}
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_if_block$3(ctx) {
  let div;
  let warning;
  let current;
  warning = new Warning({
    props: {
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(warning.$$.fragment);
      attr(div, "class", "warning-container svelte-9xeusa");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(warning, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const warning_changes = {};
      if (dirty & 520) {
        warning_changes.$$scope = { dirty, ctx: ctx2 };
      }
      warning.$set(warning_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(warning.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(warning.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component2(warning);
    }
  };
}
function create_default_slot$3(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag();
      html_anchor = empty2();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(ctx[3], target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        html_tag.p(ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_each_block(ctx) {
  let walletbutton;
  let current;
  function func() {
    return ctx[5](ctx[6]);
  }
  walletbutton = new WalletButton({
    props: {
      connected: ctx[4](ctx[6].label),
      connecting: ctx[2] === ctx[6].label,
      label: ctx[6].label,
      icon: ctx[6].icon,
      onClick: func
    }
  });
  return {
    c() {
      create_component(walletbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(walletbutton, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const walletbutton_changes = {};
      if (dirty & 1)
        walletbutton_changes.connected = ctx[4](ctx[6].label);
      if (dirty & 5)
        walletbutton_changes.connecting = ctx[2] === ctx[6].label;
      if (dirty & 1)
        walletbutton_changes.label = ctx[6].label;
      if (dirty & 1)
        walletbutton_changes.icon = ctx[6].icon;
      if (dirty & 3)
        walletbutton_changes.onClick = func;
      walletbutton.$set(walletbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(walletbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(walletbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(walletbutton, detaching);
    }
  };
}
function create_fragment$6(ctx) {
  let div1;
  let t2;
  let div0;
  let current;
  let if_block = ctx[3] && create_if_block$3(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t2 = space();
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "wallets-container svelte-9xeusa");
      attr(div1, "class", "outer-container svelte-9xeusa");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 23) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let { wallets } = $$props;
  let { selectWallet } = $$props;
  let { connectingWalletLabel } = $$props;
  let { connectingErrorMessage } = $$props;
  function checkConnected(label) {
    const { wallets: wallets2 } = state.get();
    return !!wallets2.find((wallet2) => wallet2.label === label);
  }
  const func = (wallet2) => selectWallet(wallet2);
  $$self.$$set = ($$props2) => {
    if ("wallets" in $$props2)
      $$invalidate(0, wallets = $$props2.wallets);
    if ("selectWallet" in $$props2)
      $$invalidate(1, selectWallet = $$props2.selectWallet);
    if ("connectingWalletLabel" in $$props2)
      $$invalidate(2, connectingWalletLabel = $$props2.connectingWalletLabel);
    if ("connectingErrorMessage" in $$props2)
      $$invalidate(3, connectingErrorMessage = $$props2.connectingErrorMessage);
  };
  return [
    wallets,
    selectWallet,
    connectingWalletLabel,
    connectingErrorMessage,
    checkConnected,
    func
  ];
}
var SelectingWallet = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$6, create_fragment$6, safe_not_equal2, {
      wallets: 0,
      selectWallet: 1,
      connectingWalletLabel: 2,
      connectingErrorMessage: 3
    }, add_css$6);
  }
};
var blocknative = `
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 790.34 114.51" width="80%">
  <defs>
    <style>.cls-1{fill:#262a3d;}.cls-2{fill:url(#linear-gradient);}.cls-3{fill:url(#linear-gradient-2);}</style>
    <linearGradient id="linear-gradient" x1="694.45" y1="46.08" x2="741.39" y2="46.08" gradientUnits="userSpaceOnUse">
      <stop offset="0" stop-color="#55ccfe"/><stop offset="1" stop-color="#5e93ef"/>
    </linearGradient>
    <linearGradient id="linear-gradient-2" x1="694.45" y1="86.73" x2="788.33" y2="86.73" xlink:href="#linear-gradient"/>
  </defs>
  <polygon class="cls-1" points="710.09 86.73 694.45 59.63 725.74 59.63 725.74 59.63 741.39 86.73 710.09 86.73"/>
  <polygon class="cls-2" points="725.74 59.63 694.45 59.63 710.09 32.53 741.39 32.53 725.74 59.63"/>
  <polygon class="cls-1" points="757.03 59.63 741.39 32.53 710.09 32.53 694.45 5.43 757.03 5.43 788.33 59.63 757.03 59.63"/>
  <polygon class="cls-3" points="757.03 113.83 694.45 113.83 710.09 86.73 741.39 86.73 757.03 59.63 788.33 59.63 757.03 113.83"/>
  <path class="cls-1" d="M70.51,65.77c0,19.47-14.37,34.5-31.88,34.5-9.54,0-16.47-3.53-21.17-9.54v7.71H.6V6.87L17.46,1.68V40.82c4.7-6,11.63-9.54,21.17-9.54C56.14,31.28,70.51,46.3,70.51,65.77Zm-16.86,0c0-11-7.7-18.42-18.16-18.42s-18,7.45-18,18.42,7.71,18.43,18,18.43S53.65,76.75,53.65,65.77Z"/>
  <path class="cls-1" d="M78.09,6.87,94.94,1.68V98.44H78.09Z"/><path class="cls-1" d="M102.39,65.77a34.56,34.56,0,1,1,34.49,34.5A34.13,34.13,0,0,1,102.39,65.77Zm52.26,0c0-10.58-7.71-18-17.77-18s-17.64,7.45-17.64,18,7.71,18,17.64,18S154.65,76.36,154.65,65.77Z"/>
  <path class="cls-1" d="M177.9,65.77c0-19.47,14.63-34.49,34.49-34.49,12.81,0,23.91,6.79,29.27,16.85l-14.5,8.5c-2.62-5.36-8.24-8.76-14.9-8.76-10.06,0-17.51,7.45-17.51,17.9s7.45,17.77,17.51,17.77c6.8,0,12.41-3.26,15-8.62l14.63,8.36a33.47,33.47,0,0,1-29.53,17C192.53,100.27,177.9,85.24,177.9,65.77Z"/>
  <path class="cls-1" d="M290.32,98.44,266.54,68.78V98.44H249.68V6.87l16.86-5.19V61.85L289,33.11h20.12L282.87,65.38l27.05,33.06Z"/>
  <path class="cls-1" d="M377.26,58.32V98.44H360.4v-38c0-8.89-5.35-13.46-12.93-13.46-8.23,0-14.38,4.83-14.38,16.2V98.44H316.24V33.11h16.85v7.31c3.92-5.88,10.72-9.14,19.47-9.14C366.41,31.28,377.26,41,377.26,58.32Z"/>
  <path class="cls-1" d="M454.72,33.11V98.44H437.87V90.73c-4.71,5.88-11.76,9.54-21.3,9.54-17.38,0-31.75-15-31.75-34.5s14.37-34.49,31.75-34.49c9.54,0,16.59,3.66,21.3,9.54V33.11ZM437.87,65.77c0-11-7.71-18.42-18.17-18.42s-18,7.45-18,18.42,7.71,18.43,18,18.43S437.87,76.75,437.87,65.77Z"/>
  <path class="cls-1" d="M498.65,49.31V33.11H483.88V13.9L467,19.09v57.4c0,17.64,8,24.56,31.63,22V83.15c-9.67.53-14.77.39-14.77-6.66V49.31Z"/><path class="cls-1" d="M510.46,33.11h16.85V98.44H510.46Z"/>
  <path class="cls-1" d="M603.13,33.11,578.3,98.44H559.09L534.27,33.11h18.55l15.81,45.73,15.94-45.73Z"/><path class="cls-1" d="M639.2,85c6.53,0,11.76-2.74,14.64-6.53l13.58,7.84c-6.14,8.88-15.94,14-28.48,14-22,0-35.8-15-35.8-34.5s14-34.49,34.49-34.49c19.34,0,33.06,15.29,33.06,34.49A39.11,39.11,0,0,1,670,72.7H620.78C623.13,81.32,630.32,85,639.2,85Zm14.64-25.35c-2.1-9.41-9.15-13.2-16.21-13.2-9,0-15.15,4.84-17.12,13.2Z"/>
</svg>
`;
function add_css$5(target) {
  append_styles(target, "svelte-f9sn92", ".sidebar.svelte-f9sn92{padding:var(--onboard-spacing-3, var(--spacing-3));border-radius:24px 0 0 24px;background:var(\n      --onboard-connect-sidebar-background,\n      var(--onboard-gray-100, var(--gray-100))\n    );color:var(\n      --onboard-connect-sidebar-color,\n      var(--onboard-gray-700, var(--gray-700))\n    )}.inner-container.svelte-f9sn92{padding-left:var(--onboard-spacing-5, var(--spacing-5));max-width:236px}.icon-container.svelte-f9sn92{height:3rem;display:flex;margin-bottom:var(--onboard-spacing-4, var(--spacing-4))}.heading.svelte-f9sn92{font-size:var(--onboard-font-size-3, var(--font-size-3));margin:0 0 var(--onboard-spacing-5, var(--spacing-5)) 0}.subheading.svelte-f9sn92{margin:0 0 var(--onboard-spacing-5, var(--spacing-5)) 0}.description.svelte-f9sn92{line-height:20px;font-size:var(--onboard-font-size-6, var(--font-size-6));margin:0}.indicators.svelte-f9sn92{display:flex;align-items:center;margin-top:var(--onboard-spacing-2, var(--spacing-2))}.indicator.svelte-f9sn92{position:relative;width:8px;height:8px;border-radius:8px;background:var(\n      --onboard-connect-sidebar-progress-background,\n      var(--onboard-gray-200, var(--gray-200))\n    );transition:background 250ms ease-in-out}.indicator.on.svelte-f9sn92{background:var(\n      --onboard-connect-sidebar-progress-color,\n      var(--onboard-primary-600, var(--primary-600))\n    );border:2px solid\n      var(\n        --onboard-connect-sidebar-progress-background,\n        var(--onboard-gray-200, var(--gray-200))\n      )}.join.svelte-f9sn92{position:relative;z-index:1;right:4px;height:2px;background:var(\n      --onboard-connect-sidebar-progress-background,\n      var(--onboard-gray-200, var(--gray-200))\n    );transition:background 250ms ease-in-out}.join.active.svelte-f9sn92{background:var(\n      --onboard-connect-sidebar-progress-color,\n      var(--onboard-primary-600, var(--primary-600))\n    )}img.svelte-f9sn92{max-width:100%;height:auto}");
}
function create_else_block_1(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag();
      html_anchor = empty2();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(blocknative, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p: noop3,
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_if_block_1$2(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (isSVG(ctx2[3] || ctx2[2]))
      return create_if_block_2$2;
    return create_else_block;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = ctx[3] || ctx[2]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "logo");
      attr(img, "class", "svelte-f9sn92");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p: noop3,
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_if_block_2$2(ctx) {
  let html_tag;
  let raw_value = (ctx[3] || ctx[2]) + "";
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag();
      html_anchor = empty2();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p: noop3,
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_if_block$2(ctx) {
  let h2;
  let t_value = ctx[1](`connect.${ctx[0]}.sidebar.heading`, { default: ctx[7] }) + "";
  let t2;
  return {
    c() {
      h2 = element("h2");
      t2 = text(t_value);
      attr(h2, "class", "heading svelte-f9sn92");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      append(h2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 3 && t_value !== (t_value = ctx2[1](`connect.${ctx2[0]}.sidebar.heading`, { default: ctx2[7] }) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(h2);
    }
  };
}
function create_fragment$5(ctx) {
  let div8;
  let div7;
  let div0;
  let t0;
  let show_if = ctx[1](`connect.${ctx[0]}.sidebar.heading`, { default: "" });
  let t1;
  let h4;
  let t2_value = ctx[1](`connect.${ctx[0]}.sidebar.subheading`, { default: ctx[5] }) + "";
  let t2;
  let t3;
  let p2;
  let t4_value = ctx[1](`connect.${ctx[0]}.sidebar.paragraph`, {
    values: { app: ctx[4] },
    default: ctx[6]
  }) + "";
  let t4;
  let t5;
  let div6;
  let div1;
  let t6;
  let div2;
  let div2_style_value;
  let t7;
  let div3;
  let t8;
  let div4;
  let div4_style_value;
  let t9;
  let div5;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3] || ctx2[2])
      return create_if_block_1$2;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = show_if && create_if_block$2(ctx);
  return {
    c() {
      div8 = element("div");
      div7 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      h4 = element("h4");
      t2 = text(t2_value);
      t3 = space();
      p2 = element("p");
      t4 = text(t4_value);
      t5 = space();
      div6 = element("div");
      div1 = element("div");
      t6 = space();
      div2 = element("div");
      t7 = space();
      div3 = element("div");
      t8 = space();
      div4 = element("div");
      t9 = space();
      div5 = element("div");
      attr(div0, "class", "icon-container svelte-f9sn92");
      attr(h4, "class", "subheading svelte-f9sn92");
      attr(p2, "class", "description svelte-f9sn92");
      attr(div1, "class", "indicator svelte-f9sn92");
      toggle_class(div1, "on", true);
      attr(div2, "class", "join svelte-f9sn92");
      attr(div2, "style", div2_style_value = `${ctx[0] !== "selectingWallet" ? "right: 4px; width: 52px;" : "right: 2px; width: 54px;"}`);
      toggle_class(div2, "active", ctx[0] !== "selectingWallet");
      attr(div3, "class", "indicator svelte-f9sn92");
      attr(div3, "style", `right: 8px;`);
      toggle_class(div3, "on", ctx[0] !== "selectingWallet");
      attr(div4, "class", "join svelte-f9sn92");
      attr(div4, "style", div4_style_value = `${ctx[0] === "connectedWallet" ? "right: 12px; width: 52px;" : "right: 10px; width: 54px;"}`);
      toggle_class(div4, "active", ctx[0] === "connectedWallet");
      attr(div5, "style", `right: 16px;`);
      attr(div5, "class", "indicator svelte-f9sn92");
      toggle_class(div5, "on", ctx[0] === "connectedWallet");
      attr(div6, "class", "indicators svelte-f9sn92");
      attr(div7, "class", "inner-container svelte-f9sn92");
      attr(div8, "class", "sidebar svelte-f9sn92");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      append(div8, div7);
      append(div7, div0);
      if_block0.m(div0, null);
      append(div7, t0);
      if (if_block1)
        if_block1.m(div7, null);
      append(div7, t1);
      append(div7, h4);
      append(h4, t2);
      append(div7, t3);
      append(div7, p2);
      append(p2, t4);
      append(div7, t5);
      append(div7, div6);
      append(div6, div1);
      append(div6, t6);
      append(div6, div2);
      append(div6, t7);
      append(div6, div3);
      append(div6, t8);
      append(div6, div4);
      append(div6, t9);
      append(div6, div5);
    },
    p(ctx2, [dirty]) {
      if_block0.p(ctx2, dirty);
      if (dirty & 3)
        show_if = ctx2[1](`connect.${ctx2[0]}.sidebar.heading`, { default: "" });
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$2(ctx2);
          if_block1.c();
          if_block1.m(div7, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 3 && t2_value !== (t2_value = ctx2[1](`connect.${ctx2[0]}.sidebar.subheading`, { default: ctx2[5] }) + ""))
        set_data(t2, t2_value);
      if (dirty & 3 && t4_value !== (t4_value = ctx2[1](`connect.${ctx2[0]}.sidebar.paragraph`, {
        values: { app: ctx2[4] },
        default: ctx2[6]
      }) + ""))
        set_data(t4, t4_value);
      if (dirty & 1 && div2_style_value !== (div2_style_value = `${ctx2[0] !== "selectingWallet" ? "right: 4px; width: 52px;" : "right: 2px; width: 54px;"}`)) {
        attr(div2, "style", div2_style_value);
      }
      if (dirty & 1) {
        toggle_class(div2, "active", ctx2[0] !== "selectingWallet");
      }
      if (dirty & 1) {
        toggle_class(div3, "on", ctx2[0] !== "selectingWallet");
      }
      if (dirty & 1 && div4_style_value !== (div4_style_value = `${ctx2[0] === "connectedWallet" ? "right: 12px; width: 52px;" : "right: 10px; width: 54px;"}`)) {
        attr(div4, "style", div4_style_value);
      }
      if (dirty & 1) {
        toggle_class(div4, "active", ctx2[0] === "connectedWallet");
      }
      if (dirty & 1) {
        toggle_class(div5, "on", ctx2[0] === "connectedWallet");
      }
    },
    i: noop3,
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div8);
      if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(1, $_ = $$value));
  let { step } = $$props;
  const { appMetadata: appMetadata2 } = internalState$.getValue();
  const { icon, logo, name: name2 = "This app" } = appMetadata2 || {};
  const defaultContent = en.connect[step].sidebar;
  const { subheading, paragraph } = defaultContent;
  const { heading } = defaultContent;
  $$self.$$set = ($$props2) => {
    if ("step" in $$props2)
      $$invalidate(0, step = $$props2.step);
  };
  return [step, $_, icon, logo, name2, subheading, paragraph, heading];
}
var Sidebar = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$5, create_fragment$5, safe_not_equal2, { step: 0 }, add_css$5);
  }
};
function add_css$4(target) {
  append_styles(target, "svelte-37ahne", ".container.svelte-37ahne{position:relative;display:flex;font-family:var(--onboard-font-family-normal, var(--font-family-normal));line-height:24px;color:var(--onboard-gray-700, var(--gray-700));font-size:var(--onboard-font-size-5, var(--font-size-5));height:var(--onboard-connect-content-height, 440px);overflow:hidden}.content.svelte-37ahne{width:var(--onboard-connect-content-width, 488px);display:flex;flex-direction:column}.scroll-container.svelte-37ahne{overflow-y:auto;transition:opacity 250ms ease-in-out;scrollbar-width:none}.scroll-container.svelte-37ahne::-webkit-scrollbar{display:none}.header.svelte-37ahne{position:relative;display:flex;align-items:center;box-shadow:var(--onboard-shadow-2, var(--shadow-2));background-color:var(\n      --onboard-connect-header-background,\n      var(--onboard-white, var(--white))\n    );color:var(\n      --onboard-connect-header-color,\n      var(--onboard-black, var(--black))\n    );border-radius:0 24px 0 0}.header-heading.svelte-37ahne{margin:var(--onboard-spacing-4, var(--spacing-4));line-height:16px}.button-container.svelte-37ahne{position:absolute;right:var(--onboard-spacing-5, var(--spacing-5));top:var(--onboard-spacing-5, var(--spacing-5))}.disabled.svelte-37ahne{opacity:0.2;pointer-events:none}@media all and (max-width: 520px){.content.svelte-37ahne{width:100%}.container.svelte-37ahne{height:auto;min-height:228px}}");
}
function create_if_block$1(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      close: ctx[13],
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 134219775) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(modal, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let sidebar;
  let current;
  sidebar = new Sidebar({ props: { step: ctx[1] } });
  return {
    c() {
      create_component(sidebar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sidebar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sidebar_changes = {};
      if (dirty & 2)
        sidebar_changes.step = ctx2[1];
      sidebar.$set(sidebar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(sidebar, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4, create_if_block_5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3].length)
      return 0;
    if (!ctx2[0])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_5(ctx) {
  let installwallet;
  let current;
  installwallet = new InstallWallet({});
  return {
    c() {
      create_component(installwallet.$$.fragment);
    },
    m(target, anchor) {
      mount_component(installwallet, target, anchor);
      current = true;
    },
    p: noop3,
    i(local) {
      if (current)
        return;
      transition_in(installwallet.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(installwallet.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(installwallet, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let agreement2;
  let updating_agreed;
  let t2;
  let div;
  let selectingwallet;
  let current;
  function agreement_agreed_binding(value) {
    ctx[17](value);
  }
  let agreement_props = {};
  if (ctx[5] !== void 0) {
    agreement_props.agreed = ctx[5];
  }
  agreement2 = new Agreement({ props: agreement_props });
  binding_callbacks.push(() => bind2(agreement2, "agreed", agreement_agreed_binding));
  selectingwallet = new SelectingWallet({
    props: {
      selectWallet: ctx[11],
      wallets: ctx[3],
      connectingWalletLabel: ctx[6],
      connectingErrorMessage: ctx[7]
    }
  });
  return {
    c() {
      create_component(agreement2.$$.fragment);
      t2 = space();
      div = element("div");
      create_component(selectingwallet.$$.fragment);
      attr(div, "class", "svelte-37ahne");
      toggle_class(div, "disabled", !ctx[5]);
    },
    m(target, anchor) {
      mount_component(agreement2, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      mount_component(selectingwallet, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const agreement_changes = {};
      if (!updating_agreed && dirty & 32) {
        updating_agreed = true;
        agreement_changes.agreed = ctx2[5];
        add_flush_callback(() => updating_agreed = false);
      }
      agreement2.$set(agreement_changes);
      const selectingwallet_changes = {};
      if (dirty & 8)
        selectingwallet_changes.wallets = ctx2[3];
      if (dirty & 64)
        selectingwallet_changes.connectingWalletLabel = ctx2[6];
      if (dirty & 128)
        selectingwallet_changes.connectingErrorMessage = ctx2[7];
      selectingwallet.$set(selectingwallet_changes);
      if (dirty & 32) {
        toggle_class(div, "disabled", !ctx2[5]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(agreement2.$$.fragment, local);
      transition_in(selectingwallet.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(agreement2.$$.fragment, local);
      transition_out(selectingwallet.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(agreement2, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div);
      destroy_component2(selectingwallet);
    }
  };
}
function create_if_block_2$1(ctx) {
  let connectingwallet;
  let current;
  connectingwallet = new ConnectingWallet({
    props: {
      connectWallet: ctx[14],
      connectionRejected: ctx[2],
      setStep: ctx[15],
      deselectWallet: ctx[12],
      selectedWallet: ctx[4]
    }
  });
  return {
    c() {
      create_component(connectingwallet.$$.fragment);
    },
    m(target, anchor) {
      mount_component(connectingwallet, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const connectingwallet_changes = {};
      if (dirty & 4)
        connectingwallet_changes.connectionRejected = ctx2[2];
      if (dirty & 16)
        connectingwallet_changes.selectedWallet = ctx2[4];
      connectingwallet.$set(connectingwallet_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(connectingwallet.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(connectingwallet.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(connectingwallet, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let connectedwallet;
  let current;
  connectedwallet = new ConnectedWallet({
    props: {
      selectedWallet: ctx[4]
    }
  });
  return {
    c() {
      create_component(connectedwallet.$$.fragment);
    },
    m(target, anchor) {
      mount_component(connectedwallet, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const connectedwallet_changes = {};
      if (dirty & 16)
        connectedwallet_changes.selectedWallet = ctx2[4];
      connectedwallet.$set(connectedwallet_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(connectedwallet.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(connectedwallet.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(connectedwallet, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let div4;
  let t0;
  let div3;
  let div1;
  let h4;
  let t1_value = ctx[10](`connect.${ctx[1]}.header`, {
    default: en.connect[ctx[1]].header,
    values: {
      connectionRejected: ctx[2],
      wallet: ctx[4] && ctx[4].label
    }
  }) + "";
  let t1;
  let t2;
  let div0;
  let closebutton;
  let t3;
  let div2;
  let t4;
  let t5;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[8] >= 809 && create_if_block_6(ctx);
  closebutton = new CloseButton({});
  let if_block1 = ctx[1] === "selectingWallet" && create_if_block_3(ctx);
  let if_block2 = ctx[1] === "connectingWallet" && ctx[4] && create_if_block_2$1(ctx);
  let if_block3 = ctx[1] === "connectedWallet" && ctx[4] && create_if_block_1$1(ctx);
  return {
    c() {
      div4 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      h4 = element("h4");
      t1 = text(t1_value);
      t2 = space();
      div0 = element("div");
      create_component(closebutton.$$.fragment);
      t3 = space();
      div2 = element("div");
      if (if_block1)
        if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      if (if_block3)
        if_block3.c();
      attr(h4, "class", "header-heading svelte-37ahne");
      attr(div0, "class", "button-container svelte-37ahne");
      attr(div1, "class", "header svelte-37ahne");
      attr(div2, "class", "scroll-container svelte-37ahne");
      attr(div3, "class", "content svelte-37ahne");
      attr(div4, "class", "container svelte-37ahne");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      if (if_block0)
        if_block0.m(div4, null);
      append(div4, t0);
      append(div4, div3);
      append(div3, div1);
      append(div1, h4);
      append(h4, t1);
      append(div1, t2);
      append(div1, div0);
      mount_component(closebutton, div0, null);
      append(div3, t3);
      append(div3, div2);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t4);
      if (if_block2)
        if_block2.m(div2, null);
      append(div2, t5);
      if (if_block3)
        if_block3.m(div2, null);
      ctx[18](div2);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "click", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[8] >= 809) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div4, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty & 1046) && t1_value !== (t1_value = ctx2[10](`connect.${ctx2[1]}.header`, {
        default: en.connect[ctx2[1]].header,
        values: {
          connectionRejected: ctx2[2],
          wallet: ctx2[4] && ctx2[4].label
        }
      }) + ""))
        set_data(t1, t1_value);
      if (ctx2[1] === "selectingWallet") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[1] === "connectingWallet" && ctx2[4]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 18) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, t5);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[1] === "connectedWallet" && ctx2[4]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 18) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$1(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(closebutton.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(closebutton.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block0)
        if_block0.d();
      destroy_component2(closebutton);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      ctx[18](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  add_render_callback(ctx[16]);
  let if_block = (!ctx[0] || ctx[0] && !ctx[0].disableModals) && create_if_block$1(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(window, "resize", ctx[16]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!ctx2[0] || ctx2[0] && !ctx2[0].disableModals) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(10, $_ = $$value));
  let { autoSelect } = $$props;
  const { appMetadata: appMetadata2 } = internalState$.getValue();
  const { walletModules } = state.get();
  let connectionRejected = false;
  let wallets = [];
  let selectedWallet;
  let agreed;
  let connectingWalletLabel;
  let connectingErrorMessage;
  let windowWidth;
  let scrollContainer;
  const walletToAutoSelect = autoSelect && walletModules.find(({ label }) => label.toLowerCase() === autoSelect.label.toLowerCase());
  async function selectWallet({ label, icon, getInterface }) {
    $$invalidate(6, connectingWalletLabel = label);
    try {
      const existingWallet = state.get().wallets.find((wallet2) => wallet2.label === label);
      if (existingWallet) {
        addWallet(existingWallet);
        try {
          await selectAccounts(existingWallet.provider);
          setTimeout(() => setStep("connectedWallet"), 1);
        } catch (error) {
          const { code } = error;
          if (code === ProviderRpcErrorCode.UNSUPPORTED_METHOD || code === ProviderRpcErrorCode.DOES_NOT_EXIST) {
            connectWallet$.next({
              inProgress: false,
              actionRequired: existingWallet.label
            });
          }
        }
        $$invalidate(4, selectedWallet = existingWallet);
        return;
      }
      const { chains: chains2 } = state.get();
      const { provider, instance: instance2 } = await getInterface({
        chains: chains2,
        BigNumber,
        EventEmitter: import_eventemitter3.default,
        appMetadata: appMetadata2
      });
      const loadedIcon = await icon;
      $$invalidate(4, selectedWallet = {
        label,
        icon: loadedIcon,
        provider,
        instance: instance2,
        accounts: [],
        chains: [{ namespace: "evm", id: "0x1" }]
      });
      $$invalidate(7, connectingErrorMessage = "");
      setTimeout(() => setStep("connectingWallet"), 1);
    } catch (error) {
      const { message } = error;
      $$invalidate(7, connectingErrorMessage = message);
      scrollToTop();
    } finally {
      $$invalidate(6, connectingWalletLabel = "");
    }
  }
  function deselectWallet() {
    $$invalidate(4, selectedWallet = null);
  }
  function updateSelectedWallet(update7) {
    $$invalidate(4, selectedWallet = __spreadValues(__spreadValues({}, selectedWallet), update7));
  }
  async function autoSelectWallet(wallet2) {
    const { getIcon, getInterface, label } = wallet2;
    const icon = getIcon();
    selectWallet({ label, icon, getInterface });
  }
  async function loadWalletsForSelection() {
    $$invalidate(3, wallets = walletModules.map(({ getIcon, getInterface, label }) => {
      return { label, icon: getIcon(), getInterface };
    }));
  }
  function close() {
    connectWallet$.next({ inProgress: false });
  }
  async function connectWallet() {
    $$invalidate(2, connectionRejected = false);
    const { provider, label } = selectedWallet;
    try {
      const [address] = await requestAccounts(provider);
      if (!address) {
        return;
      }
      const chain2 = await getChainId(provider);
      const update7 = {
        accounts: [{ address, ens: null, balance: null }],
        chains: [{ namespace: "evm", id: chain2 }]
      };
      addWallet(__spreadValues(__spreadValues({}, selectedWallet), update7));
      trackWallet(provider, label);
      updateSelectedWallet(update7);
      setStep("connectedWallet");
    } catch (error) {
      const { code } = error;
      if (code === ProviderRpcErrorCode.ACCOUNT_ACCESS_REJECTED) {
        $$invalidate(2, connectionRejected = true);
        return;
      }
      if (code === ProviderRpcErrorCode.ACCOUNT_ACCESS_ALREADY_REQUESTED) {
        return;
      }
    }
  }
  async function updateAccountDetails() {
    const { accounts: accounts2, chains: selectedWalletChains } = selectedWallet;
    const appChains = state.get().chains;
    const [connectedWalletChain] = selectedWalletChains;
    const appChain = appChains.find(({ namespace, id: id7 }) => namespace === connectedWalletChain.namespace && id7 === connectedWalletChain.id);
    const { address } = accounts2[0];
    let { balance: balance2, ens: ens2 } = accounts2[0];
    if (balance2 === null) {
      getBalance(address, appChain).then((balance3) => {
        updateAccount(selectedWallet.label, address, { balance: balance3 });
      });
    }
    if (ens2 === null && validEnsChain(connectedWalletChain.id)) {
      getEns(address, appChain).then((ens3) => {
        updateAccount(selectedWallet.label, address, { ens: ens3 });
      });
    }
    setTimeout(() => connectWallet$.next({ inProgress: false }), 1500);
  }
  let step = "selectingWallet";
  function setStep(update7) {
    $$invalidate(1, step = update7);
  }
  function scrollToTop() {
    scrollContainer && scrollContainer.scrollTo(0, 0);
  }
  function onwindowresize() {
    $$invalidate(8, windowWidth = window.innerWidth);
  }
  function agreement_agreed_binding(value) {
    agreed = value;
    $$invalidate(5, agreed);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollContainer = $$value;
      $$invalidate(9, scrollContainer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("autoSelect" in $$props2)
      $$invalidate(0, autoSelect = $$props2.autoSelect);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      switch (step) {
        case "selectingWallet": {
          if (walletToAutoSelect) {
            autoSelectWallet(walletToAutoSelect);
          } else {
            loadWalletsForSelection();
          }
          break;
        }
        case "connectingWallet": {
          connectWallet();
          break;
        }
        case "connectedWallet": {
          updateAccountDetails();
          break;
        }
      }
    }
  };
  return [
    autoSelect,
    step,
    connectionRejected,
    wallets,
    selectedWallet,
    agreed,
    connectingWalletLabel,
    connectingErrorMessage,
    windowWidth,
    scrollContainer,
    $_,
    selectWallet,
    deselectWallet,
    close,
    connectWallet,
    setStep,
    onwindowresize,
    agreement_agreed_binding,
    div2_binding
  ];
}
var Index$1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$4, create_fragment$4, safe_not_equal2, { autoSelect: 0 }, add_css$4);
  }
};
function add_css$3(target) {
  append_styles(target, "svelte-gp520o", ".container.svelte-gp520o{position:relative;padding:var(--onboard-spacing-4, var(--spacing-4));font-family:var(--onboard-font-family-normal, var(--font-family-normal));line-height:16px;font-size:var(--onboard-font-size-5, var(--font-size-5))}.close.svelte-gp520o{position:absolute;top:var(--onboard-spacing-5, var(--spacing-5));right:var(--onboard-spacing-5, var(--spacing-5));padding:0.5rem}h4.svelte-gp520o{font-size:var(--onboard-font-size-3, var(--font-size-3));margin:var(--onboard-spacing-4, var(--spacing-4)) 0}p.svelte-gp520o{margin:0 0 var(--onboard-spacing-4, var(--spacing-4)) 0;max-width:488px}");
}
function create_default_slot$1(ctx) {
  let div1;
  let h4;
  let t0_value = ctx[0]("modals.switchChain.heading", { default: en.modals.switchChain.heading }) + "";
  let t0;
  let t1;
  let p0;
  let t2_value = ctx[0]("modals.switchChain.paragraph1", {
    default: en.modals.switchChain.paragraph1,
    values: {
      app: ctx[1] && ctx[1].name || "This app",
      nextNetworkName: ctx[2]
    }
  }) + "";
  let t2;
  let t3;
  let p1;
  let t4_value = ctx[0]("modals.switchChain.paragraph2", {
    default: en.modals.switchChain.paragraph2
  }) + "";
  let t4;
  let t5;
  let div0;
  let closebutton;
  let current;
  let mounted;
  let dispose;
  closebutton = new CloseButton({});
  return {
    c() {
      div1 = element("div");
      h4 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      p0 = element("p");
      t2 = text(t2_value);
      t3 = space();
      p1 = element("p");
      t4 = text(t4_value);
      t5 = space();
      div0 = element("div");
      create_component(closebutton.$$.fragment);
      attr(h4, "class", "svelte-gp520o");
      attr(p0, "class", "svelte-gp520o");
      attr(p1, "class", "svelte-gp520o");
      attr(div0, "class", "close svelte-gp520o");
      attr(div1, "class", "container svelte-gp520o");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, h4);
      append(h4, t0);
      append(div1, t1);
      append(div1, p0);
      append(p0, t2);
      append(div1, t3);
      append(div1, p1);
      append(p1, t4);
      append(div1, t5);
      append(div1, div0);
      mount_component(closebutton, div0, null);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "click", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0]("modals.switchChain.heading", { default: en.modals.switchChain.heading }) + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0]("modals.switchChain.paragraph1", {
        default: en.modals.switchChain.paragraph1,
        values: {
          app: ctx2[1] && ctx2[1].name || "This app",
          nextNetworkName: ctx2[2]
        }
      }) + ""))
        set_data(t2, t2_value);
      if ((!current || dirty & 1) && t4_value !== (t4_value = ctx2[0]("modals.switchChain.paragraph2", {
        default: en.modals.switchChain.paragraph2
      }) + ""))
        set_data(t4, t4_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(closebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(closebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component2(closebutton);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      close: ctx[3],
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 33) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(modal, detaching);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $switchChainModal$;
  let $_;
  component_subscribe($$self, switchChainModal$, ($$value) => $$invalidate(4, $switchChainModal$ = $$value));
  component_subscribe($$self, X, ($$value) => $$invalidate(0, $_ = $$value));
  const { appMetadata: appMetadata2 } = internalState$.getValue();
  const nextNetworkName = $switchChainModal$.chain.label;
  function close() {
    switchChainModal$.next(null);
  }
  return [$_, appMetadata2, nextNetworkName, close];
}
var SwitchChain = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$3, create_fragment$3, safe_not_equal2, {}, add_css$3);
  }
};
function add_css$2(target) {
  append_styles(target, "svelte-x7wzte", ".icon.svelte-x7wzte{display:flex;border-radius:50px;box-sizing:border-box;color:var(--onboard-primary-500, var(--primary-500))}");
}
function create_fragment$2(ctx) {
  let div;
  let div_style_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", "icon svelte-x7wzte");
      attr(div, "style", div_style_value = `width: ${ctx[0]}px; height: ${ctx[0]}px;`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = infoIcon;
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && div_style_value !== (div_style_value = `width: ${ctx2[0]}px; height: ${ctx2[0]}px;`)) {
        attr(div, "style", div_style_value);
      }
    },
    i: noop3,
    o: noop3,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let { size = 20 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
  };
  return [size];
}
var InfoIcon = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$2, create_fragment$2, safe_not_equal2, { size: 0 }, add_css$2);
  }
};
function add_css$1(target) {
  append_styles(target, "svelte-14tlaaq", ".content.svelte-14tlaaq{padding:1rem;width:300px;font-family:var(--onboard-font-family-normal, var(--font-family-normal));font-size:var(--onboard-font-size-5, var(--font-size-5));line-height:24px}.icon-container.svelte-14tlaaq{display:flex;justify-content:center;align-items:center;width:3rem;height:3rem;background-color:var(--onboard-primary-100, var(--primary-100));border-radius:24px}h4.svelte-14tlaaq{margin:1.5rem 0 0.5rem 0;font-weight:700}p.svelte-14tlaaq{margin:0;font-weight:400}a.svelte-14tlaaq{font-weight:700}button.svelte-14tlaaq{margin-top:1.5rem;width:100%;background-color:var(--onboard-gray-500, var(--gray-500));font-weight:700;line-height:16px;color:var(--onboard-white, var(--white));justify-content:center}");
}
function create_default_slot(ctx) {
  let div1;
  let div0;
  let infoicon;
  let t0;
  let h4;
  let t1_value = ctx[1]("modals.actionRequired.heading", { values: { wallet: ctx[0] } }) + "";
  let t1;
  let t2;
  let p2;
  let t3_value = ctx[1]("modals.actionRequired.paragraph") + "";
  let t3;
  let t4;
  let a2;
  let t5_value = ctx[1]("modals.actionRequired.linkText") + "";
  let t5;
  let t6;
  let button;
  let t7_value = ctx[1]("modals.actionRequired.buttonText") + "";
  let t7;
  let current;
  let mounted;
  let dispose;
  infoicon = new InfoIcon({});
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(infoicon.$$.fragment);
      t0 = space();
      h4 = element("h4");
      t1 = text(t1_value);
      t2 = space();
      p2 = element("p");
      t3 = text(t3_value);
      t4 = space();
      a2 = element("a");
      t5 = text(t5_value);
      t6 = space();
      button = element("button");
      t7 = text(t7_value);
      attr(div0, "class", "icon-container svelte-14tlaaq");
      attr(h4, "class", "svelte-14tlaaq");
      attr(a2, "href", "https://blocknative.com/blog");
      attr(a2, "target", "_blank");
      attr(a2, "rel", "noreferrer noopener");
      attr(a2, "class", "svelte-14tlaaq");
      attr(p2, "class", "svelte-14tlaaq");
      attr(button, "class", "svelte-14tlaaq");
      attr(div1, "class", "content svelte-14tlaaq");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(infoicon, div0, null);
      append(div1, t0);
      append(div1, h4);
      append(h4, t1);
      append(div1, t2);
      append(div1, p2);
      append(p2, t3);
      append(p2, t4);
      append(p2, a2);
      append(a2, t5);
      append(div1, t6);
      append(div1, button);
      append(button, t7);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 3) && t1_value !== (t1_value = ctx2[1]("modals.actionRequired.heading", { values: { wallet: ctx2[0] } }) + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & 2) && t3_value !== (t3_value = ctx2[1]("modals.actionRequired.paragraph") + ""))
        set_data(t3, t3_value);
      if ((!current || dirty & 2) && t5_value !== (t5_value = ctx2[1]("modals.actionRequired.linkText") + ""))
        set_data(t5, t5_value);
      if ((!current || dirty & 2) && t7_value !== (t7_value = ctx2[1]("modals.actionRequired.buttonText") + ""))
        set_data(t7, t7_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(infoicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(infoicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component2(infoicon);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      close: ctx[2],
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 11) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(modal, detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $_;
  component_subscribe($$self, X, ($$value) => $$invalidate(1, $_ = $$value));
  let { wallet: wallet2 } = $$props;
  function close() {
    connectWallet$.next({ inProgress: false, actionRequired: "" });
  }
  $$self.$$set = ($$props2) => {
    if ("wallet" in $$props2)
      $$invalidate(0, wallet2 = $$props2.wallet);
  };
  return [wallet2, $_, close];
}
var ActionRequired = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$1, create_fragment$1, safe_not_equal2, { wallet: 0 }, add_css$1);
  }
};
function add_css(target) {
  append_styles(target, "svelte-seg8z3", `input, textarea{background:var(--onboard-white, var(--white))}input, textarea, select{width:100%;padding:0.5rem 1rem;outline:2px solid var(--onboard-gray-200, var(--gray-200));border:none;border-radius:8px;font-size:1rem;line-height:1.5;color:var(--onboard-gray-600, var(--gray-600));transition:all 200ms ease-in-out}input[type='checkbox']{-webkit-appearance:none;width:auto;background-color:var(--onboard-white, var(--white));outline:1px solid var(--onboard-gray-300, var(--gray-300));border:none;padding:0.5em;border-radius:3px;display:flex;justify-content:center;align-items:center;position:relative;cursor:pointer}input[type='checkbox']:hover{border-color:var(
      --onboard-checkbox-background,
      var(--onboard-primary-500, var(--primary-500))
    )}input[type='checkbox']:checked{background-color:var(
      --onboard-checkbox-background,
      var(--onboard-primary-500, var(--primary-500))
    );border-color:var(
      --onboard-checkbox-background,
      var(--onboard-primary-500, var(--primary-500))
    );color:var(--onboard-checkbox-color, var(--onboard-white, var(--white)))}input[type='checkbox']:checked:after{content:url("data:image/svg+xml,%3Csvg width='0.885em' height='0.6em' viewBox='0 0 14 11' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0 6L5 11L14 2L12.59 0.58L5 8.17L1.41 4.59L0 6Z' fill='white'/%3E%3C/svg%3E");font-size:12px;position:absolute;color:var(--onboard-checkbox-color, var(--onboard-white, var(--white)))}input:hover, textarea:hover, select:hover{border-color:var(
      --onboard-checkbox-color,
      var(--onboard-white, var(--white))
    )}input:focus, textarea.focus, select:focus{border-color:var(--onboard-primary-500, var(--primary-500));box-shadow:0 0 1px 1px
      var(
        --onboard-checkbox-background,
        var(--onboard-primary-500, var(--primary-500))
      );box-shadow:0 0 0 1px -moz-mac-focusring}input:disabled, textarea:disabled, select:disabled{background-color:var(--gray-100)}input::-moz-focus-inner{outline:0;padding:0;margin-top:-2px;margin-bottom:-2px}::-webkit-input-placeholder{color:var(--gray-300)}::-moz-placeholder{color:var(--gray-300)}:-ms-input-placeholder{color:var(--gray-300)}:-moz-placeholder{color:var(--gray-300)}a{color:var(
      --onboard-link-color,
      var(--onboard-primary-500, var(--primary-500))
    );text-decoration:none}button{display:flex;align-items:center;padding:calc(var(--onboard-spacing-4, var(--spacing-4)) - 1px);border-radius:24px;cursor:pointer;font:inherit;border:none}.onboard-button-primary{background:var(--onboard-white, var(--white));padding:calc(var(--onboard-spacing-5, var(--spacing-5)) - 1px)
      calc(var(--onboard-spacing-4, var(--spacing-4)) - 1px);color:var(--onboard-gray-500, var(--gray-500));font-size:var(--onboard-font-size-6, var(--font-size-6));line-height:var(--onboard-font-line-height-3, var(--font-line-height-3));border:1px solid var(--onboard-gray-500, var(--gray-500));font-weight:700}`);
}
function create_if_block_2(ctx) {
  let connect3;
  let current;
  connect3 = new Index$1({
    props: {
      autoSelect: ctx[0].autoSelect
    }
  });
  return {
    c() {
      create_component(connect3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(connect3, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const connect_changes = {};
      if (dirty & 1)
        connect_changes.autoSelect = ctx2[0].autoSelect;
      connect3.$set(connect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(connect3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(connect3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(connect3, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let actionrequired;
  let current;
  actionrequired = new ActionRequired({
    props: {
      wallet: ctx[0].actionRequired
    }
  });
  return {
    c() {
      create_component(actionrequired.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actionrequired, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const actionrequired_changes = {};
      if (dirty & 1)
        actionrequired_changes.wallet = ctx2[0].actionRequired;
      actionrequired.$set(actionrequired_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actionrequired.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionrequired.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(actionrequired, detaching);
    }
  };
}
function create_if_block(ctx) {
  let switchchain;
  let current;
  switchchain = new SwitchChain({});
  return {
    c() {
      create_component(switchchain.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switchchain, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(switchchain.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switchchain.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component2(switchchain, detaching);
    }
  };
}
function create_fragment(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[0].inProgress && create_if_block_2(ctx);
  let if_block1 = ctx[0].actionRequired && create_if_block_1(ctx);
  let if_block2 = ctx[1] && create_if_block();
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty2();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0].inProgress) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[0].actionRequired) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block2) {
          if (dirty & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $connectWallet$;
  let $switchChainModal$;
  component_subscribe($$self, connectWallet$, ($$value) => $$invalidate(0, $connectWallet$ = $$value));
  component_subscribe($$self, switchChainModal$, ($$value) => $$invalidate(1, $switchChainModal$ = $$value));
  return [$connectWallet$, $switchChainModal$];
}
var Index = class extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance, create_fragment, safe_not_equal2, {}, add_css);
  }
};
var API = {
  connectWallet: connect$1,
  disconnectWallet: disconnect,
  setChain,
  state: {
    get: state.get,
    select: state.select,
    actions: {
      setWalletModules
    }
  }
};
function init6(options) {
  if (typeof window === "undefined")
    return API;
  if (options) {
    const error = validateInitOptions(options);
    if (error) {
      throw error;
    }
  }
  const { wallets, chains: chains2, appMetadata: appMetadata2 = null, i18n } = options;
  initialize(i18n);
  addChains(chains2);
  const { svelteInstance } = internalState$.getValue();
  if (svelteInstance) {
    console.warn("Re-initializing Onboard and resetting back to initial state");
    reset$.next();
  }
  const device = getDeviceInfo();
  const app = svelteInstance || mountApp();
  internalState$.next({
    appMetadata: appMetadata2,
    svelteInstance: app,
    device
  });
  setWalletModules(wallets);
  return API;
}
function mountApp() {
  class Onboard extends HTMLElement {
    constructor() {
      super();
    }
  }
  if (!customElements.get("onboard-v2")) {
    customElements.define("onboard-v2", Onboard);
  }
  const styleEl = document.createElement("style");
  styleEl.innerHTML = `
    ${SofiaProRegular}
  `;
  document.body.appendChild(styleEl);
  const onboard = document.createElement("onboard-v2");
  const target = onboard.attachShadow({ mode: "open" });
  onboard.style.all = "initial";
  target.innerHTML = `
      <style>
        :host {  
          /* COLORS */
          --white: white;
          --black: black;
          --primary-1: #2F80ED;
          --primary-100: #eff1fc;
          --primary-200: #d0d4f7;
          --primary-300: #b1b8f2;
          --primary-400: #929bed;
          --primary-500: #6370e5;
          --primary-600: #454ea0;
          --primary-700: #323873;
          --gray-100: #ebebed;
          --gray-200: #c2c4c9;
          --gray-300: #999ca5;
          --gray-400: #707481;
          --gray-500: #33394b;
          --gray-600: #242835;
          --gray-700: #1a1d26;
          --success-100: #d1fae3;
          --success-200: #baf7d5;
          --success-300: #a4f4c6;
          --success-400: #8df2b8;
          --success-500: #5aec99;
          --success-600: #18ce66;
          --success-700: #129b4d;
          --danger-100: #ffe5e6;
          --danger-200: #ffcccc;
          --danger-300: #ffb3b3;
          --danger-400: #ff8080;
          --danger-500: #ff4f4f;
          --danger-600: #cc0000;
          --danger-700: #660000;
          --warning-100: #ffefcc;
          --warning-200: #ffe7b3;
          --warning-300: #ffd780;
          --warning-400: #ffc74c;
          --warning-500: #ffaf00;
          --warning-600: #cc8c00;
          --warning-700: #664600;
  
          /* FONTS */
          --font-family-normal: Sofia Pro;
  
          --font-size-1: 3rem;
          --font-size-2: 2.25rem;
          --font-size-3: 1.5rem;
          --font-size-4: 1.25rem;
          --font-size-5: 1rem;
          --font-size-6: .875rem;
          --font-size-7: .75rem;
  
          --font-line-height-1: 24px;
          --font-line-height-2: 20px;
          --font-line-height-3: 16px;
          --font-line-height-4: 12px;
  
          /* SPACING */
          --spacing-1: 3rem;
          --spacing-2: 2rem;
          --spacing-3: 1.5rem;
          --spacing-4: 1rem;
          --spacing-5: 0.5rem;
  
          /* SHADOWS */
          --shadow-1: 0px 4px 12px rgba(0, 0, 0, 0.1);
          --shadow-2: inset 0px -1px 0px rgba(0, 0, 0, 0.1);

          --modal-z-index: 10;
        }
      </style>
    `;
  document.body.appendChild(onboard);
  const app = new Index({
    target
  });
  return app;
}

// node_modules/@web3-onboard/react/dist/index.js
var web3Onboard = null;
var init7 = (options) => {
  web3Onboard = init6(options);
  return web3Onboard;
};
var useConnectWallet = () => {
  if (!web3Onboard)
    throw new Error("Must initialize before using hooks.");
  const [wallet2, setConnectedWallet] = (0, import_react.useState)(() => web3Onboard.state.get().wallets[0] || null);
  const [connecting, setConnecting] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    const subscription = web3Onboard.state.select("wallets").subscribe((wallets) => setConnectedWallet(wallets[0] || null));
    return () => subscription.unsubscribe();
  }, [wallet2]);
  const connect3 = (0, import_react.useCallback)(async (options) => {
    setConnecting(true);
    const [connectedWallet] = await web3Onboard.connectWallet(options);
    setConnecting(false);
    setConnectedWallet(connectedWallet || null);
  }, []);
  const disconnect2 = (0, import_react.useCallback)(async ({ label }) => {
    setConnecting(true);
    await web3Onboard.disconnectWallet({ label });
    setConnectedWallet(null);
    setConnecting(false);
  }, []);
  return [{ wallet: wallet2, connecting }, connect3, disconnect2];
};
var useSetChain = (walletLabel) => {
  if (!web3Onboard)
    throw new Error("Must initialize before using hooks.");
  const { state: state2, setChain: setChain2 } = web3Onboard;
  const [settingChain, setInProgress] = (0, import_react.useState)(false);
  const [connectedChain2, setConnectedChain] = (0, import_react.useState)(() => {
    const initialWallets = web3Onboard.state.get().wallets;
    if (initialWallets.length === 0)
      return null;
    return (initialWallets.find(({ label }) => label === walletLabel) || initialWallets[0]).chains[0] || null;
  });
  const chains2 = (0, import_react.useMemo)(() => state2.get().chains, []);
  (0, import_react.useEffect)(() => {
    const subscription = state2.select("wallets").subscribe((wallets) => {
      const wallet2 = wallets.find(({ label }) => label === walletLabel) || wallets[0];
      wallet2 && setConnectedChain(wallet2.chains[0]);
    });
    return () => subscription.unsubscribe();
  }, []);
  const set = (0, import_react.useCallback)(async (options) => {
    setInProgress(true);
    await setChain2(__spreadProps(__spreadValues({}, options), { wallet: walletLabel }));
    setInProgress(false);
  }, []);
  return [{ chains: chains2, connectedChain: connectedChain2, settingChain }, set];
};
var useWallets = () => {
  if (!web3Onboard)
    throw new Error("Must initialize before using hooks.");
  const [wallets, setConnectedWallets] = (0, import_react.useState)(() => web3Onboard.state.get().wallets);
  (0, import_react.useEffect)(() => {
    const wallets$2 = web3Onboard.state.select("wallets");
    const subscription = wallets$2.subscribe(setConnectedWallets);
    return () => subscription.unsubscribe();
  }, []);
  return wallets;
};
export {
  init7 as init,
  useConnectWallet,
  useSetChain,
  useWallets,
  web3Onboard
};
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=@web3-onboard_react.js.map
