{
  "version": 3,
  "sources": ["dep:@web3-onboard_ledger", "../@web3-onboard/ledger/dist/index.js"],
  "sourcesContent": ["import d from \"./node_modules/@web3-onboard/ledger/dist/index.js\";export default d;", "// these cannot be dynamically imported\nimport { TypedDataUtils } from '@metamask/eth-sig-util';\nimport { Buffer } from 'buffer';\nconst LEDGER_LIVE_PATH = `m/44'/60'`;\nconst LEDGER_DEFAULT_PATH = `m/44'/60'/0'`;\nconst DEFAULT_BASE_PATHS = [\n    {\n        label: 'Ledger Live',\n        value: LEDGER_LIVE_PATH\n    },\n    {\n        label: 'Ledger Legacy',\n        value: LEDGER_DEFAULT_PATH\n    }\n];\nconst assets = [\n    {\n        label: 'ETH'\n    }\n];\nconst supportsWebUSB = () => Promise.resolve(!!navigator &&\n    !!navigator.usb &&\n    typeof navigator.usb.getDevices === 'function');\n/**\n * Returns the correct ledger transport based on browser compatibility for webUSB.\n * @returns\n */\nconst getTransport = async () => ((await supportsWebUSB())\n    ? (await import('@ledgerhq/hw-transport-webusb')).default\n    : (await import('@ledgerhq/hw-transport-u2f')).default).create();\nconst getAccount = async (derivationPath, asset, index, provider, eth) => {\n    const dPath = derivationPath === LEDGER_LIVE_PATH\n        ? `${derivationPath}/${index}'/0/0`\n        : `${derivationPath}/${index}`;\n    const { address } = await eth.getAddress(dPath);\n    return {\n        derivationPath: dPath,\n        address,\n        balance: {\n            asset: asset.label,\n            value: await provider.getBalance(address)\n        }\n    };\n};\nconst getAddresses = async (derivationPath, asset, provider, eth) => {\n    const accounts = [];\n    let index = 0;\n    let zeroBalanceAccounts = 0;\n    // Iterates until a 0 balance account is found\n    // Then adds 4 more 0 balance accounts to the array\n    while (zeroBalanceAccounts < 5) {\n        const acc = await getAccount(derivationPath, asset, index, provider, eth);\n        if (acc.balance.value.isZero()) {\n            zeroBalanceAccounts++;\n            accounts.push(acc);\n        }\n        else {\n            accounts.push(acc);\n            // Reset the number of 0 balance accounts\n            zeroBalanceAccounts = 0;\n        }\n        index++;\n    }\n    return accounts;\n};\nfunction ledger({ customNetwork } = {}) {\n    const getIcon = async () => (await import('./icon.js')).default;\n    return () => {\n        let accounts;\n        return {\n            label: 'Ledger',\n            getIcon,\n            getInterface: async ({ EventEmitter, chains }) => {\n                const Eth = (await import('@ledgerhq/hw-app-eth')).default;\n                const { default: Common, Hardfork } = await import('@ethereumjs/common');\n                const ethUtil = await import('ethereumjs-util');\n                const { SignTypedDataVersion } = await import('@metamask/eth-sig-util');\n                const { StaticJsonRpcProvider } = await import('@ethersproject/providers');\n                const { accountSelect, createEIP1193Provider, ProviderRpcError } = await import('@web3-onboard/common');\n                const { TransactionFactory: Transaction, Capability } = await import('@ethereumjs/tx');\n                const transport = await getTransport();\n                const eth = new Eth(transport);\n                const eventEmitter = new EventEmitter();\n                let currentChain = chains[0];\n                const scanAccounts = async ({ derivationPath, chainId, asset }) => {\n                    try {\n                        currentChain =\n                            chains.find(({ id }) => id === chainId) || currentChain;\n                        const provider = new StaticJsonRpcProvider(currentChain.rpcUrl);\n                        // Checks to see if this is a custom derivation path\n                        // If it is then just return the single account\n                        if (derivationPath !== LEDGER_LIVE_PATH &&\n                            derivationPath !== LEDGER_DEFAULT_PATH) {\n                            const { address } = await eth.getAddress(derivationPath);\n                            return [\n                                {\n                                    derivationPath,\n                                    address,\n                                    balance: {\n                                        asset: asset.label,\n                                        value: await provider.getBalance(address)\n                                    }\n                                }\n                            ];\n                        }\n                        return getAddresses(derivationPath, asset, provider, eth);\n                    }\n                    catch (error) {\n                        const { statusText } = error;\n                        throw new Error(statusText === 'UNKNOWN_ERROR'\n                            ? 'Ledger device is locked, please unlock to continue'\n                            : statusText);\n                    }\n                };\n                const getAccounts = async () => {\n                    accounts = await accountSelect({\n                        basePaths: DEFAULT_BASE_PATHS,\n                        assets,\n                        chains,\n                        scanAccounts\n                    });\n                    if (accounts && accounts.length) {\n                        eventEmitter.emit('accountsChanged', [accounts[0].address]);\n                    }\n                    return accounts;\n                };\n                const request = async ({ method, params }) => {\n                    const response = await fetch(currentChain.rpcUrl, {\n                        method: 'POST',\n                        body: JSON.stringify({\n                            id: '42',\n                            method,\n                            params\n                        })\n                    }).then(res => res.json());\n                    if (response.result) {\n                        return response.result;\n                    }\n                    else {\n                        throw response.error;\n                    }\n                };\n                const ledgerProvider = { request };\n                const provider = createEIP1193Provider(ledgerProvider, {\n                    eth_requestAccounts: async () => {\n                        // Triggers the account select modal if no accounts have been selected\n                        const accounts = await getAccounts();\n                        if (!Array.isArray(accounts))\n                            throw new Error('No account selected. Must call eth_requestAccounts first.');\n                        if (accounts.length === 0) {\n                            throw new ProviderRpcError({\n                                code: 4001,\n                                message: 'User rejected the request.'\n                            });\n                        }\n                        if (!accounts[0].hasOwnProperty('address'))\n                            throw new Error('No address property associated with the selected account');\n                        return [accounts[0].address];\n                    },\n                    eth_selectAccounts: async () => {\n                        const accounts = await getAccounts();\n                        return accounts.map(({ address }) => address);\n                    },\n                    eth_accounts: async () => {\n                        return Array.isArray(accounts) &&\n                            accounts.length &&\n                            accounts[0].hasOwnProperty('address')\n                            ? [accounts[0].address]\n                            : [];\n                    },\n                    eth_chainId: async () => {\n                        return (currentChain && currentChain.id) || '';\n                    },\n                    eth_signTransaction: async ({ params: [transactionObject] }) => {\n                        if (!accounts || !Array.isArray(accounts) || !accounts.length)\n                            throw new Error('No account selected. Must call eth_requestAccounts first.');\n                        let account;\n                        if (transactionObject.hasOwnProperty('from')) {\n                            account = accounts.find(account => account.address === transactionObject.from);\n                        }\n                        account = account ? account : accounts[0];\n                        const { address: from, derivationPath } = account;\n                        // Set the `from` field to the currently selected account\n                        transactionObject = { ...transactionObject, from };\n                        // @ts-ignore\n                        const CommonConstructor = Common.default || Common;\n                        const common = new CommonConstructor({\n                            chain: customNetwork || currentChain.hasOwnProperty('id')\n                                ? Number.parseInt(currentChain.id)\n                                : 1,\n                            // Berlin is the minimum hardfork that will allow for EIP1559\n                            hardfork: Hardfork.Berlin,\n                            // List of supported EIPS\n                            eips: [1559]\n                        });\n                        transactionObject.gasLimit =\n                            transactionObject.gas || transactionObject.gasLimit;\n                        const transaction = Transaction.fromTxData({\n                            ...transactionObject\n                        }, { common });\n                        let unsignedTx = transaction.getMessageToSign(false);\n                        // If this is not an EIP1559 transaction then it is legacy and it needs to be\n                        // rlp encoded before being passed to ledger\n                        if (!transaction.supports(Capability.EIP1559FeeMarket)) {\n                            unsignedTx = ethUtil.rlp.encode(unsignedTx);\n                        }\n                        const { v, r, s } = await eth.signTransaction(derivationPath, unsignedTx.toString('hex'));\n                        // Reconstruct the signed transaction\n                        const signedTx = Transaction.fromTxData({\n                            ...transactionObject,\n                            v: `0x${v}`,\n                            r: `0x${r}`,\n                            s: `0x${s}`\n                        }, { common });\n                        return signedTx ? `0x${signedTx.serialize().toString('hex')}` : '';\n                    },\n                    eth_sendTransaction: async ({ baseRequest, params }) => {\n                        const signedTx = await provider.request({\n                            method: 'eth_signTransaction',\n                            params\n                        });\n                        const transactionHash = await baseRequest({\n                            method: 'eth_sendRawTransaction',\n                            params: [signedTx]\n                        });\n                        return transactionHash;\n                    },\n                    eth_sign: async ({ params: [address, message] }) => {\n                        if (!(accounts && accounts.length && accounts.length > 0))\n                            throw new Error('No account selected. Must call eth_requestAccounts first.');\n                        const account = accounts.find(account => account.address === address) ||\n                            accounts[0];\n                        return eth\n                            .signPersonalMessage(account.derivationPath, Buffer.from(message).toString('hex'))\n                            .then(result => {\n                            let v = (result['v'] - 27).toString(16);\n                            if (v.length < 2) {\n                                v = '0' + v;\n                            }\n                            return `0x${result['r']}${result['s']}${v}`;\n                        });\n                    },\n                    eth_signTypedData: async ({ params: [address, typedData] }) => {\n                        if (!(accounts && accounts.length && accounts.length > 0))\n                            throw new Error('No account selected. Must call eth_requestAccounts first.');\n                        const account = accounts.find(account => account.address === address) ||\n                            accounts[0];\n                        const domainHash = TypedDataUtils.hashStruct('EIP712Domain', typedData.domain, typedData.types, SignTypedDataVersion.V3).toString('hex');\n                        const messageHash = TypedDataUtils.hashStruct(typedData.primaryType, typedData.message, typedData.types, SignTypedDataVersion.V3).toString('hex');\n                        return eth\n                            .signEIP712HashedMessage(account.derivationPath, domainHash, messageHash)\n                            .then(result => {\n                            let v = (result['v'] - 27).toString(16);\n                            if (v.length < 2) {\n                                v = '0' + v;\n                            }\n                            return `0x${result['r']}${result['s']}${v}`;\n                        });\n                    },\n                    wallet_switchEthereumChain: async ({ params: [{ chainId }] }) => {\n                        currentChain =\n                            chains.find(({ id }) => id === chainId) || currentChain;\n                        if (!currentChain)\n                            throw new Error('chain must be set before switching');\n                        eventEmitter.emit('chainChanged', currentChain.id);\n                        return null;\n                    },\n                    wallet_addEthereumChain: null\n                });\n                provider.on = eventEmitter.on.bind(eventEmitter);\n                return {\n                    provider\n                };\n            }\n        };\n    };\n}\nexport default ledger;\n"],
  "mappings": "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",
  "names": []
}
